[
    {
        "func_name": "build",
        "original": "def build(f, txt):\n    \"\"\"\n    f : path to file name\n    txt : str containing the file info\n    \"\"\"\n    f = open(f, 'w')\n    f.write(txt)\n    f.close()",
        "mutated": [
            "def build(f, txt):\n    if False:\n        i = 10\n    '\\n    f : path to file name\\n    txt : str containing the file info\\n    '\n    f = open(f, 'w')\n    f.write(txt)\n    f.close()",
            "def build(f, txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    f : path to file name\\n    txt : str containing the file info\\n    '\n    f = open(f, 'w')\n    f.write(txt)\n    f.close()",
            "def build(f, txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    f : path to file name\\n    txt : str containing the file info\\n    '\n    f = open(f, 'w')\n    f.write(txt)\n    f.close()",
            "def build(f, txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    f : path to file name\\n    txt : str containing the file info\\n    '\n    f = open(f, 'w')\n    f.write(txt)\n    f.close()",
            "def build(f, txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    f : path to file name\\n    txt : str containing the file info\\n    '\n    f = open(f, 'w')\n    f.write(txt)\n    f.close()"
        ]
    },
    {
        "func_name": "start",
        "original": "def start(model_name, trt):\n    \"\"\"\n    txt : str containing the file info\n    \"\"\"\n    txt = ''\n    txt += \"<?xml version='1.0' encoding='utf-8'?>\\n\"\n    txt += '<nrml xmlns:gml=\"http://www.opengis.net/gml\"\\n'\n    txt += '\\txmlns=\"http://openquake.org/xmlns/nrml/0.5\">\\n'\n    txt += '\\t<sourceModel name=\"Single Fault Rupture Sources\">\\n'\n    txt += '\\t\\t<sourceGroup name=\"group 0\" tectonicRegion=\"' + trt + '\">\\n'\n    return txt",
        "mutated": [
            "def start(model_name, trt):\n    if False:\n        i = 10\n    '\\n    txt : str containing the file info\\n    '\n    txt = ''\n    txt += \"<?xml version='1.0' encoding='utf-8'?>\\n\"\n    txt += '<nrml xmlns:gml=\"http://www.opengis.net/gml\"\\n'\n    txt += '\\txmlns=\"http://openquake.org/xmlns/nrml/0.5\">\\n'\n    txt += '\\t<sourceModel name=\"Single Fault Rupture Sources\">\\n'\n    txt += '\\t\\t<sourceGroup name=\"group 0\" tectonicRegion=\"' + trt + '\">\\n'\n    return txt",
            "def start(model_name, trt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    txt : str containing the file info\\n    '\n    txt = ''\n    txt += \"<?xml version='1.0' encoding='utf-8'?>\\n\"\n    txt += '<nrml xmlns:gml=\"http://www.opengis.net/gml\"\\n'\n    txt += '\\txmlns=\"http://openquake.org/xmlns/nrml/0.5\">\\n'\n    txt += '\\t<sourceModel name=\"Single Fault Rupture Sources\">\\n'\n    txt += '\\t\\t<sourceGroup name=\"group 0\" tectonicRegion=\"' + trt + '\">\\n'\n    return txt",
            "def start(model_name, trt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    txt : str containing the file info\\n    '\n    txt = ''\n    txt += \"<?xml version='1.0' encoding='utf-8'?>\\n\"\n    txt += '<nrml xmlns:gml=\"http://www.opengis.net/gml\"\\n'\n    txt += '\\txmlns=\"http://openquake.org/xmlns/nrml/0.5\">\\n'\n    txt += '\\t<sourceModel name=\"Single Fault Rupture Sources\">\\n'\n    txt += '\\t\\t<sourceGroup name=\"group 0\" tectonicRegion=\"' + trt + '\">\\n'\n    return txt",
            "def start(model_name, trt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    txt : str containing the file info\\n    '\n    txt = ''\n    txt += \"<?xml version='1.0' encoding='utf-8'?>\\n\"\n    txt += '<nrml xmlns:gml=\"http://www.opengis.net/gml\"\\n'\n    txt += '\\txmlns=\"http://openquake.org/xmlns/nrml/0.5\">\\n'\n    txt += '\\t<sourceModel name=\"Single Fault Rupture Sources\">\\n'\n    txt += '\\t\\t<sourceGroup name=\"group 0\" tectonicRegion=\"' + trt + '\">\\n'\n    return txt",
            "def start(model_name, trt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    txt : str containing the file info\\n    '\n    txt = ''\n    txt += \"<?xml version='1.0' encoding='utf-8'?>\\n\"\n    txt += '<nrml xmlns:gml=\"http://www.opengis.net/gml\"\\n'\n    txt += '\\txmlns=\"http://openquake.org/xmlns/nrml/0.5\">\\n'\n    txt += '\\t<sourceModel name=\"Single Fault Rupture Sources\">\\n'\n    txt += '\\t\\t<sourceGroup name=\"group 0\" tectonicRegion=\"' + trt + '\">\\n'\n    return txt"
        ]
    },
    {
        "func_name": "wrt_kite_geo",
        "original": "def wrt_kite_geo(fault_name, faults_names, faults_data, resample, vertical_faults):\n    \"\"\"\n    txt : str containing the file info\n    faults_names : list of the fault names in order (serves for indexing)\n    faults_data : dict containing all faults info\n    resample : list with a boolean and the resample parameters if needed\n                when resampling the coordinates is necessary to lower the\n                number of points.\n    vertical_faults : bool , option to write all faults vertical\n    \"\"\"\n    index_fault = faults_names.index(fault_name)\n    ColLon = faults_data[index_fault]['lon']\n    ColLat = faults_data[index_fault]['lat']\n    Depth = faults_data[index_fault]['depth']\n    if Depth and all((elem == 'sf' for elem in Depth)):\n        type_of_fault = 'sf'\n    else:\n        type_of_fault = 'cf'\n        Depth = [float(i) for i in Depth]\n    if type_of_fault == 'sf':\n        usd = faults_data[index_fault]['upper_sismo_depth']\n        lsd = faults_data[index_fault]['lower_sismo_depth']\n        if vertical_faults == False:\n            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n            hdist_top = usd / dip_tan\n            hdist_bottom = lsd / dip_tan\n        else:\n            hdist_top = 0.0\n            hdist_bottom = 0.0\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        if str('N') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('S') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('E') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 90.0 and compass_bearing < 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('W') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 90.0 or compass_bearing > 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        ColLon = list(ColLon)\n        ColLat = list(ColLat)\n        do_resample = resample[0]\n        if do_resample == True:\n            min_d = resample[1]\n            max_d = resample[2]\n            az_d = resample[3]\n            (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n            for i_pt in range(len(ColLon) - 2):\n                add_point = False\n                i_pt += 1\n                dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                    add_point = True\n                    if i_pt == len(ColLon) - 2:\n                        last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                        if last_dist_after < min_d:\n                            add_point = False\n                if add_point == True:\n                    resampled_ColLon.append(ColLon[i_pt])\n                    resampled_ColLat.append(ColLat[i_pt])\n            resampled_ColLon.append(ColLon[-1])\n            resampled_ColLat.append(ColLat[-1])\n            (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n            plot_stuf_detail = False\n            if plot_stuf_detail == True:\n                min_dist_tmp = min_d\n                for i_pt in range(len(ColLon) - 2):\n                    dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                    if dist_tmp < min_dist_tmp:\n                        min_dist_tmp = dist_tmp\n                if min_dist_tmp < min_d / 2.0:\n                    print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n        txt = '\\t\\t\\t<kiteSurface>\\n'\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        strike = compass_bearing\n        mean_azimuth = (strike + 90.0) % 360\n        use_local_azimuth = False\n        i_pt = 0\n        for (x, y) in zip(ColLon, ColLat):\n            if use_local_azimuth == True:\n                if [x, y] == [ColLon[0], ColLat[0]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                else:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n            else:\n                azimuth = mean_azimuth\n            txt += '\\t\\t\\t<profile>\\n'\n            txt += '\\t\\t\\t\\t<gml:LineString>\\n'\n            txt += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n            (xt, yt) = point_at(x, y, azimuth, hdist_top)\n            txt += '\\t\\t\\t\\t\\t\\t' + '%.5f' % xt + ' ' + '%.5f' % yt + ' ' + '%.2f' % usd + ' '\n            (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n            txt += '%.5f' % xb + ' ' + '%.5f' % yb + ' ' + '%.2f' % lsd + '\\n'\n            txt += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n            txt += '\\t\\t\\t\\t</gml:LineString>\\n'\n            txt += '\\t\\t\\t</profile>\\n'\n            i_pt += 1\n        txt += '\\t\\t\\t</kiteSurface>\\n'\n    return txt",
        "mutated": [
            "def wrt_kite_geo(fault_name, faults_names, faults_data, resample, vertical_faults):\n    if False:\n        i = 10\n    '\\n    txt : str containing the file info\\n    faults_names : list of the fault names in order (serves for indexing)\\n    faults_data : dict containing all faults info\\n    resample : list with a boolean and the resample parameters if needed\\n                when resampling the coordinates is necessary to lower the\\n                number of points.\\n    vertical_faults : bool , option to write all faults vertical\\n    '\n    index_fault = faults_names.index(fault_name)\n    ColLon = faults_data[index_fault]['lon']\n    ColLat = faults_data[index_fault]['lat']\n    Depth = faults_data[index_fault]['depth']\n    if Depth and all((elem == 'sf' for elem in Depth)):\n        type_of_fault = 'sf'\n    else:\n        type_of_fault = 'cf'\n        Depth = [float(i) for i in Depth]\n    if type_of_fault == 'sf':\n        usd = faults_data[index_fault]['upper_sismo_depth']\n        lsd = faults_data[index_fault]['lower_sismo_depth']\n        if vertical_faults == False:\n            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n            hdist_top = usd / dip_tan\n            hdist_bottom = lsd / dip_tan\n        else:\n            hdist_top = 0.0\n            hdist_bottom = 0.0\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        if str('N') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('S') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('E') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 90.0 and compass_bearing < 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('W') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 90.0 or compass_bearing > 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        ColLon = list(ColLon)\n        ColLat = list(ColLat)\n        do_resample = resample[0]\n        if do_resample == True:\n            min_d = resample[1]\n            max_d = resample[2]\n            az_d = resample[3]\n            (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n            for i_pt in range(len(ColLon) - 2):\n                add_point = False\n                i_pt += 1\n                dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                    add_point = True\n                    if i_pt == len(ColLon) - 2:\n                        last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                        if last_dist_after < min_d:\n                            add_point = False\n                if add_point == True:\n                    resampled_ColLon.append(ColLon[i_pt])\n                    resampled_ColLat.append(ColLat[i_pt])\n            resampled_ColLon.append(ColLon[-1])\n            resampled_ColLat.append(ColLat[-1])\n            (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n            plot_stuf_detail = False\n            if plot_stuf_detail == True:\n                min_dist_tmp = min_d\n                for i_pt in range(len(ColLon) - 2):\n                    dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                    if dist_tmp < min_dist_tmp:\n                        min_dist_tmp = dist_tmp\n                if min_dist_tmp < min_d / 2.0:\n                    print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n        txt = '\\t\\t\\t<kiteSurface>\\n'\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        strike = compass_bearing\n        mean_azimuth = (strike + 90.0) % 360\n        use_local_azimuth = False\n        i_pt = 0\n        for (x, y) in zip(ColLon, ColLat):\n            if use_local_azimuth == True:\n                if [x, y] == [ColLon[0], ColLat[0]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                else:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n            else:\n                azimuth = mean_azimuth\n            txt += '\\t\\t\\t<profile>\\n'\n            txt += '\\t\\t\\t\\t<gml:LineString>\\n'\n            txt += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n            (xt, yt) = point_at(x, y, azimuth, hdist_top)\n            txt += '\\t\\t\\t\\t\\t\\t' + '%.5f' % xt + ' ' + '%.5f' % yt + ' ' + '%.2f' % usd + ' '\n            (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n            txt += '%.5f' % xb + ' ' + '%.5f' % yb + ' ' + '%.2f' % lsd + '\\n'\n            txt += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n            txt += '\\t\\t\\t\\t</gml:LineString>\\n'\n            txt += '\\t\\t\\t</profile>\\n'\n            i_pt += 1\n        txt += '\\t\\t\\t</kiteSurface>\\n'\n    return txt",
            "def wrt_kite_geo(fault_name, faults_names, faults_data, resample, vertical_faults):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    txt : str containing the file info\\n    faults_names : list of the fault names in order (serves for indexing)\\n    faults_data : dict containing all faults info\\n    resample : list with a boolean and the resample parameters if needed\\n                when resampling the coordinates is necessary to lower the\\n                number of points.\\n    vertical_faults : bool , option to write all faults vertical\\n    '\n    index_fault = faults_names.index(fault_name)\n    ColLon = faults_data[index_fault]['lon']\n    ColLat = faults_data[index_fault]['lat']\n    Depth = faults_data[index_fault]['depth']\n    if Depth and all((elem == 'sf' for elem in Depth)):\n        type_of_fault = 'sf'\n    else:\n        type_of_fault = 'cf'\n        Depth = [float(i) for i in Depth]\n    if type_of_fault == 'sf':\n        usd = faults_data[index_fault]['upper_sismo_depth']\n        lsd = faults_data[index_fault]['lower_sismo_depth']\n        if vertical_faults == False:\n            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n            hdist_top = usd / dip_tan\n            hdist_bottom = lsd / dip_tan\n        else:\n            hdist_top = 0.0\n            hdist_bottom = 0.0\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        if str('N') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('S') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('E') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 90.0 and compass_bearing < 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('W') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 90.0 or compass_bearing > 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        ColLon = list(ColLon)\n        ColLat = list(ColLat)\n        do_resample = resample[0]\n        if do_resample == True:\n            min_d = resample[1]\n            max_d = resample[2]\n            az_d = resample[3]\n            (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n            for i_pt in range(len(ColLon) - 2):\n                add_point = False\n                i_pt += 1\n                dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                    add_point = True\n                    if i_pt == len(ColLon) - 2:\n                        last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                        if last_dist_after < min_d:\n                            add_point = False\n                if add_point == True:\n                    resampled_ColLon.append(ColLon[i_pt])\n                    resampled_ColLat.append(ColLat[i_pt])\n            resampled_ColLon.append(ColLon[-1])\n            resampled_ColLat.append(ColLat[-1])\n            (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n            plot_stuf_detail = False\n            if plot_stuf_detail == True:\n                min_dist_tmp = min_d\n                for i_pt in range(len(ColLon) - 2):\n                    dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                    if dist_tmp < min_dist_tmp:\n                        min_dist_tmp = dist_tmp\n                if min_dist_tmp < min_d / 2.0:\n                    print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n        txt = '\\t\\t\\t<kiteSurface>\\n'\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        strike = compass_bearing\n        mean_azimuth = (strike + 90.0) % 360\n        use_local_azimuth = False\n        i_pt = 0\n        for (x, y) in zip(ColLon, ColLat):\n            if use_local_azimuth == True:\n                if [x, y] == [ColLon[0], ColLat[0]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                else:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n            else:\n                azimuth = mean_azimuth\n            txt += '\\t\\t\\t<profile>\\n'\n            txt += '\\t\\t\\t\\t<gml:LineString>\\n'\n            txt += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n            (xt, yt) = point_at(x, y, azimuth, hdist_top)\n            txt += '\\t\\t\\t\\t\\t\\t' + '%.5f' % xt + ' ' + '%.5f' % yt + ' ' + '%.2f' % usd + ' '\n            (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n            txt += '%.5f' % xb + ' ' + '%.5f' % yb + ' ' + '%.2f' % lsd + '\\n'\n            txt += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n            txt += '\\t\\t\\t\\t</gml:LineString>\\n'\n            txt += '\\t\\t\\t</profile>\\n'\n            i_pt += 1\n        txt += '\\t\\t\\t</kiteSurface>\\n'\n    return txt",
            "def wrt_kite_geo(fault_name, faults_names, faults_data, resample, vertical_faults):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    txt : str containing the file info\\n    faults_names : list of the fault names in order (serves for indexing)\\n    faults_data : dict containing all faults info\\n    resample : list with a boolean and the resample parameters if needed\\n                when resampling the coordinates is necessary to lower the\\n                number of points.\\n    vertical_faults : bool , option to write all faults vertical\\n    '\n    index_fault = faults_names.index(fault_name)\n    ColLon = faults_data[index_fault]['lon']\n    ColLat = faults_data[index_fault]['lat']\n    Depth = faults_data[index_fault]['depth']\n    if Depth and all((elem == 'sf' for elem in Depth)):\n        type_of_fault = 'sf'\n    else:\n        type_of_fault = 'cf'\n        Depth = [float(i) for i in Depth]\n    if type_of_fault == 'sf':\n        usd = faults_data[index_fault]['upper_sismo_depth']\n        lsd = faults_data[index_fault]['lower_sismo_depth']\n        if vertical_faults == False:\n            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n            hdist_top = usd / dip_tan\n            hdist_bottom = lsd / dip_tan\n        else:\n            hdist_top = 0.0\n            hdist_bottom = 0.0\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        if str('N') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('S') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('E') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 90.0 and compass_bearing < 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('W') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 90.0 or compass_bearing > 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        ColLon = list(ColLon)\n        ColLat = list(ColLat)\n        do_resample = resample[0]\n        if do_resample == True:\n            min_d = resample[1]\n            max_d = resample[2]\n            az_d = resample[3]\n            (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n            for i_pt in range(len(ColLon) - 2):\n                add_point = False\n                i_pt += 1\n                dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                    add_point = True\n                    if i_pt == len(ColLon) - 2:\n                        last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                        if last_dist_after < min_d:\n                            add_point = False\n                if add_point == True:\n                    resampled_ColLon.append(ColLon[i_pt])\n                    resampled_ColLat.append(ColLat[i_pt])\n            resampled_ColLon.append(ColLon[-1])\n            resampled_ColLat.append(ColLat[-1])\n            (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n            plot_stuf_detail = False\n            if plot_stuf_detail == True:\n                min_dist_tmp = min_d\n                for i_pt in range(len(ColLon) - 2):\n                    dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                    if dist_tmp < min_dist_tmp:\n                        min_dist_tmp = dist_tmp\n                if min_dist_tmp < min_d / 2.0:\n                    print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n        txt = '\\t\\t\\t<kiteSurface>\\n'\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        strike = compass_bearing\n        mean_azimuth = (strike + 90.0) % 360\n        use_local_azimuth = False\n        i_pt = 0\n        for (x, y) in zip(ColLon, ColLat):\n            if use_local_azimuth == True:\n                if [x, y] == [ColLon[0], ColLat[0]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                else:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n            else:\n                azimuth = mean_azimuth\n            txt += '\\t\\t\\t<profile>\\n'\n            txt += '\\t\\t\\t\\t<gml:LineString>\\n'\n            txt += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n            (xt, yt) = point_at(x, y, azimuth, hdist_top)\n            txt += '\\t\\t\\t\\t\\t\\t' + '%.5f' % xt + ' ' + '%.5f' % yt + ' ' + '%.2f' % usd + ' '\n            (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n            txt += '%.5f' % xb + ' ' + '%.5f' % yb + ' ' + '%.2f' % lsd + '\\n'\n            txt += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n            txt += '\\t\\t\\t\\t</gml:LineString>\\n'\n            txt += '\\t\\t\\t</profile>\\n'\n            i_pt += 1\n        txt += '\\t\\t\\t</kiteSurface>\\n'\n    return txt",
            "def wrt_kite_geo(fault_name, faults_names, faults_data, resample, vertical_faults):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    txt : str containing the file info\\n    faults_names : list of the fault names in order (serves for indexing)\\n    faults_data : dict containing all faults info\\n    resample : list with a boolean and the resample parameters if needed\\n                when resampling the coordinates is necessary to lower the\\n                number of points.\\n    vertical_faults : bool , option to write all faults vertical\\n    '\n    index_fault = faults_names.index(fault_name)\n    ColLon = faults_data[index_fault]['lon']\n    ColLat = faults_data[index_fault]['lat']\n    Depth = faults_data[index_fault]['depth']\n    if Depth and all((elem == 'sf' for elem in Depth)):\n        type_of_fault = 'sf'\n    else:\n        type_of_fault = 'cf'\n        Depth = [float(i) for i in Depth]\n    if type_of_fault == 'sf':\n        usd = faults_data[index_fault]['upper_sismo_depth']\n        lsd = faults_data[index_fault]['lower_sismo_depth']\n        if vertical_faults == False:\n            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n            hdist_top = usd / dip_tan\n            hdist_bottom = lsd / dip_tan\n        else:\n            hdist_top = 0.0\n            hdist_bottom = 0.0\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        if str('N') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('S') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('E') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 90.0 and compass_bearing < 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('W') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 90.0 or compass_bearing > 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        ColLon = list(ColLon)\n        ColLat = list(ColLat)\n        do_resample = resample[0]\n        if do_resample == True:\n            min_d = resample[1]\n            max_d = resample[2]\n            az_d = resample[3]\n            (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n            for i_pt in range(len(ColLon) - 2):\n                add_point = False\n                i_pt += 1\n                dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                    add_point = True\n                    if i_pt == len(ColLon) - 2:\n                        last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                        if last_dist_after < min_d:\n                            add_point = False\n                if add_point == True:\n                    resampled_ColLon.append(ColLon[i_pt])\n                    resampled_ColLat.append(ColLat[i_pt])\n            resampled_ColLon.append(ColLon[-1])\n            resampled_ColLat.append(ColLat[-1])\n            (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n            plot_stuf_detail = False\n            if plot_stuf_detail == True:\n                min_dist_tmp = min_d\n                for i_pt in range(len(ColLon) - 2):\n                    dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                    if dist_tmp < min_dist_tmp:\n                        min_dist_tmp = dist_tmp\n                if min_dist_tmp < min_d / 2.0:\n                    print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n        txt = '\\t\\t\\t<kiteSurface>\\n'\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        strike = compass_bearing\n        mean_azimuth = (strike + 90.0) % 360\n        use_local_azimuth = False\n        i_pt = 0\n        for (x, y) in zip(ColLon, ColLat):\n            if use_local_azimuth == True:\n                if [x, y] == [ColLon[0], ColLat[0]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                else:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n            else:\n                azimuth = mean_azimuth\n            txt += '\\t\\t\\t<profile>\\n'\n            txt += '\\t\\t\\t\\t<gml:LineString>\\n'\n            txt += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n            (xt, yt) = point_at(x, y, azimuth, hdist_top)\n            txt += '\\t\\t\\t\\t\\t\\t' + '%.5f' % xt + ' ' + '%.5f' % yt + ' ' + '%.2f' % usd + ' '\n            (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n            txt += '%.5f' % xb + ' ' + '%.5f' % yb + ' ' + '%.2f' % lsd + '\\n'\n            txt += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n            txt += '\\t\\t\\t\\t</gml:LineString>\\n'\n            txt += '\\t\\t\\t</profile>\\n'\n            i_pt += 1\n        txt += '\\t\\t\\t</kiteSurface>\\n'\n    return txt",
            "def wrt_kite_geo(fault_name, faults_names, faults_data, resample, vertical_faults):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    txt : str containing the file info\\n    faults_names : list of the fault names in order (serves for indexing)\\n    faults_data : dict containing all faults info\\n    resample : list with a boolean and the resample parameters if needed\\n                when resampling the coordinates is necessary to lower the\\n                number of points.\\n    vertical_faults : bool , option to write all faults vertical\\n    '\n    index_fault = faults_names.index(fault_name)\n    ColLon = faults_data[index_fault]['lon']\n    ColLat = faults_data[index_fault]['lat']\n    Depth = faults_data[index_fault]['depth']\n    if Depth and all((elem == 'sf' for elem in Depth)):\n        type_of_fault = 'sf'\n    else:\n        type_of_fault = 'cf'\n        Depth = [float(i) for i in Depth]\n    if type_of_fault == 'sf':\n        usd = faults_data[index_fault]['upper_sismo_depth']\n        lsd = faults_data[index_fault]['lower_sismo_depth']\n        if vertical_faults == False:\n            dip_tan = math.tan(math.radians(faults_data[index_fault]['dip']))\n            hdist_top = usd / dip_tan\n            hdist_bottom = lsd / dip_tan\n        else:\n            hdist_top = 0.0\n            hdist_bottom = 0.0\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        if str('N') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('S') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 180.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('E') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing > 90.0 and compass_bearing < 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        elif str('W') in str(faults_data[index_fault]['oriented']):\n            if compass_bearing < 90.0 or compass_bearing > 270.0:\n                ColLon = reversed(ColLon)\n                ColLat = reversed(ColLat)\n        ColLon = list(ColLon)\n        ColLat = list(ColLat)\n        do_resample = resample[0]\n        if do_resample == True:\n            min_d = resample[1]\n            max_d = resample[2]\n            az_d = resample[3]\n            (resampled_ColLon, resampled_ColLat) = ([ColLon[0]], [ColLat[0]])\n            for i_pt in range(len(ColLon) - 2):\n                add_point = False\n                i_pt += 1\n                dist_before = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt], ColLat[i_pt])\n                dist_after = distance(resampled_ColLon[-1], resampled_ColLat[-1], ColLon[i_pt + 1], ColLat[i_pt + 1])\n                az_before = calculate_initial_compass_bearing((resampled_ColLon[-1], resampled_ColLat[-1]), (ColLon[i_pt], ColLat[i_pt]))\n                az_after = calculate_initial_compass_bearing((ColLon[i_pt], ColLat[i_pt]), (ColLon[i_pt + 1], ColLat[i_pt + 1]))\n                if dist_before > min_d and (dist_after > max_d or abs(az_before - az_after) > az_d):\n                    add_point = True\n                    if i_pt == len(ColLon) - 2:\n                        last_dist_after = distance(ColLon[i_pt], ColLat[i_pt], ColLon[-1], ColLat[-1])\n                        if last_dist_after < min_d:\n                            add_point = False\n                if add_point == True:\n                    resampled_ColLon.append(ColLon[i_pt])\n                    resampled_ColLat.append(ColLat[i_pt])\n            resampled_ColLon.append(ColLon[-1])\n            resampled_ColLat.append(ColLat[-1])\n            (ColLon, ColLat) = (resampled_ColLon, resampled_ColLat)\n            plot_stuf_detail = False\n            if plot_stuf_detail == True:\n                min_dist_tmp = min_d\n                for i_pt in range(len(ColLon) - 2):\n                    dist_tmp = distance(resampled_ColLon[i_pt + 1], resampled_ColLat[i_pt + 1], resampled_ColLon[i_pt], resampled_ColLat[i_pt])\n                    if dist_tmp < min_dist_tmp:\n                        min_dist_tmp = dist_tmp\n                if min_dist_tmp < min_d / 2.0:\n                    print('min dist :', round(min_dist_tmp), 'id: ', faults_data[index_fault]['name'])\n        txt = '\\t\\t\\t<kiteSurface>\\n'\n        compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[-1], ColLon[-1]))\n        strike = compass_bearing\n        mean_azimuth = (strike + 90.0) % 360\n        use_local_azimuth = False\n        i_pt = 0\n        for (x, y) in zip(ColLon, ColLat):\n            if use_local_azimuth == True:\n                if [x, y] == [ColLon[0], ColLat[0]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[0], ColLon[0]), (ColLat[1], ColLon[1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                elif [x, y] == [ColLon[-1], ColLat[-1]]:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[-2], ColLon[-2]), (ColLat[-1], ColLon[-1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                else:\n                    compass_bearing = calculate_initial_compass_bearing((ColLat[i_pt - 1], ColLon[i_pt - 1]), (ColLat[i_pt + 1], ColLon[i_pt + 1]))\n                    strike = compass_bearing\n                    azimuth = (strike + 90.0) % 360\n                azimuth = (mean_azimuth + azimuth) / 2.0 % 360\n            else:\n                azimuth = mean_azimuth\n            txt += '\\t\\t\\t<profile>\\n'\n            txt += '\\t\\t\\t\\t<gml:LineString>\\n'\n            txt += '\\t\\t\\t\\t\\t<gml:posList>\\n'\n            (xt, yt) = point_at(x, y, azimuth, hdist_top)\n            txt += '\\t\\t\\t\\t\\t\\t' + '%.5f' % xt + ' ' + '%.5f' % yt + ' ' + '%.2f' % usd + ' '\n            (xb, yb) = point_at(x, y, azimuth, hdist_bottom)\n            txt += '%.5f' % xb + ' ' + '%.5f' % yb + ' ' + '%.2f' % lsd + '\\n'\n            txt += '\\t\\t\\t\\t\\t</gml:posList>\\n'\n            txt += '\\t\\t\\t\\t</gml:LineString>\\n'\n            txt += '\\t\\t\\t</profile>\\n'\n            i_pt += 1\n        txt += '\\t\\t\\t</kiteSurface>\\n'\n    return txt"
        ]
    },
    {
        "func_name": "wrt_source",
        "original": "def wrt_source(txt, section_id, faults_names, faults_data, geotype, resample, vertical_faults, trt, M_min, MFD, ScL_oq):\n    \"\"\"\n    txt : str containing the file info\n    geotype : type of geometry of the section (kite, complex, or  simple)\n    resample : list with a boolean and the resample parameters if needed\n    vertical_faults : bool, option to force all faults vertical\n    \"\"\"\n    section_name = faults_names[section_id]\n    txt += '    <kiteFaultSource name=\"' + section_name + '\" id=\"' + str(section_id) + '\" tectonicRegion=\"' + trt + '\">\\n'\n    if geotype == 'kite':\n        out = wrt_kite_geo(section_name, faults_names, faults_data, resample, vertical_faults)\n    if geotype == 'complex':\n        out = wrt_complex_geo()\n    if geotype == 'simple':\n        out = wrt_simple_geo()\n    txt += out\n    txt += '        <magScaleRel> ' + ScL_oq + ' </magScaleRel>\\n'\n    txt += '        <ruptAspectRatio> 1.0 </ruptAspectRatio>\\n'\n    txt += '        <incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n    txt += '        <occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n    txt += '        </incrementalMFD>\\n'\n    txt += '        <rake> ' + str(faults_data[section_id]['rake']) + '</rake>\\n'\n    txt += '        </kiteFaultSource>\\n'\n    return txt",
        "mutated": [
            "def wrt_source(txt, section_id, faults_names, faults_data, geotype, resample, vertical_faults, trt, M_min, MFD, ScL_oq):\n    if False:\n        i = 10\n    '\\n    txt : str containing the file info\\n    geotype : type of geometry of the section (kite, complex, or  simple)\\n    resample : list with a boolean and the resample parameters if needed\\n    vertical_faults : bool, option to force all faults vertical\\n    '\n    section_name = faults_names[section_id]\n    txt += '    <kiteFaultSource name=\"' + section_name + '\" id=\"' + str(section_id) + '\" tectonicRegion=\"' + trt + '\">\\n'\n    if geotype == 'kite':\n        out = wrt_kite_geo(section_name, faults_names, faults_data, resample, vertical_faults)\n    if geotype == 'complex':\n        out = wrt_complex_geo()\n    if geotype == 'simple':\n        out = wrt_simple_geo()\n    txt += out\n    txt += '        <magScaleRel> ' + ScL_oq + ' </magScaleRel>\\n'\n    txt += '        <ruptAspectRatio> 1.0 </ruptAspectRatio>\\n'\n    txt += '        <incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n    txt += '        <occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n    txt += '        </incrementalMFD>\\n'\n    txt += '        <rake> ' + str(faults_data[section_id]['rake']) + '</rake>\\n'\n    txt += '        </kiteFaultSource>\\n'\n    return txt",
            "def wrt_source(txt, section_id, faults_names, faults_data, geotype, resample, vertical_faults, trt, M_min, MFD, ScL_oq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    txt : str containing the file info\\n    geotype : type of geometry of the section (kite, complex, or  simple)\\n    resample : list with a boolean and the resample parameters if needed\\n    vertical_faults : bool, option to force all faults vertical\\n    '\n    section_name = faults_names[section_id]\n    txt += '    <kiteFaultSource name=\"' + section_name + '\" id=\"' + str(section_id) + '\" tectonicRegion=\"' + trt + '\">\\n'\n    if geotype == 'kite':\n        out = wrt_kite_geo(section_name, faults_names, faults_data, resample, vertical_faults)\n    if geotype == 'complex':\n        out = wrt_complex_geo()\n    if geotype == 'simple':\n        out = wrt_simple_geo()\n    txt += out\n    txt += '        <magScaleRel> ' + ScL_oq + ' </magScaleRel>\\n'\n    txt += '        <ruptAspectRatio> 1.0 </ruptAspectRatio>\\n'\n    txt += '        <incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n    txt += '        <occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n    txt += '        </incrementalMFD>\\n'\n    txt += '        <rake> ' + str(faults_data[section_id]['rake']) + '</rake>\\n'\n    txt += '        </kiteFaultSource>\\n'\n    return txt",
            "def wrt_source(txt, section_id, faults_names, faults_data, geotype, resample, vertical_faults, trt, M_min, MFD, ScL_oq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    txt : str containing the file info\\n    geotype : type of geometry of the section (kite, complex, or  simple)\\n    resample : list with a boolean and the resample parameters if needed\\n    vertical_faults : bool, option to force all faults vertical\\n    '\n    section_name = faults_names[section_id]\n    txt += '    <kiteFaultSource name=\"' + section_name + '\" id=\"' + str(section_id) + '\" tectonicRegion=\"' + trt + '\">\\n'\n    if geotype == 'kite':\n        out = wrt_kite_geo(section_name, faults_names, faults_data, resample, vertical_faults)\n    if geotype == 'complex':\n        out = wrt_complex_geo()\n    if geotype == 'simple':\n        out = wrt_simple_geo()\n    txt += out\n    txt += '        <magScaleRel> ' + ScL_oq + ' </magScaleRel>\\n'\n    txt += '        <ruptAspectRatio> 1.0 </ruptAspectRatio>\\n'\n    txt += '        <incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n    txt += '        <occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n    txt += '        </incrementalMFD>\\n'\n    txt += '        <rake> ' + str(faults_data[section_id]['rake']) + '</rake>\\n'\n    txt += '        </kiteFaultSource>\\n'\n    return txt",
            "def wrt_source(txt, section_id, faults_names, faults_data, geotype, resample, vertical_faults, trt, M_min, MFD, ScL_oq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    txt : str containing the file info\\n    geotype : type of geometry of the section (kite, complex, or  simple)\\n    resample : list with a boolean and the resample parameters if needed\\n    vertical_faults : bool, option to force all faults vertical\\n    '\n    section_name = faults_names[section_id]\n    txt += '    <kiteFaultSource name=\"' + section_name + '\" id=\"' + str(section_id) + '\" tectonicRegion=\"' + trt + '\">\\n'\n    if geotype == 'kite':\n        out = wrt_kite_geo(section_name, faults_names, faults_data, resample, vertical_faults)\n    if geotype == 'complex':\n        out = wrt_complex_geo()\n    if geotype == 'simple':\n        out = wrt_simple_geo()\n    txt += out\n    txt += '        <magScaleRel> ' + ScL_oq + ' </magScaleRel>\\n'\n    txt += '        <ruptAspectRatio> 1.0 </ruptAspectRatio>\\n'\n    txt += '        <incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n    txt += '        <occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n    txt += '        </incrementalMFD>\\n'\n    txt += '        <rake> ' + str(faults_data[section_id]['rake']) + '</rake>\\n'\n    txt += '        </kiteFaultSource>\\n'\n    return txt",
            "def wrt_source(txt, section_id, faults_names, faults_data, geotype, resample, vertical_faults, trt, M_min, MFD, ScL_oq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    txt : str containing the file info\\n    geotype : type of geometry of the section (kite, complex, or  simple)\\n    resample : list with a boolean and the resample parameters if needed\\n    vertical_faults : bool, option to force all faults vertical\\n    '\n    section_name = faults_names[section_id]\n    txt += '    <kiteFaultSource name=\"' + section_name + '\" id=\"' + str(section_id) + '\" tectonicRegion=\"' + trt + '\">\\n'\n    if geotype == 'kite':\n        out = wrt_kite_geo(section_name, faults_names, faults_data, resample, vertical_faults)\n    if geotype == 'complex':\n        out = wrt_complex_geo()\n    if geotype == 'simple':\n        out = wrt_simple_geo()\n    txt += out\n    txt += '        <magScaleRel> ' + ScL_oq + ' </magScaleRel>\\n'\n    txt += '        <ruptAspectRatio> 1.0 </ruptAspectRatio>\\n'\n    txt += '        <incrementalMFD minMag=\"' + str(M_min) + '\" binWidth=\"0.10\">\\n'\n    txt += '        <occurRates> ' + ' '.join(list(map(str, MFD))) + '</occurRates>\\n'\n    txt += '        </incrementalMFD>\\n'\n    txt += '        <rake> ' + str(faults_data[section_id]['rake']) + '</rake>\\n'\n    txt += '        </kiteFaultSource>\\n'\n    return txt"
        ]
    },
    {
        "func_name": "end",
        "original": "def end(txt):\n    \"\"\"\n    txt : str containing the file info\n    \"\"\"\n    txt += '        </sourceGroup>\\n'\n    txt += '    </sourceModel>\\n'\n    txt += '</nrml>\\n'\n    return txt\n    return txt",
        "mutated": [
            "def end(txt):\n    if False:\n        i = 10\n    '\\n    txt : str containing the file info\\n    '\n    txt += '        </sourceGroup>\\n'\n    txt += '    </sourceModel>\\n'\n    txt += '</nrml>\\n'\n    return txt\n    return txt",
            "def end(txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    txt : str containing the file info\\n    '\n    txt += '        </sourceGroup>\\n'\n    txt += '    </sourceModel>\\n'\n    txt += '</nrml>\\n'\n    return txt\n    return txt",
            "def end(txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    txt : str containing the file info\\n    '\n    txt += '        </sourceGroup>\\n'\n    txt += '    </sourceModel>\\n'\n    txt += '</nrml>\\n'\n    return txt\n    return txt",
            "def end(txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    txt : str containing the file info\\n    '\n    txt += '        </sourceGroup>\\n'\n    txt += '    </sourceModel>\\n'\n    txt += '</nrml>\\n'\n    return txt\n    return txt",
            "def end(txt):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    txt : str containing the file info\\n    '\n    txt += '        </sourceGroup>\\n'\n    txt += '    </sourceModel>\\n'\n    txt += '</nrml>\\n'\n    return txt\n    return txt"
        ]
    }
]