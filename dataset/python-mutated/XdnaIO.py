"""Bio.SeqIO support for the "xdna" file format.

The Xdna binary format is generated by Christian Marck's DNA Strider program
and also used by Serial Cloner.
"""
import warnings
from re import match
from struct import pack
from struct import unpack
from Bio import BiopythonWarning
from Bio.Seq import Seq
from Bio.SeqFeature import ExactPosition
from Bio.SeqFeature import SimpleLocation
from Bio.SeqFeature import SeqFeature
from Bio.SeqRecord import SeqRecord
from .Interfaces import SequenceIterator
from .Interfaces import SequenceWriter
_seq_types = {0: None, 1: 'DNA', 2: 'DNA', 3: 'RNA', 4: 'protein'}
_seq_topologies = {0: 'linear', 1: 'circular'}

def _read(handle, length):
    if False:
        return 10
    'Read the specified number of bytes from the given handle.'
    data = handle.read(length)
    if len(data) < length:
        raise ValueError('Cannot read %d bytes from handle' % length)
    return data

def _read_pstring(handle):
    if False:
        for i in range(10):
            print('nop')
    'Read a Pascal string.\n\n    A Pascal string comprises a single byte giving the length of the string\n    followed by as many bytes.\n    '
    length = unpack('>B', _read(handle, 1))[0]
    return unpack('%ds' % length, _read(handle, length))[0].decode('ASCII')

def _read_pstring_as_integer(handle):
    if False:
        i = 10
        return i + 15
    return int(_read_pstring(handle))

def _read_overhang(handle):
    if False:
        i = 10
        return i + 15
    'Read an overhang specification.\n\n    An overhang is represented in a XDNA file as:\n      - a Pascal string containing the text representation of the overhang\n        length, which also indicates the nature of the overhang:\n        - a length of zero means no overhang,\n        - a negative length means a 3\' overhang,\n        - a positive length means a 5\' overhang;\n      - the actual overhang sequence.\n\n    Examples:\n      - 0x01 0x30: no overhang ("0", as a P-string)\n      - 0x01 0x32 0x41 0x41: 5\' AA overhang (P-string "2", then "AA")\n      - 0x02 0x2D 0x31 0x43: 3\' C overhang (P-string "-1", then "C")\n\n    Returns a tuple (length, sequence).\n\n    '
    length = _read_pstring_as_integer(handle)
    if length != 0:
        overhang = _read(handle, abs(length))
        return (length, overhang)
    else:
        return (None, None)

def _parse_feature_description(desc, qualifiers):
    if False:
        while True:
            i = 10
    "Parse the description field of a Xdna feature.\n\n    The 'description' field of a feature sometimes contains several\n    GenBank-like qualifiers, separated by carriage returns (CR, 0x0D).\n    "
    for line in [x for x in desc.split('\r') if len(x) > 0]:
        m = match('^([^=]+)="([^"]+)"?$', line)
        if m:
            (qual, value) = m.groups()
            qualifiers[qual] = [value]
        elif '"' not in line:
            qualifiers['note'] = [line]

def _read_feature(handle, record):
    if False:
        for i in range(10):
            print('nop')
    'Read a single sequence feature.'
    name = _read_pstring(handle)
    desc = _read_pstring(handle)
    type = _read_pstring(handle) or 'misc_feature'
    start = _read_pstring_as_integer(handle)
    end = _read_pstring_as_integer(handle)
    (forward, display, arrow) = unpack('>BBxB', _read(handle, 4))
    if forward:
        strand = 1
    else:
        strand = -1
        (start, end) = (end, start)
    _read_pstring(handle)
    location = SimpleLocation(start - 1, end, strand=strand)
    qualifiers = {}
    if name:
        qualifiers['label'] = [name]
    _parse_feature_description(desc, qualifiers)
    feature = SeqFeature(location, type=type, qualifiers=qualifiers)
    record.features.append(feature)

class XdnaIterator(SequenceIterator):
    """Parser for Xdna files."""

    def __init__(self, source):
        if False:
            i = 10
            return i + 15
        'Parse a Xdna file and return a SeqRecord object.\n\n        Argument source is a file-like object in binary mode or a path to a file.\n\n        Note that this is an "iterator" in name only since an Xdna file always\n        contain a single sequence.\n\n        '
        super().__init__(source, mode='b', fmt='Xdna')

    def parse(self, handle):
        if False:
            return 10
        'Start parsing the file, and return a SeqRecord generator.'
        header = handle.read(112)
        if not header:
            raise ValueError('Empty file.')
        if len(header) < 112:
            raise ValueError('Improper header, cannot read 112 bytes from handle')
        records = self.iterate(handle, header)
        return records

    def iterate(self, handle, header):
        if False:
            for i in range(10):
                print('nop')
        'Parse the file and generate SeqRecord objects.'
        (version, seq_type, topology, length, neg_length, com_length) = unpack('>BBB25xII60xI12x', header)
        if version != 0:
            raise ValueError('Unsupported XDNA version')
        if seq_type not in _seq_types:
            raise ValueError('Unknown sequence type')
        sequence = _read(handle, length).decode('ASCII')
        comment = _read(handle, com_length).decode('ASCII')
        name = comment.split(' ')[0]
        record = SeqRecord(Seq(sequence), description=comment, name=name, id=name)
        if _seq_types[seq_type]:
            record.annotations['molecule_type'] = _seq_types[seq_type]
        if topology in _seq_topologies:
            record.annotations['topology'] = _seq_topologies[topology]
        if len(handle.read(1)) == 1:
            _read_overhang(handle)
            _read_overhang(handle)
            num_features = unpack('>B', _read(handle, 1))[0]
            while num_features > 0:
                _read_feature(handle, record)
                num_features -= 1
        yield record

class XdnaWriter(SequenceWriter):
    """Write files in the Xdna format."""

    def __init__(self, target):
        if False:
            i = 10
            return i + 15
        'Initialize an Xdna writer object.\n\n        Arguments:\n         - target - Output stream opened in binary mode, or a path to a file.\n\n        '
        super().__init__(target, mode='wb')

    def write_file(self, records):
        if False:
            while True:
                i = 10
        'Write the specified record to a Xdna file.\n\n        Note that the function expects a list (or iterable) of records\n        as per the SequenceWriter interface, but the list should contain\n        only one record as the Xdna format is a mono-record format.\n        '
        records = iter(records)
        try:
            record = next(records)
        except StopIteration:
            raise ValueError('Must have one sequence') from None
        try:
            next(records)
            raise ValueError('More than one sequence found')
        except StopIteration:
            pass
        self._has_truncated_strings = False
        molecule_type = record.annotations.get('molecule_type')
        if molecule_type is None:
            seqtype = 0
        elif 'DNA' in molecule_type:
            seqtype = 1
        elif 'RNA' in molecule_type:
            seqtype = 3
        elif 'protein' in molecule_type:
            seqtype = 4
        else:
            seqtype = 0
        if record.annotations.get('topology', 'linear') == 'circular':
            topology = 1
        else:
            topology = 0
        if record.description.startswith(record.id):
            comment = record.description
        else:
            comment = f'{record.id} {record.description}'
        self.handle.write(pack('>BBB25xII60xI11xB', 0, seqtype, topology, len(record), 0, len(comment), 255))
        self.handle.write(bytes(record.seq))
        self.handle.write(comment.encode('ASCII'))
        self.handle.write(pack('>B', 0))
        self._write_pstring('0')
        self._write_pstring('0')
        features = [f for f in record.features if isinstance(f.location.start, ExactPosition) and isinstance(f.location.end, ExactPosition)]
        drop = len(record.features) - len(features)
        if drop > 0:
            warnings.warn(f'Dropping {drop} features with fuzzy locations', BiopythonWarning)
        if len(features) > 255:
            drop = len(features) - 255
            warnings.warn(f'Too many features, dropping the last {drop}', BiopythonWarning)
            features = features[:255]
        self.handle.write(pack('>B', len(features)))
        for feature in features:
            self._write_pstring(feature.qualifiers.get('label', [''])[0])
            description = ''
            for qname in feature.qualifiers:
                if qname in ('label', 'translation'):
                    continue
                for val in feature.qualifiers[qname]:
                    if len(description) > 0:
                        description = description + '\r'
                    description = description + f'{qname}="{val}"'
            self._write_pstring(description)
            self._write_pstring(feature.type)
            start = int(feature.location.start) + 1
            end = int(feature.location.end)
            strand = 1
            if feature.location.strand == -1:
                (start, end) = (end, start)
                strand = 0
            self._write_pstring(str(start))
            self._write_pstring(str(end))
            self.handle.write(pack('>BBBB', strand, 1, 0, 1))
            self._write_pstring('127,127,127')
        if self._has_truncated_strings:
            warnings.warn('Some annotations were truncated to 255 characters', BiopythonWarning)
        return 1

    def _write_pstring(self, s):
        if False:
            i = 10
            return i + 15
        'Write the given string as a Pascal string.'
        if len(s) > 255:
            self._has_truncated_strings = True
            s = s[:255]
        self.handle.write(pack('>B', len(s)))
        self.handle.write(s.encode('ASCII'))