[
    {
        "func_name": "to_dict",
        "original": "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> MutableMappingT:\n    ...",
        "mutated": [
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> MutableMappingT:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> MutableMappingT:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> MutableMappingT:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> MutableMappingT:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> MutableMappingT:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "to_dict",
        "original": "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> list[MutableMappingT]:\n    ...",
        "mutated": [
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> list[MutableMappingT]:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> list[MutableMappingT]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> list[MutableMappingT]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> list[MutableMappingT]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[MutableMappingT] | MutableMappingT, index: bool=...) -> list[MutableMappingT]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "to_dict",
        "original": "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[dict]=..., index: bool=...) -> dict:\n    ...",
        "mutated": [
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[dict]=..., index: bool=...) -> dict:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[dict]=..., index: bool=...) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[dict]=..., index: bool=...) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[dict]=..., index: bool=...) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'index']=..., *, into: type[dict]=..., index: bool=...) -> dict:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "to_dict",
        "original": "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[dict]=..., index: bool=...) -> list[dict]:\n    ...",
        "mutated": [
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[dict]=..., index: bool=...) -> list[dict]:\n    if False:\n        i = 10\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[dict]=..., index: bool=...) -> list[dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[dict]=..., index: bool=...) -> list[dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[dict]=..., index: bool=...) -> list[dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ...",
            "@overload\ndef to_dict(df: DataFrame, orient: Literal['records'], *, into: type[dict]=..., index: bool=...) -> list[dict]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ..."
        ]
    },
    {
        "func_name": "to_dict",
        "original": "def to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'records', 'index']='dict', *, into: type[MutableMappingT] | MutableMappingT=dict, index: bool=True) -> MutableMappingT | list[MutableMappingT]:\n    \"\"\"\n    Convert the DataFrame to a dictionary.\n\n    The type of the key-value pairs can be customized with the parameters\n    (see below).\n\n    Parameters\n    ----------\n    orient : str {'dict', 'list', 'series', 'split', 'tight', 'records', 'index'}\n        Determines the type of the values of the dictionary.\n\n        - 'dict' (default) : dict like {column -> {index -> value}}\n        - 'list' : dict like {column -> [values]}\n        - 'series' : dict like {column -> Series(values)}\n        - 'split' : dict like\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values]}\n        - 'tight' : dict like\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values],\n          'index_names' -> [index.names], 'column_names' -> [column.names]}\n        - 'records' : list like\n          [{column -> value}, ... , {column -> value}]\n        - 'index' : dict like {index -> {column -> value}}\n\n        .. versionadded:: 1.4.0\n            'tight' as an allowed value for the ``orient`` argument\n\n    into : class, default dict\n        The collections.abc.MutableMapping subclass used for all Mappings\n        in the return value.  Can be the actual class or an empty\n        instance of the mapping type you want.  If you want a\n        collections.defaultdict, you must pass it initialized.\n\n    index : bool, default True\n        Whether to include the index item (and index_names item if `orient`\n        is 'tight') in the returned dictionary. Can only be ``False``\n        when `orient` is 'split' or 'tight'.\n\n        .. versionadded:: 2.0.0\n\n    Returns\n    -------\n    dict, list or collections.abc.Mapping\n        Return a collections.abc.MutableMapping object representing the\n        DataFrame. The resulting transformation depends on the `orient` parameter.\n    \"\"\"\n    if not df.columns.is_unique:\n        warnings.warn('DataFrame columns are not unique, some columns will be omitted.', UserWarning, stacklevel=find_stack_level())\n    into_c = com.standardize_mapping(into)\n    orient = orient.lower()\n    if not index and orient not in ['split', 'tight']:\n        raise ValueError(\"'index=False' is only valid when 'orient' is 'split' or 'tight'\")\n    if orient == 'series':\n        return into_c(((k, v) for (k, v) in df.items()))\n    box_native_indices = [i for (i, col_dtype) in enumerate(df.dtypes.values) if col_dtype == np.dtype(object) or isinstance(col_dtype, ExtensionDtype)]\n    are_all_object_dtype_cols = len(box_native_indices) == len(df.dtypes)\n    if orient == 'dict':\n        return into_c(((k, v.to_dict(into=into)) for (k, v) in df.items()))\n    elif orient == 'list':\n        object_dtype_indices_as_set: set[int] = set(box_native_indices)\n        return into_c(((k, list(map(maybe_box_native, v.to_numpy().tolist())) if i in object_dtype_indices_as_set else v.to_numpy().tolist()) for (i, (k, v)) in enumerate(df.items())))\n    elif orient == 'split':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', data)))\n    elif orient == 'tight':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', [list(map(maybe_box_native, t)) for t in df.itertuples(index=False, name=None)])) + ((('index_names', list(df.index.names)),) if index else ()) + (('column_names', list(df.columns.names)),))\n    elif orient == 'records':\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            rows = (dict(zip(columns, row)) for row in df.itertuples(index=False, name=None))\n            return [into_c(((k, maybe_box_native(v)) for (k, v) in row.items())) for row in rows]\n        else:\n            data = [into_c(zip(columns, t)) for t in df.itertuples(index=False, name=None)]\n            if box_native_indices:\n                object_dtype_indices_as_set = set(box_native_indices)\n                object_dtype_cols = {col for (i, col) in enumerate(df.columns) if i in object_dtype_indices_as_set}\n                for row in data:\n                    for col in object_dtype_cols:\n                        row[col] = maybe_box_native(row[col])\n            return data\n    elif orient == 'index':\n        if not df.index.is_unique:\n            raise ValueError(\"DataFrame index must be unique for orient='index'.\")\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            return into_c(((t[0], dict(zip(df.columns, map(maybe_box_native, t[1:])))) for t in df.itertuples(name=None)))\n        elif box_native_indices:\n            object_dtype_indices_as_set = set(box_native_indices)\n            is_object_dtype_by_index = [i in object_dtype_indices_as_set for i in range(len(df.columns))]\n            return into_c(((t[0], {columns[i]: maybe_box_native(v) if is_object_dtype_by_index[i] else v for (i, v) in enumerate(t[1:])}) for t in df.itertuples(name=None)))\n        else:\n            return into_c(((t[0], dict(zip(df.columns, t[1:]))) for t in df.itertuples(name=None)))\n    else:\n        raise ValueError(f\"orient '{orient}' not understood\")",
        "mutated": [
            "def to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'records', 'index']='dict', *, into: type[MutableMappingT] | MutableMappingT=dict, index: bool=True) -> MutableMappingT | list[MutableMappingT]:\n    if False:\n        i = 10\n    \"\\n    Convert the DataFrame to a dictionary.\\n\\n    The type of the key-value pairs can be customized with the parameters\\n    (see below).\\n\\n    Parameters\\n    ----------\\n    orient : str {'dict', 'list', 'series', 'split', 'tight', 'records', 'index'}\\n        Determines the type of the values of the dictionary.\\n\\n        - 'dict' (default) : dict like {column -> {index -> value}}\\n        - 'list' : dict like {column -> [values]}\\n        - 'series' : dict like {column -> Series(values)}\\n        - 'split' : dict like\\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values]}\\n        - 'tight' : dict like\\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values],\\n          'index_names' -> [index.names], 'column_names' -> [column.names]}\\n        - 'records' : list like\\n          [{column -> value}, ... , {column -> value}]\\n        - 'index' : dict like {index -> {column -> value}}\\n\\n        .. versionadded:: 1.4.0\\n            'tight' as an allowed value for the ``orient`` argument\\n\\n    into : class, default dict\\n        The collections.abc.MutableMapping subclass used for all Mappings\\n        in the return value.  Can be the actual class or an empty\\n        instance of the mapping type you want.  If you want a\\n        collections.defaultdict, you must pass it initialized.\\n\\n    index : bool, default True\\n        Whether to include the index item (and index_names item if `orient`\\n        is 'tight') in the returned dictionary. Can only be ``False``\\n        when `orient` is 'split' or 'tight'.\\n\\n        .. versionadded:: 2.0.0\\n\\n    Returns\\n    -------\\n    dict, list or collections.abc.Mapping\\n        Return a collections.abc.MutableMapping object representing the\\n        DataFrame. The resulting transformation depends on the `orient` parameter.\\n    \"\n    if not df.columns.is_unique:\n        warnings.warn('DataFrame columns are not unique, some columns will be omitted.', UserWarning, stacklevel=find_stack_level())\n    into_c = com.standardize_mapping(into)\n    orient = orient.lower()\n    if not index and orient not in ['split', 'tight']:\n        raise ValueError(\"'index=False' is only valid when 'orient' is 'split' or 'tight'\")\n    if orient == 'series':\n        return into_c(((k, v) for (k, v) in df.items()))\n    box_native_indices = [i for (i, col_dtype) in enumerate(df.dtypes.values) if col_dtype == np.dtype(object) or isinstance(col_dtype, ExtensionDtype)]\n    are_all_object_dtype_cols = len(box_native_indices) == len(df.dtypes)\n    if orient == 'dict':\n        return into_c(((k, v.to_dict(into=into)) for (k, v) in df.items()))\n    elif orient == 'list':\n        object_dtype_indices_as_set: set[int] = set(box_native_indices)\n        return into_c(((k, list(map(maybe_box_native, v.to_numpy().tolist())) if i in object_dtype_indices_as_set else v.to_numpy().tolist()) for (i, (k, v)) in enumerate(df.items())))\n    elif orient == 'split':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', data)))\n    elif orient == 'tight':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', [list(map(maybe_box_native, t)) for t in df.itertuples(index=False, name=None)])) + ((('index_names', list(df.index.names)),) if index else ()) + (('column_names', list(df.columns.names)),))\n    elif orient == 'records':\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            rows = (dict(zip(columns, row)) for row in df.itertuples(index=False, name=None))\n            return [into_c(((k, maybe_box_native(v)) for (k, v) in row.items())) for row in rows]\n        else:\n            data = [into_c(zip(columns, t)) for t in df.itertuples(index=False, name=None)]\n            if box_native_indices:\n                object_dtype_indices_as_set = set(box_native_indices)\n                object_dtype_cols = {col for (i, col) in enumerate(df.columns) if i in object_dtype_indices_as_set}\n                for row in data:\n                    for col in object_dtype_cols:\n                        row[col] = maybe_box_native(row[col])\n            return data\n    elif orient == 'index':\n        if not df.index.is_unique:\n            raise ValueError(\"DataFrame index must be unique for orient='index'.\")\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            return into_c(((t[0], dict(zip(df.columns, map(maybe_box_native, t[1:])))) for t in df.itertuples(name=None)))\n        elif box_native_indices:\n            object_dtype_indices_as_set = set(box_native_indices)\n            is_object_dtype_by_index = [i in object_dtype_indices_as_set for i in range(len(df.columns))]\n            return into_c(((t[0], {columns[i]: maybe_box_native(v) if is_object_dtype_by_index[i] else v for (i, v) in enumerate(t[1:])}) for t in df.itertuples(name=None)))\n        else:\n            return into_c(((t[0], dict(zip(df.columns, t[1:]))) for t in df.itertuples(name=None)))\n    else:\n        raise ValueError(f\"orient '{orient}' not understood\")",
            "def to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'records', 'index']='dict', *, into: type[MutableMappingT] | MutableMappingT=dict, index: bool=True) -> MutableMappingT | list[MutableMappingT]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Convert the DataFrame to a dictionary.\\n\\n    The type of the key-value pairs can be customized with the parameters\\n    (see below).\\n\\n    Parameters\\n    ----------\\n    orient : str {'dict', 'list', 'series', 'split', 'tight', 'records', 'index'}\\n        Determines the type of the values of the dictionary.\\n\\n        - 'dict' (default) : dict like {column -> {index -> value}}\\n        - 'list' : dict like {column -> [values]}\\n        - 'series' : dict like {column -> Series(values)}\\n        - 'split' : dict like\\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values]}\\n        - 'tight' : dict like\\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values],\\n          'index_names' -> [index.names], 'column_names' -> [column.names]}\\n        - 'records' : list like\\n          [{column -> value}, ... , {column -> value}]\\n        - 'index' : dict like {index -> {column -> value}}\\n\\n        .. versionadded:: 1.4.0\\n            'tight' as an allowed value for the ``orient`` argument\\n\\n    into : class, default dict\\n        The collections.abc.MutableMapping subclass used for all Mappings\\n        in the return value.  Can be the actual class or an empty\\n        instance of the mapping type you want.  If you want a\\n        collections.defaultdict, you must pass it initialized.\\n\\n    index : bool, default True\\n        Whether to include the index item (and index_names item if `orient`\\n        is 'tight') in the returned dictionary. Can only be ``False``\\n        when `orient` is 'split' or 'tight'.\\n\\n        .. versionadded:: 2.0.0\\n\\n    Returns\\n    -------\\n    dict, list or collections.abc.Mapping\\n        Return a collections.abc.MutableMapping object representing the\\n        DataFrame. The resulting transformation depends on the `orient` parameter.\\n    \"\n    if not df.columns.is_unique:\n        warnings.warn('DataFrame columns are not unique, some columns will be omitted.', UserWarning, stacklevel=find_stack_level())\n    into_c = com.standardize_mapping(into)\n    orient = orient.lower()\n    if not index and orient not in ['split', 'tight']:\n        raise ValueError(\"'index=False' is only valid when 'orient' is 'split' or 'tight'\")\n    if orient == 'series':\n        return into_c(((k, v) for (k, v) in df.items()))\n    box_native_indices = [i for (i, col_dtype) in enumerate(df.dtypes.values) if col_dtype == np.dtype(object) or isinstance(col_dtype, ExtensionDtype)]\n    are_all_object_dtype_cols = len(box_native_indices) == len(df.dtypes)\n    if orient == 'dict':\n        return into_c(((k, v.to_dict(into=into)) for (k, v) in df.items()))\n    elif orient == 'list':\n        object_dtype_indices_as_set: set[int] = set(box_native_indices)\n        return into_c(((k, list(map(maybe_box_native, v.to_numpy().tolist())) if i in object_dtype_indices_as_set else v.to_numpy().tolist()) for (i, (k, v)) in enumerate(df.items())))\n    elif orient == 'split':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', data)))\n    elif orient == 'tight':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', [list(map(maybe_box_native, t)) for t in df.itertuples(index=False, name=None)])) + ((('index_names', list(df.index.names)),) if index else ()) + (('column_names', list(df.columns.names)),))\n    elif orient == 'records':\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            rows = (dict(zip(columns, row)) for row in df.itertuples(index=False, name=None))\n            return [into_c(((k, maybe_box_native(v)) for (k, v) in row.items())) for row in rows]\n        else:\n            data = [into_c(zip(columns, t)) for t in df.itertuples(index=False, name=None)]\n            if box_native_indices:\n                object_dtype_indices_as_set = set(box_native_indices)\n                object_dtype_cols = {col for (i, col) in enumerate(df.columns) if i in object_dtype_indices_as_set}\n                for row in data:\n                    for col in object_dtype_cols:\n                        row[col] = maybe_box_native(row[col])\n            return data\n    elif orient == 'index':\n        if not df.index.is_unique:\n            raise ValueError(\"DataFrame index must be unique for orient='index'.\")\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            return into_c(((t[0], dict(zip(df.columns, map(maybe_box_native, t[1:])))) for t in df.itertuples(name=None)))\n        elif box_native_indices:\n            object_dtype_indices_as_set = set(box_native_indices)\n            is_object_dtype_by_index = [i in object_dtype_indices_as_set for i in range(len(df.columns))]\n            return into_c(((t[0], {columns[i]: maybe_box_native(v) if is_object_dtype_by_index[i] else v for (i, v) in enumerate(t[1:])}) for t in df.itertuples(name=None)))\n        else:\n            return into_c(((t[0], dict(zip(df.columns, t[1:]))) for t in df.itertuples(name=None)))\n    else:\n        raise ValueError(f\"orient '{orient}' not understood\")",
            "def to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'records', 'index']='dict', *, into: type[MutableMappingT] | MutableMappingT=dict, index: bool=True) -> MutableMappingT | list[MutableMappingT]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Convert the DataFrame to a dictionary.\\n\\n    The type of the key-value pairs can be customized with the parameters\\n    (see below).\\n\\n    Parameters\\n    ----------\\n    orient : str {'dict', 'list', 'series', 'split', 'tight', 'records', 'index'}\\n        Determines the type of the values of the dictionary.\\n\\n        - 'dict' (default) : dict like {column -> {index -> value}}\\n        - 'list' : dict like {column -> [values]}\\n        - 'series' : dict like {column -> Series(values)}\\n        - 'split' : dict like\\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values]}\\n        - 'tight' : dict like\\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values],\\n          'index_names' -> [index.names], 'column_names' -> [column.names]}\\n        - 'records' : list like\\n          [{column -> value}, ... , {column -> value}]\\n        - 'index' : dict like {index -> {column -> value}}\\n\\n        .. versionadded:: 1.4.0\\n            'tight' as an allowed value for the ``orient`` argument\\n\\n    into : class, default dict\\n        The collections.abc.MutableMapping subclass used for all Mappings\\n        in the return value.  Can be the actual class or an empty\\n        instance of the mapping type you want.  If you want a\\n        collections.defaultdict, you must pass it initialized.\\n\\n    index : bool, default True\\n        Whether to include the index item (and index_names item if `orient`\\n        is 'tight') in the returned dictionary. Can only be ``False``\\n        when `orient` is 'split' or 'tight'.\\n\\n        .. versionadded:: 2.0.0\\n\\n    Returns\\n    -------\\n    dict, list or collections.abc.Mapping\\n        Return a collections.abc.MutableMapping object representing the\\n        DataFrame. The resulting transformation depends on the `orient` parameter.\\n    \"\n    if not df.columns.is_unique:\n        warnings.warn('DataFrame columns are not unique, some columns will be omitted.', UserWarning, stacklevel=find_stack_level())\n    into_c = com.standardize_mapping(into)\n    orient = orient.lower()\n    if not index and orient not in ['split', 'tight']:\n        raise ValueError(\"'index=False' is only valid when 'orient' is 'split' or 'tight'\")\n    if orient == 'series':\n        return into_c(((k, v) for (k, v) in df.items()))\n    box_native_indices = [i for (i, col_dtype) in enumerate(df.dtypes.values) if col_dtype == np.dtype(object) or isinstance(col_dtype, ExtensionDtype)]\n    are_all_object_dtype_cols = len(box_native_indices) == len(df.dtypes)\n    if orient == 'dict':\n        return into_c(((k, v.to_dict(into=into)) for (k, v) in df.items()))\n    elif orient == 'list':\n        object_dtype_indices_as_set: set[int] = set(box_native_indices)\n        return into_c(((k, list(map(maybe_box_native, v.to_numpy().tolist())) if i in object_dtype_indices_as_set else v.to_numpy().tolist()) for (i, (k, v)) in enumerate(df.items())))\n    elif orient == 'split':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', data)))\n    elif orient == 'tight':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', [list(map(maybe_box_native, t)) for t in df.itertuples(index=False, name=None)])) + ((('index_names', list(df.index.names)),) if index else ()) + (('column_names', list(df.columns.names)),))\n    elif orient == 'records':\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            rows = (dict(zip(columns, row)) for row in df.itertuples(index=False, name=None))\n            return [into_c(((k, maybe_box_native(v)) for (k, v) in row.items())) for row in rows]\n        else:\n            data = [into_c(zip(columns, t)) for t in df.itertuples(index=False, name=None)]\n            if box_native_indices:\n                object_dtype_indices_as_set = set(box_native_indices)\n                object_dtype_cols = {col for (i, col) in enumerate(df.columns) if i in object_dtype_indices_as_set}\n                for row in data:\n                    for col in object_dtype_cols:\n                        row[col] = maybe_box_native(row[col])\n            return data\n    elif orient == 'index':\n        if not df.index.is_unique:\n            raise ValueError(\"DataFrame index must be unique for orient='index'.\")\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            return into_c(((t[0], dict(zip(df.columns, map(maybe_box_native, t[1:])))) for t in df.itertuples(name=None)))\n        elif box_native_indices:\n            object_dtype_indices_as_set = set(box_native_indices)\n            is_object_dtype_by_index = [i in object_dtype_indices_as_set for i in range(len(df.columns))]\n            return into_c(((t[0], {columns[i]: maybe_box_native(v) if is_object_dtype_by_index[i] else v for (i, v) in enumerate(t[1:])}) for t in df.itertuples(name=None)))\n        else:\n            return into_c(((t[0], dict(zip(df.columns, t[1:]))) for t in df.itertuples(name=None)))\n    else:\n        raise ValueError(f\"orient '{orient}' not understood\")",
            "def to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'records', 'index']='dict', *, into: type[MutableMappingT] | MutableMappingT=dict, index: bool=True) -> MutableMappingT | list[MutableMappingT]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Convert the DataFrame to a dictionary.\\n\\n    The type of the key-value pairs can be customized with the parameters\\n    (see below).\\n\\n    Parameters\\n    ----------\\n    orient : str {'dict', 'list', 'series', 'split', 'tight', 'records', 'index'}\\n        Determines the type of the values of the dictionary.\\n\\n        - 'dict' (default) : dict like {column -> {index -> value}}\\n        - 'list' : dict like {column -> [values]}\\n        - 'series' : dict like {column -> Series(values)}\\n        - 'split' : dict like\\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values]}\\n        - 'tight' : dict like\\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values],\\n          'index_names' -> [index.names], 'column_names' -> [column.names]}\\n        - 'records' : list like\\n          [{column -> value}, ... , {column -> value}]\\n        - 'index' : dict like {index -> {column -> value}}\\n\\n        .. versionadded:: 1.4.0\\n            'tight' as an allowed value for the ``orient`` argument\\n\\n    into : class, default dict\\n        The collections.abc.MutableMapping subclass used for all Mappings\\n        in the return value.  Can be the actual class or an empty\\n        instance of the mapping type you want.  If you want a\\n        collections.defaultdict, you must pass it initialized.\\n\\n    index : bool, default True\\n        Whether to include the index item (and index_names item if `orient`\\n        is 'tight') in the returned dictionary. Can only be ``False``\\n        when `orient` is 'split' or 'tight'.\\n\\n        .. versionadded:: 2.0.0\\n\\n    Returns\\n    -------\\n    dict, list or collections.abc.Mapping\\n        Return a collections.abc.MutableMapping object representing the\\n        DataFrame. The resulting transformation depends on the `orient` parameter.\\n    \"\n    if not df.columns.is_unique:\n        warnings.warn('DataFrame columns are not unique, some columns will be omitted.', UserWarning, stacklevel=find_stack_level())\n    into_c = com.standardize_mapping(into)\n    orient = orient.lower()\n    if not index and orient not in ['split', 'tight']:\n        raise ValueError(\"'index=False' is only valid when 'orient' is 'split' or 'tight'\")\n    if orient == 'series':\n        return into_c(((k, v) for (k, v) in df.items()))\n    box_native_indices = [i for (i, col_dtype) in enumerate(df.dtypes.values) if col_dtype == np.dtype(object) or isinstance(col_dtype, ExtensionDtype)]\n    are_all_object_dtype_cols = len(box_native_indices) == len(df.dtypes)\n    if orient == 'dict':\n        return into_c(((k, v.to_dict(into=into)) for (k, v) in df.items()))\n    elif orient == 'list':\n        object_dtype_indices_as_set: set[int] = set(box_native_indices)\n        return into_c(((k, list(map(maybe_box_native, v.to_numpy().tolist())) if i in object_dtype_indices_as_set else v.to_numpy().tolist()) for (i, (k, v)) in enumerate(df.items())))\n    elif orient == 'split':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', data)))\n    elif orient == 'tight':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', [list(map(maybe_box_native, t)) for t in df.itertuples(index=False, name=None)])) + ((('index_names', list(df.index.names)),) if index else ()) + (('column_names', list(df.columns.names)),))\n    elif orient == 'records':\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            rows = (dict(zip(columns, row)) for row in df.itertuples(index=False, name=None))\n            return [into_c(((k, maybe_box_native(v)) for (k, v) in row.items())) for row in rows]\n        else:\n            data = [into_c(zip(columns, t)) for t in df.itertuples(index=False, name=None)]\n            if box_native_indices:\n                object_dtype_indices_as_set = set(box_native_indices)\n                object_dtype_cols = {col for (i, col) in enumerate(df.columns) if i in object_dtype_indices_as_set}\n                for row in data:\n                    for col in object_dtype_cols:\n                        row[col] = maybe_box_native(row[col])\n            return data\n    elif orient == 'index':\n        if not df.index.is_unique:\n            raise ValueError(\"DataFrame index must be unique for orient='index'.\")\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            return into_c(((t[0], dict(zip(df.columns, map(maybe_box_native, t[1:])))) for t in df.itertuples(name=None)))\n        elif box_native_indices:\n            object_dtype_indices_as_set = set(box_native_indices)\n            is_object_dtype_by_index = [i in object_dtype_indices_as_set for i in range(len(df.columns))]\n            return into_c(((t[0], {columns[i]: maybe_box_native(v) if is_object_dtype_by_index[i] else v for (i, v) in enumerate(t[1:])}) for t in df.itertuples(name=None)))\n        else:\n            return into_c(((t[0], dict(zip(df.columns, t[1:]))) for t in df.itertuples(name=None)))\n    else:\n        raise ValueError(f\"orient '{orient}' not understood\")",
            "def to_dict(df: DataFrame, orient: Literal['dict', 'list', 'series', 'split', 'tight', 'records', 'index']='dict', *, into: type[MutableMappingT] | MutableMappingT=dict, index: bool=True) -> MutableMappingT | list[MutableMappingT]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Convert the DataFrame to a dictionary.\\n\\n    The type of the key-value pairs can be customized with the parameters\\n    (see below).\\n\\n    Parameters\\n    ----------\\n    orient : str {'dict', 'list', 'series', 'split', 'tight', 'records', 'index'}\\n        Determines the type of the values of the dictionary.\\n\\n        - 'dict' (default) : dict like {column -> {index -> value}}\\n        - 'list' : dict like {column -> [values]}\\n        - 'series' : dict like {column -> Series(values)}\\n        - 'split' : dict like\\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values]}\\n        - 'tight' : dict like\\n          {'index' -> [index], 'columns' -> [columns], 'data' -> [values],\\n          'index_names' -> [index.names], 'column_names' -> [column.names]}\\n        - 'records' : list like\\n          [{column -> value}, ... , {column -> value}]\\n        - 'index' : dict like {index -> {column -> value}}\\n\\n        .. versionadded:: 1.4.0\\n            'tight' as an allowed value for the ``orient`` argument\\n\\n    into : class, default dict\\n        The collections.abc.MutableMapping subclass used for all Mappings\\n        in the return value.  Can be the actual class or an empty\\n        instance of the mapping type you want.  If you want a\\n        collections.defaultdict, you must pass it initialized.\\n\\n    index : bool, default True\\n        Whether to include the index item (and index_names item if `orient`\\n        is 'tight') in the returned dictionary. Can only be ``False``\\n        when `orient` is 'split' or 'tight'.\\n\\n        .. versionadded:: 2.0.0\\n\\n    Returns\\n    -------\\n    dict, list or collections.abc.Mapping\\n        Return a collections.abc.MutableMapping object representing the\\n        DataFrame. The resulting transformation depends on the `orient` parameter.\\n    \"\n    if not df.columns.is_unique:\n        warnings.warn('DataFrame columns are not unique, some columns will be omitted.', UserWarning, stacklevel=find_stack_level())\n    into_c = com.standardize_mapping(into)\n    orient = orient.lower()\n    if not index and orient not in ['split', 'tight']:\n        raise ValueError(\"'index=False' is only valid when 'orient' is 'split' or 'tight'\")\n    if orient == 'series':\n        return into_c(((k, v) for (k, v) in df.items()))\n    box_native_indices = [i for (i, col_dtype) in enumerate(df.dtypes.values) if col_dtype == np.dtype(object) or isinstance(col_dtype, ExtensionDtype)]\n    are_all_object_dtype_cols = len(box_native_indices) == len(df.dtypes)\n    if orient == 'dict':\n        return into_c(((k, v.to_dict(into=into)) for (k, v) in df.items()))\n    elif orient == 'list':\n        object_dtype_indices_as_set: set[int] = set(box_native_indices)\n        return into_c(((k, list(map(maybe_box_native, v.to_numpy().tolist())) if i in object_dtype_indices_as_set else v.to_numpy().tolist()) for (i, (k, v)) in enumerate(df.items())))\n    elif orient == 'split':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', data)))\n    elif orient == 'tight':\n        data = df._create_data_for_split_and_tight_to_dict(are_all_object_dtype_cols, box_native_indices)\n        return into_c(((('index', df.index.tolist()),) if index else ()) + (('columns', df.columns.tolist()), ('data', [list(map(maybe_box_native, t)) for t in df.itertuples(index=False, name=None)])) + ((('index_names', list(df.index.names)),) if index else ()) + (('column_names', list(df.columns.names)),))\n    elif orient == 'records':\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            rows = (dict(zip(columns, row)) for row in df.itertuples(index=False, name=None))\n            return [into_c(((k, maybe_box_native(v)) for (k, v) in row.items())) for row in rows]\n        else:\n            data = [into_c(zip(columns, t)) for t in df.itertuples(index=False, name=None)]\n            if box_native_indices:\n                object_dtype_indices_as_set = set(box_native_indices)\n                object_dtype_cols = {col for (i, col) in enumerate(df.columns) if i in object_dtype_indices_as_set}\n                for row in data:\n                    for col in object_dtype_cols:\n                        row[col] = maybe_box_native(row[col])\n            return data\n    elif orient == 'index':\n        if not df.index.is_unique:\n            raise ValueError(\"DataFrame index must be unique for orient='index'.\")\n        columns = df.columns.tolist()\n        if are_all_object_dtype_cols:\n            return into_c(((t[0], dict(zip(df.columns, map(maybe_box_native, t[1:])))) for t in df.itertuples(name=None)))\n        elif box_native_indices:\n            object_dtype_indices_as_set = set(box_native_indices)\n            is_object_dtype_by_index = [i in object_dtype_indices_as_set for i in range(len(df.columns))]\n            return into_c(((t[0], {columns[i]: maybe_box_native(v) if is_object_dtype_by_index[i] else v for (i, v) in enumerate(t[1:])}) for t in df.itertuples(name=None)))\n        else:\n            return into_c(((t[0], dict(zip(df.columns, t[1:]))) for t in df.itertuples(name=None)))\n    else:\n        raise ValueError(f\"orient '{orient}' not understood\")"
        ]
    }
]