[
    {
        "func_name": "adapted_rand_error",
        "original": "def adapted_rand_error(image_true=None, image_test=None, *, table=None, ignore_labels=(0,), alpha=0.5):\n    \"\"\"Compute Adapted Rand error as defined by the SNEMI3D contest. [1]_\n\n    Parameters\n    ----------\n    image_true : ndarray of int\n        Ground-truth label image, same shape as im_test.\n    image_test : ndarray of int\n        Test image.\n    table : scipy.sparse array in crs format, optional\n        A contingency table built with skimage.evaluate.contingency_table.\n        If None, it will be computed on the fly.\n    ignore_labels : sequence of int, optional\n        Labels to ignore. Any part of the true image labeled with any of these\n        values will not be counted in the score.\n    alpha : float, optional\n        Relative weight given to precision and recall in the adapted Rand error\n        calculation.\n\n    Returns\n    -------\n    are : float\n        The adapted Rand error.\n    prec : float\n        The adapted Rand precision: this is the number of pairs of pixels that\n        have the same label in the test label image *and* in the true image,\n        divided by the number in the test image.\n    rec : float\n        The adapted Rand recall: this is the number of pairs of pixels that\n        have the same label in the test label image *and* in the true image,\n        divided by the number in the true image.\n\n    Notes\n    -----\n    Pixels with label 0 in the true segmentation are ignored in the score.\n\n    The adapted Rand error is calculated as follows:\n\n    :math:`1 - \\\\frac{\\\\sum_{ij} p_{ij}^{2}}{\\\\alpha \\\\sum_{k} s_{k}^{2} +\n    (1-\\\\alpha)\\\\sum_{k} t_{k}^{2}}`,\n    where :math:`p_{ij}` is the probability that a pixel has the same label\n    in the test image *and* in the true image, :math:`t_{k}` is the\n    probability that a pixel has label :math:`k` in the true image,\n    and :math:`s_{k}` is the probability that a pixel has label :math:`k`\n    in the test image.\n\n    Default behavior is to weight precision and recall equally in the\n    adapted Rand error calculation.\n    When alpha = 0, adapted Rand error = recall.\n    When alpha = 1, adapted Rand error = precision.\n\n\n    References\n    ----------\n    .. [1] Arganda-Carreras I, Turaga SC, Berger DR, et al. (2015)\n           Crowdsourcing the creation of image segmentation algorithms\n           for connectomics. Front. Neuroanat. 9:142.\n           :DOI:`10.3389/fnana.2015.00142`\n    \"\"\"\n    if image_test is not None and image_true is not None:\n        check_shape_equality(image_true, image_test)\n    if table is None:\n        p_ij = contingency_table(image_true, image_test, ignore_labels=ignore_labels, normalize=False)\n    else:\n        p_ij = table\n    if alpha < 0.0 or alpha > 1.0:\n        raise ValueError('alpha must be between 0 and 1')\n    sum_p_ij2 = p_ij.data @ p_ij.data - p_ij.sum()\n    a_i = p_ij.sum(axis=1).A.ravel()\n    b_i = p_ij.sum(axis=0).A.ravel()\n    sum_a2 = a_i @ a_i - a_i.sum()\n    sum_b2 = b_i @ b_i - b_i.sum()\n    precision = sum_p_ij2 / sum_a2\n    recall = sum_p_ij2 / sum_b2\n    fscore = sum_p_ij2 / (alpha * sum_a2 + (1 - alpha) * sum_b2)\n    are = 1.0 - fscore\n    return (are, precision, recall)",
        "mutated": [
            "def adapted_rand_error(image_true=None, image_test=None, *, table=None, ignore_labels=(0,), alpha=0.5):\n    if False:\n        i = 10\n    'Compute Adapted Rand error as defined by the SNEMI3D contest. [1]_\\n\\n    Parameters\\n    ----------\\n    image_true : ndarray of int\\n        Ground-truth label image, same shape as im_test.\\n    image_test : ndarray of int\\n        Test image.\\n    table : scipy.sparse array in crs format, optional\\n        A contingency table built with skimage.evaluate.contingency_table.\\n        If None, it will be computed on the fly.\\n    ignore_labels : sequence of int, optional\\n        Labels to ignore. Any part of the true image labeled with any of these\\n        values will not be counted in the score.\\n    alpha : float, optional\\n        Relative weight given to precision and recall in the adapted Rand error\\n        calculation.\\n\\n    Returns\\n    -------\\n    are : float\\n        The adapted Rand error.\\n    prec : float\\n        The adapted Rand precision: this is the number of pairs of pixels that\\n        have the same label in the test label image *and* in the true image,\\n        divided by the number in the test image.\\n    rec : float\\n        The adapted Rand recall: this is the number of pairs of pixels that\\n        have the same label in the test label image *and* in the true image,\\n        divided by the number in the true image.\\n\\n    Notes\\n    -----\\n    Pixels with label 0 in the true segmentation are ignored in the score.\\n\\n    The adapted Rand error is calculated as follows:\\n\\n    :math:`1 - \\\\frac{\\\\sum_{ij} p_{ij}^{2}}{\\\\alpha \\\\sum_{k} s_{k}^{2} +\\n    (1-\\\\alpha)\\\\sum_{k} t_{k}^{2}}`,\\n    where :math:`p_{ij}` is the probability that a pixel has the same label\\n    in the test image *and* in the true image, :math:`t_{k}` is the\\n    probability that a pixel has label :math:`k` in the true image,\\n    and :math:`s_{k}` is the probability that a pixel has label :math:`k`\\n    in the test image.\\n\\n    Default behavior is to weight precision and recall equally in the\\n    adapted Rand error calculation.\\n    When alpha = 0, adapted Rand error = recall.\\n    When alpha = 1, adapted Rand error = precision.\\n\\n\\n    References\\n    ----------\\n    .. [1] Arganda-Carreras I, Turaga SC, Berger DR, et al. (2015)\\n           Crowdsourcing the creation of image segmentation algorithms\\n           for connectomics. Front. Neuroanat. 9:142.\\n           :DOI:`10.3389/fnana.2015.00142`\\n    '\n    if image_test is not None and image_true is not None:\n        check_shape_equality(image_true, image_test)\n    if table is None:\n        p_ij = contingency_table(image_true, image_test, ignore_labels=ignore_labels, normalize=False)\n    else:\n        p_ij = table\n    if alpha < 0.0 or alpha > 1.0:\n        raise ValueError('alpha must be between 0 and 1')\n    sum_p_ij2 = p_ij.data @ p_ij.data - p_ij.sum()\n    a_i = p_ij.sum(axis=1).A.ravel()\n    b_i = p_ij.sum(axis=0).A.ravel()\n    sum_a2 = a_i @ a_i - a_i.sum()\n    sum_b2 = b_i @ b_i - b_i.sum()\n    precision = sum_p_ij2 / sum_a2\n    recall = sum_p_ij2 / sum_b2\n    fscore = sum_p_ij2 / (alpha * sum_a2 + (1 - alpha) * sum_b2)\n    are = 1.0 - fscore\n    return (are, precision, recall)",
            "def adapted_rand_error(image_true=None, image_test=None, *, table=None, ignore_labels=(0,), alpha=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Compute Adapted Rand error as defined by the SNEMI3D contest. [1]_\\n\\n    Parameters\\n    ----------\\n    image_true : ndarray of int\\n        Ground-truth label image, same shape as im_test.\\n    image_test : ndarray of int\\n        Test image.\\n    table : scipy.sparse array in crs format, optional\\n        A contingency table built with skimage.evaluate.contingency_table.\\n        If None, it will be computed on the fly.\\n    ignore_labels : sequence of int, optional\\n        Labels to ignore. Any part of the true image labeled with any of these\\n        values will not be counted in the score.\\n    alpha : float, optional\\n        Relative weight given to precision and recall in the adapted Rand error\\n        calculation.\\n\\n    Returns\\n    -------\\n    are : float\\n        The adapted Rand error.\\n    prec : float\\n        The adapted Rand precision: this is the number of pairs of pixels that\\n        have the same label in the test label image *and* in the true image,\\n        divided by the number in the test image.\\n    rec : float\\n        The adapted Rand recall: this is the number of pairs of pixels that\\n        have the same label in the test label image *and* in the true image,\\n        divided by the number in the true image.\\n\\n    Notes\\n    -----\\n    Pixels with label 0 in the true segmentation are ignored in the score.\\n\\n    The adapted Rand error is calculated as follows:\\n\\n    :math:`1 - \\\\frac{\\\\sum_{ij} p_{ij}^{2}}{\\\\alpha \\\\sum_{k} s_{k}^{2} +\\n    (1-\\\\alpha)\\\\sum_{k} t_{k}^{2}}`,\\n    where :math:`p_{ij}` is the probability that a pixel has the same label\\n    in the test image *and* in the true image, :math:`t_{k}` is the\\n    probability that a pixel has label :math:`k` in the true image,\\n    and :math:`s_{k}` is the probability that a pixel has label :math:`k`\\n    in the test image.\\n\\n    Default behavior is to weight precision and recall equally in the\\n    adapted Rand error calculation.\\n    When alpha = 0, adapted Rand error = recall.\\n    When alpha = 1, adapted Rand error = precision.\\n\\n\\n    References\\n    ----------\\n    .. [1] Arganda-Carreras I, Turaga SC, Berger DR, et al. (2015)\\n           Crowdsourcing the creation of image segmentation algorithms\\n           for connectomics. Front. Neuroanat. 9:142.\\n           :DOI:`10.3389/fnana.2015.00142`\\n    '\n    if image_test is not None and image_true is not None:\n        check_shape_equality(image_true, image_test)\n    if table is None:\n        p_ij = contingency_table(image_true, image_test, ignore_labels=ignore_labels, normalize=False)\n    else:\n        p_ij = table\n    if alpha < 0.0 or alpha > 1.0:\n        raise ValueError('alpha must be between 0 and 1')\n    sum_p_ij2 = p_ij.data @ p_ij.data - p_ij.sum()\n    a_i = p_ij.sum(axis=1).A.ravel()\n    b_i = p_ij.sum(axis=0).A.ravel()\n    sum_a2 = a_i @ a_i - a_i.sum()\n    sum_b2 = b_i @ b_i - b_i.sum()\n    precision = sum_p_ij2 / sum_a2\n    recall = sum_p_ij2 / sum_b2\n    fscore = sum_p_ij2 / (alpha * sum_a2 + (1 - alpha) * sum_b2)\n    are = 1.0 - fscore\n    return (are, precision, recall)",
            "def adapted_rand_error(image_true=None, image_test=None, *, table=None, ignore_labels=(0,), alpha=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Compute Adapted Rand error as defined by the SNEMI3D contest. [1]_\\n\\n    Parameters\\n    ----------\\n    image_true : ndarray of int\\n        Ground-truth label image, same shape as im_test.\\n    image_test : ndarray of int\\n        Test image.\\n    table : scipy.sparse array in crs format, optional\\n        A contingency table built with skimage.evaluate.contingency_table.\\n        If None, it will be computed on the fly.\\n    ignore_labels : sequence of int, optional\\n        Labels to ignore. Any part of the true image labeled with any of these\\n        values will not be counted in the score.\\n    alpha : float, optional\\n        Relative weight given to precision and recall in the adapted Rand error\\n        calculation.\\n\\n    Returns\\n    -------\\n    are : float\\n        The adapted Rand error.\\n    prec : float\\n        The adapted Rand precision: this is the number of pairs of pixels that\\n        have the same label in the test label image *and* in the true image,\\n        divided by the number in the test image.\\n    rec : float\\n        The adapted Rand recall: this is the number of pairs of pixels that\\n        have the same label in the test label image *and* in the true image,\\n        divided by the number in the true image.\\n\\n    Notes\\n    -----\\n    Pixels with label 0 in the true segmentation are ignored in the score.\\n\\n    The adapted Rand error is calculated as follows:\\n\\n    :math:`1 - \\\\frac{\\\\sum_{ij} p_{ij}^{2}}{\\\\alpha \\\\sum_{k} s_{k}^{2} +\\n    (1-\\\\alpha)\\\\sum_{k} t_{k}^{2}}`,\\n    where :math:`p_{ij}` is the probability that a pixel has the same label\\n    in the test image *and* in the true image, :math:`t_{k}` is the\\n    probability that a pixel has label :math:`k` in the true image,\\n    and :math:`s_{k}` is the probability that a pixel has label :math:`k`\\n    in the test image.\\n\\n    Default behavior is to weight precision and recall equally in the\\n    adapted Rand error calculation.\\n    When alpha = 0, adapted Rand error = recall.\\n    When alpha = 1, adapted Rand error = precision.\\n\\n\\n    References\\n    ----------\\n    .. [1] Arganda-Carreras I, Turaga SC, Berger DR, et al. (2015)\\n           Crowdsourcing the creation of image segmentation algorithms\\n           for connectomics. Front. Neuroanat. 9:142.\\n           :DOI:`10.3389/fnana.2015.00142`\\n    '\n    if image_test is not None and image_true is not None:\n        check_shape_equality(image_true, image_test)\n    if table is None:\n        p_ij = contingency_table(image_true, image_test, ignore_labels=ignore_labels, normalize=False)\n    else:\n        p_ij = table\n    if alpha < 0.0 or alpha > 1.0:\n        raise ValueError('alpha must be between 0 and 1')\n    sum_p_ij2 = p_ij.data @ p_ij.data - p_ij.sum()\n    a_i = p_ij.sum(axis=1).A.ravel()\n    b_i = p_ij.sum(axis=0).A.ravel()\n    sum_a2 = a_i @ a_i - a_i.sum()\n    sum_b2 = b_i @ b_i - b_i.sum()\n    precision = sum_p_ij2 / sum_a2\n    recall = sum_p_ij2 / sum_b2\n    fscore = sum_p_ij2 / (alpha * sum_a2 + (1 - alpha) * sum_b2)\n    are = 1.0 - fscore\n    return (are, precision, recall)",
            "def adapted_rand_error(image_true=None, image_test=None, *, table=None, ignore_labels=(0,), alpha=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Compute Adapted Rand error as defined by the SNEMI3D contest. [1]_\\n\\n    Parameters\\n    ----------\\n    image_true : ndarray of int\\n        Ground-truth label image, same shape as im_test.\\n    image_test : ndarray of int\\n        Test image.\\n    table : scipy.sparse array in crs format, optional\\n        A contingency table built with skimage.evaluate.contingency_table.\\n        If None, it will be computed on the fly.\\n    ignore_labels : sequence of int, optional\\n        Labels to ignore. Any part of the true image labeled with any of these\\n        values will not be counted in the score.\\n    alpha : float, optional\\n        Relative weight given to precision and recall in the adapted Rand error\\n        calculation.\\n\\n    Returns\\n    -------\\n    are : float\\n        The adapted Rand error.\\n    prec : float\\n        The adapted Rand precision: this is the number of pairs of pixels that\\n        have the same label in the test label image *and* in the true image,\\n        divided by the number in the test image.\\n    rec : float\\n        The adapted Rand recall: this is the number of pairs of pixels that\\n        have the same label in the test label image *and* in the true image,\\n        divided by the number in the true image.\\n\\n    Notes\\n    -----\\n    Pixels with label 0 in the true segmentation are ignored in the score.\\n\\n    The adapted Rand error is calculated as follows:\\n\\n    :math:`1 - \\\\frac{\\\\sum_{ij} p_{ij}^{2}}{\\\\alpha \\\\sum_{k} s_{k}^{2} +\\n    (1-\\\\alpha)\\\\sum_{k} t_{k}^{2}}`,\\n    where :math:`p_{ij}` is the probability that a pixel has the same label\\n    in the test image *and* in the true image, :math:`t_{k}` is the\\n    probability that a pixel has label :math:`k` in the true image,\\n    and :math:`s_{k}` is the probability that a pixel has label :math:`k`\\n    in the test image.\\n\\n    Default behavior is to weight precision and recall equally in the\\n    adapted Rand error calculation.\\n    When alpha = 0, adapted Rand error = recall.\\n    When alpha = 1, adapted Rand error = precision.\\n\\n\\n    References\\n    ----------\\n    .. [1] Arganda-Carreras I, Turaga SC, Berger DR, et al. (2015)\\n           Crowdsourcing the creation of image segmentation algorithms\\n           for connectomics. Front. Neuroanat. 9:142.\\n           :DOI:`10.3389/fnana.2015.00142`\\n    '\n    if image_test is not None and image_true is not None:\n        check_shape_equality(image_true, image_test)\n    if table is None:\n        p_ij = contingency_table(image_true, image_test, ignore_labels=ignore_labels, normalize=False)\n    else:\n        p_ij = table\n    if alpha < 0.0 or alpha > 1.0:\n        raise ValueError('alpha must be between 0 and 1')\n    sum_p_ij2 = p_ij.data @ p_ij.data - p_ij.sum()\n    a_i = p_ij.sum(axis=1).A.ravel()\n    b_i = p_ij.sum(axis=0).A.ravel()\n    sum_a2 = a_i @ a_i - a_i.sum()\n    sum_b2 = b_i @ b_i - b_i.sum()\n    precision = sum_p_ij2 / sum_a2\n    recall = sum_p_ij2 / sum_b2\n    fscore = sum_p_ij2 / (alpha * sum_a2 + (1 - alpha) * sum_b2)\n    are = 1.0 - fscore\n    return (are, precision, recall)",
            "def adapted_rand_error(image_true=None, image_test=None, *, table=None, ignore_labels=(0,), alpha=0.5):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Compute Adapted Rand error as defined by the SNEMI3D contest. [1]_\\n\\n    Parameters\\n    ----------\\n    image_true : ndarray of int\\n        Ground-truth label image, same shape as im_test.\\n    image_test : ndarray of int\\n        Test image.\\n    table : scipy.sparse array in crs format, optional\\n        A contingency table built with skimage.evaluate.contingency_table.\\n        If None, it will be computed on the fly.\\n    ignore_labels : sequence of int, optional\\n        Labels to ignore. Any part of the true image labeled with any of these\\n        values will not be counted in the score.\\n    alpha : float, optional\\n        Relative weight given to precision and recall in the adapted Rand error\\n        calculation.\\n\\n    Returns\\n    -------\\n    are : float\\n        The adapted Rand error.\\n    prec : float\\n        The adapted Rand precision: this is the number of pairs of pixels that\\n        have the same label in the test label image *and* in the true image,\\n        divided by the number in the test image.\\n    rec : float\\n        The adapted Rand recall: this is the number of pairs of pixels that\\n        have the same label in the test label image *and* in the true image,\\n        divided by the number in the true image.\\n\\n    Notes\\n    -----\\n    Pixels with label 0 in the true segmentation are ignored in the score.\\n\\n    The adapted Rand error is calculated as follows:\\n\\n    :math:`1 - \\\\frac{\\\\sum_{ij} p_{ij}^{2}}{\\\\alpha \\\\sum_{k} s_{k}^{2} +\\n    (1-\\\\alpha)\\\\sum_{k} t_{k}^{2}}`,\\n    where :math:`p_{ij}` is the probability that a pixel has the same label\\n    in the test image *and* in the true image, :math:`t_{k}` is the\\n    probability that a pixel has label :math:`k` in the true image,\\n    and :math:`s_{k}` is the probability that a pixel has label :math:`k`\\n    in the test image.\\n\\n    Default behavior is to weight precision and recall equally in the\\n    adapted Rand error calculation.\\n    When alpha = 0, adapted Rand error = recall.\\n    When alpha = 1, adapted Rand error = precision.\\n\\n\\n    References\\n    ----------\\n    .. [1] Arganda-Carreras I, Turaga SC, Berger DR, et al. (2015)\\n           Crowdsourcing the creation of image segmentation algorithms\\n           for connectomics. Front. Neuroanat. 9:142.\\n           :DOI:`10.3389/fnana.2015.00142`\\n    '\n    if image_test is not None and image_true is not None:\n        check_shape_equality(image_true, image_test)\n    if table is None:\n        p_ij = contingency_table(image_true, image_test, ignore_labels=ignore_labels, normalize=False)\n    else:\n        p_ij = table\n    if alpha < 0.0 or alpha > 1.0:\n        raise ValueError('alpha must be between 0 and 1')\n    sum_p_ij2 = p_ij.data @ p_ij.data - p_ij.sum()\n    a_i = p_ij.sum(axis=1).A.ravel()\n    b_i = p_ij.sum(axis=0).A.ravel()\n    sum_a2 = a_i @ a_i - a_i.sum()\n    sum_b2 = b_i @ b_i - b_i.sum()\n    precision = sum_p_ij2 / sum_a2\n    recall = sum_p_ij2 / sum_b2\n    fscore = sum_p_ij2 / (alpha * sum_a2 + (1 - alpha) * sum_b2)\n    are = 1.0 - fscore\n    return (are, precision, recall)"
        ]
    }
]