import sys
if sys.version_info.major >= 3:
    long = int
'\n>>> from builtin_converters_ext import *\n\n# Provide values for integer converter tests\n>>> def _signed_values(s):\n...     base = 2 ** (8 * s - 1)\n...     return [[-base, -1, 1, base - 1], [-base - 1, base]]\n>>> def _unsigned_values(s):\n...     base = 2 ** (8 * s)\n...     return [[1, base - 1], [long(-1), -1, base]]\n\n# Wrappers to simplify tests\n>>> def should_pass(method, values):\n...     result = map(method, values[0])\n...     if result != values[0]:\n...         print("Got %s but expected %s" % (result, values[0]))\n>>> def test_overflow(method, values):\n...     for v in values[1]:\n...         try: method(v)\n...         except OverflowError: pass\n...         else: print("OverflowError expected")\n\n# Synthesize idendity functions in case long long not supported\n>>> if not \'rewrap_value_long_long\' in dir():\n...     def rewrap_value_long_long(x): return long(x)\n...     def rewrap_value_unsigned_long_long(x): return long(x)\n...     def rewrap_const_reference_long_long(x): return long(x)\n...     def rewrap_const_reference_unsigned_long_long(x): return long(x)\n>>> if not \'long_long_size\' in dir():\n...     def long_long_size(): return long_size()\n\n>>> try: bool_exists = bool\n... except: pass\n... else:\n...     rewrap_value_bool(True)\n...     rewrap_value_bool(False)\nTrue\nFalse\n\n>>> rewrap_value_bool(None)\n0\n>>> rewrap_value_bool(0)\n0\n>>> rewrap_value_bool(33)\n1\n>>> rewrap_value_char(\'x\')\n\'x\'\n\n  Note that there\'s currently silent truncation of strings passed to\n  char arguments.\n\n>>> rewrap_value_char(\'xy\')\n\'x\'\n>>> rewrap_value_signed_char(42)\n42\n>>> rewrap_value_unsigned_char(42)\n42\n>>> rewrap_value_int(42)\n42\n>>> rewrap_value_unsigned_int(42)\n42\n>>> rewrap_value_short(42)\n42\n>>> rewrap_value_unsigned_short(42)\n42\n>>> rewrap_value_long(42)\n42\n>>> rewrap_value_unsigned_long(42)\n42\n\n    test unsigned long values which don\'t fit in a signed long.\n    strip any \'L\' characters in case the platform has > 32 bit longs\n\n>>> hex(rewrap_value_unsigned_long(long(0x80000001))).replace(\'L\',\'\')\n\'0x80000001\'\n\n>>> rewrap_value_long_long(42) == 42\nTrue\n>>> rewrap_value_unsigned_long_long(42) == 42\nTrue\n\n   show that we have range checking.\n\n>>> should_pass(rewrap_value_signed_char, _signed_values(char_size()))\n>>> should_pass(rewrap_value_short, _signed_values(short_size()))\n>>> should_pass(rewrap_value_int, _signed_values(int_size()))\n>>> should_pass(rewrap_value_long, _signed_values(long_size()))\n>>> should_pass(rewrap_value_long_long, _signed_values(long_long_size()))\n\n>>> should_pass(rewrap_value_unsigned_char, _unsigned_values(char_size()))\n>>> should_pass(rewrap_value_unsigned_short, _unsigned_values(short_size()))\n>>> should_pass(rewrap_value_unsigned_int, _unsigned_values(int_size()))\n>>> should_pass(rewrap_value_unsigned_long, _unsigned_values(long_size()))\n>>> should_pass(rewrap_value_unsigned_long_long,\n...     _unsigned_values(long_long_size()))\n\n>>> test_overflow(rewrap_value_signed_char, _signed_values(char_size()))\n>>> test_overflow(rewrap_value_short, _signed_values(short_size()))\n>>> test_overflow(rewrap_value_int, _signed_values(int_size()))\n>>> test_overflow(rewrap_value_long, _signed_values(long_size()))\n>>> test_overflow(rewrap_value_long_long, _signed_values(long_long_size()))\n\n>>> test_overflow(rewrap_value_unsigned_char, _unsigned_values(char_size()))\n>>> test_overflow(rewrap_value_unsigned_short, _unsigned_values(short_size()))\n>>> test_overflow(rewrap_value_unsigned_int, _unsigned_values(int_size()))\n>>> test_overflow(rewrap_value_unsigned_long, _unsigned_values(long_size()))\n\n# Exceptionally for PyLong_AsUnsignedLongLong(), a negative value raises\n# TypeError on Python versions prior to 2.7\n>>> for v in _unsigned_values(long_long_size())[1]:\n...     try: rewrap_value_unsigned_long_long(v)\n...     except (OverflowError, TypeError): pass\n...     else: print("OverflowError or TypeError expected")\n\n>>> assert abs(rewrap_value_float(4.2) - 4.2) < .000001\n>>> rewrap_value_double(4.2) - 4.2\n0.0\n>>> rewrap_value_long_double(4.2) - 4.2\n0.0\n\n>>> assert abs(rewrap_value_complex_float(4+.2j) - (4+.2j)) < .000001\n>>> assert abs(rewrap_value_complex_double(4+.2j) - (4+.2j)) < .000001\n>>> assert abs(rewrap_value_complex_long_double(4+.2j) - (4+.2j)) < .000001\n\n>>> rewrap_value_cstring(\'hello, world\')\n\'hello, world\'\n>>> rewrap_value_string(\'yo, wassup?\')\n\'yo, wassup?\'\n\n>>> print(rewrap_value_wstring(u\'yo, wassup?\'))\nyo, wassup?\n\n>>> print(rewrap_value_wstring(u\'\\U0001f4a9\'))\n\\U0001f4a9\n\n   test that overloading on unicode works:\n\n>>> print(rewrap_value_string(u\'yo, wassup?\'))\nyo, wassup?\n\n   wrap strings with embedded nulls:\n\n>>> rewrap_value_string(\'yo,\\0wassup?\')\n\'yo,\\x00wassup?\'\n\n>>> rewrap_value_handle(1)\n1\n>>> x = \'hi\'\n>>> assert rewrap_value_handle(x) is x\n>>> assert rewrap_value_object(x) is x\n\n  Note that we can currently get a mutable pointer into an immutable\n  Python string:\n\n>>> rewrap_value_mutable_cstring(\'hello, world\')\n\'hello, world\'\n\n>>> rewrap_const_reference_bool(None)\n0\n>>> rewrap_const_reference_bool(0)\n0\n\n>>> try: rewrap_const_reference_bool(\'yes\')\n... except TypeError: pass\n... else: print(\'expected a TypeError exception\')\n\n>>> rewrap_const_reference_char(\'x\')\n\'x\'\n\n  Note that there\'s currently silent truncation of strings passed to\n  char arguments.\n\n>>> rewrap_const_reference_char(\'xy\')\n\'x\'\n>>> rewrap_const_reference_signed_char(42)\n42\n>>> rewrap_const_reference_unsigned_char(42)\n42\n>>> rewrap_const_reference_int(42)\n42\n>>> rewrap_const_reference_unsigned_int(42)\n42\n>>> rewrap_const_reference_short(42)\n42\n>>> rewrap_const_reference_unsigned_short(42)\n42\n>>> rewrap_const_reference_long(42)\n42\n>>> rewrap_const_reference_unsigned_long(42)\n42\n>>> rewrap_const_reference_long_long(42) == 42\nTrue\n>>> rewrap_const_reference_unsigned_long_long(42) == 42\nTrue\n\n\n>>> assert abs(rewrap_const_reference_float(4.2) - 4.2) < .000001\n>>> rewrap_const_reference_double(4.2) - 4.2\n0.0\n>>> rewrap_const_reference_long_double(4.2) - 4.2\n0.0\n\n>>> assert abs(rewrap_const_reference_complex_float(4+.2j) - (4+.2j)) < .000001\n>>> assert abs(rewrap_const_reference_complex_double(4+.2j) - (4+.2j)) < .000001\n>>> assert abs(rewrap_const_reference_complex_long_double(4+.2j) - (4+.2j)) < .000001\n\n>>> rewrap_const_reference_cstring(\'hello, world\')\n\'hello, world\'\n>>> rewrap_const_reference_string(\'yo, wassup?\')\n\'yo, wassup?\'\n\n>>> rewrap_const_reference_handle(1)\n1\n>>> x = \'hi\'\n>>> assert rewrap_const_reference_handle(x) is x\n>>> assert rewrap_const_reference_object(x) is x\n>>> assert rewrap_reference_object(x) is x\n\n\nCheck that None <==> NULL\n\n>>> rewrap_const_reference_cstring(None)\n\nBut None cannot be converted to a string object:\n\n>>> try: rewrap_const_reference_string(None)\n... except TypeError: pass\n... else: print(\'expected a TypeError exception\')\n\nNow check implicit conversions between floating/integer types\n\n>>> rewrap_const_reference_float(42)\n42.0\n\n>>> rewrap_const_reference_float(long(42))\n42.0\n\n>>> try: rewrap_const_reference_int(42.0)\n... except TypeError: pass\n... else: print(\'expected a TypeError exception\')\n\n>>> rewrap_value_float(42)\n42.0\n\n>>> try: rewrap_value_int(42.0)\n... except TypeError: pass\n... else: print(\'expected a TypeError exception\')\n\nCheck that classic classes also work\n\n>>> class FortyTwo:\n...     def __int__(self):\n...         return 42\n...     def __float__(self):\n...         return 42.0\n...     def __complex__(self):\n...         return complex(4+.2j)\n...     def __str__(self):\n...         return \'42\'\n\n>>> try: rewrap_const_reference_float(FortyTwo())\n... except TypeError: pass\n... else: print(\'expected a TypeError exception\')\n\n>>> try: rewrap_value_int(FortyTwo())\n... except TypeError: pass\n... else: print(\'expected a TypeError exception\')\n\n>>> try: rewrap_const_reference_string(FortyTwo())\n... except TypeError: pass\n... else: print(\'expected a TypeError exception\')\n\n>>> try: rewrap_value_complex_double(FortyTwo())\n... except TypeError: pass\n... else: print(\'expected a TypeError exception\')\n\n# show that arbitrary handle<T> instantiations can be returned\n>>> assert get_type(1) is type(1)\n\n>>> assert return_null_handle() is None\n'
import sys
if sys.version_info.major >= 3:
    long = int

def run(args=None):
    if False:
        while True:
            i = 10
    import sys
    import doctest
    import builtin_converters_ext
    if 'rewrap_value_long_long' in dir(builtin_converters_ext):
        print('LONG_LONG supported, testing...')
    else:
        print('LONG_LONG not supported, skipping those tests...')
    if args is not None:
        sys.argv = args
    return doctest.testmod(sys.modules.get(__name__))
if __name__ == '__main__':
    print('running...')
    import sys
    status = run()[0]
    if status == 0:
        print('Done.')
    sys.exit(status)