[
    {
        "func_name": "read_chunk",
        "original": "def read_chunk(addr):\n    \"\"\"Read a chunk's metadata.\"\"\"\n    renames = {'mchunk_size': 'size', 'mchunk_prev_size': 'prev_size'}\n    if isinstance(pwndbg.heap.current, DebugSymsHeap):\n        val = pwndbg.gdblib.typeinfo.read_gdbvalue('struct malloc_chunk', addr)\n    else:\n        val = pwndbg.heap.current.malloc_chunk(addr)\n    return dict({renames.get(key, key): int(val[key]) for key in val.type.keys()})",
        "mutated": [
            "def read_chunk(addr):\n    if False:\n        i = 10\n    \"Read a chunk's metadata.\"\n    renames = {'mchunk_size': 'size', 'mchunk_prev_size': 'prev_size'}\n    if isinstance(pwndbg.heap.current, DebugSymsHeap):\n        val = pwndbg.gdblib.typeinfo.read_gdbvalue('struct malloc_chunk', addr)\n    else:\n        val = pwndbg.heap.current.malloc_chunk(addr)\n    return dict({renames.get(key, key): int(val[key]) for key in val.type.keys()})",
            "def read_chunk(addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Read a chunk's metadata.\"\n    renames = {'mchunk_size': 'size', 'mchunk_prev_size': 'prev_size'}\n    if isinstance(pwndbg.heap.current, DebugSymsHeap):\n        val = pwndbg.gdblib.typeinfo.read_gdbvalue('struct malloc_chunk', addr)\n    else:\n        val = pwndbg.heap.current.malloc_chunk(addr)\n    return dict({renames.get(key, key): int(val[key]) for key in val.type.keys()})",
            "def read_chunk(addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Read a chunk's metadata.\"\n    renames = {'mchunk_size': 'size', 'mchunk_prev_size': 'prev_size'}\n    if isinstance(pwndbg.heap.current, DebugSymsHeap):\n        val = pwndbg.gdblib.typeinfo.read_gdbvalue('struct malloc_chunk', addr)\n    else:\n        val = pwndbg.heap.current.malloc_chunk(addr)\n    return dict({renames.get(key, key): int(val[key]) for key in val.type.keys()})",
            "def read_chunk(addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Read a chunk's metadata.\"\n    renames = {'mchunk_size': 'size', 'mchunk_prev_size': 'prev_size'}\n    if isinstance(pwndbg.heap.current, DebugSymsHeap):\n        val = pwndbg.gdblib.typeinfo.read_gdbvalue('struct malloc_chunk', addr)\n    else:\n        val = pwndbg.heap.current.malloc_chunk(addr)\n    return dict({renames.get(key, key): int(val[key]) for key in val.type.keys()})",
            "def read_chunk(addr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Read a chunk's metadata.\"\n    renames = {'mchunk_size': 'size', 'mchunk_prev_size': 'prev_size'}\n    if isinstance(pwndbg.heap.current, DebugSymsHeap):\n        val = pwndbg.gdblib.typeinfo.read_gdbvalue('struct malloc_chunk', addr)\n    else:\n        val = pwndbg.heap.current.malloc_chunk(addr)\n    return dict({renames.get(key, key): int(val[key]) for key in val.type.keys()})"
        ]
    },
    {
        "func_name": "format_bin",
        "original": "def format_bin(bins: Bins, verbose=False, offset=None):\n    allocator = pwndbg.heap.current\n    if offset is None:\n        offset = allocator.chunk_key_offset('fd')\n    result = []\n    bins_type = bins.bin_type\n    for size in bins.bins:\n        b = bins.bins[size]\n        (count, is_chain_corrupted) = (None, False)\n        safe_lnk = False\n        if bins_type == BinType.FAST:\n            chain_fd = b.fd_chain\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        elif bins_type == BinType.TCACHE:\n            chain_fd = b.fd_chain\n            count = b.count\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        else:\n            chain_fd = b.fd_chain\n            chain_bk = b.bk_chain\n            is_chain_corrupted = b.is_corrupted\n        if not verbose and (chain_fd == [0] and (not count)) and (not is_chain_corrupted):\n            continue\n        if bins_type == BinType.TCACHE:\n            limit = 8\n            if count <= 7:\n                limit = count + 1\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, limit=limit, safe_linking=safe_lnk)\n        else:\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, safe_linking=safe_lnk)\n        if isinstance(size, int):\n            if bins_type == BinType.LARGE:\n                (start_size, end_size) = allocator.largebin_size_range_from_index(size)\n                size = hex(start_size) + '-'\n                if end_size != pwndbg.gdblib.arch.ptrmask:\n                    size += hex(end_size)\n                else:\n                    size += '\u221e'\n            else:\n                size = hex(size)\n        if is_chain_corrupted:\n            line = message.hint(size) + message.error(' [corrupted]') + '\\n'\n            line += message.hint('FD: ') + formatted_chain + '\\n'\n            line += message.hint('BK: ') + pwndbg.chain.format(chain_bk[0], offset=allocator.chunk_key_offset('bk'))\n        else:\n            if count is not None:\n                line = (message.hint(size) + message.hint(' [%3d]' % count) + ': ').ljust(13)\n            else:\n                line = (message.hint(size) + ': ').ljust(13)\n            line += formatted_chain\n        result.append(line)\n    if not result:\n        result.append(message.hint('empty'))\n    return result",
        "mutated": [
            "def format_bin(bins: Bins, verbose=False, offset=None):\n    if False:\n        i = 10\n    allocator = pwndbg.heap.current\n    if offset is None:\n        offset = allocator.chunk_key_offset('fd')\n    result = []\n    bins_type = bins.bin_type\n    for size in bins.bins:\n        b = bins.bins[size]\n        (count, is_chain_corrupted) = (None, False)\n        safe_lnk = False\n        if bins_type == BinType.FAST:\n            chain_fd = b.fd_chain\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        elif bins_type == BinType.TCACHE:\n            chain_fd = b.fd_chain\n            count = b.count\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        else:\n            chain_fd = b.fd_chain\n            chain_bk = b.bk_chain\n            is_chain_corrupted = b.is_corrupted\n        if not verbose and (chain_fd == [0] and (not count)) and (not is_chain_corrupted):\n            continue\n        if bins_type == BinType.TCACHE:\n            limit = 8\n            if count <= 7:\n                limit = count + 1\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, limit=limit, safe_linking=safe_lnk)\n        else:\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, safe_linking=safe_lnk)\n        if isinstance(size, int):\n            if bins_type == BinType.LARGE:\n                (start_size, end_size) = allocator.largebin_size_range_from_index(size)\n                size = hex(start_size) + '-'\n                if end_size != pwndbg.gdblib.arch.ptrmask:\n                    size += hex(end_size)\n                else:\n                    size += '\u221e'\n            else:\n                size = hex(size)\n        if is_chain_corrupted:\n            line = message.hint(size) + message.error(' [corrupted]') + '\\n'\n            line += message.hint('FD: ') + formatted_chain + '\\n'\n            line += message.hint('BK: ') + pwndbg.chain.format(chain_bk[0], offset=allocator.chunk_key_offset('bk'))\n        else:\n            if count is not None:\n                line = (message.hint(size) + message.hint(' [%3d]' % count) + ': ').ljust(13)\n            else:\n                line = (message.hint(size) + ': ').ljust(13)\n            line += formatted_chain\n        result.append(line)\n    if not result:\n        result.append(message.hint('empty'))\n    return result",
            "def format_bin(bins: Bins, verbose=False, offset=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    allocator = pwndbg.heap.current\n    if offset is None:\n        offset = allocator.chunk_key_offset('fd')\n    result = []\n    bins_type = bins.bin_type\n    for size in bins.bins:\n        b = bins.bins[size]\n        (count, is_chain_corrupted) = (None, False)\n        safe_lnk = False\n        if bins_type == BinType.FAST:\n            chain_fd = b.fd_chain\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        elif bins_type == BinType.TCACHE:\n            chain_fd = b.fd_chain\n            count = b.count\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        else:\n            chain_fd = b.fd_chain\n            chain_bk = b.bk_chain\n            is_chain_corrupted = b.is_corrupted\n        if not verbose and (chain_fd == [0] and (not count)) and (not is_chain_corrupted):\n            continue\n        if bins_type == BinType.TCACHE:\n            limit = 8\n            if count <= 7:\n                limit = count + 1\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, limit=limit, safe_linking=safe_lnk)\n        else:\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, safe_linking=safe_lnk)\n        if isinstance(size, int):\n            if bins_type == BinType.LARGE:\n                (start_size, end_size) = allocator.largebin_size_range_from_index(size)\n                size = hex(start_size) + '-'\n                if end_size != pwndbg.gdblib.arch.ptrmask:\n                    size += hex(end_size)\n                else:\n                    size += '\u221e'\n            else:\n                size = hex(size)\n        if is_chain_corrupted:\n            line = message.hint(size) + message.error(' [corrupted]') + '\\n'\n            line += message.hint('FD: ') + formatted_chain + '\\n'\n            line += message.hint('BK: ') + pwndbg.chain.format(chain_bk[0], offset=allocator.chunk_key_offset('bk'))\n        else:\n            if count is not None:\n                line = (message.hint(size) + message.hint(' [%3d]' % count) + ': ').ljust(13)\n            else:\n                line = (message.hint(size) + ': ').ljust(13)\n            line += formatted_chain\n        result.append(line)\n    if not result:\n        result.append(message.hint('empty'))\n    return result",
            "def format_bin(bins: Bins, verbose=False, offset=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    allocator = pwndbg.heap.current\n    if offset is None:\n        offset = allocator.chunk_key_offset('fd')\n    result = []\n    bins_type = bins.bin_type\n    for size in bins.bins:\n        b = bins.bins[size]\n        (count, is_chain_corrupted) = (None, False)\n        safe_lnk = False\n        if bins_type == BinType.FAST:\n            chain_fd = b.fd_chain\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        elif bins_type == BinType.TCACHE:\n            chain_fd = b.fd_chain\n            count = b.count\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        else:\n            chain_fd = b.fd_chain\n            chain_bk = b.bk_chain\n            is_chain_corrupted = b.is_corrupted\n        if not verbose and (chain_fd == [0] and (not count)) and (not is_chain_corrupted):\n            continue\n        if bins_type == BinType.TCACHE:\n            limit = 8\n            if count <= 7:\n                limit = count + 1\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, limit=limit, safe_linking=safe_lnk)\n        else:\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, safe_linking=safe_lnk)\n        if isinstance(size, int):\n            if bins_type == BinType.LARGE:\n                (start_size, end_size) = allocator.largebin_size_range_from_index(size)\n                size = hex(start_size) + '-'\n                if end_size != pwndbg.gdblib.arch.ptrmask:\n                    size += hex(end_size)\n                else:\n                    size += '\u221e'\n            else:\n                size = hex(size)\n        if is_chain_corrupted:\n            line = message.hint(size) + message.error(' [corrupted]') + '\\n'\n            line += message.hint('FD: ') + formatted_chain + '\\n'\n            line += message.hint('BK: ') + pwndbg.chain.format(chain_bk[0], offset=allocator.chunk_key_offset('bk'))\n        else:\n            if count is not None:\n                line = (message.hint(size) + message.hint(' [%3d]' % count) + ': ').ljust(13)\n            else:\n                line = (message.hint(size) + ': ').ljust(13)\n            line += formatted_chain\n        result.append(line)\n    if not result:\n        result.append(message.hint('empty'))\n    return result",
            "def format_bin(bins: Bins, verbose=False, offset=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    allocator = pwndbg.heap.current\n    if offset is None:\n        offset = allocator.chunk_key_offset('fd')\n    result = []\n    bins_type = bins.bin_type\n    for size in bins.bins:\n        b = bins.bins[size]\n        (count, is_chain_corrupted) = (None, False)\n        safe_lnk = False\n        if bins_type == BinType.FAST:\n            chain_fd = b.fd_chain\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        elif bins_type == BinType.TCACHE:\n            chain_fd = b.fd_chain\n            count = b.count\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        else:\n            chain_fd = b.fd_chain\n            chain_bk = b.bk_chain\n            is_chain_corrupted = b.is_corrupted\n        if not verbose and (chain_fd == [0] and (not count)) and (not is_chain_corrupted):\n            continue\n        if bins_type == BinType.TCACHE:\n            limit = 8\n            if count <= 7:\n                limit = count + 1\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, limit=limit, safe_linking=safe_lnk)\n        else:\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, safe_linking=safe_lnk)\n        if isinstance(size, int):\n            if bins_type == BinType.LARGE:\n                (start_size, end_size) = allocator.largebin_size_range_from_index(size)\n                size = hex(start_size) + '-'\n                if end_size != pwndbg.gdblib.arch.ptrmask:\n                    size += hex(end_size)\n                else:\n                    size += '\u221e'\n            else:\n                size = hex(size)\n        if is_chain_corrupted:\n            line = message.hint(size) + message.error(' [corrupted]') + '\\n'\n            line += message.hint('FD: ') + formatted_chain + '\\n'\n            line += message.hint('BK: ') + pwndbg.chain.format(chain_bk[0], offset=allocator.chunk_key_offset('bk'))\n        else:\n            if count is not None:\n                line = (message.hint(size) + message.hint(' [%3d]' % count) + ': ').ljust(13)\n            else:\n                line = (message.hint(size) + ': ').ljust(13)\n            line += formatted_chain\n        result.append(line)\n    if not result:\n        result.append(message.hint('empty'))\n    return result",
            "def format_bin(bins: Bins, verbose=False, offset=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    allocator = pwndbg.heap.current\n    if offset is None:\n        offset = allocator.chunk_key_offset('fd')\n    result = []\n    bins_type = bins.bin_type\n    for size in bins.bins:\n        b = bins.bins[size]\n        (count, is_chain_corrupted) = (None, False)\n        safe_lnk = False\n        if bins_type == BinType.FAST:\n            chain_fd = b.fd_chain\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        elif bins_type == BinType.TCACHE:\n            chain_fd = b.fd_chain\n            count = b.count\n            safe_lnk = pwndbg.glibc.check_safe_linking()\n        else:\n            chain_fd = b.fd_chain\n            chain_bk = b.bk_chain\n            is_chain_corrupted = b.is_corrupted\n        if not verbose and (chain_fd == [0] and (not count)) and (not is_chain_corrupted):\n            continue\n        if bins_type == BinType.TCACHE:\n            limit = 8\n            if count <= 7:\n                limit = count + 1\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, limit=limit, safe_linking=safe_lnk)\n        else:\n            formatted_chain = pwndbg.chain.format(chain_fd[0], offset=offset, safe_linking=safe_lnk)\n        if isinstance(size, int):\n            if bins_type == BinType.LARGE:\n                (start_size, end_size) = allocator.largebin_size_range_from_index(size)\n                size = hex(start_size) + '-'\n                if end_size != pwndbg.gdblib.arch.ptrmask:\n                    size += hex(end_size)\n                else:\n                    size += '\u221e'\n            else:\n                size = hex(size)\n        if is_chain_corrupted:\n            line = message.hint(size) + message.error(' [corrupted]') + '\\n'\n            line += message.hint('FD: ') + formatted_chain + '\\n'\n            line += message.hint('BK: ') + pwndbg.chain.format(chain_bk[0], offset=allocator.chunk_key_offset('bk'))\n        else:\n            if count is not None:\n                line = (message.hint(size) + message.hint(' [%3d]' % count) + ': ').ljust(13)\n            else:\n                line = (message.hint(size) + ': ').ljust(13)\n            line += formatted_chain\n        result.append(line)\n    if not result:\n        result.append(message.hint('empty'))\n    return result"
        ]
    },
    {
        "func_name": "print_no_arena_found_error",
        "original": "def print_no_arena_found_error(tid=None) -> None:\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No arena found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))",
        "mutated": [
            "def print_no_arena_found_error(tid=None) -> None:\n    if False:\n        i = 10\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No arena found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))",
            "def print_no_arena_found_error(tid=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No arena found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))",
            "def print_no_arena_found_error(tid=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No arena found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))",
            "def print_no_arena_found_error(tid=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No arena found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))",
            "def print_no_arena_found_error(tid=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No arena found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))"
        ]
    },
    {
        "func_name": "print_no_tcache_bins_found_error",
        "original": "def print_no_tcache_bins_found_error(tid=None) -> None:\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No tcache bins found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))",
        "mutated": [
            "def print_no_tcache_bins_found_error(tid=None) -> None:\n    if False:\n        i = 10\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No tcache bins found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))",
            "def print_no_tcache_bins_found_error(tid=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No tcache bins found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))",
            "def print_no_tcache_bins_found_error(tid=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No tcache bins found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))",
            "def print_no_tcache_bins_found_error(tid=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No tcache bins found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))",
            "def print_no_tcache_bins_found_error(tid=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if tid is None:\n        tid = pwndbg.gdblib.proc.thread_id\n    print(message.notice(f\"No tcache bins found for thread {message.hint(tid)} (the thread hasn't performed any allocations).\"))"
        ]
    },
    {
        "func_name": "heap",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef heap(addr=None, verbose=False, simple=False) -> None:\n    \"\"\"Iteratively print chunks on a heap, default to the current thread's\n    active heap.\n    \"\"\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        chunk = Chunk(addr)\n        while chunk is not None:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)\n            chunk = chunk.next_chunk()\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        h = arena.active_heap\n        for chunk in h:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef heap(addr=None, verbose=False, simple=False) -> None:\n    if False:\n        i = 10\n    \"Iteratively print chunks on a heap, default to the current thread's\\n    active heap.\\n    \"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        chunk = Chunk(addr)\n        while chunk is not None:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)\n            chunk = chunk.next_chunk()\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        h = arena.active_heap\n        for chunk in h:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef heap(addr=None, verbose=False, simple=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Iteratively print chunks on a heap, default to the current thread's\\n    active heap.\\n    \"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        chunk = Chunk(addr)\n        while chunk is not None:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)\n            chunk = chunk.next_chunk()\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        h = arena.active_heap\n        for chunk in h:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef heap(addr=None, verbose=False, simple=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Iteratively print chunks on a heap, default to the current thread's\\n    active heap.\\n    \"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        chunk = Chunk(addr)\n        while chunk is not None:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)\n            chunk = chunk.next_chunk()\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        h = arena.active_heap\n        for chunk in h:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef heap(addr=None, verbose=False, simple=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Iteratively print chunks on a heap, default to the current thread's\\n    active heap.\\n    \"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        chunk = Chunk(addr)\n        while chunk is not None:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)\n            chunk = chunk.next_chunk()\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        h = arena.active_heap\n        for chunk in h:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef heap(addr=None, verbose=False, simple=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Iteratively print chunks on a heap, default to the current thread's\\n    active heap.\\n    \"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        chunk = Chunk(addr)\n        while chunk is not None:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)\n            chunk = chunk.next_chunk()\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        h = arena.active_heap\n        for chunk in h:\n            malloc_chunk(chunk.address, verbose=verbose, simple=simple)"
        ]
    },
    {
        "func_name": "arena",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arena(addr=None) -> None:\n    \"\"\"Print the contents of an arena, default to the current thread's arena.\"\"\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        tid = pwndbg.gdblib.proc.thread_id\n        if arena is None:\n            print_no_arena_found_error(tid)\n            return\n        print(message.notice(f'Arena for thread {message.hint(tid)} is located at: {message.hint(hex(arena.address))}'))\n    print(arena._gdbValue)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arena(addr=None) -> None:\n    if False:\n        i = 10\n    \"Print the contents of an arena, default to the current thread's arena.\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        tid = pwndbg.gdblib.proc.thread_id\n        if arena is None:\n            print_no_arena_found_error(tid)\n            return\n        print(message.notice(f'Arena for thread {message.hint(tid)} is located at: {message.hint(hex(arena.address))}'))\n    print(arena._gdbValue)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arena(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print the contents of an arena, default to the current thread's arena.\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        tid = pwndbg.gdblib.proc.thread_id\n        if arena is None:\n            print_no_arena_found_error(tid)\n            return\n        print(message.notice(f'Arena for thread {message.hint(tid)} is located at: {message.hint(hex(arena.address))}'))\n    print(arena._gdbValue)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arena(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print the contents of an arena, default to the current thread's arena.\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        tid = pwndbg.gdblib.proc.thread_id\n        if arena is None:\n            print_no_arena_found_error(tid)\n            return\n        print(message.notice(f'Arena for thread {message.hint(tid)} is located at: {message.hint(hex(arena.address))}'))\n    print(arena._gdbValue)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arena(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print the contents of an arena, default to the current thread's arena.\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        tid = pwndbg.gdblib.proc.thread_id\n        if arena is None:\n            print_no_arena_found_error(tid)\n            return\n        print(message.notice(f'Arena for thread {message.hint(tid)} is located at: {message.hint(hex(arena.address))}'))\n    print(arena._gdbValue)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arena(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print the contents of an arena, default to the current thread's arena.\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        tid = pwndbg.gdblib.proc.thread_id\n        if arena is None:\n            print_no_arena_found_error(tid)\n            return\n        print(message.notice(f'Arena for thread {message.hint(tid)} is located at: {message.hint(hex(arena.address))}'))\n    print(arena._gdbValue)"
        ]
    },
    {
        "func_name": "arenas",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arenas() -> None:\n    \"\"\"Lists this process's arenas.\"\"\"\n    allocator = pwndbg.heap.current\n    arenas = allocator.arenas\n    table = []\n    headers = ['arena type', 'arena address', 'heap address', 'map start', 'map end', 'perm', 'size', 'offset', 'file']\n    for arena in arenas:\n        (arena_type, text_color) = ('main_arena', message.success) if arena.is_main_arena else ('non-main arena', message.hint)\n        first_heap = arena.heaps[0]\n        row = [text_color(arena_type), text_color(hex(arena.address)), text_color(hex(first_heap.start))]\n        for mapping_data in str(pwndbg.gdblib.vmmap.find(first_heap.start)).split():\n            row.append(M.c.heap(mapping_data))\n        table.append(row)\n        for extra_heap in arena.heaps[1:]:\n            row = ['', text_color('\u21b3'), text_color(hex(extra_heap.start))]\n            for mapping_data in str(pwndbg.gdblib.vmmap.find(extra_heap.start)).split():\n                row.append(M.c.heap(mapping_data))\n            table.append(row)\n    print(tabulate(table, headers, stralign='right'))",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arenas() -> None:\n    if False:\n        i = 10\n    \"Lists this process's arenas.\"\n    allocator = pwndbg.heap.current\n    arenas = allocator.arenas\n    table = []\n    headers = ['arena type', 'arena address', 'heap address', 'map start', 'map end', 'perm', 'size', 'offset', 'file']\n    for arena in arenas:\n        (arena_type, text_color) = ('main_arena', message.success) if arena.is_main_arena else ('non-main arena', message.hint)\n        first_heap = arena.heaps[0]\n        row = [text_color(arena_type), text_color(hex(arena.address)), text_color(hex(first_heap.start))]\n        for mapping_data in str(pwndbg.gdblib.vmmap.find(first_heap.start)).split():\n            row.append(M.c.heap(mapping_data))\n        table.append(row)\n        for extra_heap in arena.heaps[1:]:\n            row = ['', text_color('\u21b3'), text_color(hex(extra_heap.start))]\n            for mapping_data in str(pwndbg.gdblib.vmmap.find(extra_heap.start)).split():\n                row.append(M.c.heap(mapping_data))\n            table.append(row)\n    print(tabulate(table, headers, stralign='right'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arenas() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Lists this process's arenas.\"\n    allocator = pwndbg.heap.current\n    arenas = allocator.arenas\n    table = []\n    headers = ['arena type', 'arena address', 'heap address', 'map start', 'map end', 'perm', 'size', 'offset', 'file']\n    for arena in arenas:\n        (arena_type, text_color) = ('main_arena', message.success) if arena.is_main_arena else ('non-main arena', message.hint)\n        first_heap = arena.heaps[0]\n        row = [text_color(arena_type), text_color(hex(arena.address)), text_color(hex(first_heap.start))]\n        for mapping_data in str(pwndbg.gdblib.vmmap.find(first_heap.start)).split():\n            row.append(M.c.heap(mapping_data))\n        table.append(row)\n        for extra_heap in arena.heaps[1:]:\n            row = ['', text_color('\u21b3'), text_color(hex(extra_heap.start))]\n            for mapping_data in str(pwndbg.gdblib.vmmap.find(extra_heap.start)).split():\n                row.append(M.c.heap(mapping_data))\n            table.append(row)\n    print(tabulate(table, headers, stralign='right'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arenas() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Lists this process's arenas.\"\n    allocator = pwndbg.heap.current\n    arenas = allocator.arenas\n    table = []\n    headers = ['arena type', 'arena address', 'heap address', 'map start', 'map end', 'perm', 'size', 'offset', 'file']\n    for arena in arenas:\n        (arena_type, text_color) = ('main_arena', message.success) if arena.is_main_arena else ('non-main arena', message.hint)\n        first_heap = arena.heaps[0]\n        row = [text_color(arena_type), text_color(hex(arena.address)), text_color(hex(first_heap.start))]\n        for mapping_data in str(pwndbg.gdblib.vmmap.find(first_heap.start)).split():\n            row.append(M.c.heap(mapping_data))\n        table.append(row)\n        for extra_heap in arena.heaps[1:]:\n            row = ['', text_color('\u21b3'), text_color(hex(extra_heap.start))]\n            for mapping_data in str(pwndbg.gdblib.vmmap.find(extra_heap.start)).split():\n                row.append(M.c.heap(mapping_data))\n            table.append(row)\n    print(tabulate(table, headers, stralign='right'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arenas() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Lists this process's arenas.\"\n    allocator = pwndbg.heap.current\n    arenas = allocator.arenas\n    table = []\n    headers = ['arena type', 'arena address', 'heap address', 'map start', 'map end', 'perm', 'size', 'offset', 'file']\n    for arena in arenas:\n        (arena_type, text_color) = ('main_arena', message.success) if arena.is_main_arena else ('non-main arena', message.hint)\n        first_heap = arena.heaps[0]\n        row = [text_color(arena_type), text_color(hex(arena.address)), text_color(hex(first_heap.start))]\n        for mapping_data in str(pwndbg.gdblib.vmmap.find(first_heap.start)).split():\n            row.append(M.c.heap(mapping_data))\n        table.append(row)\n        for extra_heap in arena.heaps[1:]:\n            row = ['', text_color('\u21b3'), text_color(hex(extra_heap.start))]\n            for mapping_data in str(pwndbg.gdblib.vmmap.find(extra_heap.start)).split():\n                row.append(M.c.heap(mapping_data))\n            table.append(row)\n    print(tabulate(table, headers, stralign='right'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef arenas() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Lists this process's arenas.\"\n    allocator = pwndbg.heap.current\n    arenas = allocator.arenas\n    table = []\n    headers = ['arena type', 'arena address', 'heap address', 'map start', 'map end', 'perm', 'size', 'offset', 'file']\n    for arena in arenas:\n        (arena_type, text_color) = ('main_arena', message.success) if arena.is_main_arena else ('non-main arena', message.hint)\n        first_heap = arena.heaps[0]\n        row = [text_color(arena_type), text_color(hex(arena.address)), text_color(hex(first_heap.start))]\n        for mapping_data in str(pwndbg.gdblib.vmmap.find(first_heap.start)).split():\n            row.append(M.c.heap(mapping_data))\n        table.append(row)\n        for extra_heap in arena.heaps[1:]:\n            row = ['', text_color('\u21b3'), text_color(hex(extra_heap.start))]\n            for mapping_data in str(pwndbg.gdblib.vmmap.find(extra_heap.start)).split():\n                row.append(M.c.heap(mapping_data))\n            table.append(row)\n    print(tabulate(table, headers, stralign='right'))"
        ]
    },
    {
        "func_name": "tcache",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcache(addr=None) -> None:\n    \"\"\"Print a thread's tcache contents, default to the current thread's\n    tcache.\n    \"\"\"\n    allocator = pwndbg.heap.current\n    tcache = allocator.get_tcache(addr)\n    tid = pwndbg.gdblib.proc.thread_id\n    if tcache:\n        print(message.notice(f'tcache is pointing to: {message.hint(hex(tcache.address))} for thread {message.hint(tid)}'))\n    else:\n        print_no_tcache_bins_found_error(tid)\n    if tcache:\n        print(tcache)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcache(addr=None) -> None:\n    if False:\n        i = 10\n    \"Print a thread's tcache contents, default to the current thread's\\n    tcache.\\n    \"\n    allocator = pwndbg.heap.current\n    tcache = allocator.get_tcache(addr)\n    tid = pwndbg.gdblib.proc.thread_id\n    if tcache:\n        print(message.notice(f'tcache is pointing to: {message.hint(hex(tcache.address))} for thread {message.hint(tid)}'))\n    else:\n        print_no_tcache_bins_found_error(tid)\n    if tcache:\n        print(tcache)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcache(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print a thread's tcache contents, default to the current thread's\\n    tcache.\\n    \"\n    allocator = pwndbg.heap.current\n    tcache = allocator.get_tcache(addr)\n    tid = pwndbg.gdblib.proc.thread_id\n    if tcache:\n        print(message.notice(f'tcache is pointing to: {message.hint(hex(tcache.address))} for thread {message.hint(tid)}'))\n    else:\n        print_no_tcache_bins_found_error(tid)\n    if tcache:\n        print(tcache)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcache(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print a thread's tcache contents, default to the current thread's\\n    tcache.\\n    \"\n    allocator = pwndbg.heap.current\n    tcache = allocator.get_tcache(addr)\n    tid = pwndbg.gdblib.proc.thread_id\n    if tcache:\n        print(message.notice(f'tcache is pointing to: {message.hint(hex(tcache.address))} for thread {message.hint(tid)}'))\n    else:\n        print_no_tcache_bins_found_error(tid)\n    if tcache:\n        print(tcache)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcache(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print a thread's tcache contents, default to the current thread's\\n    tcache.\\n    \"\n    allocator = pwndbg.heap.current\n    tcache = allocator.get_tcache(addr)\n    tid = pwndbg.gdblib.proc.thread_id\n    if tcache:\n        print(message.notice(f'tcache is pointing to: {message.hint(hex(tcache.address))} for thread {message.hint(tid)}'))\n    else:\n        print_no_tcache_bins_found_error(tid)\n    if tcache:\n        print(tcache)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcache(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print a thread's tcache contents, default to the current thread's\\n    tcache.\\n    \"\n    allocator = pwndbg.heap.current\n    tcache = allocator.get_tcache(addr)\n    tid = pwndbg.gdblib.proc.thread_id\n    if tcache:\n        print(message.notice(f'tcache is pointing to: {message.hint(hex(tcache.address))} for thread {message.hint(tid)}'))\n    else:\n        print_no_tcache_bins_found_error(tid)\n    if tcache:\n        print(tcache)"
        ]
    },
    {
        "func_name": "mp",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef mp() -> None:\n    \"\"\"Print the mp_ struct's contents.\"\"\"\n    allocator = pwndbg.heap.current\n    print(message.notice('mp_ struct at: ') + message.hint(hex(allocator.mp.address)))\n    print(allocator.mp)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef mp() -> None:\n    if False:\n        i = 10\n    \"Print the mp_ struct's contents.\"\n    allocator = pwndbg.heap.current\n    print(message.notice('mp_ struct at: ') + message.hint(hex(allocator.mp.address)))\n    print(allocator.mp)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef mp() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print the mp_ struct's contents.\"\n    allocator = pwndbg.heap.current\n    print(message.notice('mp_ struct at: ') + message.hint(hex(allocator.mp.address)))\n    print(allocator.mp)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef mp() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print the mp_ struct's contents.\"\n    allocator = pwndbg.heap.current\n    print(message.notice('mp_ struct at: ') + message.hint(hex(allocator.mp.address)))\n    print(allocator.mp)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef mp() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print the mp_ struct's contents.\"\n    allocator = pwndbg.heap.current\n    print(message.notice('mp_ struct at: ') + message.hint(hex(allocator.mp.address)))\n    print(allocator.mp)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef mp() -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print the mp_ struct's contents.\"\n    allocator = pwndbg.heap.current\n    print(message.notice('mp_ struct at: ') + message.hint(hex(allocator.mp.address)))\n    print(allocator.mp)"
        ]
    },
    {
        "func_name": "top_chunk",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef top_chunk(addr=None) -> None:\n    \"\"\"Print relevant information about an arena's top chunk, default to the\n    current thread's arena.\n    \"\"\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n    malloc_chunk(arena.top)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef top_chunk(addr=None) -> None:\n    if False:\n        i = 10\n    \"Print relevant information about an arena's top chunk, default to the\\n    current thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n    malloc_chunk(arena.top)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef top_chunk(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print relevant information about an arena's top chunk, default to the\\n    current thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n    malloc_chunk(arena.top)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef top_chunk(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print relevant information about an arena's top chunk, default to the\\n    current thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n    malloc_chunk(arena.top)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef top_chunk(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print relevant information about an arena's top chunk, default to the\\n    current thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n    malloc_chunk(arena.top)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef top_chunk(addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print relevant information about an arena's top chunk, default to the\\n    current thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        arena = Arena(addr)\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n    malloc_chunk(arena.top)"
        ]
    },
    {
        "func_name": "malloc_chunk",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef malloc_chunk(addr, fake=False, verbose=False, simple=False) -> None:\n    \"\"\"Print a malloc_chunk struct's contents.\"\"\"\n    allocator = pwndbg.heap.current\n    chunk = Chunk(addr)\n    headers_to_print = []\n    fields_to_print = set()\n    out_fields = f'Addr: {M.get(chunk.address)}\\n'\n    if fake:\n        headers_to_print.append(message.on('Fake chunk'))\n        verbose = True\n    if simple:\n        if not headers_to_print:\n            headers_to_print.append(message.hint(M.get(chunk.address)))\n        out_fields = ''\n        verbose = True\n    else:\n        arena = chunk.arena\n        if not fake and arena:\n            if chunk.is_top_chunk:\n                headers_to_print.append(message.off('Top chunk'))\n        if not chunk.is_top_chunk and arena:\n            bins_list = [allocator.fastbins(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address), allocator.unsortedbin(arena.address)]\n            if allocator.has_tcache():\n                bins_list.append(allocator.tcachebins(None))\n            bins_list = [x for x in bins_list if x is not None]\n            no_match = True\n            for bins in bins_list:\n                if bins.contains_chunk(chunk.real_size, chunk.address):\n                    no_match = False\n                    headers_to_print.append(message.on(f'Free chunk ({bins.bin_type})'))\n                    if not verbose:\n                        fields_to_print.update(bins.bin_type.valid_fields())\n            if no_match:\n                headers_to_print.append(message.hint('Allocated chunk'))\n    if verbose:\n        fields_to_print.update(['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize'])\n    else:\n        out_fields += f'Size: 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n    (prev_inuse, is_mmapped, non_main_arena) = allocator.chunk_flags(chunk.size)\n    if prev_inuse:\n        headers_to_print.append(message.hint('PREV_INUSE'))\n    if is_mmapped:\n        headers_to_print.append(message.hint('IS_MMAPED'))\n    if non_main_arena:\n        headers_to_print.append(message.hint('NON_MAIN_ARENA'))\n    fields_ordered = ['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize']\n    for field_to_print in fields_ordered:\n        if field_to_print not in fields_to_print:\n            continue\n        if field_to_print == 'size':\n            out_fields += message.system('size') + f': 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n        else:\n            out_fields += message.system(field_to_print) + f': 0x{getattr(chunk, field_to_print):02x}\\n'\n    print(' | '.join(headers_to_print) + '\\n' + out_fields)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef malloc_chunk(addr, fake=False, verbose=False, simple=False) -> None:\n    if False:\n        i = 10\n    \"Print a malloc_chunk struct's contents.\"\n    allocator = pwndbg.heap.current\n    chunk = Chunk(addr)\n    headers_to_print = []\n    fields_to_print = set()\n    out_fields = f'Addr: {M.get(chunk.address)}\\n'\n    if fake:\n        headers_to_print.append(message.on('Fake chunk'))\n        verbose = True\n    if simple:\n        if not headers_to_print:\n            headers_to_print.append(message.hint(M.get(chunk.address)))\n        out_fields = ''\n        verbose = True\n    else:\n        arena = chunk.arena\n        if not fake and arena:\n            if chunk.is_top_chunk:\n                headers_to_print.append(message.off('Top chunk'))\n        if not chunk.is_top_chunk and arena:\n            bins_list = [allocator.fastbins(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address), allocator.unsortedbin(arena.address)]\n            if allocator.has_tcache():\n                bins_list.append(allocator.tcachebins(None))\n            bins_list = [x for x in bins_list if x is not None]\n            no_match = True\n            for bins in bins_list:\n                if bins.contains_chunk(chunk.real_size, chunk.address):\n                    no_match = False\n                    headers_to_print.append(message.on(f'Free chunk ({bins.bin_type})'))\n                    if not verbose:\n                        fields_to_print.update(bins.bin_type.valid_fields())\n            if no_match:\n                headers_to_print.append(message.hint('Allocated chunk'))\n    if verbose:\n        fields_to_print.update(['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize'])\n    else:\n        out_fields += f'Size: 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n    (prev_inuse, is_mmapped, non_main_arena) = allocator.chunk_flags(chunk.size)\n    if prev_inuse:\n        headers_to_print.append(message.hint('PREV_INUSE'))\n    if is_mmapped:\n        headers_to_print.append(message.hint('IS_MMAPED'))\n    if non_main_arena:\n        headers_to_print.append(message.hint('NON_MAIN_ARENA'))\n    fields_ordered = ['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize']\n    for field_to_print in fields_ordered:\n        if field_to_print not in fields_to_print:\n            continue\n        if field_to_print == 'size':\n            out_fields += message.system('size') + f': 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n        else:\n            out_fields += message.system(field_to_print) + f': 0x{getattr(chunk, field_to_print):02x}\\n'\n    print(' | '.join(headers_to_print) + '\\n' + out_fields)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef malloc_chunk(addr, fake=False, verbose=False, simple=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print a malloc_chunk struct's contents.\"\n    allocator = pwndbg.heap.current\n    chunk = Chunk(addr)\n    headers_to_print = []\n    fields_to_print = set()\n    out_fields = f'Addr: {M.get(chunk.address)}\\n'\n    if fake:\n        headers_to_print.append(message.on('Fake chunk'))\n        verbose = True\n    if simple:\n        if not headers_to_print:\n            headers_to_print.append(message.hint(M.get(chunk.address)))\n        out_fields = ''\n        verbose = True\n    else:\n        arena = chunk.arena\n        if not fake and arena:\n            if chunk.is_top_chunk:\n                headers_to_print.append(message.off('Top chunk'))\n        if not chunk.is_top_chunk and arena:\n            bins_list = [allocator.fastbins(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address), allocator.unsortedbin(arena.address)]\n            if allocator.has_tcache():\n                bins_list.append(allocator.tcachebins(None))\n            bins_list = [x for x in bins_list if x is not None]\n            no_match = True\n            for bins in bins_list:\n                if bins.contains_chunk(chunk.real_size, chunk.address):\n                    no_match = False\n                    headers_to_print.append(message.on(f'Free chunk ({bins.bin_type})'))\n                    if not verbose:\n                        fields_to_print.update(bins.bin_type.valid_fields())\n            if no_match:\n                headers_to_print.append(message.hint('Allocated chunk'))\n    if verbose:\n        fields_to_print.update(['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize'])\n    else:\n        out_fields += f'Size: 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n    (prev_inuse, is_mmapped, non_main_arena) = allocator.chunk_flags(chunk.size)\n    if prev_inuse:\n        headers_to_print.append(message.hint('PREV_INUSE'))\n    if is_mmapped:\n        headers_to_print.append(message.hint('IS_MMAPED'))\n    if non_main_arena:\n        headers_to_print.append(message.hint('NON_MAIN_ARENA'))\n    fields_ordered = ['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize']\n    for field_to_print in fields_ordered:\n        if field_to_print not in fields_to_print:\n            continue\n        if field_to_print == 'size':\n            out_fields += message.system('size') + f': 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n        else:\n            out_fields += message.system(field_to_print) + f': 0x{getattr(chunk, field_to_print):02x}\\n'\n    print(' | '.join(headers_to_print) + '\\n' + out_fields)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef malloc_chunk(addr, fake=False, verbose=False, simple=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print a malloc_chunk struct's contents.\"\n    allocator = pwndbg.heap.current\n    chunk = Chunk(addr)\n    headers_to_print = []\n    fields_to_print = set()\n    out_fields = f'Addr: {M.get(chunk.address)}\\n'\n    if fake:\n        headers_to_print.append(message.on('Fake chunk'))\n        verbose = True\n    if simple:\n        if not headers_to_print:\n            headers_to_print.append(message.hint(M.get(chunk.address)))\n        out_fields = ''\n        verbose = True\n    else:\n        arena = chunk.arena\n        if not fake and arena:\n            if chunk.is_top_chunk:\n                headers_to_print.append(message.off('Top chunk'))\n        if not chunk.is_top_chunk and arena:\n            bins_list = [allocator.fastbins(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address), allocator.unsortedbin(arena.address)]\n            if allocator.has_tcache():\n                bins_list.append(allocator.tcachebins(None))\n            bins_list = [x for x in bins_list if x is not None]\n            no_match = True\n            for bins in bins_list:\n                if bins.contains_chunk(chunk.real_size, chunk.address):\n                    no_match = False\n                    headers_to_print.append(message.on(f'Free chunk ({bins.bin_type})'))\n                    if not verbose:\n                        fields_to_print.update(bins.bin_type.valid_fields())\n            if no_match:\n                headers_to_print.append(message.hint('Allocated chunk'))\n    if verbose:\n        fields_to_print.update(['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize'])\n    else:\n        out_fields += f'Size: 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n    (prev_inuse, is_mmapped, non_main_arena) = allocator.chunk_flags(chunk.size)\n    if prev_inuse:\n        headers_to_print.append(message.hint('PREV_INUSE'))\n    if is_mmapped:\n        headers_to_print.append(message.hint('IS_MMAPED'))\n    if non_main_arena:\n        headers_to_print.append(message.hint('NON_MAIN_ARENA'))\n    fields_ordered = ['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize']\n    for field_to_print in fields_ordered:\n        if field_to_print not in fields_to_print:\n            continue\n        if field_to_print == 'size':\n            out_fields += message.system('size') + f': 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n        else:\n            out_fields += message.system(field_to_print) + f': 0x{getattr(chunk, field_to_print):02x}\\n'\n    print(' | '.join(headers_to_print) + '\\n' + out_fields)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef malloc_chunk(addr, fake=False, verbose=False, simple=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print a malloc_chunk struct's contents.\"\n    allocator = pwndbg.heap.current\n    chunk = Chunk(addr)\n    headers_to_print = []\n    fields_to_print = set()\n    out_fields = f'Addr: {M.get(chunk.address)}\\n'\n    if fake:\n        headers_to_print.append(message.on('Fake chunk'))\n        verbose = True\n    if simple:\n        if not headers_to_print:\n            headers_to_print.append(message.hint(M.get(chunk.address)))\n        out_fields = ''\n        verbose = True\n    else:\n        arena = chunk.arena\n        if not fake and arena:\n            if chunk.is_top_chunk:\n                headers_to_print.append(message.off('Top chunk'))\n        if not chunk.is_top_chunk and arena:\n            bins_list = [allocator.fastbins(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address), allocator.unsortedbin(arena.address)]\n            if allocator.has_tcache():\n                bins_list.append(allocator.tcachebins(None))\n            bins_list = [x for x in bins_list if x is not None]\n            no_match = True\n            for bins in bins_list:\n                if bins.contains_chunk(chunk.real_size, chunk.address):\n                    no_match = False\n                    headers_to_print.append(message.on(f'Free chunk ({bins.bin_type})'))\n                    if not verbose:\n                        fields_to_print.update(bins.bin_type.valid_fields())\n            if no_match:\n                headers_to_print.append(message.hint('Allocated chunk'))\n    if verbose:\n        fields_to_print.update(['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize'])\n    else:\n        out_fields += f'Size: 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n    (prev_inuse, is_mmapped, non_main_arena) = allocator.chunk_flags(chunk.size)\n    if prev_inuse:\n        headers_to_print.append(message.hint('PREV_INUSE'))\n    if is_mmapped:\n        headers_to_print.append(message.hint('IS_MMAPED'))\n    if non_main_arena:\n        headers_to_print.append(message.hint('NON_MAIN_ARENA'))\n    fields_ordered = ['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize']\n    for field_to_print in fields_ordered:\n        if field_to_print not in fields_to_print:\n            continue\n        if field_to_print == 'size':\n            out_fields += message.system('size') + f': 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n        else:\n            out_fields += message.system(field_to_print) + f': 0x{getattr(chunk, field_to_print):02x}\\n'\n    print(' | '.join(headers_to_print) + '\\n' + out_fields)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef malloc_chunk(addr, fake=False, verbose=False, simple=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print a malloc_chunk struct's contents.\"\n    allocator = pwndbg.heap.current\n    chunk = Chunk(addr)\n    headers_to_print = []\n    fields_to_print = set()\n    out_fields = f'Addr: {M.get(chunk.address)}\\n'\n    if fake:\n        headers_to_print.append(message.on('Fake chunk'))\n        verbose = True\n    if simple:\n        if not headers_to_print:\n            headers_to_print.append(message.hint(M.get(chunk.address)))\n        out_fields = ''\n        verbose = True\n    else:\n        arena = chunk.arena\n        if not fake and arena:\n            if chunk.is_top_chunk:\n                headers_to_print.append(message.off('Top chunk'))\n        if not chunk.is_top_chunk and arena:\n            bins_list = [allocator.fastbins(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address), allocator.unsortedbin(arena.address)]\n            if allocator.has_tcache():\n                bins_list.append(allocator.tcachebins(None))\n            bins_list = [x for x in bins_list if x is not None]\n            no_match = True\n            for bins in bins_list:\n                if bins.contains_chunk(chunk.real_size, chunk.address):\n                    no_match = False\n                    headers_to_print.append(message.on(f'Free chunk ({bins.bin_type})'))\n                    if not verbose:\n                        fields_to_print.update(bins.bin_type.valid_fields())\n            if no_match:\n                headers_to_print.append(message.hint('Allocated chunk'))\n    if verbose:\n        fields_to_print.update(['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize'])\n    else:\n        out_fields += f'Size: 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n    (prev_inuse, is_mmapped, non_main_arena) = allocator.chunk_flags(chunk.size)\n    if prev_inuse:\n        headers_to_print.append(message.hint('PREV_INUSE'))\n    if is_mmapped:\n        headers_to_print.append(message.hint('IS_MMAPED'))\n    if non_main_arena:\n        headers_to_print.append(message.hint('NON_MAIN_ARENA'))\n    fields_ordered = ['prev_size', 'size', 'fd', 'bk', 'fd_nextsize', 'bk_nextsize']\n    for field_to_print in fields_ordered:\n        if field_to_print not in fields_to_print:\n            continue\n        if field_to_print == 'size':\n            out_fields += message.system('size') + f': 0x{chunk.real_size:02x} (with flag bits: 0x{chunk.size:02x})\\n'\n        else:\n            out_fields += message.system(field_to_print) + f': 0x{getattr(chunk, field_to_print):02x}\\n'\n    print(' | '.join(headers_to_print) + '\\n' + out_fields)"
        ]
    },
    {
        "func_name": "bins",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef bins(addr=None, tcache_addr=None) -> None:\n    \"\"\"Print the contents of all an arena's bins and a thread's tcache,\n    default to the current thread's arena and tcache.\n    \"\"\"\n    if pwndbg.heap.current.has_tcache():\n        if tcache_addr is None and pwndbg.heap.current.thread_cache is None:\n            print_no_tcache_bins_found_error()\n        else:\n            tcachebins(tcache_addr)\n    if addr is None and pwndbg.heap.current.thread_arena is None:\n        print_no_arena_found_error()\n        return\n    fastbins(addr)\n    unsortedbin(addr)\n    smallbins(addr)\n    largebins(addr)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef bins(addr=None, tcache_addr=None) -> None:\n    if False:\n        i = 10\n    \"Print the contents of all an arena's bins and a thread's tcache,\\n    default to the current thread's arena and tcache.\\n    \"\n    if pwndbg.heap.current.has_tcache():\n        if tcache_addr is None and pwndbg.heap.current.thread_cache is None:\n            print_no_tcache_bins_found_error()\n        else:\n            tcachebins(tcache_addr)\n    if addr is None and pwndbg.heap.current.thread_arena is None:\n        print_no_arena_found_error()\n        return\n    fastbins(addr)\n    unsortedbin(addr)\n    smallbins(addr)\n    largebins(addr)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef bins(addr=None, tcache_addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print the contents of all an arena's bins and a thread's tcache,\\n    default to the current thread's arena and tcache.\\n    \"\n    if pwndbg.heap.current.has_tcache():\n        if tcache_addr is None and pwndbg.heap.current.thread_cache is None:\n            print_no_tcache_bins_found_error()\n        else:\n            tcachebins(tcache_addr)\n    if addr is None and pwndbg.heap.current.thread_arena is None:\n        print_no_arena_found_error()\n        return\n    fastbins(addr)\n    unsortedbin(addr)\n    smallbins(addr)\n    largebins(addr)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef bins(addr=None, tcache_addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print the contents of all an arena's bins and a thread's tcache,\\n    default to the current thread's arena and tcache.\\n    \"\n    if pwndbg.heap.current.has_tcache():\n        if tcache_addr is None and pwndbg.heap.current.thread_cache is None:\n            print_no_tcache_bins_found_error()\n        else:\n            tcachebins(tcache_addr)\n    if addr is None and pwndbg.heap.current.thread_arena is None:\n        print_no_arena_found_error()\n        return\n    fastbins(addr)\n    unsortedbin(addr)\n    smallbins(addr)\n    largebins(addr)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef bins(addr=None, tcache_addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print the contents of all an arena's bins and a thread's tcache,\\n    default to the current thread's arena and tcache.\\n    \"\n    if pwndbg.heap.current.has_tcache():\n        if tcache_addr is None and pwndbg.heap.current.thread_cache is None:\n            print_no_tcache_bins_found_error()\n        else:\n            tcachebins(tcache_addr)\n    if addr is None and pwndbg.heap.current.thread_arena is None:\n        print_no_arena_found_error()\n        return\n    fastbins(addr)\n    unsortedbin(addr)\n    smallbins(addr)\n    largebins(addr)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef bins(addr=None, tcache_addr=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print the contents of all an arena's bins and a thread's tcache,\\n    default to the current thread's arena and tcache.\\n    \"\n    if pwndbg.heap.current.has_tcache():\n        if tcache_addr is None and pwndbg.heap.current.thread_cache is None:\n            print_no_tcache_bins_found_error()\n        else:\n            tcachebins(tcache_addr)\n    if addr is None and pwndbg.heap.current.thread_arena is None:\n        print_no_arena_found_error()\n        return\n    fastbins(addr)\n    unsortedbin(addr)\n    smallbins(addr)\n    largebins(addr)"
        ]
    },
    {
        "func_name": "fastbins",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef fastbins(addr=None, verbose=False) -> None:\n    \"\"\"Print the contents of an arena's fastbins, default to the current\n    thread's arena.\n    \"\"\"\n    allocator = pwndbg.heap.current\n    fastbins = allocator.fastbins(addr)\n    if fastbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(fastbins, verbose)\n    print(C.banner('fastbins'))\n    for node in formatted_bins:\n        print(node)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef fastbins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n    \"Print the contents of an arena's fastbins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    fastbins = allocator.fastbins(addr)\n    if fastbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(fastbins, verbose)\n    print(C.banner('fastbins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef fastbins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print the contents of an arena's fastbins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    fastbins = allocator.fastbins(addr)\n    if fastbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(fastbins, verbose)\n    print(C.banner('fastbins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef fastbins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print the contents of an arena's fastbins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    fastbins = allocator.fastbins(addr)\n    if fastbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(fastbins, verbose)\n    print(C.banner('fastbins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef fastbins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print the contents of an arena's fastbins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    fastbins = allocator.fastbins(addr)\n    if fastbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(fastbins, verbose)\n    print(C.banner('fastbins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef fastbins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print the contents of an arena's fastbins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    fastbins = allocator.fastbins(addr)\n    if fastbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(fastbins, verbose)\n    print(C.banner('fastbins'))\n    for node in formatted_bins:\n        print(node)"
        ]
    },
    {
        "func_name": "unsortedbin",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef unsortedbin(addr=None, verbose=False) -> None:\n    \"\"\"Print the contents of an arena's unsortedbin, default to the current\n    thread's arena.\n    \"\"\"\n    allocator = pwndbg.heap.current\n    unsortedbin = allocator.unsortedbin(addr)\n    if unsortedbin is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(unsortedbin, verbose)\n    print(C.banner('unsortedbin'))\n    for node in formatted_bins:\n        print(node)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef unsortedbin(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n    \"Print the contents of an arena's unsortedbin, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    unsortedbin = allocator.unsortedbin(addr)\n    if unsortedbin is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(unsortedbin, verbose)\n    print(C.banner('unsortedbin'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef unsortedbin(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print the contents of an arena's unsortedbin, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    unsortedbin = allocator.unsortedbin(addr)\n    if unsortedbin is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(unsortedbin, verbose)\n    print(C.banner('unsortedbin'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef unsortedbin(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print the contents of an arena's unsortedbin, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    unsortedbin = allocator.unsortedbin(addr)\n    if unsortedbin is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(unsortedbin, verbose)\n    print(C.banner('unsortedbin'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef unsortedbin(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print the contents of an arena's unsortedbin, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    unsortedbin = allocator.unsortedbin(addr)\n    if unsortedbin is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(unsortedbin, verbose)\n    print(C.banner('unsortedbin'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef unsortedbin(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print the contents of an arena's unsortedbin, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    unsortedbin = allocator.unsortedbin(addr)\n    if unsortedbin is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(unsortedbin, verbose)\n    print(C.banner('unsortedbin'))\n    for node in formatted_bins:\n        print(node)"
        ]
    },
    {
        "func_name": "smallbins",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef smallbins(addr=None, verbose=False) -> None:\n    \"\"\"Print the contents of an arena's smallbins, default to the current\n    thread's arena.\n    \"\"\"\n    allocator = pwndbg.heap.current\n    smallbins = allocator.smallbins(addr)\n    if smallbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(smallbins, verbose)\n    print(C.banner('smallbins'))\n    for node in formatted_bins:\n        print(node)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef smallbins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n    \"Print the contents of an arena's smallbins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    smallbins = allocator.smallbins(addr)\n    if smallbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(smallbins, verbose)\n    print(C.banner('smallbins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef smallbins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print the contents of an arena's smallbins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    smallbins = allocator.smallbins(addr)\n    if smallbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(smallbins, verbose)\n    print(C.banner('smallbins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef smallbins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print the contents of an arena's smallbins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    smallbins = allocator.smallbins(addr)\n    if smallbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(smallbins, verbose)\n    print(C.banner('smallbins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef smallbins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print the contents of an arena's smallbins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    smallbins = allocator.smallbins(addr)\n    if smallbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(smallbins, verbose)\n    print(C.banner('smallbins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef smallbins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print the contents of an arena's smallbins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    smallbins = allocator.smallbins(addr)\n    if smallbins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(smallbins, verbose)\n    print(C.banner('smallbins'))\n    for node in formatted_bins:\n        print(node)"
        ]
    },
    {
        "func_name": "largebins",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef largebins(addr=None, verbose=False) -> None:\n    \"\"\"Print the contents of an arena's largebins, default to the current\n    thread's arena.\n    \"\"\"\n    allocator = pwndbg.heap.current\n    largebins = allocator.largebins(addr)\n    if largebins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(largebins, verbose)\n    print(C.banner('largebins'))\n    for node in formatted_bins:\n        print(node)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef largebins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n    \"Print the contents of an arena's largebins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    largebins = allocator.largebins(addr)\n    if largebins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(largebins, verbose)\n    print(C.banner('largebins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef largebins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print the contents of an arena's largebins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    largebins = allocator.largebins(addr)\n    if largebins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(largebins, verbose)\n    print(C.banner('largebins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef largebins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print the contents of an arena's largebins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    largebins = allocator.largebins(addr)\n    if largebins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(largebins, verbose)\n    print(C.banner('largebins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef largebins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print the contents of an arena's largebins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    largebins = allocator.largebins(addr)\n    if largebins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(largebins, verbose)\n    print(C.banner('largebins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef largebins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print the contents of an arena's largebins, default to the current\\n    thread's arena.\\n    \"\n    allocator = pwndbg.heap.current\n    largebins = allocator.largebins(addr)\n    if largebins is None:\n        print_no_arena_found_error()\n        return\n    formatted_bins = format_bin(largebins, verbose)\n    print(C.banner('largebins'))\n    for node in formatted_bins:\n        print(node)"
        ]
    },
    {
        "func_name": "tcachebins",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcachebins(addr=None, verbose=False) -> None:\n    \"\"\"Print the contents of a tcache, default to the current thread's tcache.\"\"\"\n    allocator = pwndbg.heap.current\n    tcachebins = allocator.tcachebins(addr)\n    if tcachebins is None:\n        print_no_tcache_bins_found_error()\n        return\n    formatted_bins = format_bin(tcachebins, verbose, offset=allocator.tcache_next_offset)\n    print(C.banner('tcachebins'))\n    for node in formatted_bins:\n        print(node)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcachebins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n    \"Print the contents of a tcache, default to the current thread's tcache.\"\n    allocator = pwndbg.heap.current\n    tcachebins = allocator.tcachebins(addr)\n    if tcachebins is None:\n        print_no_tcache_bins_found_error()\n        return\n    formatted_bins = format_bin(tcachebins, verbose, offset=allocator.tcache_next_offset)\n    print(C.banner('tcachebins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcachebins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Print the contents of a tcache, default to the current thread's tcache.\"\n    allocator = pwndbg.heap.current\n    tcachebins = allocator.tcachebins(addr)\n    if tcachebins is None:\n        print_no_tcache_bins_found_error()\n        return\n    formatted_bins = format_bin(tcachebins, verbose, offset=allocator.tcache_next_offset)\n    print(C.banner('tcachebins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcachebins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Print the contents of a tcache, default to the current thread's tcache.\"\n    allocator = pwndbg.heap.current\n    tcachebins = allocator.tcachebins(addr)\n    if tcachebins is None:\n        print_no_tcache_bins_found_error()\n        return\n    formatted_bins = format_bin(tcachebins, verbose, offset=allocator.tcache_next_offset)\n    print(C.banner('tcachebins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcachebins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Print the contents of a tcache, default to the current thread's tcache.\"\n    allocator = pwndbg.heap.current\n    tcachebins = allocator.tcachebins(addr)\n    if tcachebins is None:\n        print_no_tcache_bins_found_error()\n        return\n    formatted_bins = format_bin(tcachebins, verbose, offset=allocator.tcache_next_offset)\n    print(C.banner('tcachebins'))\n    for node in formatted_bins:\n        print(node)",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWithTcache\n@pwndbg.commands.OnlyWhenUserspace\ndef tcachebins(addr=None, verbose=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Print the contents of a tcache, default to the current thread's tcache.\"\n    allocator = pwndbg.heap.current\n    tcachebins = allocator.tcachebins(addr)\n    if tcachebins is None:\n        print_no_tcache_bins_found_error()\n        return\n    formatted_bins = format_bin(tcachebins, verbose, offset=allocator.tcache_next_offset)\n    print(C.banner('tcachebins'))\n    for node in formatted_bins:\n        print(node)"
        ]
    },
    {
        "func_name": "find_fake_fast",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef find_fake_fast(target_address, max_candidate_size=None, align=False, glibc_fastbin_bug=False) -> None:\n    \"\"\"Find candidate fake fast chunks overlapping the specified address.\"\"\"\n    allocator = pwndbg.heap.current\n    size_sz = allocator.size_sz\n    min_chunk_size = allocator.min_chunk_size\n    global_max_fast = allocator.global_max_fast\n    size_field_width = gdb.lookup_type('unsigned int').sizeof if glibc_fastbin_bug else size_sz\n    if max_candidate_size is None:\n        max_candidate_size = global_max_fast\n    else:\n        max_candidate_size = int(max_candidate_size)\n        if max_candidate_size > global_max_fast:\n            print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the global_max_fast value of {global_max_fast:#04x}'))\n    target_address = int(target_address)\n    if max_candidate_size > target_address:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the target address {target_address:#x}'))\n        print(message.warn(f'Using maximum candidate size of {target_address:#x}'))\n        max_candidate_size = target_address\n    elif max_candidate_size < min_chunk_size:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is smaller than the minimum chunk size of {min_chunk_size:#04x}'))\n        print(message.warn(f'Using maximum candidate size of {min_chunk_size:#04x}'))\n        max_candidate_size = min_chunk_size\n    max_candidate_size &= ~allocator.malloc_align_mask\n    search_start = target_address - max_candidate_size + size_sz\n    search_end = target_address\n    if pwndbg.gdblib.memory.peek(search_start) is None:\n        search_start = pwndbg.lib.memory.page_size_align(search_start)\n        if search_start > search_end - size_field_width or pwndbg.gdblib.memory.peek(search_start) is None:\n            print(message.warn('No fake fast chunk candidates found; memory preceding target address is not readable'))\n            return None\n    if align:\n        search_start = pwndbg.lib.memory.align_up(search_start, size_sz)\n        search_start |= size_sz\n        if search_start > search_end - size_field_width:\n            print(message.warn(\"No fake fast chunk candidates found; alignment didn't leave enough space for a size field\"))\n            return None\n    print(message.notice(f'Searching for fastbin size fields up to {max_candidate_size:#04x}, starting at {search_start:#x} resulting in an overlap of {target_address:#x}'))\n    search_region = pwndbg.gdblib.memory.read(search_start, search_end - search_start, partial=True)\n    print(C.banner('FAKE CHUNKS'))\n    step = allocator.malloc_alignment if align else 1\n    for i in range(0, len(search_region), step):\n        candidate = search_region[i:i + size_field_width]\n        if len(candidate) == size_field_width:\n            size_field = pwndbg.gdblib.arch.unpack_size(candidate, size_field_width)\n            size_field &= ~allocator.malloc_align_mask\n            if size_field < min_chunk_size or size_field > max_candidate_size:\n                continue\n            candidate_address = search_start + i\n            if candidate_address + size_field >= target_address + size_sz:\n                malloc_chunk(candidate_address - size_sz, fake=True)\n        else:\n            break",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef find_fake_fast(target_address, max_candidate_size=None, align=False, glibc_fastbin_bug=False) -> None:\n    if False:\n        i = 10\n    'Find candidate fake fast chunks overlapping the specified address.'\n    allocator = pwndbg.heap.current\n    size_sz = allocator.size_sz\n    min_chunk_size = allocator.min_chunk_size\n    global_max_fast = allocator.global_max_fast\n    size_field_width = gdb.lookup_type('unsigned int').sizeof if glibc_fastbin_bug else size_sz\n    if max_candidate_size is None:\n        max_candidate_size = global_max_fast\n    else:\n        max_candidate_size = int(max_candidate_size)\n        if max_candidate_size > global_max_fast:\n            print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the global_max_fast value of {global_max_fast:#04x}'))\n    target_address = int(target_address)\n    if max_candidate_size > target_address:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the target address {target_address:#x}'))\n        print(message.warn(f'Using maximum candidate size of {target_address:#x}'))\n        max_candidate_size = target_address\n    elif max_candidate_size < min_chunk_size:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is smaller than the minimum chunk size of {min_chunk_size:#04x}'))\n        print(message.warn(f'Using maximum candidate size of {min_chunk_size:#04x}'))\n        max_candidate_size = min_chunk_size\n    max_candidate_size &= ~allocator.malloc_align_mask\n    search_start = target_address - max_candidate_size + size_sz\n    search_end = target_address\n    if pwndbg.gdblib.memory.peek(search_start) is None:\n        search_start = pwndbg.lib.memory.page_size_align(search_start)\n        if search_start > search_end - size_field_width or pwndbg.gdblib.memory.peek(search_start) is None:\n            print(message.warn('No fake fast chunk candidates found; memory preceding target address is not readable'))\n            return None\n    if align:\n        search_start = pwndbg.lib.memory.align_up(search_start, size_sz)\n        search_start |= size_sz\n        if search_start > search_end - size_field_width:\n            print(message.warn(\"No fake fast chunk candidates found; alignment didn't leave enough space for a size field\"))\n            return None\n    print(message.notice(f'Searching for fastbin size fields up to {max_candidate_size:#04x}, starting at {search_start:#x} resulting in an overlap of {target_address:#x}'))\n    search_region = pwndbg.gdblib.memory.read(search_start, search_end - search_start, partial=True)\n    print(C.banner('FAKE CHUNKS'))\n    step = allocator.malloc_alignment if align else 1\n    for i in range(0, len(search_region), step):\n        candidate = search_region[i:i + size_field_width]\n        if len(candidate) == size_field_width:\n            size_field = pwndbg.gdblib.arch.unpack_size(candidate, size_field_width)\n            size_field &= ~allocator.malloc_align_mask\n            if size_field < min_chunk_size or size_field > max_candidate_size:\n                continue\n            candidate_address = search_start + i\n            if candidate_address + size_field >= target_address + size_sz:\n                malloc_chunk(candidate_address - size_sz, fake=True)\n        else:\n            break",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef find_fake_fast(target_address, max_candidate_size=None, align=False, glibc_fastbin_bug=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find candidate fake fast chunks overlapping the specified address.'\n    allocator = pwndbg.heap.current\n    size_sz = allocator.size_sz\n    min_chunk_size = allocator.min_chunk_size\n    global_max_fast = allocator.global_max_fast\n    size_field_width = gdb.lookup_type('unsigned int').sizeof if glibc_fastbin_bug else size_sz\n    if max_candidate_size is None:\n        max_candidate_size = global_max_fast\n    else:\n        max_candidate_size = int(max_candidate_size)\n        if max_candidate_size > global_max_fast:\n            print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the global_max_fast value of {global_max_fast:#04x}'))\n    target_address = int(target_address)\n    if max_candidate_size > target_address:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the target address {target_address:#x}'))\n        print(message.warn(f'Using maximum candidate size of {target_address:#x}'))\n        max_candidate_size = target_address\n    elif max_candidate_size < min_chunk_size:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is smaller than the minimum chunk size of {min_chunk_size:#04x}'))\n        print(message.warn(f'Using maximum candidate size of {min_chunk_size:#04x}'))\n        max_candidate_size = min_chunk_size\n    max_candidate_size &= ~allocator.malloc_align_mask\n    search_start = target_address - max_candidate_size + size_sz\n    search_end = target_address\n    if pwndbg.gdblib.memory.peek(search_start) is None:\n        search_start = pwndbg.lib.memory.page_size_align(search_start)\n        if search_start > search_end - size_field_width or pwndbg.gdblib.memory.peek(search_start) is None:\n            print(message.warn('No fake fast chunk candidates found; memory preceding target address is not readable'))\n            return None\n    if align:\n        search_start = pwndbg.lib.memory.align_up(search_start, size_sz)\n        search_start |= size_sz\n        if search_start > search_end - size_field_width:\n            print(message.warn(\"No fake fast chunk candidates found; alignment didn't leave enough space for a size field\"))\n            return None\n    print(message.notice(f'Searching for fastbin size fields up to {max_candidate_size:#04x}, starting at {search_start:#x} resulting in an overlap of {target_address:#x}'))\n    search_region = pwndbg.gdblib.memory.read(search_start, search_end - search_start, partial=True)\n    print(C.banner('FAKE CHUNKS'))\n    step = allocator.malloc_alignment if align else 1\n    for i in range(0, len(search_region), step):\n        candidate = search_region[i:i + size_field_width]\n        if len(candidate) == size_field_width:\n            size_field = pwndbg.gdblib.arch.unpack_size(candidate, size_field_width)\n            size_field &= ~allocator.malloc_align_mask\n            if size_field < min_chunk_size or size_field > max_candidate_size:\n                continue\n            candidate_address = search_start + i\n            if candidate_address + size_field >= target_address + size_sz:\n                malloc_chunk(candidate_address - size_sz, fake=True)\n        else:\n            break",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef find_fake_fast(target_address, max_candidate_size=None, align=False, glibc_fastbin_bug=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find candidate fake fast chunks overlapping the specified address.'\n    allocator = pwndbg.heap.current\n    size_sz = allocator.size_sz\n    min_chunk_size = allocator.min_chunk_size\n    global_max_fast = allocator.global_max_fast\n    size_field_width = gdb.lookup_type('unsigned int').sizeof if glibc_fastbin_bug else size_sz\n    if max_candidate_size is None:\n        max_candidate_size = global_max_fast\n    else:\n        max_candidate_size = int(max_candidate_size)\n        if max_candidate_size > global_max_fast:\n            print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the global_max_fast value of {global_max_fast:#04x}'))\n    target_address = int(target_address)\n    if max_candidate_size > target_address:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the target address {target_address:#x}'))\n        print(message.warn(f'Using maximum candidate size of {target_address:#x}'))\n        max_candidate_size = target_address\n    elif max_candidate_size < min_chunk_size:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is smaller than the minimum chunk size of {min_chunk_size:#04x}'))\n        print(message.warn(f'Using maximum candidate size of {min_chunk_size:#04x}'))\n        max_candidate_size = min_chunk_size\n    max_candidate_size &= ~allocator.malloc_align_mask\n    search_start = target_address - max_candidate_size + size_sz\n    search_end = target_address\n    if pwndbg.gdblib.memory.peek(search_start) is None:\n        search_start = pwndbg.lib.memory.page_size_align(search_start)\n        if search_start > search_end - size_field_width or pwndbg.gdblib.memory.peek(search_start) is None:\n            print(message.warn('No fake fast chunk candidates found; memory preceding target address is not readable'))\n            return None\n    if align:\n        search_start = pwndbg.lib.memory.align_up(search_start, size_sz)\n        search_start |= size_sz\n        if search_start > search_end - size_field_width:\n            print(message.warn(\"No fake fast chunk candidates found; alignment didn't leave enough space for a size field\"))\n            return None\n    print(message.notice(f'Searching for fastbin size fields up to {max_candidate_size:#04x}, starting at {search_start:#x} resulting in an overlap of {target_address:#x}'))\n    search_region = pwndbg.gdblib.memory.read(search_start, search_end - search_start, partial=True)\n    print(C.banner('FAKE CHUNKS'))\n    step = allocator.malloc_alignment if align else 1\n    for i in range(0, len(search_region), step):\n        candidate = search_region[i:i + size_field_width]\n        if len(candidate) == size_field_width:\n            size_field = pwndbg.gdblib.arch.unpack_size(candidate, size_field_width)\n            size_field &= ~allocator.malloc_align_mask\n            if size_field < min_chunk_size or size_field > max_candidate_size:\n                continue\n            candidate_address = search_start + i\n            if candidate_address + size_field >= target_address + size_sz:\n                malloc_chunk(candidate_address - size_sz, fake=True)\n        else:\n            break",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef find_fake_fast(target_address, max_candidate_size=None, align=False, glibc_fastbin_bug=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find candidate fake fast chunks overlapping the specified address.'\n    allocator = pwndbg.heap.current\n    size_sz = allocator.size_sz\n    min_chunk_size = allocator.min_chunk_size\n    global_max_fast = allocator.global_max_fast\n    size_field_width = gdb.lookup_type('unsigned int').sizeof if glibc_fastbin_bug else size_sz\n    if max_candidate_size is None:\n        max_candidate_size = global_max_fast\n    else:\n        max_candidate_size = int(max_candidate_size)\n        if max_candidate_size > global_max_fast:\n            print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the global_max_fast value of {global_max_fast:#04x}'))\n    target_address = int(target_address)\n    if max_candidate_size > target_address:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the target address {target_address:#x}'))\n        print(message.warn(f'Using maximum candidate size of {target_address:#x}'))\n        max_candidate_size = target_address\n    elif max_candidate_size < min_chunk_size:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is smaller than the minimum chunk size of {min_chunk_size:#04x}'))\n        print(message.warn(f'Using maximum candidate size of {min_chunk_size:#04x}'))\n        max_candidate_size = min_chunk_size\n    max_candidate_size &= ~allocator.malloc_align_mask\n    search_start = target_address - max_candidate_size + size_sz\n    search_end = target_address\n    if pwndbg.gdblib.memory.peek(search_start) is None:\n        search_start = pwndbg.lib.memory.page_size_align(search_start)\n        if search_start > search_end - size_field_width or pwndbg.gdblib.memory.peek(search_start) is None:\n            print(message.warn('No fake fast chunk candidates found; memory preceding target address is not readable'))\n            return None\n    if align:\n        search_start = pwndbg.lib.memory.align_up(search_start, size_sz)\n        search_start |= size_sz\n        if search_start > search_end - size_field_width:\n            print(message.warn(\"No fake fast chunk candidates found; alignment didn't leave enough space for a size field\"))\n            return None\n    print(message.notice(f'Searching for fastbin size fields up to {max_candidate_size:#04x}, starting at {search_start:#x} resulting in an overlap of {target_address:#x}'))\n    search_region = pwndbg.gdblib.memory.read(search_start, search_end - search_start, partial=True)\n    print(C.banner('FAKE CHUNKS'))\n    step = allocator.malloc_alignment if align else 1\n    for i in range(0, len(search_region), step):\n        candidate = search_region[i:i + size_field_width]\n        if len(candidate) == size_field_width:\n            size_field = pwndbg.gdblib.arch.unpack_size(candidate, size_field_width)\n            size_field &= ~allocator.malloc_align_mask\n            if size_field < min_chunk_size or size_field > max_candidate_size:\n                continue\n            candidate_address = search_start + i\n            if candidate_address + size_field >= target_address + size_sz:\n                malloc_chunk(candidate_address - size_sz, fake=True)\n        else:\n            break",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef find_fake_fast(target_address, max_candidate_size=None, align=False, glibc_fastbin_bug=False) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find candidate fake fast chunks overlapping the specified address.'\n    allocator = pwndbg.heap.current\n    size_sz = allocator.size_sz\n    min_chunk_size = allocator.min_chunk_size\n    global_max_fast = allocator.global_max_fast\n    size_field_width = gdb.lookup_type('unsigned int').sizeof if glibc_fastbin_bug else size_sz\n    if max_candidate_size is None:\n        max_candidate_size = global_max_fast\n    else:\n        max_candidate_size = int(max_candidate_size)\n        if max_candidate_size > global_max_fast:\n            print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the global_max_fast value of {global_max_fast:#04x}'))\n    target_address = int(target_address)\n    if max_candidate_size > target_address:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is greater than the target address {target_address:#x}'))\n        print(message.warn(f'Using maximum candidate size of {target_address:#x}'))\n        max_candidate_size = target_address\n    elif max_candidate_size < min_chunk_size:\n        print(message.warn(f'Maximum candidate size {max_candidate_size:#04x} is smaller than the minimum chunk size of {min_chunk_size:#04x}'))\n        print(message.warn(f'Using maximum candidate size of {min_chunk_size:#04x}'))\n        max_candidate_size = min_chunk_size\n    max_candidate_size &= ~allocator.malloc_align_mask\n    search_start = target_address - max_candidate_size + size_sz\n    search_end = target_address\n    if pwndbg.gdblib.memory.peek(search_start) is None:\n        search_start = pwndbg.lib.memory.page_size_align(search_start)\n        if search_start > search_end - size_field_width or pwndbg.gdblib.memory.peek(search_start) is None:\n            print(message.warn('No fake fast chunk candidates found; memory preceding target address is not readable'))\n            return None\n    if align:\n        search_start = pwndbg.lib.memory.align_up(search_start, size_sz)\n        search_start |= size_sz\n        if search_start > search_end - size_field_width:\n            print(message.warn(\"No fake fast chunk candidates found; alignment didn't leave enough space for a size field\"))\n            return None\n    print(message.notice(f'Searching for fastbin size fields up to {max_candidate_size:#04x}, starting at {search_start:#x} resulting in an overlap of {target_address:#x}'))\n    search_region = pwndbg.gdblib.memory.read(search_start, search_end - search_start, partial=True)\n    print(C.banner('FAKE CHUNKS'))\n    step = allocator.malloc_alignment if align else 1\n    for i in range(0, len(search_region), step):\n        candidate = search_region[i:i + size_field_width]\n        if len(candidate) == size_field_width:\n            size_field = pwndbg.gdblib.arch.unpack_size(candidate, size_field_width)\n            size_field &= ~allocator.malloc_align_mask\n            if size_field < min_chunk_size or size_field > max_candidate_size:\n                continue\n            candidate_address = search_start + i\n            if candidate_address + size_field >= target_address + size_sz:\n                malloc_chunk(candidate_address - size_sz, fake=True)\n        else:\n            break"
        ]
    },
    {
        "func_name": "vis_heap_chunks",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef vis_heap_chunks(addr=None, count=None, beyond_top=None, no_truncate=None, all_chunks=None) -> None:\n    \"\"\"Visualize chunks on a heap, default to the current arena's active heap.\"\"\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        cursor = int(addr)\n        heap_region = Heap(cursor)\n        arena = heap_region.arena\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        heap_region = arena.active_heap\n        cursor = heap_region.start\n    ptr_size = allocator.size_sz\n    chunk_delims = []\n    cursor_backup = cursor\n    chunk = Chunk(cursor)\n    chunk_id = 0\n    while True:\n        if not all_chunks and chunk_id == count + 1:\n            break\n        if cursor not in heap_region:\n            chunk_delims.append(heap_region.end)\n            break\n        if cursor in chunk_delims or cursor + ptr_size in chunk_delims:\n            break\n        if chunk.prev_inuse:\n            chunk_delims.append(cursor + ptr_size)\n        else:\n            chunk_delims.append(cursor)\n        if chunk.is_top_chunk and (not beyond_top) or cursor == heap_region.end - ptr_size * 2:\n            chunk_delims.append(cursor + ptr_size * 2)\n            break\n        cursor += chunk.real_size\n        chunk = Chunk(cursor)\n        chunk_id += 1\n    color_funcs = [generateColorFunction('yellow'), generateColorFunction('cyan'), generateColorFunction('purple'), generateColorFunction('green'), generateColorFunction('blue')]\n    bin_collections = [allocator.fastbins(arena.address), allocator.unsortedbin(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address)]\n    if allocator.has_tcache():\n        bin_collections.insert(0, allocator.tcachebins(None))\n    printed = 0\n    out = ''\n    asc = ''\n    labels = []\n    cursor = cursor_backup\n    chunk = Chunk(cursor)\n    has_huge_chunk = False\n    half_max_size = pwndbg.lib.memory.round_up(pwndbg.gdblib.config.max_visualize_chunk_size, ptr_size << 2) >> 1\n    bin_labels_map: dict[int, list[str]] = bin_labels_mapping(bin_collections)\n    for (c, stop) in enumerate(chunk_delims):\n        color_func = color_funcs[c % len(color_funcs)]\n        if stop - cursor > 65536:\n            has_huge_chunk = True\n        first_cut = True\n        begin_addr = pwndbg.lib.memory.round_down(cursor, ptr_size << 1)\n        end_addr = pwndbg.lib.memory.round_down(stop, ptr_size << 1)\n        while cursor != stop:\n            if not no_truncate and half_max_size > 0 and (begin_addr + half_max_size <= cursor < end_addr - half_max_size):\n                if first_cut:\n                    out += '\\n' + '.' * len(hex(cursor))\n                    first_cut = False\n                cursor += ptr_size\n                continue\n            if printed % 2 == 0:\n                out += '\\n0x%x' % cursor\n            data = pwndbg.gdblib.memory.read(cursor, ptr_size)\n            cell = pwndbg.gdblib.arch.unpack(data)\n            cell_hex = f'\\t0x{cell:0{ptr_size * 2}x}'\n            out += color_func(cell_hex)\n            printed += 1\n            labels.extend(bin_labels_map.get(cursor, []))\n            if cursor == arena.top:\n                labels.append('Top chunk')\n            asc += bin_ascii(data)\n            if printed % 2 == 0:\n                out += '\\t' + color_func(asc) + ('\\t <-- ' + ', '.join(labels) if labels else '')\n                asc = ''\n                labels = []\n            cursor += ptr_size\n    print(out)\n    if has_huge_chunk and pwndbg.gdblib.config.max_visualize_chunk_size == 0:\n        print(message.warn('You can try `set max-visualize-chunk-size 0x500` and re-run this command.\\n'))",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef vis_heap_chunks(addr=None, count=None, beyond_top=None, no_truncate=None, all_chunks=None) -> None:\n    if False:\n        i = 10\n    \"Visualize chunks on a heap, default to the current arena's active heap.\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        cursor = int(addr)\n        heap_region = Heap(cursor)\n        arena = heap_region.arena\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        heap_region = arena.active_heap\n        cursor = heap_region.start\n    ptr_size = allocator.size_sz\n    chunk_delims = []\n    cursor_backup = cursor\n    chunk = Chunk(cursor)\n    chunk_id = 0\n    while True:\n        if not all_chunks and chunk_id == count + 1:\n            break\n        if cursor not in heap_region:\n            chunk_delims.append(heap_region.end)\n            break\n        if cursor in chunk_delims or cursor + ptr_size in chunk_delims:\n            break\n        if chunk.prev_inuse:\n            chunk_delims.append(cursor + ptr_size)\n        else:\n            chunk_delims.append(cursor)\n        if chunk.is_top_chunk and (not beyond_top) or cursor == heap_region.end - ptr_size * 2:\n            chunk_delims.append(cursor + ptr_size * 2)\n            break\n        cursor += chunk.real_size\n        chunk = Chunk(cursor)\n        chunk_id += 1\n    color_funcs = [generateColorFunction('yellow'), generateColorFunction('cyan'), generateColorFunction('purple'), generateColorFunction('green'), generateColorFunction('blue')]\n    bin_collections = [allocator.fastbins(arena.address), allocator.unsortedbin(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address)]\n    if allocator.has_tcache():\n        bin_collections.insert(0, allocator.tcachebins(None))\n    printed = 0\n    out = ''\n    asc = ''\n    labels = []\n    cursor = cursor_backup\n    chunk = Chunk(cursor)\n    has_huge_chunk = False\n    half_max_size = pwndbg.lib.memory.round_up(pwndbg.gdblib.config.max_visualize_chunk_size, ptr_size << 2) >> 1\n    bin_labels_map: dict[int, list[str]] = bin_labels_mapping(bin_collections)\n    for (c, stop) in enumerate(chunk_delims):\n        color_func = color_funcs[c % len(color_funcs)]\n        if stop - cursor > 65536:\n            has_huge_chunk = True\n        first_cut = True\n        begin_addr = pwndbg.lib.memory.round_down(cursor, ptr_size << 1)\n        end_addr = pwndbg.lib.memory.round_down(stop, ptr_size << 1)\n        while cursor != stop:\n            if not no_truncate and half_max_size > 0 and (begin_addr + half_max_size <= cursor < end_addr - half_max_size):\n                if first_cut:\n                    out += '\\n' + '.' * len(hex(cursor))\n                    first_cut = False\n                cursor += ptr_size\n                continue\n            if printed % 2 == 0:\n                out += '\\n0x%x' % cursor\n            data = pwndbg.gdblib.memory.read(cursor, ptr_size)\n            cell = pwndbg.gdblib.arch.unpack(data)\n            cell_hex = f'\\t0x{cell:0{ptr_size * 2}x}'\n            out += color_func(cell_hex)\n            printed += 1\n            labels.extend(bin_labels_map.get(cursor, []))\n            if cursor == arena.top:\n                labels.append('Top chunk')\n            asc += bin_ascii(data)\n            if printed % 2 == 0:\n                out += '\\t' + color_func(asc) + ('\\t <-- ' + ', '.join(labels) if labels else '')\n                asc = ''\n                labels = []\n            cursor += ptr_size\n    print(out)\n    if has_huge_chunk and pwndbg.gdblib.config.max_visualize_chunk_size == 0:\n        print(message.warn('You can try `set max-visualize-chunk-size 0x500` and re-run this command.\\n'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef vis_heap_chunks(addr=None, count=None, beyond_top=None, no_truncate=None, all_chunks=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Visualize chunks on a heap, default to the current arena's active heap.\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        cursor = int(addr)\n        heap_region = Heap(cursor)\n        arena = heap_region.arena\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        heap_region = arena.active_heap\n        cursor = heap_region.start\n    ptr_size = allocator.size_sz\n    chunk_delims = []\n    cursor_backup = cursor\n    chunk = Chunk(cursor)\n    chunk_id = 0\n    while True:\n        if not all_chunks and chunk_id == count + 1:\n            break\n        if cursor not in heap_region:\n            chunk_delims.append(heap_region.end)\n            break\n        if cursor in chunk_delims or cursor + ptr_size in chunk_delims:\n            break\n        if chunk.prev_inuse:\n            chunk_delims.append(cursor + ptr_size)\n        else:\n            chunk_delims.append(cursor)\n        if chunk.is_top_chunk and (not beyond_top) or cursor == heap_region.end - ptr_size * 2:\n            chunk_delims.append(cursor + ptr_size * 2)\n            break\n        cursor += chunk.real_size\n        chunk = Chunk(cursor)\n        chunk_id += 1\n    color_funcs = [generateColorFunction('yellow'), generateColorFunction('cyan'), generateColorFunction('purple'), generateColorFunction('green'), generateColorFunction('blue')]\n    bin_collections = [allocator.fastbins(arena.address), allocator.unsortedbin(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address)]\n    if allocator.has_tcache():\n        bin_collections.insert(0, allocator.tcachebins(None))\n    printed = 0\n    out = ''\n    asc = ''\n    labels = []\n    cursor = cursor_backup\n    chunk = Chunk(cursor)\n    has_huge_chunk = False\n    half_max_size = pwndbg.lib.memory.round_up(pwndbg.gdblib.config.max_visualize_chunk_size, ptr_size << 2) >> 1\n    bin_labels_map: dict[int, list[str]] = bin_labels_mapping(bin_collections)\n    for (c, stop) in enumerate(chunk_delims):\n        color_func = color_funcs[c % len(color_funcs)]\n        if stop - cursor > 65536:\n            has_huge_chunk = True\n        first_cut = True\n        begin_addr = pwndbg.lib.memory.round_down(cursor, ptr_size << 1)\n        end_addr = pwndbg.lib.memory.round_down(stop, ptr_size << 1)\n        while cursor != stop:\n            if not no_truncate and half_max_size > 0 and (begin_addr + half_max_size <= cursor < end_addr - half_max_size):\n                if first_cut:\n                    out += '\\n' + '.' * len(hex(cursor))\n                    first_cut = False\n                cursor += ptr_size\n                continue\n            if printed % 2 == 0:\n                out += '\\n0x%x' % cursor\n            data = pwndbg.gdblib.memory.read(cursor, ptr_size)\n            cell = pwndbg.gdblib.arch.unpack(data)\n            cell_hex = f'\\t0x{cell:0{ptr_size * 2}x}'\n            out += color_func(cell_hex)\n            printed += 1\n            labels.extend(bin_labels_map.get(cursor, []))\n            if cursor == arena.top:\n                labels.append('Top chunk')\n            asc += bin_ascii(data)\n            if printed % 2 == 0:\n                out += '\\t' + color_func(asc) + ('\\t <-- ' + ', '.join(labels) if labels else '')\n                asc = ''\n                labels = []\n            cursor += ptr_size\n    print(out)\n    if has_huge_chunk and pwndbg.gdblib.config.max_visualize_chunk_size == 0:\n        print(message.warn('You can try `set max-visualize-chunk-size 0x500` and re-run this command.\\n'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef vis_heap_chunks(addr=None, count=None, beyond_top=None, no_truncate=None, all_chunks=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Visualize chunks on a heap, default to the current arena's active heap.\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        cursor = int(addr)\n        heap_region = Heap(cursor)\n        arena = heap_region.arena\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        heap_region = arena.active_heap\n        cursor = heap_region.start\n    ptr_size = allocator.size_sz\n    chunk_delims = []\n    cursor_backup = cursor\n    chunk = Chunk(cursor)\n    chunk_id = 0\n    while True:\n        if not all_chunks and chunk_id == count + 1:\n            break\n        if cursor not in heap_region:\n            chunk_delims.append(heap_region.end)\n            break\n        if cursor in chunk_delims or cursor + ptr_size in chunk_delims:\n            break\n        if chunk.prev_inuse:\n            chunk_delims.append(cursor + ptr_size)\n        else:\n            chunk_delims.append(cursor)\n        if chunk.is_top_chunk and (not beyond_top) or cursor == heap_region.end - ptr_size * 2:\n            chunk_delims.append(cursor + ptr_size * 2)\n            break\n        cursor += chunk.real_size\n        chunk = Chunk(cursor)\n        chunk_id += 1\n    color_funcs = [generateColorFunction('yellow'), generateColorFunction('cyan'), generateColorFunction('purple'), generateColorFunction('green'), generateColorFunction('blue')]\n    bin_collections = [allocator.fastbins(arena.address), allocator.unsortedbin(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address)]\n    if allocator.has_tcache():\n        bin_collections.insert(0, allocator.tcachebins(None))\n    printed = 0\n    out = ''\n    asc = ''\n    labels = []\n    cursor = cursor_backup\n    chunk = Chunk(cursor)\n    has_huge_chunk = False\n    half_max_size = pwndbg.lib.memory.round_up(pwndbg.gdblib.config.max_visualize_chunk_size, ptr_size << 2) >> 1\n    bin_labels_map: dict[int, list[str]] = bin_labels_mapping(bin_collections)\n    for (c, stop) in enumerate(chunk_delims):\n        color_func = color_funcs[c % len(color_funcs)]\n        if stop - cursor > 65536:\n            has_huge_chunk = True\n        first_cut = True\n        begin_addr = pwndbg.lib.memory.round_down(cursor, ptr_size << 1)\n        end_addr = pwndbg.lib.memory.round_down(stop, ptr_size << 1)\n        while cursor != stop:\n            if not no_truncate and half_max_size > 0 and (begin_addr + half_max_size <= cursor < end_addr - half_max_size):\n                if first_cut:\n                    out += '\\n' + '.' * len(hex(cursor))\n                    first_cut = False\n                cursor += ptr_size\n                continue\n            if printed % 2 == 0:\n                out += '\\n0x%x' % cursor\n            data = pwndbg.gdblib.memory.read(cursor, ptr_size)\n            cell = pwndbg.gdblib.arch.unpack(data)\n            cell_hex = f'\\t0x{cell:0{ptr_size * 2}x}'\n            out += color_func(cell_hex)\n            printed += 1\n            labels.extend(bin_labels_map.get(cursor, []))\n            if cursor == arena.top:\n                labels.append('Top chunk')\n            asc += bin_ascii(data)\n            if printed % 2 == 0:\n                out += '\\t' + color_func(asc) + ('\\t <-- ' + ', '.join(labels) if labels else '')\n                asc = ''\n                labels = []\n            cursor += ptr_size\n    print(out)\n    if has_huge_chunk and pwndbg.gdblib.config.max_visualize_chunk_size == 0:\n        print(message.warn('You can try `set max-visualize-chunk-size 0x500` and re-run this command.\\n'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef vis_heap_chunks(addr=None, count=None, beyond_top=None, no_truncate=None, all_chunks=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Visualize chunks on a heap, default to the current arena's active heap.\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        cursor = int(addr)\n        heap_region = Heap(cursor)\n        arena = heap_region.arena\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        heap_region = arena.active_heap\n        cursor = heap_region.start\n    ptr_size = allocator.size_sz\n    chunk_delims = []\n    cursor_backup = cursor\n    chunk = Chunk(cursor)\n    chunk_id = 0\n    while True:\n        if not all_chunks and chunk_id == count + 1:\n            break\n        if cursor not in heap_region:\n            chunk_delims.append(heap_region.end)\n            break\n        if cursor in chunk_delims or cursor + ptr_size in chunk_delims:\n            break\n        if chunk.prev_inuse:\n            chunk_delims.append(cursor + ptr_size)\n        else:\n            chunk_delims.append(cursor)\n        if chunk.is_top_chunk and (not beyond_top) or cursor == heap_region.end - ptr_size * 2:\n            chunk_delims.append(cursor + ptr_size * 2)\n            break\n        cursor += chunk.real_size\n        chunk = Chunk(cursor)\n        chunk_id += 1\n    color_funcs = [generateColorFunction('yellow'), generateColorFunction('cyan'), generateColorFunction('purple'), generateColorFunction('green'), generateColorFunction('blue')]\n    bin_collections = [allocator.fastbins(arena.address), allocator.unsortedbin(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address)]\n    if allocator.has_tcache():\n        bin_collections.insert(0, allocator.tcachebins(None))\n    printed = 0\n    out = ''\n    asc = ''\n    labels = []\n    cursor = cursor_backup\n    chunk = Chunk(cursor)\n    has_huge_chunk = False\n    half_max_size = pwndbg.lib.memory.round_up(pwndbg.gdblib.config.max_visualize_chunk_size, ptr_size << 2) >> 1\n    bin_labels_map: dict[int, list[str]] = bin_labels_mapping(bin_collections)\n    for (c, stop) in enumerate(chunk_delims):\n        color_func = color_funcs[c % len(color_funcs)]\n        if stop - cursor > 65536:\n            has_huge_chunk = True\n        first_cut = True\n        begin_addr = pwndbg.lib.memory.round_down(cursor, ptr_size << 1)\n        end_addr = pwndbg.lib.memory.round_down(stop, ptr_size << 1)\n        while cursor != stop:\n            if not no_truncate and half_max_size > 0 and (begin_addr + half_max_size <= cursor < end_addr - half_max_size):\n                if first_cut:\n                    out += '\\n' + '.' * len(hex(cursor))\n                    first_cut = False\n                cursor += ptr_size\n                continue\n            if printed % 2 == 0:\n                out += '\\n0x%x' % cursor\n            data = pwndbg.gdblib.memory.read(cursor, ptr_size)\n            cell = pwndbg.gdblib.arch.unpack(data)\n            cell_hex = f'\\t0x{cell:0{ptr_size * 2}x}'\n            out += color_func(cell_hex)\n            printed += 1\n            labels.extend(bin_labels_map.get(cursor, []))\n            if cursor == arena.top:\n                labels.append('Top chunk')\n            asc += bin_ascii(data)\n            if printed % 2 == 0:\n                out += '\\t' + color_func(asc) + ('\\t <-- ' + ', '.join(labels) if labels else '')\n                asc = ''\n                labels = []\n            cursor += ptr_size\n    print(out)\n    if has_huge_chunk and pwndbg.gdblib.config.max_visualize_chunk_size == 0:\n        print(message.warn('You can try `set max-visualize-chunk-size 0x500` and re-run this command.\\n'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWithResolvedHeapSyms\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef vis_heap_chunks(addr=None, count=None, beyond_top=None, no_truncate=None, all_chunks=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Visualize chunks on a heap, default to the current arena's active heap.\"\n    allocator = pwndbg.heap.current\n    if addr is not None:\n        cursor = int(addr)\n        heap_region = Heap(cursor)\n        arena = heap_region.arena\n    else:\n        arena = allocator.thread_arena\n        if arena is None:\n            print_no_arena_found_error()\n            return\n        heap_region = arena.active_heap\n        cursor = heap_region.start\n    ptr_size = allocator.size_sz\n    chunk_delims = []\n    cursor_backup = cursor\n    chunk = Chunk(cursor)\n    chunk_id = 0\n    while True:\n        if not all_chunks and chunk_id == count + 1:\n            break\n        if cursor not in heap_region:\n            chunk_delims.append(heap_region.end)\n            break\n        if cursor in chunk_delims or cursor + ptr_size in chunk_delims:\n            break\n        if chunk.prev_inuse:\n            chunk_delims.append(cursor + ptr_size)\n        else:\n            chunk_delims.append(cursor)\n        if chunk.is_top_chunk and (not beyond_top) or cursor == heap_region.end - ptr_size * 2:\n            chunk_delims.append(cursor + ptr_size * 2)\n            break\n        cursor += chunk.real_size\n        chunk = Chunk(cursor)\n        chunk_id += 1\n    color_funcs = [generateColorFunction('yellow'), generateColorFunction('cyan'), generateColorFunction('purple'), generateColorFunction('green'), generateColorFunction('blue')]\n    bin_collections = [allocator.fastbins(arena.address), allocator.unsortedbin(arena.address), allocator.smallbins(arena.address), allocator.largebins(arena.address)]\n    if allocator.has_tcache():\n        bin_collections.insert(0, allocator.tcachebins(None))\n    printed = 0\n    out = ''\n    asc = ''\n    labels = []\n    cursor = cursor_backup\n    chunk = Chunk(cursor)\n    has_huge_chunk = False\n    half_max_size = pwndbg.lib.memory.round_up(pwndbg.gdblib.config.max_visualize_chunk_size, ptr_size << 2) >> 1\n    bin_labels_map: dict[int, list[str]] = bin_labels_mapping(bin_collections)\n    for (c, stop) in enumerate(chunk_delims):\n        color_func = color_funcs[c % len(color_funcs)]\n        if stop - cursor > 65536:\n            has_huge_chunk = True\n        first_cut = True\n        begin_addr = pwndbg.lib.memory.round_down(cursor, ptr_size << 1)\n        end_addr = pwndbg.lib.memory.round_down(stop, ptr_size << 1)\n        while cursor != stop:\n            if not no_truncate and half_max_size > 0 and (begin_addr + half_max_size <= cursor < end_addr - half_max_size):\n                if first_cut:\n                    out += '\\n' + '.' * len(hex(cursor))\n                    first_cut = False\n                cursor += ptr_size\n                continue\n            if printed % 2 == 0:\n                out += '\\n0x%x' % cursor\n            data = pwndbg.gdblib.memory.read(cursor, ptr_size)\n            cell = pwndbg.gdblib.arch.unpack(data)\n            cell_hex = f'\\t0x{cell:0{ptr_size * 2}x}'\n            out += color_func(cell_hex)\n            printed += 1\n            labels.extend(bin_labels_map.get(cursor, []))\n            if cursor == arena.top:\n                labels.append('Top chunk')\n            asc += bin_ascii(data)\n            if printed % 2 == 0:\n                out += '\\t' + color_func(asc) + ('\\t <-- ' + ', '.join(labels) if labels else '')\n                asc = ''\n                labels = []\n            cursor += ptr_size\n    print(out)\n    if has_huge_chunk and pwndbg.gdblib.config.max_visualize_chunk_size == 0:\n        print(message.warn('You can try `set max-visualize-chunk-size 0x500` and re-run this command.\\n'))"
        ]
    },
    {
        "func_name": "bin_ascii",
        "original": "def bin_ascii(bs):\n    return ''.join((chr(c) if c in VALID_CHARS else '.' for c in bs))",
        "mutated": [
            "def bin_ascii(bs):\n    if False:\n        i = 10\n    return ''.join((chr(c) if c in VALID_CHARS else '.' for c in bs))",
            "def bin_ascii(bs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return ''.join((chr(c) if c in VALID_CHARS else '.' for c in bs))",
            "def bin_ascii(bs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return ''.join((chr(c) if c in VALID_CHARS else '.' for c in bs))",
            "def bin_ascii(bs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return ''.join((chr(c) if c in VALID_CHARS else '.' for c in bs))",
            "def bin_ascii(bs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return ''.join((chr(c) if c in VALID_CHARS else '.' for c in bs))"
        ]
    },
    {
        "func_name": "bin_labels_mapping",
        "original": "def bin_labels_mapping(collections):\n    \"\"\"\n    Returns all potential bin labels for all potential addresses\n    We precompute all of them because doing this on demand was too slow and inefficient\n    See #1675 for more details\n    \"\"\"\n    labels_mapping: dict[int, list[str]] = {}\n    for bins in collections:\n        if not bins:\n            continue\n        bins_type = bins.bin_type\n        for size in bins.bins.keys():\n            b = bins.bins[size]\n            if isinstance(size, int):\n                size = hex(size)\n            count = f'/{b.count:d}' if bins_type == BinType.TCACHE else None\n            chunks = b.fd_chain\n            for chunk_addr in chunks:\n                labels_mapping.setdefault(chunk_addr, []).append(f\"{bins_type:s}[{size:s}][{chunks.index(chunk_addr):d}{count or ''}]\")\n    return labels_mapping",
        "mutated": [
            "def bin_labels_mapping(collections):\n    if False:\n        i = 10\n    '\\n    Returns all potential bin labels for all potential addresses\\n    We precompute all of them because doing this on demand was too slow and inefficient\\n    See #1675 for more details\\n    '\n    labels_mapping: dict[int, list[str]] = {}\n    for bins in collections:\n        if not bins:\n            continue\n        bins_type = bins.bin_type\n        for size in bins.bins.keys():\n            b = bins.bins[size]\n            if isinstance(size, int):\n                size = hex(size)\n            count = f'/{b.count:d}' if bins_type == BinType.TCACHE else None\n            chunks = b.fd_chain\n            for chunk_addr in chunks:\n                labels_mapping.setdefault(chunk_addr, []).append(f\"{bins_type:s}[{size:s}][{chunks.index(chunk_addr):d}{count or ''}]\")\n    return labels_mapping",
            "def bin_labels_mapping(collections):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns all potential bin labels for all potential addresses\\n    We precompute all of them because doing this on demand was too slow and inefficient\\n    See #1675 for more details\\n    '\n    labels_mapping: dict[int, list[str]] = {}\n    for bins in collections:\n        if not bins:\n            continue\n        bins_type = bins.bin_type\n        for size in bins.bins.keys():\n            b = bins.bins[size]\n            if isinstance(size, int):\n                size = hex(size)\n            count = f'/{b.count:d}' if bins_type == BinType.TCACHE else None\n            chunks = b.fd_chain\n            for chunk_addr in chunks:\n                labels_mapping.setdefault(chunk_addr, []).append(f\"{bins_type:s}[{size:s}][{chunks.index(chunk_addr):d}{count or ''}]\")\n    return labels_mapping",
            "def bin_labels_mapping(collections):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns all potential bin labels for all potential addresses\\n    We precompute all of them because doing this on demand was too slow and inefficient\\n    See #1675 for more details\\n    '\n    labels_mapping: dict[int, list[str]] = {}\n    for bins in collections:\n        if not bins:\n            continue\n        bins_type = bins.bin_type\n        for size in bins.bins.keys():\n            b = bins.bins[size]\n            if isinstance(size, int):\n                size = hex(size)\n            count = f'/{b.count:d}' if bins_type == BinType.TCACHE else None\n            chunks = b.fd_chain\n            for chunk_addr in chunks:\n                labels_mapping.setdefault(chunk_addr, []).append(f\"{bins_type:s}[{size:s}][{chunks.index(chunk_addr):d}{count or ''}]\")\n    return labels_mapping",
            "def bin_labels_mapping(collections):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns all potential bin labels for all potential addresses\\n    We precompute all of them because doing this on demand was too slow and inefficient\\n    See #1675 for more details\\n    '\n    labels_mapping: dict[int, list[str]] = {}\n    for bins in collections:\n        if not bins:\n            continue\n        bins_type = bins.bin_type\n        for size in bins.bins.keys():\n            b = bins.bins[size]\n            if isinstance(size, int):\n                size = hex(size)\n            count = f'/{b.count:d}' if bins_type == BinType.TCACHE else None\n            chunks = b.fd_chain\n            for chunk_addr in chunks:\n                labels_mapping.setdefault(chunk_addr, []).append(f\"{bins_type:s}[{size:s}][{chunks.index(chunk_addr):d}{count or ''}]\")\n    return labels_mapping",
            "def bin_labels_mapping(collections):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns all potential bin labels for all potential addresses\\n    We precompute all of them because doing this on demand was too slow and inefficient\\n    See #1675 for more details\\n    '\n    labels_mapping: dict[int, list[str]] = {}\n    for bins in collections:\n        if not bins:\n            continue\n        bins_type = bins.bin_type\n        for size in bins.bins.keys():\n            b = bins.bins[size]\n            if isinstance(size, int):\n                size = hex(size)\n            count = f'/{b.count:d}' if bins_type == BinType.TCACHE else None\n            chunks = b.fd_chain\n            for chunk_addr in chunks:\n                labels_mapping.setdefault(chunk_addr, []).append(f\"{bins_type:s}[{size:s}][{chunks.index(chunk_addr):d}{count or ''}]\")\n    return labels_mapping"
        ]
    },
    {
        "func_name": "unsigned_size",
        "original": "def unsigned_size(size):\n    if ptr_size < 8:\n        return ctypes.c_uint32(size).value\n    x = ctypes.c_uint64(size).value\n    return x",
        "mutated": [
            "def unsigned_size(size):\n    if False:\n        i = 10\n    if ptr_size < 8:\n        return ctypes.c_uint32(size).value\n    x = ctypes.c_uint64(size).value\n    return x",
            "def unsigned_size(size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if ptr_size < 8:\n        return ctypes.c_uint32(size).value\n    x = ctypes.c_uint64(size).value\n    return x",
            "def unsigned_size(size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if ptr_size < 8:\n        return ctypes.c_uint32(size).value\n    x = ctypes.c_uint64(size).value\n    return x",
            "def unsigned_size(size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if ptr_size < 8:\n        return ctypes.c_uint32(size).value\n    x = ctypes.c_uint64(size).value\n    return x",
            "def unsigned_size(size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if ptr_size < 8:\n        return ctypes.c_uint32(size).value\n    x = ctypes.c_uint64(size).value\n    return x"
        ]
    },
    {
        "func_name": "chunksize",
        "original": "def chunksize(chunk_size):\n    return chunk_size & ~7",
        "mutated": [
            "def chunksize(chunk_size):\n    if False:\n        i = 10\n    return chunk_size & ~7",
            "def chunksize(chunk_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return chunk_size & ~7",
            "def chunksize(chunk_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return chunk_size & ~7",
            "def chunksize(chunk_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return chunk_size & ~7",
            "def chunksize(chunk_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return chunk_size & ~7"
        ]
    },
    {
        "func_name": "finalize",
        "original": "def finalize(errors_found, returned_before_error) -> None:\n    print('-' * 10)\n    if returned_before_error:\n        print(message.success('Free should succeed!'))\n    elif errors_found > 0:\n        print(message.error('Errors found!'))\n    else:\n        print(message.success('All checks passed!'))",
        "mutated": [
            "def finalize(errors_found, returned_before_error) -> None:\n    if False:\n        i = 10\n    print('-' * 10)\n    if returned_before_error:\n        print(message.success('Free should succeed!'))\n    elif errors_found > 0:\n        print(message.error('Errors found!'))\n    else:\n        print(message.success('All checks passed!'))",
            "def finalize(errors_found, returned_before_error) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    print('-' * 10)\n    if returned_before_error:\n        print(message.success('Free should succeed!'))\n    elif errors_found > 0:\n        print(message.error('Errors found!'))\n    else:\n        print(message.success('All checks passed!'))",
            "def finalize(errors_found, returned_before_error) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    print('-' * 10)\n    if returned_before_error:\n        print(message.success('Free should succeed!'))\n    elif errors_found > 0:\n        print(message.error('Errors found!'))\n    else:\n        print(message.success('All checks passed!'))",
            "def finalize(errors_found, returned_before_error) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    print('-' * 10)\n    if returned_before_error:\n        print(message.success('Free should succeed!'))\n    elif errors_found > 0:\n        print(message.error('Errors found!'))\n    else:\n        print(message.success('All checks passed!'))",
            "def finalize(errors_found, returned_before_error) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    print('-' * 10)\n    if returned_before_error:\n        print(message.success('Free should succeed!'))\n    elif errors_found > 0:\n        print(message.error('Errors found!'))\n    else:\n        print(message.success('All checks passed!'))"
        ]
    },
    {
        "func_name": "try_free",
        "original": "@pwndbg.commands.ArgparsedCommand(try_free_parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef try_free(addr) -> None:\n    addr = int(addr)\n    free_hook = pwndbg.gdblib.symbol.address('__free_hook')\n    if free_hook is not None:\n        if pwndbg.gdblib.memory.pvoid(free_hook) != 0:\n            print(message.success('__libc_free: will execute __free_hook'))\n    if addr == 0:\n        print(message.success('__libc_free: addr is 0, nothing to do'))\n        return\n    allocator = pwndbg.heap.current\n    arena = allocator.thread_arena\n    if arena is None:\n        print_no_arena_found_error()\n        return\n    aligned_lsb = allocator.malloc_align_mask.bit_length()\n    size_sz = allocator.size_sz\n    malloc_alignment = allocator.malloc_alignment\n    malloc_align_mask = allocator.malloc_align_mask\n    chunk_minsize = allocator.minsize\n    ptr_size = pwndbg.gdblib.arch.ptrsize\n\n    def unsigned_size(size):\n        if ptr_size < 8:\n            return ctypes.c_uint32(size).value\n        x = ctypes.c_uint64(size).value\n        return x\n\n    def chunksize(chunk_size):\n        return chunk_size & ~7\n\n    def finalize(errors_found, returned_before_error) -> None:\n        print('-' * 10)\n        if returned_before_error:\n            print(message.success('Free should succeed!'))\n        elif errors_found > 0:\n            print(message.error('Errors found!'))\n        else:\n            print(message.success('All checks passed!'))\n    addr -= 2 * size_sz\n    try:\n        chunk = read_chunk(addr)\n    except gdb.MemoryError as e:\n        print(message.error(f\"Can't read chunk at address 0x{addr:x}, memory error\"))\n        return\n    chunk_size = unsigned_size(chunk['size'])\n    chunk_size_unmasked = chunksize(chunk_size)\n    (_, is_mmapped, _) = allocator.chunk_flags(chunk_size)\n    if is_mmapped:\n        print(message.notice('__libc_free: Doing munmap_chunk'))\n        return\n    errors_found = 0\n    returned_before_error = False\n    print(message.notice('General checks'))\n    max_mem = (1 << ptr_size * 8) - 1\n    if addr + chunk_size >= max_mem:\n        err = 'free(): invalid pointer -> &chunk + chunk->size > max memory\\n'\n        err += '    0x{:x} + 0x{:x} > 0x{:x}'\n        err = err.format(addr, chunk_size, max_mem)\n        print(message.error(err))\n        errors_found += 1\n    addr_tmp = addr\n    if malloc_alignment != 2 * size_sz:\n        addr_tmp = addr + 2 * size_sz\n    if addr_tmp & malloc_align_mask != 0:\n        err = 'free(): invalid pointer -> misaligned chunk\\n'\n        err += '    LSB of 0x{:x} are 0b{}, should be 0b{}'\n        if addr_tmp != addr:\n            err += f' (0x{2 * size_sz:x} was added to the address)'\n        err = err.format(addr_tmp, bin(addr_tmp)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked < chunk_minsize:\n        err = \"free(): invalid size -> chunk's size smaller than MINSIZE\\n\"\n        err += '    size is 0x{:x}, MINSIZE is 0x{:x}'\n        err = err.format(chunk_size_unmasked, chunk_minsize)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked & malloc_align_mask != 0:\n        err = \"free(): invalid size -> chunk's size is not aligned\\n\"\n        err += '    LSB of size 0x{:x} are 0b{}, should be 0b{}'\n        err = err.format(chunk_size_unmasked, bin(chunk_size_unmasked)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if allocator.has_tcache() and 'key' in allocator.tcache_entry.keys():\n        tc_idx = (chunk_size_unmasked - chunk_minsize + malloc_alignment - 1) // malloc_alignment\n        if tc_idx < allocator.mp['tcache_bins']:\n            print(message.notice('Tcache checks'))\n            e = addr + 2 * size_sz\n            e += allocator.tcache_entry.keys().index('key') * ptr_size\n            e = pwndbg.gdblib.memory.pvoid(e)\n            tcache_addr = int(allocator.thread_cache.address)\n            if e == tcache_addr:\n                print(message.error('Will do checks for tcache double-free (memory_tcache_double_free)'))\n                errors_found += 1\n            if int(allocator.get_tcache()['counts'][tc_idx]) < int(allocator.mp['tcache_count']):\n                print(message.success('Using tcache_put'))\n                if errors_found == 0:\n                    returned_before_error = True\n    if errors_found > 0:\n        finalize(errors_found, returned_before_error)\n        return\n    if chunk_size_unmasked <= allocator.global_max_fast:\n        print(message.notice('Fastbin checks'))\n        chunk_fastbin_idx = allocator.fastbin_index(chunk_size_unmasked)\n        fastbin_list = allocator.fastbins(arena.address).bins[(chunk_fastbin_idx + 2) * (ptr_size * 2)].fd_chain\n        try:\n            next_chunk = read_chunk(addr + chunk_size_unmasked)\n        except gdb.MemoryError as e:\n            print(message.error(f\"Can't read next chunk at address 0x{chunk + chunk_size_unmasked:x}, memory error\"))\n            finalize(errors_found, returned_before_error)\n            return\n        next_chunk_size = unsigned_size(next_chunk['size'])\n        if next_chunk_size <= 2 * size_sz or chunksize(next_chunk_size) >= arena.system_mem:\n            err = \"free(): invalid next size (fast) -> next chunk's size not in [2*size_sz; av->system_mem]\\n\"\n            err += \"    next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        if int(fastbin_list[0]) == addr:\n            err = 'double free or corruption (fasttop) -> chunk already is on top of fastbin list\\n'\n            err += '    fastbin idx == {}'\n            err = err.format(chunk_fastbin_idx)\n            print(message.error(err))\n            errors_found += 1\n        fastbin_top_chunk = int(fastbin_list[0])\n        if fastbin_top_chunk != 0:\n            try:\n                fastbin_top_chunk = read_chunk(fastbin_top_chunk)\n            except gdb.MemoryError as e:\n                print(message.error(f\"Can't read top fastbin chunk at address 0x{fastbin_top_chunk:x}, memory error\"))\n                finalize(errors_found, returned_before_error)\n                return\n            fastbin_top_chunk_size = chunksize(unsigned_size(fastbin_top_chunk['size']))\n            if chunk_fastbin_idx != allocator.fastbin_index(fastbin_top_chunk_size):\n                err = \"invalid fastbin entry (free) -> chunk's size is not near top chunk's size\\n\"\n                err += \"    chunk's size == {}, idx == {}\\n\"\n                err += \"    top chunk's size == {}, idx == {}\"\n                err += '    if `have_lock` is false then the error is invalid'\n                err = err.format(chunk['size'], chunk_fastbin_idx, fastbin_top_chunk_size, allocator.fastbin_index(fastbin_top_chunk_size))\n                print(message.error(err))\n                errors_found += 1\n    elif is_mmapped == 0:\n        print(message.notice('Not mapped checks'))\n        if addr == arena.top:\n            err = 'double free or corruption (top) -> chunk is top chunk'\n            print(message.error(err))\n            errors_found += 1\n        NONCONTIGUOUS_BIT = 2\n        top_chunk_addr = arena.top\n        top_chunk = read_chunk(top_chunk_addr)\n        next_chunk_addr = addr + chunk_size_unmasked\n        if arena.flags & NONCONTIGUOUS_BIT == 0 and next_chunk_addr >= top_chunk_addr + chunksize(top_chunk['size']):\n            err = 'double free or corruption (out) -> next chunk is beyond arena and arena is contiguous\\n'\n            err += 'next chunk at 0x{:x}, end of arena at 0x{:x}'\n            err = err.format(next_chunk_addr, top_chunk_addr + chunksize(unsigned_size(top_chunk['size'])))\n            print(message.error(err))\n            errors_found += 1\n        try:\n            next_chunk = read_chunk(next_chunk_addr)\n            next_chunk_size = chunksize(unsigned_size(next_chunk['size']))\n        except (OverflowError, gdb.MemoryError) as e:\n            print(message.error(f\"Can't read next chunk at address 0x{next_chunk_addr:x}\"))\n            finalize(errors_found, returned_before_error)\n            return\n        (prev_inuse, _, _) = allocator.chunk_flags(next_chunk['size'])\n        if prev_inuse == 0:\n            err = \"double free or corruption (!prev) -> next chunk's previous-in-use bit is 0\\n\"\n            print(message.error(err))\n            errors_found += 1\n        if next_chunk_size <= 2 * size_sz or next_chunk_size >= arena.system_mem:\n            err = \"free(): invalid next size (normal) -> next chunk's size not in [2*size_sz; system_mem]\\n\"\n            err += \"next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        (prev_inuse, _, _) = allocator.chunk_flags(chunk['size'])\n        if prev_inuse == 0:\n            print(message.notice('Backward consolidation'))\n            prev_size = chunksize(unsigned_size(chunk['prev_size']))\n            prev_chunk_addr = addr - prev_size\n            try:\n                prev_chunk = read_chunk(prev_chunk_addr)\n                prev_chunk_size = chunksize(unsigned_size(prev_chunk['size']))\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{prev_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            if prev_chunk_size != prev_size:\n                err = 'corrupted size vs. prev_size while consolidating\\n'\n                err += 'prev_size field is 0x{:x}, prev chunk at 0x{:x}, prev chunk size is 0x{:x}'\n                err = err.format(prev_size, prev_chunk_addr, prev_chunk_size)\n                print(message.error(err))\n                errors_found += 1\n            else:\n                addr = prev_chunk_addr\n                chunk_size += prev_size\n                chunk_size_unmasked += prev_size\n                try_unlink(addr)\n        if next_chunk_addr != top_chunk_addr:\n            print(message.notice('Next chunk is not top chunk'))\n            try:\n                next_next_chunk_addr = next_chunk_addr + next_chunk_size\n                next_next_chunk = read_chunk(next_next_chunk_addr)\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{next_next_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            (prev_inuse, _, _) = allocator.chunk_flags(next_next_chunk['size'])\n            if prev_inuse == 0:\n                print(message.notice('Forward consolidation'))\n                try_unlink(next_chunk_addr)\n                chunk_size += next_chunk_size\n                chunk_size_unmasked += next_chunk_size\n            else:\n                print(message.notice(\"Clearing next chunk's P bit\"))\n            unsorted_addr = int(arena.bins[0])\n            try:\n                unsorted = read_chunk(unsorted_addr)\n                try:\n                    if read_chunk(unsorted['fd'])['bk'] != unsorted_addr:\n                        err = 'free(): corrupted unsorted chunks -> unsorted_chunk->fd->bk != unsorted_chunk\\n'\n                        err += 'unsorted at 0x{:x}, unsorted->fd == 0x{:x}, unsorted->fd->bk == 0x{:x}'\n                        err = err.format(unsorted_addr, unsorted['fd'], read_chunk(unsorted['fd'])['bk'])\n                        print(message.error(err))\n                        errors_found += 1\n                except (OverflowError, gdb.MemoryError) as e:\n                    print(message.error(f\"Can't read chunk at 0x{unsorted['fd']:x}, it is unsorted bin fd\"))\n                    errors_found += 1\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read unsorted bin chunk at 0x{unsorted_addr:x}\"))\n                errors_found += 1\n        else:\n            print(message.notice('Next chunk is top chunk'))\n            chunk_size += next_chunk_size\n            chunk_size_unmasked += next_chunk_size\n        FASTBIN_CONSOLIDATION_THRESHOLD = 65536\n        if chunk_size_unmasked >= FASTBIN_CONSOLIDATION_THRESHOLD:\n            print(message.notice('Doing malloc_consolidate and systrim/heap_trim'))\n    else:\n        print(message.notice('Doing munmap_chunk'))\n    finalize(errors_found, returned_before_error)",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(try_free_parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef try_free(addr) -> None:\n    if False:\n        i = 10\n    addr = int(addr)\n    free_hook = pwndbg.gdblib.symbol.address('__free_hook')\n    if free_hook is not None:\n        if pwndbg.gdblib.memory.pvoid(free_hook) != 0:\n            print(message.success('__libc_free: will execute __free_hook'))\n    if addr == 0:\n        print(message.success('__libc_free: addr is 0, nothing to do'))\n        return\n    allocator = pwndbg.heap.current\n    arena = allocator.thread_arena\n    if arena is None:\n        print_no_arena_found_error()\n        return\n    aligned_lsb = allocator.malloc_align_mask.bit_length()\n    size_sz = allocator.size_sz\n    malloc_alignment = allocator.malloc_alignment\n    malloc_align_mask = allocator.malloc_align_mask\n    chunk_minsize = allocator.minsize\n    ptr_size = pwndbg.gdblib.arch.ptrsize\n\n    def unsigned_size(size):\n        if ptr_size < 8:\n            return ctypes.c_uint32(size).value\n        x = ctypes.c_uint64(size).value\n        return x\n\n    def chunksize(chunk_size):\n        return chunk_size & ~7\n\n    def finalize(errors_found, returned_before_error) -> None:\n        print('-' * 10)\n        if returned_before_error:\n            print(message.success('Free should succeed!'))\n        elif errors_found > 0:\n            print(message.error('Errors found!'))\n        else:\n            print(message.success('All checks passed!'))\n    addr -= 2 * size_sz\n    try:\n        chunk = read_chunk(addr)\n    except gdb.MemoryError as e:\n        print(message.error(f\"Can't read chunk at address 0x{addr:x}, memory error\"))\n        return\n    chunk_size = unsigned_size(chunk['size'])\n    chunk_size_unmasked = chunksize(chunk_size)\n    (_, is_mmapped, _) = allocator.chunk_flags(chunk_size)\n    if is_mmapped:\n        print(message.notice('__libc_free: Doing munmap_chunk'))\n        return\n    errors_found = 0\n    returned_before_error = False\n    print(message.notice('General checks'))\n    max_mem = (1 << ptr_size * 8) - 1\n    if addr + chunk_size >= max_mem:\n        err = 'free(): invalid pointer -> &chunk + chunk->size > max memory\\n'\n        err += '    0x{:x} + 0x{:x} > 0x{:x}'\n        err = err.format(addr, chunk_size, max_mem)\n        print(message.error(err))\n        errors_found += 1\n    addr_tmp = addr\n    if malloc_alignment != 2 * size_sz:\n        addr_tmp = addr + 2 * size_sz\n    if addr_tmp & malloc_align_mask != 0:\n        err = 'free(): invalid pointer -> misaligned chunk\\n'\n        err += '    LSB of 0x{:x} are 0b{}, should be 0b{}'\n        if addr_tmp != addr:\n            err += f' (0x{2 * size_sz:x} was added to the address)'\n        err = err.format(addr_tmp, bin(addr_tmp)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked < chunk_minsize:\n        err = \"free(): invalid size -> chunk's size smaller than MINSIZE\\n\"\n        err += '    size is 0x{:x}, MINSIZE is 0x{:x}'\n        err = err.format(chunk_size_unmasked, chunk_minsize)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked & malloc_align_mask != 0:\n        err = \"free(): invalid size -> chunk's size is not aligned\\n\"\n        err += '    LSB of size 0x{:x} are 0b{}, should be 0b{}'\n        err = err.format(chunk_size_unmasked, bin(chunk_size_unmasked)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if allocator.has_tcache() and 'key' in allocator.tcache_entry.keys():\n        tc_idx = (chunk_size_unmasked - chunk_minsize + malloc_alignment - 1) // malloc_alignment\n        if tc_idx < allocator.mp['tcache_bins']:\n            print(message.notice('Tcache checks'))\n            e = addr + 2 * size_sz\n            e += allocator.tcache_entry.keys().index('key') * ptr_size\n            e = pwndbg.gdblib.memory.pvoid(e)\n            tcache_addr = int(allocator.thread_cache.address)\n            if e == tcache_addr:\n                print(message.error('Will do checks for tcache double-free (memory_tcache_double_free)'))\n                errors_found += 1\n            if int(allocator.get_tcache()['counts'][tc_idx]) < int(allocator.mp['tcache_count']):\n                print(message.success('Using tcache_put'))\n                if errors_found == 0:\n                    returned_before_error = True\n    if errors_found > 0:\n        finalize(errors_found, returned_before_error)\n        return\n    if chunk_size_unmasked <= allocator.global_max_fast:\n        print(message.notice('Fastbin checks'))\n        chunk_fastbin_idx = allocator.fastbin_index(chunk_size_unmasked)\n        fastbin_list = allocator.fastbins(arena.address).bins[(chunk_fastbin_idx + 2) * (ptr_size * 2)].fd_chain\n        try:\n            next_chunk = read_chunk(addr + chunk_size_unmasked)\n        except gdb.MemoryError as e:\n            print(message.error(f\"Can't read next chunk at address 0x{chunk + chunk_size_unmasked:x}, memory error\"))\n            finalize(errors_found, returned_before_error)\n            return\n        next_chunk_size = unsigned_size(next_chunk['size'])\n        if next_chunk_size <= 2 * size_sz or chunksize(next_chunk_size) >= arena.system_mem:\n            err = \"free(): invalid next size (fast) -> next chunk's size not in [2*size_sz; av->system_mem]\\n\"\n            err += \"    next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        if int(fastbin_list[0]) == addr:\n            err = 'double free or corruption (fasttop) -> chunk already is on top of fastbin list\\n'\n            err += '    fastbin idx == {}'\n            err = err.format(chunk_fastbin_idx)\n            print(message.error(err))\n            errors_found += 1\n        fastbin_top_chunk = int(fastbin_list[0])\n        if fastbin_top_chunk != 0:\n            try:\n                fastbin_top_chunk = read_chunk(fastbin_top_chunk)\n            except gdb.MemoryError as e:\n                print(message.error(f\"Can't read top fastbin chunk at address 0x{fastbin_top_chunk:x}, memory error\"))\n                finalize(errors_found, returned_before_error)\n                return\n            fastbin_top_chunk_size = chunksize(unsigned_size(fastbin_top_chunk['size']))\n            if chunk_fastbin_idx != allocator.fastbin_index(fastbin_top_chunk_size):\n                err = \"invalid fastbin entry (free) -> chunk's size is not near top chunk's size\\n\"\n                err += \"    chunk's size == {}, idx == {}\\n\"\n                err += \"    top chunk's size == {}, idx == {}\"\n                err += '    if `have_lock` is false then the error is invalid'\n                err = err.format(chunk['size'], chunk_fastbin_idx, fastbin_top_chunk_size, allocator.fastbin_index(fastbin_top_chunk_size))\n                print(message.error(err))\n                errors_found += 1\n    elif is_mmapped == 0:\n        print(message.notice('Not mapped checks'))\n        if addr == arena.top:\n            err = 'double free or corruption (top) -> chunk is top chunk'\n            print(message.error(err))\n            errors_found += 1\n        NONCONTIGUOUS_BIT = 2\n        top_chunk_addr = arena.top\n        top_chunk = read_chunk(top_chunk_addr)\n        next_chunk_addr = addr + chunk_size_unmasked\n        if arena.flags & NONCONTIGUOUS_BIT == 0 and next_chunk_addr >= top_chunk_addr + chunksize(top_chunk['size']):\n            err = 'double free or corruption (out) -> next chunk is beyond arena and arena is contiguous\\n'\n            err += 'next chunk at 0x{:x}, end of arena at 0x{:x}'\n            err = err.format(next_chunk_addr, top_chunk_addr + chunksize(unsigned_size(top_chunk['size'])))\n            print(message.error(err))\n            errors_found += 1\n        try:\n            next_chunk = read_chunk(next_chunk_addr)\n            next_chunk_size = chunksize(unsigned_size(next_chunk['size']))\n        except (OverflowError, gdb.MemoryError) as e:\n            print(message.error(f\"Can't read next chunk at address 0x{next_chunk_addr:x}\"))\n            finalize(errors_found, returned_before_error)\n            return\n        (prev_inuse, _, _) = allocator.chunk_flags(next_chunk['size'])\n        if prev_inuse == 0:\n            err = \"double free or corruption (!prev) -> next chunk's previous-in-use bit is 0\\n\"\n            print(message.error(err))\n            errors_found += 1\n        if next_chunk_size <= 2 * size_sz or next_chunk_size >= arena.system_mem:\n            err = \"free(): invalid next size (normal) -> next chunk's size not in [2*size_sz; system_mem]\\n\"\n            err += \"next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        (prev_inuse, _, _) = allocator.chunk_flags(chunk['size'])\n        if prev_inuse == 0:\n            print(message.notice('Backward consolidation'))\n            prev_size = chunksize(unsigned_size(chunk['prev_size']))\n            prev_chunk_addr = addr - prev_size\n            try:\n                prev_chunk = read_chunk(prev_chunk_addr)\n                prev_chunk_size = chunksize(unsigned_size(prev_chunk['size']))\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{prev_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            if prev_chunk_size != prev_size:\n                err = 'corrupted size vs. prev_size while consolidating\\n'\n                err += 'prev_size field is 0x{:x}, prev chunk at 0x{:x}, prev chunk size is 0x{:x}'\n                err = err.format(prev_size, prev_chunk_addr, prev_chunk_size)\n                print(message.error(err))\n                errors_found += 1\n            else:\n                addr = prev_chunk_addr\n                chunk_size += prev_size\n                chunk_size_unmasked += prev_size\n                try_unlink(addr)\n        if next_chunk_addr != top_chunk_addr:\n            print(message.notice('Next chunk is not top chunk'))\n            try:\n                next_next_chunk_addr = next_chunk_addr + next_chunk_size\n                next_next_chunk = read_chunk(next_next_chunk_addr)\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{next_next_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            (prev_inuse, _, _) = allocator.chunk_flags(next_next_chunk['size'])\n            if prev_inuse == 0:\n                print(message.notice('Forward consolidation'))\n                try_unlink(next_chunk_addr)\n                chunk_size += next_chunk_size\n                chunk_size_unmasked += next_chunk_size\n            else:\n                print(message.notice(\"Clearing next chunk's P bit\"))\n            unsorted_addr = int(arena.bins[0])\n            try:\n                unsorted = read_chunk(unsorted_addr)\n                try:\n                    if read_chunk(unsorted['fd'])['bk'] != unsorted_addr:\n                        err = 'free(): corrupted unsorted chunks -> unsorted_chunk->fd->bk != unsorted_chunk\\n'\n                        err += 'unsorted at 0x{:x}, unsorted->fd == 0x{:x}, unsorted->fd->bk == 0x{:x}'\n                        err = err.format(unsorted_addr, unsorted['fd'], read_chunk(unsorted['fd'])['bk'])\n                        print(message.error(err))\n                        errors_found += 1\n                except (OverflowError, gdb.MemoryError) as e:\n                    print(message.error(f\"Can't read chunk at 0x{unsorted['fd']:x}, it is unsorted bin fd\"))\n                    errors_found += 1\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read unsorted bin chunk at 0x{unsorted_addr:x}\"))\n                errors_found += 1\n        else:\n            print(message.notice('Next chunk is top chunk'))\n            chunk_size += next_chunk_size\n            chunk_size_unmasked += next_chunk_size\n        FASTBIN_CONSOLIDATION_THRESHOLD = 65536\n        if chunk_size_unmasked >= FASTBIN_CONSOLIDATION_THRESHOLD:\n            print(message.notice('Doing malloc_consolidate and systrim/heap_trim'))\n    else:\n        print(message.notice('Doing munmap_chunk'))\n    finalize(errors_found, returned_before_error)",
            "@pwndbg.commands.ArgparsedCommand(try_free_parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef try_free(addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    addr = int(addr)\n    free_hook = pwndbg.gdblib.symbol.address('__free_hook')\n    if free_hook is not None:\n        if pwndbg.gdblib.memory.pvoid(free_hook) != 0:\n            print(message.success('__libc_free: will execute __free_hook'))\n    if addr == 0:\n        print(message.success('__libc_free: addr is 0, nothing to do'))\n        return\n    allocator = pwndbg.heap.current\n    arena = allocator.thread_arena\n    if arena is None:\n        print_no_arena_found_error()\n        return\n    aligned_lsb = allocator.malloc_align_mask.bit_length()\n    size_sz = allocator.size_sz\n    malloc_alignment = allocator.malloc_alignment\n    malloc_align_mask = allocator.malloc_align_mask\n    chunk_minsize = allocator.minsize\n    ptr_size = pwndbg.gdblib.arch.ptrsize\n\n    def unsigned_size(size):\n        if ptr_size < 8:\n            return ctypes.c_uint32(size).value\n        x = ctypes.c_uint64(size).value\n        return x\n\n    def chunksize(chunk_size):\n        return chunk_size & ~7\n\n    def finalize(errors_found, returned_before_error) -> None:\n        print('-' * 10)\n        if returned_before_error:\n            print(message.success('Free should succeed!'))\n        elif errors_found > 0:\n            print(message.error('Errors found!'))\n        else:\n            print(message.success('All checks passed!'))\n    addr -= 2 * size_sz\n    try:\n        chunk = read_chunk(addr)\n    except gdb.MemoryError as e:\n        print(message.error(f\"Can't read chunk at address 0x{addr:x}, memory error\"))\n        return\n    chunk_size = unsigned_size(chunk['size'])\n    chunk_size_unmasked = chunksize(chunk_size)\n    (_, is_mmapped, _) = allocator.chunk_flags(chunk_size)\n    if is_mmapped:\n        print(message.notice('__libc_free: Doing munmap_chunk'))\n        return\n    errors_found = 0\n    returned_before_error = False\n    print(message.notice('General checks'))\n    max_mem = (1 << ptr_size * 8) - 1\n    if addr + chunk_size >= max_mem:\n        err = 'free(): invalid pointer -> &chunk + chunk->size > max memory\\n'\n        err += '    0x{:x} + 0x{:x} > 0x{:x}'\n        err = err.format(addr, chunk_size, max_mem)\n        print(message.error(err))\n        errors_found += 1\n    addr_tmp = addr\n    if malloc_alignment != 2 * size_sz:\n        addr_tmp = addr + 2 * size_sz\n    if addr_tmp & malloc_align_mask != 0:\n        err = 'free(): invalid pointer -> misaligned chunk\\n'\n        err += '    LSB of 0x{:x} are 0b{}, should be 0b{}'\n        if addr_tmp != addr:\n            err += f' (0x{2 * size_sz:x} was added to the address)'\n        err = err.format(addr_tmp, bin(addr_tmp)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked < chunk_minsize:\n        err = \"free(): invalid size -> chunk's size smaller than MINSIZE\\n\"\n        err += '    size is 0x{:x}, MINSIZE is 0x{:x}'\n        err = err.format(chunk_size_unmasked, chunk_minsize)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked & malloc_align_mask != 0:\n        err = \"free(): invalid size -> chunk's size is not aligned\\n\"\n        err += '    LSB of size 0x{:x} are 0b{}, should be 0b{}'\n        err = err.format(chunk_size_unmasked, bin(chunk_size_unmasked)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if allocator.has_tcache() and 'key' in allocator.tcache_entry.keys():\n        tc_idx = (chunk_size_unmasked - chunk_minsize + malloc_alignment - 1) // malloc_alignment\n        if tc_idx < allocator.mp['tcache_bins']:\n            print(message.notice('Tcache checks'))\n            e = addr + 2 * size_sz\n            e += allocator.tcache_entry.keys().index('key') * ptr_size\n            e = pwndbg.gdblib.memory.pvoid(e)\n            tcache_addr = int(allocator.thread_cache.address)\n            if e == tcache_addr:\n                print(message.error('Will do checks for tcache double-free (memory_tcache_double_free)'))\n                errors_found += 1\n            if int(allocator.get_tcache()['counts'][tc_idx]) < int(allocator.mp['tcache_count']):\n                print(message.success('Using tcache_put'))\n                if errors_found == 0:\n                    returned_before_error = True\n    if errors_found > 0:\n        finalize(errors_found, returned_before_error)\n        return\n    if chunk_size_unmasked <= allocator.global_max_fast:\n        print(message.notice('Fastbin checks'))\n        chunk_fastbin_idx = allocator.fastbin_index(chunk_size_unmasked)\n        fastbin_list = allocator.fastbins(arena.address).bins[(chunk_fastbin_idx + 2) * (ptr_size * 2)].fd_chain\n        try:\n            next_chunk = read_chunk(addr + chunk_size_unmasked)\n        except gdb.MemoryError as e:\n            print(message.error(f\"Can't read next chunk at address 0x{chunk + chunk_size_unmasked:x}, memory error\"))\n            finalize(errors_found, returned_before_error)\n            return\n        next_chunk_size = unsigned_size(next_chunk['size'])\n        if next_chunk_size <= 2 * size_sz or chunksize(next_chunk_size) >= arena.system_mem:\n            err = \"free(): invalid next size (fast) -> next chunk's size not in [2*size_sz; av->system_mem]\\n\"\n            err += \"    next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        if int(fastbin_list[0]) == addr:\n            err = 'double free or corruption (fasttop) -> chunk already is on top of fastbin list\\n'\n            err += '    fastbin idx == {}'\n            err = err.format(chunk_fastbin_idx)\n            print(message.error(err))\n            errors_found += 1\n        fastbin_top_chunk = int(fastbin_list[0])\n        if fastbin_top_chunk != 0:\n            try:\n                fastbin_top_chunk = read_chunk(fastbin_top_chunk)\n            except gdb.MemoryError as e:\n                print(message.error(f\"Can't read top fastbin chunk at address 0x{fastbin_top_chunk:x}, memory error\"))\n                finalize(errors_found, returned_before_error)\n                return\n            fastbin_top_chunk_size = chunksize(unsigned_size(fastbin_top_chunk['size']))\n            if chunk_fastbin_idx != allocator.fastbin_index(fastbin_top_chunk_size):\n                err = \"invalid fastbin entry (free) -> chunk's size is not near top chunk's size\\n\"\n                err += \"    chunk's size == {}, idx == {}\\n\"\n                err += \"    top chunk's size == {}, idx == {}\"\n                err += '    if `have_lock` is false then the error is invalid'\n                err = err.format(chunk['size'], chunk_fastbin_idx, fastbin_top_chunk_size, allocator.fastbin_index(fastbin_top_chunk_size))\n                print(message.error(err))\n                errors_found += 1\n    elif is_mmapped == 0:\n        print(message.notice('Not mapped checks'))\n        if addr == arena.top:\n            err = 'double free or corruption (top) -> chunk is top chunk'\n            print(message.error(err))\n            errors_found += 1\n        NONCONTIGUOUS_BIT = 2\n        top_chunk_addr = arena.top\n        top_chunk = read_chunk(top_chunk_addr)\n        next_chunk_addr = addr + chunk_size_unmasked\n        if arena.flags & NONCONTIGUOUS_BIT == 0 and next_chunk_addr >= top_chunk_addr + chunksize(top_chunk['size']):\n            err = 'double free or corruption (out) -> next chunk is beyond arena and arena is contiguous\\n'\n            err += 'next chunk at 0x{:x}, end of arena at 0x{:x}'\n            err = err.format(next_chunk_addr, top_chunk_addr + chunksize(unsigned_size(top_chunk['size'])))\n            print(message.error(err))\n            errors_found += 1\n        try:\n            next_chunk = read_chunk(next_chunk_addr)\n            next_chunk_size = chunksize(unsigned_size(next_chunk['size']))\n        except (OverflowError, gdb.MemoryError) as e:\n            print(message.error(f\"Can't read next chunk at address 0x{next_chunk_addr:x}\"))\n            finalize(errors_found, returned_before_error)\n            return\n        (prev_inuse, _, _) = allocator.chunk_flags(next_chunk['size'])\n        if prev_inuse == 0:\n            err = \"double free or corruption (!prev) -> next chunk's previous-in-use bit is 0\\n\"\n            print(message.error(err))\n            errors_found += 1\n        if next_chunk_size <= 2 * size_sz or next_chunk_size >= arena.system_mem:\n            err = \"free(): invalid next size (normal) -> next chunk's size not in [2*size_sz; system_mem]\\n\"\n            err += \"next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        (prev_inuse, _, _) = allocator.chunk_flags(chunk['size'])\n        if prev_inuse == 0:\n            print(message.notice('Backward consolidation'))\n            prev_size = chunksize(unsigned_size(chunk['prev_size']))\n            prev_chunk_addr = addr - prev_size\n            try:\n                prev_chunk = read_chunk(prev_chunk_addr)\n                prev_chunk_size = chunksize(unsigned_size(prev_chunk['size']))\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{prev_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            if prev_chunk_size != prev_size:\n                err = 'corrupted size vs. prev_size while consolidating\\n'\n                err += 'prev_size field is 0x{:x}, prev chunk at 0x{:x}, prev chunk size is 0x{:x}'\n                err = err.format(prev_size, prev_chunk_addr, prev_chunk_size)\n                print(message.error(err))\n                errors_found += 1\n            else:\n                addr = prev_chunk_addr\n                chunk_size += prev_size\n                chunk_size_unmasked += prev_size\n                try_unlink(addr)\n        if next_chunk_addr != top_chunk_addr:\n            print(message.notice('Next chunk is not top chunk'))\n            try:\n                next_next_chunk_addr = next_chunk_addr + next_chunk_size\n                next_next_chunk = read_chunk(next_next_chunk_addr)\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{next_next_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            (prev_inuse, _, _) = allocator.chunk_flags(next_next_chunk['size'])\n            if prev_inuse == 0:\n                print(message.notice('Forward consolidation'))\n                try_unlink(next_chunk_addr)\n                chunk_size += next_chunk_size\n                chunk_size_unmasked += next_chunk_size\n            else:\n                print(message.notice(\"Clearing next chunk's P bit\"))\n            unsorted_addr = int(arena.bins[0])\n            try:\n                unsorted = read_chunk(unsorted_addr)\n                try:\n                    if read_chunk(unsorted['fd'])['bk'] != unsorted_addr:\n                        err = 'free(): corrupted unsorted chunks -> unsorted_chunk->fd->bk != unsorted_chunk\\n'\n                        err += 'unsorted at 0x{:x}, unsorted->fd == 0x{:x}, unsorted->fd->bk == 0x{:x}'\n                        err = err.format(unsorted_addr, unsorted['fd'], read_chunk(unsorted['fd'])['bk'])\n                        print(message.error(err))\n                        errors_found += 1\n                except (OverflowError, gdb.MemoryError) as e:\n                    print(message.error(f\"Can't read chunk at 0x{unsorted['fd']:x}, it is unsorted bin fd\"))\n                    errors_found += 1\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read unsorted bin chunk at 0x{unsorted_addr:x}\"))\n                errors_found += 1\n        else:\n            print(message.notice('Next chunk is top chunk'))\n            chunk_size += next_chunk_size\n            chunk_size_unmasked += next_chunk_size\n        FASTBIN_CONSOLIDATION_THRESHOLD = 65536\n        if chunk_size_unmasked >= FASTBIN_CONSOLIDATION_THRESHOLD:\n            print(message.notice('Doing malloc_consolidate and systrim/heap_trim'))\n    else:\n        print(message.notice('Doing munmap_chunk'))\n    finalize(errors_found, returned_before_error)",
            "@pwndbg.commands.ArgparsedCommand(try_free_parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef try_free(addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    addr = int(addr)\n    free_hook = pwndbg.gdblib.symbol.address('__free_hook')\n    if free_hook is not None:\n        if pwndbg.gdblib.memory.pvoid(free_hook) != 0:\n            print(message.success('__libc_free: will execute __free_hook'))\n    if addr == 0:\n        print(message.success('__libc_free: addr is 0, nothing to do'))\n        return\n    allocator = pwndbg.heap.current\n    arena = allocator.thread_arena\n    if arena is None:\n        print_no_arena_found_error()\n        return\n    aligned_lsb = allocator.malloc_align_mask.bit_length()\n    size_sz = allocator.size_sz\n    malloc_alignment = allocator.malloc_alignment\n    malloc_align_mask = allocator.malloc_align_mask\n    chunk_minsize = allocator.minsize\n    ptr_size = pwndbg.gdblib.arch.ptrsize\n\n    def unsigned_size(size):\n        if ptr_size < 8:\n            return ctypes.c_uint32(size).value\n        x = ctypes.c_uint64(size).value\n        return x\n\n    def chunksize(chunk_size):\n        return chunk_size & ~7\n\n    def finalize(errors_found, returned_before_error) -> None:\n        print('-' * 10)\n        if returned_before_error:\n            print(message.success('Free should succeed!'))\n        elif errors_found > 0:\n            print(message.error('Errors found!'))\n        else:\n            print(message.success('All checks passed!'))\n    addr -= 2 * size_sz\n    try:\n        chunk = read_chunk(addr)\n    except gdb.MemoryError as e:\n        print(message.error(f\"Can't read chunk at address 0x{addr:x}, memory error\"))\n        return\n    chunk_size = unsigned_size(chunk['size'])\n    chunk_size_unmasked = chunksize(chunk_size)\n    (_, is_mmapped, _) = allocator.chunk_flags(chunk_size)\n    if is_mmapped:\n        print(message.notice('__libc_free: Doing munmap_chunk'))\n        return\n    errors_found = 0\n    returned_before_error = False\n    print(message.notice('General checks'))\n    max_mem = (1 << ptr_size * 8) - 1\n    if addr + chunk_size >= max_mem:\n        err = 'free(): invalid pointer -> &chunk + chunk->size > max memory\\n'\n        err += '    0x{:x} + 0x{:x} > 0x{:x}'\n        err = err.format(addr, chunk_size, max_mem)\n        print(message.error(err))\n        errors_found += 1\n    addr_tmp = addr\n    if malloc_alignment != 2 * size_sz:\n        addr_tmp = addr + 2 * size_sz\n    if addr_tmp & malloc_align_mask != 0:\n        err = 'free(): invalid pointer -> misaligned chunk\\n'\n        err += '    LSB of 0x{:x} are 0b{}, should be 0b{}'\n        if addr_tmp != addr:\n            err += f' (0x{2 * size_sz:x} was added to the address)'\n        err = err.format(addr_tmp, bin(addr_tmp)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked < chunk_minsize:\n        err = \"free(): invalid size -> chunk's size smaller than MINSIZE\\n\"\n        err += '    size is 0x{:x}, MINSIZE is 0x{:x}'\n        err = err.format(chunk_size_unmasked, chunk_minsize)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked & malloc_align_mask != 0:\n        err = \"free(): invalid size -> chunk's size is not aligned\\n\"\n        err += '    LSB of size 0x{:x} are 0b{}, should be 0b{}'\n        err = err.format(chunk_size_unmasked, bin(chunk_size_unmasked)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if allocator.has_tcache() and 'key' in allocator.tcache_entry.keys():\n        tc_idx = (chunk_size_unmasked - chunk_minsize + malloc_alignment - 1) // malloc_alignment\n        if tc_idx < allocator.mp['tcache_bins']:\n            print(message.notice('Tcache checks'))\n            e = addr + 2 * size_sz\n            e += allocator.tcache_entry.keys().index('key') * ptr_size\n            e = pwndbg.gdblib.memory.pvoid(e)\n            tcache_addr = int(allocator.thread_cache.address)\n            if e == tcache_addr:\n                print(message.error('Will do checks for tcache double-free (memory_tcache_double_free)'))\n                errors_found += 1\n            if int(allocator.get_tcache()['counts'][tc_idx]) < int(allocator.mp['tcache_count']):\n                print(message.success('Using tcache_put'))\n                if errors_found == 0:\n                    returned_before_error = True\n    if errors_found > 0:\n        finalize(errors_found, returned_before_error)\n        return\n    if chunk_size_unmasked <= allocator.global_max_fast:\n        print(message.notice('Fastbin checks'))\n        chunk_fastbin_idx = allocator.fastbin_index(chunk_size_unmasked)\n        fastbin_list = allocator.fastbins(arena.address).bins[(chunk_fastbin_idx + 2) * (ptr_size * 2)].fd_chain\n        try:\n            next_chunk = read_chunk(addr + chunk_size_unmasked)\n        except gdb.MemoryError as e:\n            print(message.error(f\"Can't read next chunk at address 0x{chunk + chunk_size_unmasked:x}, memory error\"))\n            finalize(errors_found, returned_before_error)\n            return\n        next_chunk_size = unsigned_size(next_chunk['size'])\n        if next_chunk_size <= 2 * size_sz or chunksize(next_chunk_size) >= arena.system_mem:\n            err = \"free(): invalid next size (fast) -> next chunk's size not in [2*size_sz; av->system_mem]\\n\"\n            err += \"    next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        if int(fastbin_list[0]) == addr:\n            err = 'double free or corruption (fasttop) -> chunk already is on top of fastbin list\\n'\n            err += '    fastbin idx == {}'\n            err = err.format(chunk_fastbin_idx)\n            print(message.error(err))\n            errors_found += 1\n        fastbin_top_chunk = int(fastbin_list[0])\n        if fastbin_top_chunk != 0:\n            try:\n                fastbin_top_chunk = read_chunk(fastbin_top_chunk)\n            except gdb.MemoryError as e:\n                print(message.error(f\"Can't read top fastbin chunk at address 0x{fastbin_top_chunk:x}, memory error\"))\n                finalize(errors_found, returned_before_error)\n                return\n            fastbin_top_chunk_size = chunksize(unsigned_size(fastbin_top_chunk['size']))\n            if chunk_fastbin_idx != allocator.fastbin_index(fastbin_top_chunk_size):\n                err = \"invalid fastbin entry (free) -> chunk's size is not near top chunk's size\\n\"\n                err += \"    chunk's size == {}, idx == {}\\n\"\n                err += \"    top chunk's size == {}, idx == {}\"\n                err += '    if `have_lock` is false then the error is invalid'\n                err = err.format(chunk['size'], chunk_fastbin_idx, fastbin_top_chunk_size, allocator.fastbin_index(fastbin_top_chunk_size))\n                print(message.error(err))\n                errors_found += 1\n    elif is_mmapped == 0:\n        print(message.notice('Not mapped checks'))\n        if addr == arena.top:\n            err = 'double free or corruption (top) -> chunk is top chunk'\n            print(message.error(err))\n            errors_found += 1\n        NONCONTIGUOUS_BIT = 2\n        top_chunk_addr = arena.top\n        top_chunk = read_chunk(top_chunk_addr)\n        next_chunk_addr = addr + chunk_size_unmasked\n        if arena.flags & NONCONTIGUOUS_BIT == 0 and next_chunk_addr >= top_chunk_addr + chunksize(top_chunk['size']):\n            err = 'double free or corruption (out) -> next chunk is beyond arena and arena is contiguous\\n'\n            err += 'next chunk at 0x{:x}, end of arena at 0x{:x}'\n            err = err.format(next_chunk_addr, top_chunk_addr + chunksize(unsigned_size(top_chunk['size'])))\n            print(message.error(err))\n            errors_found += 1\n        try:\n            next_chunk = read_chunk(next_chunk_addr)\n            next_chunk_size = chunksize(unsigned_size(next_chunk['size']))\n        except (OverflowError, gdb.MemoryError) as e:\n            print(message.error(f\"Can't read next chunk at address 0x{next_chunk_addr:x}\"))\n            finalize(errors_found, returned_before_error)\n            return\n        (prev_inuse, _, _) = allocator.chunk_flags(next_chunk['size'])\n        if prev_inuse == 0:\n            err = \"double free or corruption (!prev) -> next chunk's previous-in-use bit is 0\\n\"\n            print(message.error(err))\n            errors_found += 1\n        if next_chunk_size <= 2 * size_sz or next_chunk_size >= arena.system_mem:\n            err = \"free(): invalid next size (normal) -> next chunk's size not in [2*size_sz; system_mem]\\n\"\n            err += \"next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        (prev_inuse, _, _) = allocator.chunk_flags(chunk['size'])\n        if prev_inuse == 0:\n            print(message.notice('Backward consolidation'))\n            prev_size = chunksize(unsigned_size(chunk['prev_size']))\n            prev_chunk_addr = addr - prev_size\n            try:\n                prev_chunk = read_chunk(prev_chunk_addr)\n                prev_chunk_size = chunksize(unsigned_size(prev_chunk['size']))\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{prev_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            if prev_chunk_size != prev_size:\n                err = 'corrupted size vs. prev_size while consolidating\\n'\n                err += 'prev_size field is 0x{:x}, prev chunk at 0x{:x}, prev chunk size is 0x{:x}'\n                err = err.format(prev_size, prev_chunk_addr, prev_chunk_size)\n                print(message.error(err))\n                errors_found += 1\n            else:\n                addr = prev_chunk_addr\n                chunk_size += prev_size\n                chunk_size_unmasked += prev_size\n                try_unlink(addr)\n        if next_chunk_addr != top_chunk_addr:\n            print(message.notice('Next chunk is not top chunk'))\n            try:\n                next_next_chunk_addr = next_chunk_addr + next_chunk_size\n                next_next_chunk = read_chunk(next_next_chunk_addr)\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{next_next_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            (prev_inuse, _, _) = allocator.chunk_flags(next_next_chunk['size'])\n            if prev_inuse == 0:\n                print(message.notice('Forward consolidation'))\n                try_unlink(next_chunk_addr)\n                chunk_size += next_chunk_size\n                chunk_size_unmasked += next_chunk_size\n            else:\n                print(message.notice(\"Clearing next chunk's P bit\"))\n            unsorted_addr = int(arena.bins[0])\n            try:\n                unsorted = read_chunk(unsorted_addr)\n                try:\n                    if read_chunk(unsorted['fd'])['bk'] != unsorted_addr:\n                        err = 'free(): corrupted unsorted chunks -> unsorted_chunk->fd->bk != unsorted_chunk\\n'\n                        err += 'unsorted at 0x{:x}, unsorted->fd == 0x{:x}, unsorted->fd->bk == 0x{:x}'\n                        err = err.format(unsorted_addr, unsorted['fd'], read_chunk(unsorted['fd'])['bk'])\n                        print(message.error(err))\n                        errors_found += 1\n                except (OverflowError, gdb.MemoryError) as e:\n                    print(message.error(f\"Can't read chunk at 0x{unsorted['fd']:x}, it is unsorted bin fd\"))\n                    errors_found += 1\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read unsorted bin chunk at 0x{unsorted_addr:x}\"))\n                errors_found += 1\n        else:\n            print(message.notice('Next chunk is top chunk'))\n            chunk_size += next_chunk_size\n            chunk_size_unmasked += next_chunk_size\n        FASTBIN_CONSOLIDATION_THRESHOLD = 65536\n        if chunk_size_unmasked >= FASTBIN_CONSOLIDATION_THRESHOLD:\n            print(message.notice('Doing malloc_consolidate and systrim/heap_trim'))\n    else:\n        print(message.notice('Doing munmap_chunk'))\n    finalize(errors_found, returned_before_error)",
            "@pwndbg.commands.ArgparsedCommand(try_free_parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef try_free(addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    addr = int(addr)\n    free_hook = pwndbg.gdblib.symbol.address('__free_hook')\n    if free_hook is not None:\n        if pwndbg.gdblib.memory.pvoid(free_hook) != 0:\n            print(message.success('__libc_free: will execute __free_hook'))\n    if addr == 0:\n        print(message.success('__libc_free: addr is 0, nothing to do'))\n        return\n    allocator = pwndbg.heap.current\n    arena = allocator.thread_arena\n    if arena is None:\n        print_no_arena_found_error()\n        return\n    aligned_lsb = allocator.malloc_align_mask.bit_length()\n    size_sz = allocator.size_sz\n    malloc_alignment = allocator.malloc_alignment\n    malloc_align_mask = allocator.malloc_align_mask\n    chunk_minsize = allocator.minsize\n    ptr_size = pwndbg.gdblib.arch.ptrsize\n\n    def unsigned_size(size):\n        if ptr_size < 8:\n            return ctypes.c_uint32(size).value\n        x = ctypes.c_uint64(size).value\n        return x\n\n    def chunksize(chunk_size):\n        return chunk_size & ~7\n\n    def finalize(errors_found, returned_before_error) -> None:\n        print('-' * 10)\n        if returned_before_error:\n            print(message.success('Free should succeed!'))\n        elif errors_found > 0:\n            print(message.error('Errors found!'))\n        else:\n            print(message.success('All checks passed!'))\n    addr -= 2 * size_sz\n    try:\n        chunk = read_chunk(addr)\n    except gdb.MemoryError as e:\n        print(message.error(f\"Can't read chunk at address 0x{addr:x}, memory error\"))\n        return\n    chunk_size = unsigned_size(chunk['size'])\n    chunk_size_unmasked = chunksize(chunk_size)\n    (_, is_mmapped, _) = allocator.chunk_flags(chunk_size)\n    if is_mmapped:\n        print(message.notice('__libc_free: Doing munmap_chunk'))\n        return\n    errors_found = 0\n    returned_before_error = False\n    print(message.notice('General checks'))\n    max_mem = (1 << ptr_size * 8) - 1\n    if addr + chunk_size >= max_mem:\n        err = 'free(): invalid pointer -> &chunk + chunk->size > max memory\\n'\n        err += '    0x{:x} + 0x{:x} > 0x{:x}'\n        err = err.format(addr, chunk_size, max_mem)\n        print(message.error(err))\n        errors_found += 1\n    addr_tmp = addr\n    if malloc_alignment != 2 * size_sz:\n        addr_tmp = addr + 2 * size_sz\n    if addr_tmp & malloc_align_mask != 0:\n        err = 'free(): invalid pointer -> misaligned chunk\\n'\n        err += '    LSB of 0x{:x} are 0b{}, should be 0b{}'\n        if addr_tmp != addr:\n            err += f' (0x{2 * size_sz:x} was added to the address)'\n        err = err.format(addr_tmp, bin(addr_tmp)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked < chunk_minsize:\n        err = \"free(): invalid size -> chunk's size smaller than MINSIZE\\n\"\n        err += '    size is 0x{:x}, MINSIZE is 0x{:x}'\n        err = err.format(chunk_size_unmasked, chunk_minsize)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked & malloc_align_mask != 0:\n        err = \"free(): invalid size -> chunk's size is not aligned\\n\"\n        err += '    LSB of size 0x{:x} are 0b{}, should be 0b{}'\n        err = err.format(chunk_size_unmasked, bin(chunk_size_unmasked)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if allocator.has_tcache() and 'key' in allocator.tcache_entry.keys():\n        tc_idx = (chunk_size_unmasked - chunk_minsize + malloc_alignment - 1) // malloc_alignment\n        if tc_idx < allocator.mp['tcache_bins']:\n            print(message.notice('Tcache checks'))\n            e = addr + 2 * size_sz\n            e += allocator.tcache_entry.keys().index('key') * ptr_size\n            e = pwndbg.gdblib.memory.pvoid(e)\n            tcache_addr = int(allocator.thread_cache.address)\n            if e == tcache_addr:\n                print(message.error('Will do checks for tcache double-free (memory_tcache_double_free)'))\n                errors_found += 1\n            if int(allocator.get_tcache()['counts'][tc_idx]) < int(allocator.mp['tcache_count']):\n                print(message.success('Using tcache_put'))\n                if errors_found == 0:\n                    returned_before_error = True\n    if errors_found > 0:\n        finalize(errors_found, returned_before_error)\n        return\n    if chunk_size_unmasked <= allocator.global_max_fast:\n        print(message.notice('Fastbin checks'))\n        chunk_fastbin_idx = allocator.fastbin_index(chunk_size_unmasked)\n        fastbin_list = allocator.fastbins(arena.address).bins[(chunk_fastbin_idx + 2) * (ptr_size * 2)].fd_chain\n        try:\n            next_chunk = read_chunk(addr + chunk_size_unmasked)\n        except gdb.MemoryError as e:\n            print(message.error(f\"Can't read next chunk at address 0x{chunk + chunk_size_unmasked:x}, memory error\"))\n            finalize(errors_found, returned_before_error)\n            return\n        next_chunk_size = unsigned_size(next_chunk['size'])\n        if next_chunk_size <= 2 * size_sz or chunksize(next_chunk_size) >= arena.system_mem:\n            err = \"free(): invalid next size (fast) -> next chunk's size not in [2*size_sz; av->system_mem]\\n\"\n            err += \"    next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        if int(fastbin_list[0]) == addr:\n            err = 'double free or corruption (fasttop) -> chunk already is on top of fastbin list\\n'\n            err += '    fastbin idx == {}'\n            err = err.format(chunk_fastbin_idx)\n            print(message.error(err))\n            errors_found += 1\n        fastbin_top_chunk = int(fastbin_list[0])\n        if fastbin_top_chunk != 0:\n            try:\n                fastbin_top_chunk = read_chunk(fastbin_top_chunk)\n            except gdb.MemoryError as e:\n                print(message.error(f\"Can't read top fastbin chunk at address 0x{fastbin_top_chunk:x}, memory error\"))\n                finalize(errors_found, returned_before_error)\n                return\n            fastbin_top_chunk_size = chunksize(unsigned_size(fastbin_top_chunk['size']))\n            if chunk_fastbin_idx != allocator.fastbin_index(fastbin_top_chunk_size):\n                err = \"invalid fastbin entry (free) -> chunk's size is not near top chunk's size\\n\"\n                err += \"    chunk's size == {}, idx == {}\\n\"\n                err += \"    top chunk's size == {}, idx == {}\"\n                err += '    if `have_lock` is false then the error is invalid'\n                err = err.format(chunk['size'], chunk_fastbin_idx, fastbin_top_chunk_size, allocator.fastbin_index(fastbin_top_chunk_size))\n                print(message.error(err))\n                errors_found += 1\n    elif is_mmapped == 0:\n        print(message.notice('Not mapped checks'))\n        if addr == arena.top:\n            err = 'double free or corruption (top) -> chunk is top chunk'\n            print(message.error(err))\n            errors_found += 1\n        NONCONTIGUOUS_BIT = 2\n        top_chunk_addr = arena.top\n        top_chunk = read_chunk(top_chunk_addr)\n        next_chunk_addr = addr + chunk_size_unmasked\n        if arena.flags & NONCONTIGUOUS_BIT == 0 and next_chunk_addr >= top_chunk_addr + chunksize(top_chunk['size']):\n            err = 'double free or corruption (out) -> next chunk is beyond arena and arena is contiguous\\n'\n            err += 'next chunk at 0x{:x}, end of arena at 0x{:x}'\n            err = err.format(next_chunk_addr, top_chunk_addr + chunksize(unsigned_size(top_chunk['size'])))\n            print(message.error(err))\n            errors_found += 1\n        try:\n            next_chunk = read_chunk(next_chunk_addr)\n            next_chunk_size = chunksize(unsigned_size(next_chunk['size']))\n        except (OverflowError, gdb.MemoryError) as e:\n            print(message.error(f\"Can't read next chunk at address 0x{next_chunk_addr:x}\"))\n            finalize(errors_found, returned_before_error)\n            return\n        (prev_inuse, _, _) = allocator.chunk_flags(next_chunk['size'])\n        if prev_inuse == 0:\n            err = \"double free or corruption (!prev) -> next chunk's previous-in-use bit is 0\\n\"\n            print(message.error(err))\n            errors_found += 1\n        if next_chunk_size <= 2 * size_sz or next_chunk_size >= arena.system_mem:\n            err = \"free(): invalid next size (normal) -> next chunk's size not in [2*size_sz; system_mem]\\n\"\n            err += \"next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        (prev_inuse, _, _) = allocator.chunk_flags(chunk['size'])\n        if prev_inuse == 0:\n            print(message.notice('Backward consolidation'))\n            prev_size = chunksize(unsigned_size(chunk['prev_size']))\n            prev_chunk_addr = addr - prev_size\n            try:\n                prev_chunk = read_chunk(prev_chunk_addr)\n                prev_chunk_size = chunksize(unsigned_size(prev_chunk['size']))\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{prev_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            if prev_chunk_size != prev_size:\n                err = 'corrupted size vs. prev_size while consolidating\\n'\n                err += 'prev_size field is 0x{:x}, prev chunk at 0x{:x}, prev chunk size is 0x{:x}'\n                err = err.format(prev_size, prev_chunk_addr, prev_chunk_size)\n                print(message.error(err))\n                errors_found += 1\n            else:\n                addr = prev_chunk_addr\n                chunk_size += prev_size\n                chunk_size_unmasked += prev_size\n                try_unlink(addr)\n        if next_chunk_addr != top_chunk_addr:\n            print(message.notice('Next chunk is not top chunk'))\n            try:\n                next_next_chunk_addr = next_chunk_addr + next_chunk_size\n                next_next_chunk = read_chunk(next_next_chunk_addr)\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{next_next_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            (prev_inuse, _, _) = allocator.chunk_flags(next_next_chunk['size'])\n            if prev_inuse == 0:\n                print(message.notice('Forward consolidation'))\n                try_unlink(next_chunk_addr)\n                chunk_size += next_chunk_size\n                chunk_size_unmasked += next_chunk_size\n            else:\n                print(message.notice(\"Clearing next chunk's P bit\"))\n            unsorted_addr = int(arena.bins[0])\n            try:\n                unsorted = read_chunk(unsorted_addr)\n                try:\n                    if read_chunk(unsorted['fd'])['bk'] != unsorted_addr:\n                        err = 'free(): corrupted unsorted chunks -> unsorted_chunk->fd->bk != unsorted_chunk\\n'\n                        err += 'unsorted at 0x{:x}, unsorted->fd == 0x{:x}, unsorted->fd->bk == 0x{:x}'\n                        err = err.format(unsorted_addr, unsorted['fd'], read_chunk(unsorted['fd'])['bk'])\n                        print(message.error(err))\n                        errors_found += 1\n                except (OverflowError, gdb.MemoryError) as e:\n                    print(message.error(f\"Can't read chunk at 0x{unsorted['fd']:x}, it is unsorted bin fd\"))\n                    errors_found += 1\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read unsorted bin chunk at 0x{unsorted_addr:x}\"))\n                errors_found += 1\n        else:\n            print(message.notice('Next chunk is top chunk'))\n            chunk_size += next_chunk_size\n            chunk_size_unmasked += next_chunk_size\n        FASTBIN_CONSOLIDATION_THRESHOLD = 65536\n        if chunk_size_unmasked >= FASTBIN_CONSOLIDATION_THRESHOLD:\n            print(message.notice('Doing malloc_consolidate and systrim/heap_trim'))\n    else:\n        print(message.notice('Doing munmap_chunk'))\n    finalize(errors_found, returned_before_error)",
            "@pwndbg.commands.ArgparsedCommand(try_free_parser, category=CommandCategory.HEAP)\n@pwndbg.commands.OnlyWhenHeapIsInitialized\n@pwndbg.commands.OnlyWhenUserspace\ndef try_free(addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    addr = int(addr)\n    free_hook = pwndbg.gdblib.symbol.address('__free_hook')\n    if free_hook is not None:\n        if pwndbg.gdblib.memory.pvoid(free_hook) != 0:\n            print(message.success('__libc_free: will execute __free_hook'))\n    if addr == 0:\n        print(message.success('__libc_free: addr is 0, nothing to do'))\n        return\n    allocator = pwndbg.heap.current\n    arena = allocator.thread_arena\n    if arena is None:\n        print_no_arena_found_error()\n        return\n    aligned_lsb = allocator.malloc_align_mask.bit_length()\n    size_sz = allocator.size_sz\n    malloc_alignment = allocator.malloc_alignment\n    malloc_align_mask = allocator.malloc_align_mask\n    chunk_minsize = allocator.minsize\n    ptr_size = pwndbg.gdblib.arch.ptrsize\n\n    def unsigned_size(size):\n        if ptr_size < 8:\n            return ctypes.c_uint32(size).value\n        x = ctypes.c_uint64(size).value\n        return x\n\n    def chunksize(chunk_size):\n        return chunk_size & ~7\n\n    def finalize(errors_found, returned_before_error) -> None:\n        print('-' * 10)\n        if returned_before_error:\n            print(message.success('Free should succeed!'))\n        elif errors_found > 0:\n            print(message.error('Errors found!'))\n        else:\n            print(message.success('All checks passed!'))\n    addr -= 2 * size_sz\n    try:\n        chunk = read_chunk(addr)\n    except gdb.MemoryError as e:\n        print(message.error(f\"Can't read chunk at address 0x{addr:x}, memory error\"))\n        return\n    chunk_size = unsigned_size(chunk['size'])\n    chunk_size_unmasked = chunksize(chunk_size)\n    (_, is_mmapped, _) = allocator.chunk_flags(chunk_size)\n    if is_mmapped:\n        print(message.notice('__libc_free: Doing munmap_chunk'))\n        return\n    errors_found = 0\n    returned_before_error = False\n    print(message.notice('General checks'))\n    max_mem = (1 << ptr_size * 8) - 1\n    if addr + chunk_size >= max_mem:\n        err = 'free(): invalid pointer -> &chunk + chunk->size > max memory\\n'\n        err += '    0x{:x} + 0x{:x} > 0x{:x}'\n        err = err.format(addr, chunk_size, max_mem)\n        print(message.error(err))\n        errors_found += 1\n    addr_tmp = addr\n    if malloc_alignment != 2 * size_sz:\n        addr_tmp = addr + 2 * size_sz\n    if addr_tmp & malloc_align_mask != 0:\n        err = 'free(): invalid pointer -> misaligned chunk\\n'\n        err += '    LSB of 0x{:x} are 0b{}, should be 0b{}'\n        if addr_tmp != addr:\n            err += f' (0x{2 * size_sz:x} was added to the address)'\n        err = err.format(addr_tmp, bin(addr_tmp)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked < chunk_minsize:\n        err = \"free(): invalid size -> chunk's size smaller than MINSIZE\\n\"\n        err += '    size is 0x{:x}, MINSIZE is 0x{:x}'\n        err = err.format(chunk_size_unmasked, chunk_minsize)\n        print(message.error(err))\n        errors_found += 1\n    if chunk_size_unmasked & malloc_align_mask != 0:\n        err = \"free(): invalid size -> chunk's size is not aligned\\n\"\n        err += '    LSB of size 0x{:x} are 0b{}, should be 0b{}'\n        err = err.format(chunk_size_unmasked, bin(chunk_size_unmasked)[-aligned_lsb:], '0' * aligned_lsb)\n        print(message.error(err))\n        errors_found += 1\n    if allocator.has_tcache() and 'key' in allocator.tcache_entry.keys():\n        tc_idx = (chunk_size_unmasked - chunk_minsize + malloc_alignment - 1) // malloc_alignment\n        if tc_idx < allocator.mp['tcache_bins']:\n            print(message.notice('Tcache checks'))\n            e = addr + 2 * size_sz\n            e += allocator.tcache_entry.keys().index('key') * ptr_size\n            e = pwndbg.gdblib.memory.pvoid(e)\n            tcache_addr = int(allocator.thread_cache.address)\n            if e == tcache_addr:\n                print(message.error('Will do checks for tcache double-free (memory_tcache_double_free)'))\n                errors_found += 1\n            if int(allocator.get_tcache()['counts'][tc_idx]) < int(allocator.mp['tcache_count']):\n                print(message.success('Using tcache_put'))\n                if errors_found == 0:\n                    returned_before_error = True\n    if errors_found > 0:\n        finalize(errors_found, returned_before_error)\n        return\n    if chunk_size_unmasked <= allocator.global_max_fast:\n        print(message.notice('Fastbin checks'))\n        chunk_fastbin_idx = allocator.fastbin_index(chunk_size_unmasked)\n        fastbin_list = allocator.fastbins(arena.address).bins[(chunk_fastbin_idx + 2) * (ptr_size * 2)].fd_chain\n        try:\n            next_chunk = read_chunk(addr + chunk_size_unmasked)\n        except gdb.MemoryError as e:\n            print(message.error(f\"Can't read next chunk at address 0x{chunk + chunk_size_unmasked:x}, memory error\"))\n            finalize(errors_found, returned_before_error)\n            return\n        next_chunk_size = unsigned_size(next_chunk['size'])\n        if next_chunk_size <= 2 * size_sz or chunksize(next_chunk_size) >= arena.system_mem:\n            err = \"free(): invalid next size (fast) -> next chunk's size not in [2*size_sz; av->system_mem]\\n\"\n            err += \"    next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        if int(fastbin_list[0]) == addr:\n            err = 'double free or corruption (fasttop) -> chunk already is on top of fastbin list\\n'\n            err += '    fastbin idx == {}'\n            err = err.format(chunk_fastbin_idx)\n            print(message.error(err))\n            errors_found += 1\n        fastbin_top_chunk = int(fastbin_list[0])\n        if fastbin_top_chunk != 0:\n            try:\n                fastbin_top_chunk = read_chunk(fastbin_top_chunk)\n            except gdb.MemoryError as e:\n                print(message.error(f\"Can't read top fastbin chunk at address 0x{fastbin_top_chunk:x}, memory error\"))\n                finalize(errors_found, returned_before_error)\n                return\n            fastbin_top_chunk_size = chunksize(unsigned_size(fastbin_top_chunk['size']))\n            if chunk_fastbin_idx != allocator.fastbin_index(fastbin_top_chunk_size):\n                err = \"invalid fastbin entry (free) -> chunk's size is not near top chunk's size\\n\"\n                err += \"    chunk's size == {}, idx == {}\\n\"\n                err += \"    top chunk's size == {}, idx == {}\"\n                err += '    if `have_lock` is false then the error is invalid'\n                err = err.format(chunk['size'], chunk_fastbin_idx, fastbin_top_chunk_size, allocator.fastbin_index(fastbin_top_chunk_size))\n                print(message.error(err))\n                errors_found += 1\n    elif is_mmapped == 0:\n        print(message.notice('Not mapped checks'))\n        if addr == arena.top:\n            err = 'double free or corruption (top) -> chunk is top chunk'\n            print(message.error(err))\n            errors_found += 1\n        NONCONTIGUOUS_BIT = 2\n        top_chunk_addr = arena.top\n        top_chunk = read_chunk(top_chunk_addr)\n        next_chunk_addr = addr + chunk_size_unmasked\n        if arena.flags & NONCONTIGUOUS_BIT == 0 and next_chunk_addr >= top_chunk_addr + chunksize(top_chunk['size']):\n            err = 'double free or corruption (out) -> next chunk is beyond arena and arena is contiguous\\n'\n            err += 'next chunk at 0x{:x}, end of arena at 0x{:x}'\n            err = err.format(next_chunk_addr, top_chunk_addr + chunksize(unsigned_size(top_chunk['size'])))\n            print(message.error(err))\n            errors_found += 1\n        try:\n            next_chunk = read_chunk(next_chunk_addr)\n            next_chunk_size = chunksize(unsigned_size(next_chunk['size']))\n        except (OverflowError, gdb.MemoryError) as e:\n            print(message.error(f\"Can't read next chunk at address 0x{next_chunk_addr:x}\"))\n            finalize(errors_found, returned_before_error)\n            return\n        (prev_inuse, _, _) = allocator.chunk_flags(next_chunk['size'])\n        if prev_inuse == 0:\n            err = \"double free or corruption (!prev) -> next chunk's previous-in-use bit is 0\\n\"\n            print(message.error(err))\n            errors_found += 1\n        if next_chunk_size <= 2 * size_sz or next_chunk_size >= arena.system_mem:\n            err = \"free(): invalid next size (normal) -> next chunk's size not in [2*size_sz; system_mem]\\n\"\n            err += \"next chunk's size is 0x{:x}, 2*size_sz is 0x{:x}, system_mem is 0x{:x}\"\n            err = err.format(next_chunk_size, 2 * size_sz, arena.system_mem)\n            print(message.error(err))\n            errors_found += 1\n        (prev_inuse, _, _) = allocator.chunk_flags(chunk['size'])\n        if prev_inuse == 0:\n            print(message.notice('Backward consolidation'))\n            prev_size = chunksize(unsigned_size(chunk['prev_size']))\n            prev_chunk_addr = addr - prev_size\n            try:\n                prev_chunk = read_chunk(prev_chunk_addr)\n                prev_chunk_size = chunksize(unsigned_size(prev_chunk['size']))\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{prev_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            if prev_chunk_size != prev_size:\n                err = 'corrupted size vs. prev_size while consolidating\\n'\n                err += 'prev_size field is 0x{:x}, prev chunk at 0x{:x}, prev chunk size is 0x{:x}'\n                err = err.format(prev_size, prev_chunk_addr, prev_chunk_size)\n                print(message.error(err))\n                errors_found += 1\n            else:\n                addr = prev_chunk_addr\n                chunk_size += prev_size\n                chunk_size_unmasked += prev_size\n                try_unlink(addr)\n        if next_chunk_addr != top_chunk_addr:\n            print(message.notice('Next chunk is not top chunk'))\n            try:\n                next_next_chunk_addr = next_chunk_addr + next_chunk_size\n                next_next_chunk = read_chunk(next_next_chunk_addr)\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read next chunk at address 0x{next_next_chunk_addr:x}\"))\n                finalize(errors_found, returned_before_error)\n                return\n            (prev_inuse, _, _) = allocator.chunk_flags(next_next_chunk['size'])\n            if prev_inuse == 0:\n                print(message.notice('Forward consolidation'))\n                try_unlink(next_chunk_addr)\n                chunk_size += next_chunk_size\n                chunk_size_unmasked += next_chunk_size\n            else:\n                print(message.notice(\"Clearing next chunk's P bit\"))\n            unsorted_addr = int(arena.bins[0])\n            try:\n                unsorted = read_chunk(unsorted_addr)\n                try:\n                    if read_chunk(unsorted['fd'])['bk'] != unsorted_addr:\n                        err = 'free(): corrupted unsorted chunks -> unsorted_chunk->fd->bk != unsorted_chunk\\n'\n                        err += 'unsorted at 0x{:x}, unsorted->fd == 0x{:x}, unsorted->fd->bk == 0x{:x}'\n                        err = err.format(unsorted_addr, unsorted['fd'], read_chunk(unsorted['fd'])['bk'])\n                        print(message.error(err))\n                        errors_found += 1\n                except (OverflowError, gdb.MemoryError) as e:\n                    print(message.error(f\"Can't read chunk at 0x{unsorted['fd']:x}, it is unsorted bin fd\"))\n                    errors_found += 1\n            except (OverflowError, gdb.MemoryError) as e:\n                print(message.error(f\"Can't read unsorted bin chunk at 0x{unsorted_addr:x}\"))\n                errors_found += 1\n        else:\n            print(message.notice('Next chunk is top chunk'))\n            chunk_size += next_chunk_size\n            chunk_size_unmasked += next_chunk_size\n        FASTBIN_CONSOLIDATION_THRESHOLD = 65536\n        if chunk_size_unmasked >= FASTBIN_CONSOLIDATION_THRESHOLD:\n            print(message.notice('Doing malloc_consolidate and systrim/heap_trim'))\n    else:\n        print(message.notice('Doing munmap_chunk'))\n    finalize(errors_found, returned_before_error)"
        ]
    },
    {
        "func_name": "try_unlink",
        "original": "def try_unlink(addr) -> None:\n    pass",
        "mutated": [
            "def try_unlink(addr) -> None:\n    if False:\n        i = 10\n    pass",
            "def try_unlink(addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "def try_unlink(addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "def try_unlink(addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "def try_unlink(addr) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "heap_config",
        "original": "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\ndef heap_config(filter_pattern) -> None:\n    display_config(filter_pattern, 'heap', has_file_command=False)\n    print(message.hint('Some config values (e.g. main_arena) will be used only when resolve-heap-via-heuristic is `auto` or `force`'))",
        "mutated": [
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\ndef heap_config(filter_pattern) -> None:\n    if False:\n        i = 10\n    display_config(filter_pattern, 'heap', has_file_command=False)\n    print(message.hint('Some config values (e.g. main_arena) will be used only when resolve-heap-via-heuristic is `auto` or `force`'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\ndef heap_config(filter_pattern) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    display_config(filter_pattern, 'heap', has_file_command=False)\n    print(message.hint('Some config values (e.g. main_arena) will be used only when resolve-heap-via-heuristic is `auto` or `force`'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\ndef heap_config(filter_pattern) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    display_config(filter_pattern, 'heap', has_file_command=False)\n    print(message.hint('Some config values (e.g. main_arena) will be used only when resolve-heap-via-heuristic is `auto` or `force`'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\ndef heap_config(filter_pattern) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    display_config(filter_pattern, 'heap', has_file_command=False)\n    print(message.hint('Some config values (e.g. main_arena) will be used only when resolve-heap-via-heuristic is `auto` or `force`'))",
            "@pwndbg.commands.ArgparsedCommand(parser, category=CommandCategory.HEAP)\ndef heap_config(filter_pattern) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    display_config(filter_pattern, 'heap', has_file_command=False)\n    print(message.hint('Some config values (e.g. main_arena) will be used only when resolve-heap-via-heuristic is `auto` or `force`'))"
        ]
    }
]