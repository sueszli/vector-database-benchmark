[
    {
        "func_name": "ratsimp",
        "original": "def ratsimp(expr):\n    \"\"\"\n    Put an expression over a common denominator, cancel and reduce.\n\n    Examples\n    ========\n\n    >>> from sympy import ratsimp\n    >>> from sympy.abc import x, y\n    >>> ratsimp(1/x + 1/y)\n    (x + y)/(x*y)\n    \"\"\"\n    (f, g) = cancel(expr).as_numer_denom()\n    try:\n        (Q, r) = reduced(f, [g], field=True, expand=False)\n    except ComputationFailed:\n        return f / g\n    return Add(*Q) + cancel(r / g)",
        "mutated": [
            "def ratsimp(expr):\n    if False:\n        i = 10\n    '\\n    Put an expression over a common denominator, cancel and reduce.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import ratsimp\\n    >>> from sympy.abc import x, y\\n    >>> ratsimp(1/x + 1/y)\\n    (x + y)/(x*y)\\n    '\n    (f, g) = cancel(expr).as_numer_denom()\n    try:\n        (Q, r) = reduced(f, [g], field=True, expand=False)\n    except ComputationFailed:\n        return f / g\n    return Add(*Q) + cancel(r / g)",
            "def ratsimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Put an expression over a common denominator, cancel and reduce.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import ratsimp\\n    >>> from sympy.abc import x, y\\n    >>> ratsimp(1/x + 1/y)\\n    (x + y)/(x*y)\\n    '\n    (f, g) = cancel(expr).as_numer_denom()\n    try:\n        (Q, r) = reduced(f, [g], field=True, expand=False)\n    except ComputationFailed:\n        return f / g\n    return Add(*Q) + cancel(r / g)",
            "def ratsimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Put an expression over a common denominator, cancel and reduce.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import ratsimp\\n    >>> from sympy.abc import x, y\\n    >>> ratsimp(1/x + 1/y)\\n    (x + y)/(x*y)\\n    '\n    (f, g) = cancel(expr).as_numer_denom()\n    try:\n        (Q, r) = reduced(f, [g], field=True, expand=False)\n    except ComputationFailed:\n        return f / g\n    return Add(*Q) + cancel(r / g)",
            "def ratsimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Put an expression over a common denominator, cancel and reduce.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import ratsimp\\n    >>> from sympy.abc import x, y\\n    >>> ratsimp(1/x + 1/y)\\n    (x + y)/(x*y)\\n    '\n    (f, g) = cancel(expr).as_numer_denom()\n    try:\n        (Q, r) = reduced(f, [g], field=True, expand=False)\n    except ComputationFailed:\n        return f / g\n    return Add(*Q) + cancel(r / g)",
            "def ratsimp(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Put an expression over a common denominator, cancel and reduce.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import ratsimp\\n    >>> from sympy.abc import x, y\\n    >>> ratsimp(1/x + 1/y)\\n    (x + y)/(x*y)\\n    '\n    (f, g) = cancel(expr).as_numer_denom()\n    try:\n        (Q, r) = reduced(f, [g], field=True, expand=False)\n    except ComputationFailed:\n        return f / g\n    return Add(*Q) + cancel(r / g)"
        ]
    },
    {
        "func_name": "staircase",
        "original": "def staircase(n):\n    \"\"\"\n        Compute all monomials with degree less than ``n`` that are\n        not divisible by any element of ``leading_monomials``.\n        \"\"\"\n    if n == 0:\n        return [1]\n    S = []\n    for mi in combinations_with_replacement(range(len(opt.gens)), n):\n        m = [0] * len(opt.gens)\n        for i in mi:\n            m[i] += 1\n        if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n            S.append(m)\n    return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)",
        "mutated": [
            "def staircase(n):\n    if False:\n        i = 10\n    '\\n        Compute all monomials with degree less than ``n`` that are\\n        not divisible by any element of ``leading_monomials``.\\n        '\n    if n == 0:\n        return [1]\n    S = []\n    for mi in combinations_with_replacement(range(len(opt.gens)), n):\n        m = [0] * len(opt.gens)\n        for i in mi:\n            m[i] += 1\n        if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n            S.append(m)\n    return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)",
            "def staircase(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Compute all monomials with degree less than ``n`` that are\\n        not divisible by any element of ``leading_monomials``.\\n        '\n    if n == 0:\n        return [1]\n    S = []\n    for mi in combinations_with_replacement(range(len(opt.gens)), n):\n        m = [0] * len(opt.gens)\n        for i in mi:\n            m[i] += 1\n        if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n            S.append(m)\n    return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)",
            "def staircase(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Compute all monomials with degree less than ``n`` that are\\n        not divisible by any element of ``leading_monomials``.\\n        '\n    if n == 0:\n        return [1]\n    S = []\n    for mi in combinations_with_replacement(range(len(opt.gens)), n):\n        m = [0] * len(opt.gens)\n        for i in mi:\n            m[i] += 1\n        if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n            S.append(m)\n    return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)",
            "def staircase(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Compute all monomials with degree less than ``n`` that are\\n        not divisible by any element of ``leading_monomials``.\\n        '\n    if n == 0:\n        return [1]\n    S = []\n    for mi in combinations_with_replacement(range(len(opt.gens)), n):\n        m = [0] * len(opt.gens)\n        for i in mi:\n            m[i] += 1\n        if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n            S.append(m)\n    return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)",
            "def staircase(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Compute all monomials with degree less than ``n`` that are\\n        not divisible by any element of ``leading_monomials``.\\n        '\n    if n == 0:\n        return [1]\n    S = []\n    for mi in combinations_with_replacement(range(len(opt.gens)), n):\n        m = [0] * len(opt.gens)\n        for i in mi:\n            m[i] += 1\n        if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n            S.append(m)\n    return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)"
        ]
    },
    {
        "func_name": "_ratsimpmodprime",
        "original": "def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n    \"\"\"\n        Computes a rational simplification of ``a/b`` which minimizes\n        the sum of the total degrees of the numerator and the denominator.\n\n        Explanation\n        ===========\n\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\n        less than ``a`` and ``b`` respectively.\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\n        the coefficients of the normalform of ``a * d - b * c`` are\n        linear polynomials in these indeterminates.\n        If these linear polynomials, considered as system of\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\n        by construction, the degree of ``c`` and ``d`` is less than\n        the degree of ``a`` and ``b``, so a simpler representation\n        has been found.\n        After a simpler representation has been found, the algorithm\n        tries to reduce the degree of the numerator and denominator\n        and returns the result afterwards.\n\n        As an extension, if quick=False, we look at all possible degrees such\n        that the total degree is less than *or equal to* the best current\n        solution. We retain a list of all solutions of minimal degree, and try\n        to find the best one at the end.\n        \"\"\"\n    (c, d) = (a, b)\n    steps = 0\n    maxdeg = a.total_degree() + b.total_degree()\n    if quick:\n        bound = maxdeg - 1\n    else:\n        bound = maxdeg\n    while N + D <= bound:\n        if (N, D) in tested:\n            break\n        tested.add((N, D))\n        M1 = staircase(N)\n        M2 = staircase(D)\n        debugf('%s / %s: %s, %s', (N, D, M1, M2))\n        Cs = symbols('c:%d' % len(M1), cls=Dummy)\n        Ds = symbols('d:%d' % len(M2), cls=Dummy)\n        ng = Cs + Ds\n        c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n        d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n        r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n        S = Poly(r, gens=opt.gens).coeffs()\n        sol = solve(S, Cs + Ds, particular=True, quick=True)\n        if sol and (not all((s == 0 for s in sol.values()))):\n            c = c_hat.subs(sol)\n            d = d_hat.subs(sol)\n            c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            c = Poly(c, opt.gens)\n            d = Poly(d, opt.gens)\n            if d == 0:\n                raise ValueError('Ideal not prime?')\n            allsol.append((c_hat, d_hat, S, Cs + Ds))\n            if N + D != maxdeg:\n                allsol = [allsol[-1]]\n            break\n        steps += 1\n        N += 1\n        D += 1\n    if steps > 0:\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n    return (c, d, allsol)",
        "mutated": [
            "def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n    if False:\n        i = 10\n    '\\n        Computes a rational simplification of ``a/b`` which minimizes\\n        the sum of the total degrees of the numerator and the denominator.\\n\\n        Explanation\\n        ===========\\n\\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\\n        less than ``a`` and ``b`` respectively.\\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\\n        the coefficients of the normalform of ``a * d - b * c`` are\\n        linear polynomials in these indeterminates.\\n        If these linear polynomials, considered as system of\\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\\n        by construction, the degree of ``c`` and ``d`` is less than\\n        the degree of ``a`` and ``b``, so a simpler representation\\n        has been found.\\n        After a simpler representation has been found, the algorithm\\n        tries to reduce the degree of the numerator and denominator\\n        and returns the result afterwards.\\n\\n        As an extension, if quick=False, we look at all possible degrees such\\n        that the total degree is less than *or equal to* the best current\\n        solution. We retain a list of all solutions of minimal degree, and try\\n        to find the best one at the end.\\n        '\n    (c, d) = (a, b)\n    steps = 0\n    maxdeg = a.total_degree() + b.total_degree()\n    if quick:\n        bound = maxdeg - 1\n    else:\n        bound = maxdeg\n    while N + D <= bound:\n        if (N, D) in tested:\n            break\n        tested.add((N, D))\n        M1 = staircase(N)\n        M2 = staircase(D)\n        debugf('%s / %s: %s, %s', (N, D, M1, M2))\n        Cs = symbols('c:%d' % len(M1), cls=Dummy)\n        Ds = symbols('d:%d' % len(M2), cls=Dummy)\n        ng = Cs + Ds\n        c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n        d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n        r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n        S = Poly(r, gens=opt.gens).coeffs()\n        sol = solve(S, Cs + Ds, particular=True, quick=True)\n        if sol and (not all((s == 0 for s in sol.values()))):\n            c = c_hat.subs(sol)\n            d = d_hat.subs(sol)\n            c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            c = Poly(c, opt.gens)\n            d = Poly(d, opt.gens)\n            if d == 0:\n                raise ValueError('Ideal not prime?')\n            allsol.append((c_hat, d_hat, S, Cs + Ds))\n            if N + D != maxdeg:\n                allsol = [allsol[-1]]\n            break\n        steps += 1\n        N += 1\n        D += 1\n    if steps > 0:\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n    return (c, d, allsol)",
            "def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Computes a rational simplification of ``a/b`` which minimizes\\n        the sum of the total degrees of the numerator and the denominator.\\n\\n        Explanation\\n        ===========\\n\\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\\n        less than ``a`` and ``b`` respectively.\\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\\n        the coefficients of the normalform of ``a * d - b * c`` are\\n        linear polynomials in these indeterminates.\\n        If these linear polynomials, considered as system of\\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\\n        by construction, the degree of ``c`` and ``d`` is less than\\n        the degree of ``a`` and ``b``, so a simpler representation\\n        has been found.\\n        After a simpler representation has been found, the algorithm\\n        tries to reduce the degree of the numerator and denominator\\n        and returns the result afterwards.\\n\\n        As an extension, if quick=False, we look at all possible degrees such\\n        that the total degree is less than *or equal to* the best current\\n        solution. We retain a list of all solutions of minimal degree, and try\\n        to find the best one at the end.\\n        '\n    (c, d) = (a, b)\n    steps = 0\n    maxdeg = a.total_degree() + b.total_degree()\n    if quick:\n        bound = maxdeg - 1\n    else:\n        bound = maxdeg\n    while N + D <= bound:\n        if (N, D) in tested:\n            break\n        tested.add((N, D))\n        M1 = staircase(N)\n        M2 = staircase(D)\n        debugf('%s / %s: %s, %s', (N, D, M1, M2))\n        Cs = symbols('c:%d' % len(M1), cls=Dummy)\n        Ds = symbols('d:%d' % len(M2), cls=Dummy)\n        ng = Cs + Ds\n        c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n        d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n        r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n        S = Poly(r, gens=opt.gens).coeffs()\n        sol = solve(S, Cs + Ds, particular=True, quick=True)\n        if sol and (not all((s == 0 for s in sol.values()))):\n            c = c_hat.subs(sol)\n            d = d_hat.subs(sol)\n            c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            c = Poly(c, opt.gens)\n            d = Poly(d, opt.gens)\n            if d == 0:\n                raise ValueError('Ideal not prime?')\n            allsol.append((c_hat, d_hat, S, Cs + Ds))\n            if N + D != maxdeg:\n                allsol = [allsol[-1]]\n            break\n        steps += 1\n        N += 1\n        D += 1\n    if steps > 0:\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n    return (c, d, allsol)",
            "def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Computes a rational simplification of ``a/b`` which minimizes\\n        the sum of the total degrees of the numerator and the denominator.\\n\\n        Explanation\\n        ===========\\n\\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\\n        less than ``a`` and ``b`` respectively.\\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\\n        the coefficients of the normalform of ``a * d - b * c`` are\\n        linear polynomials in these indeterminates.\\n        If these linear polynomials, considered as system of\\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\\n        by construction, the degree of ``c`` and ``d`` is less than\\n        the degree of ``a`` and ``b``, so a simpler representation\\n        has been found.\\n        After a simpler representation has been found, the algorithm\\n        tries to reduce the degree of the numerator and denominator\\n        and returns the result afterwards.\\n\\n        As an extension, if quick=False, we look at all possible degrees such\\n        that the total degree is less than *or equal to* the best current\\n        solution. We retain a list of all solutions of minimal degree, and try\\n        to find the best one at the end.\\n        '\n    (c, d) = (a, b)\n    steps = 0\n    maxdeg = a.total_degree() + b.total_degree()\n    if quick:\n        bound = maxdeg - 1\n    else:\n        bound = maxdeg\n    while N + D <= bound:\n        if (N, D) in tested:\n            break\n        tested.add((N, D))\n        M1 = staircase(N)\n        M2 = staircase(D)\n        debugf('%s / %s: %s, %s', (N, D, M1, M2))\n        Cs = symbols('c:%d' % len(M1), cls=Dummy)\n        Ds = symbols('d:%d' % len(M2), cls=Dummy)\n        ng = Cs + Ds\n        c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n        d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n        r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n        S = Poly(r, gens=opt.gens).coeffs()\n        sol = solve(S, Cs + Ds, particular=True, quick=True)\n        if sol and (not all((s == 0 for s in sol.values()))):\n            c = c_hat.subs(sol)\n            d = d_hat.subs(sol)\n            c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            c = Poly(c, opt.gens)\n            d = Poly(d, opt.gens)\n            if d == 0:\n                raise ValueError('Ideal not prime?')\n            allsol.append((c_hat, d_hat, S, Cs + Ds))\n            if N + D != maxdeg:\n                allsol = [allsol[-1]]\n            break\n        steps += 1\n        N += 1\n        D += 1\n    if steps > 0:\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n    return (c, d, allsol)",
            "def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Computes a rational simplification of ``a/b`` which minimizes\\n        the sum of the total degrees of the numerator and the denominator.\\n\\n        Explanation\\n        ===========\\n\\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\\n        less than ``a`` and ``b`` respectively.\\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\\n        the coefficients of the normalform of ``a * d - b * c`` are\\n        linear polynomials in these indeterminates.\\n        If these linear polynomials, considered as system of\\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\\n        by construction, the degree of ``c`` and ``d`` is less than\\n        the degree of ``a`` and ``b``, so a simpler representation\\n        has been found.\\n        After a simpler representation has been found, the algorithm\\n        tries to reduce the degree of the numerator and denominator\\n        and returns the result afterwards.\\n\\n        As an extension, if quick=False, we look at all possible degrees such\\n        that the total degree is less than *or equal to* the best current\\n        solution. We retain a list of all solutions of minimal degree, and try\\n        to find the best one at the end.\\n        '\n    (c, d) = (a, b)\n    steps = 0\n    maxdeg = a.total_degree() + b.total_degree()\n    if quick:\n        bound = maxdeg - 1\n    else:\n        bound = maxdeg\n    while N + D <= bound:\n        if (N, D) in tested:\n            break\n        tested.add((N, D))\n        M1 = staircase(N)\n        M2 = staircase(D)\n        debugf('%s / %s: %s, %s', (N, D, M1, M2))\n        Cs = symbols('c:%d' % len(M1), cls=Dummy)\n        Ds = symbols('d:%d' % len(M2), cls=Dummy)\n        ng = Cs + Ds\n        c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n        d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n        r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n        S = Poly(r, gens=opt.gens).coeffs()\n        sol = solve(S, Cs + Ds, particular=True, quick=True)\n        if sol and (not all((s == 0 for s in sol.values()))):\n            c = c_hat.subs(sol)\n            d = d_hat.subs(sol)\n            c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            c = Poly(c, opt.gens)\n            d = Poly(d, opt.gens)\n            if d == 0:\n                raise ValueError('Ideal not prime?')\n            allsol.append((c_hat, d_hat, S, Cs + Ds))\n            if N + D != maxdeg:\n                allsol = [allsol[-1]]\n            break\n        steps += 1\n        N += 1\n        D += 1\n    if steps > 0:\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n    return (c, d, allsol)",
            "def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Computes a rational simplification of ``a/b`` which minimizes\\n        the sum of the total degrees of the numerator and the denominator.\\n\\n        Explanation\\n        ===========\\n\\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\\n        less than ``a`` and ``b`` respectively.\\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\\n        the coefficients of the normalform of ``a * d - b * c`` are\\n        linear polynomials in these indeterminates.\\n        If these linear polynomials, considered as system of\\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\\n        by construction, the degree of ``c`` and ``d`` is less than\\n        the degree of ``a`` and ``b``, so a simpler representation\\n        has been found.\\n        After a simpler representation has been found, the algorithm\\n        tries to reduce the degree of the numerator and denominator\\n        and returns the result afterwards.\\n\\n        As an extension, if quick=False, we look at all possible degrees such\\n        that the total degree is less than *or equal to* the best current\\n        solution. We retain a list of all solutions of minimal degree, and try\\n        to find the best one at the end.\\n        '\n    (c, d) = (a, b)\n    steps = 0\n    maxdeg = a.total_degree() + b.total_degree()\n    if quick:\n        bound = maxdeg - 1\n    else:\n        bound = maxdeg\n    while N + D <= bound:\n        if (N, D) in tested:\n            break\n        tested.add((N, D))\n        M1 = staircase(N)\n        M2 = staircase(D)\n        debugf('%s / %s: %s, %s', (N, D, M1, M2))\n        Cs = symbols('c:%d' % len(M1), cls=Dummy)\n        Ds = symbols('d:%d' % len(M2), cls=Dummy)\n        ng = Cs + Ds\n        c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n        d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n        r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n        S = Poly(r, gens=opt.gens).coeffs()\n        sol = solve(S, Cs + Ds, particular=True, quick=True)\n        if sol and (not all((s == 0 for s in sol.values()))):\n            c = c_hat.subs(sol)\n            d = d_hat.subs(sol)\n            c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n            c = Poly(c, opt.gens)\n            d = Poly(d, opt.gens)\n            if d == 0:\n                raise ValueError('Ideal not prime?')\n            allsol.append((c_hat, d_hat, S, Cs + Ds))\n            if N + D != maxdeg:\n                allsol = [allsol[-1]]\n            break\n        steps += 1\n        N += 1\n        D += 1\n    if steps > 0:\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n        (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n    return (c, d, allsol)"
        ]
    },
    {
        "func_name": "ratsimpmodprime",
        "original": "def ratsimpmodprime(expr, G, *gens, quick=True, polynomial=False, **args):\n    \"\"\"\n    Simplifies a rational expression ``expr`` modulo the prime ideal\n    generated by ``G``.  ``G`` should be a Groebner basis of the\n    ideal.\n\n    Examples\n    ========\n\n    >>> from sympy.simplify.ratsimp import ratsimpmodprime\n    >>> from sympy.abc import x, y\n    >>> eq = (x + y**5 + y)/(x - y)\n    >>> ratsimpmodprime(eq, [x*y**5 - x - y], x, y, order='lex')\n    (-x**2 - x*y - x - y)/(-x**2 + x*y)\n\n    If ``polynomial`` is ``False``, the algorithm computes a rational\n    simplification which minimizes the sum of the total degrees of\n    the numerator and the denominator.\n\n    If ``polynomial`` is ``True``, this function just brings numerator and\n    denominator into a canonical form. This is much faster, but has\n    potentially worse results.\n\n    References\n    ==========\n\n    .. [1] M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial\n        Ideal, https://dl.acm.org/doi/pdf/10.1145/1145768.1145809\n        (specifically, the second algorithm)\n    \"\"\"\n    from sympy.solvers.solvers import solve\n    debug('ratsimpmodprime', expr)\n    (num, denom) = cancel(expr).as_numer_denom()\n    try:\n        (polys, opt) = parallel_poly_from_expr([num, denom] + G, *gens, **args)\n    except PolificationFailed:\n        return expr\n    domain = opt.domain\n    if domain.has_assoc_Field:\n        opt.domain = domain.get_field()\n    else:\n        raise DomainError('Cannot compute rational simplification over %s' % domain)\n    leading_monomials = [g.LM(opt.order) for g in polys[2:]]\n    tested = set()\n\n    def staircase(n):\n        \"\"\"\n        Compute all monomials with degree less than ``n`` that are\n        not divisible by any element of ``leading_monomials``.\n        \"\"\"\n        if n == 0:\n            return [1]\n        S = []\n        for mi in combinations_with_replacement(range(len(opt.gens)), n):\n            m = [0] * len(opt.gens)\n            for i in mi:\n                m[i] += 1\n            if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n                S.append(m)\n        return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)\n\n    def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n        \"\"\"\n        Computes a rational simplification of ``a/b`` which minimizes\n        the sum of the total degrees of the numerator and the denominator.\n\n        Explanation\n        ===========\n\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\n        less than ``a`` and ``b`` respectively.\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\n        the coefficients of the normalform of ``a * d - b * c`` are\n        linear polynomials in these indeterminates.\n        If these linear polynomials, considered as system of\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\n        by construction, the degree of ``c`` and ``d`` is less than\n        the degree of ``a`` and ``b``, so a simpler representation\n        has been found.\n        After a simpler representation has been found, the algorithm\n        tries to reduce the degree of the numerator and denominator\n        and returns the result afterwards.\n\n        As an extension, if quick=False, we look at all possible degrees such\n        that the total degree is less than *or equal to* the best current\n        solution. We retain a list of all solutions of minimal degree, and try\n        to find the best one at the end.\n        \"\"\"\n        (c, d) = (a, b)\n        steps = 0\n        maxdeg = a.total_degree() + b.total_degree()\n        if quick:\n            bound = maxdeg - 1\n        else:\n            bound = maxdeg\n        while N + D <= bound:\n            if (N, D) in tested:\n                break\n            tested.add((N, D))\n            M1 = staircase(N)\n            M2 = staircase(D)\n            debugf('%s / %s: %s, %s', (N, D, M1, M2))\n            Cs = symbols('c:%d' % len(M1), cls=Dummy)\n            Ds = symbols('d:%d' % len(M2), cls=Dummy)\n            ng = Cs + Ds\n            c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n            d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n            r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n            S = Poly(r, gens=opt.gens).coeffs()\n            sol = solve(S, Cs + Ds, particular=True, quick=True)\n            if sol and (not all((s == 0 for s in sol.values()))):\n                c = c_hat.subs(sol)\n                d = d_hat.subs(sol)\n                c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                c = Poly(c, opt.gens)\n                d = Poly(d, opt.gens)\n                if d == 0:\n                    raise ValueError('Ideal not prime?')\n                allsol.append((c_hat, d_hat, S, Cs + Ds))\n                if N + D != maxdeg:\n                    allsol = [allsol[-1]]\n                break\n            steps += 1\n            N += 1\n            D += 1\n        if steps > 0:\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n        return (c, d, allsol)\n    num = reduced(num, G, opt.gens, order=opt.order)[1]\n    denom = reduced(denom, G, opt.gens, order=opt.order)[1]\n    if polynomial:\n        return (num / denom).cancel()\n    (c, d, allsol) = _ratsimpmodprime(Poly(num, opt.gens, domain=opt.domain), Poly(denom, opt.gens, domain=opt.domain), [])\n    if not quick and allsol:\n        debugf('Looking for best minimal solution. Got: %s', len(allsol))\n        newsol = []\n        for (c_hat, d_hat, S, ng) in allsol:\n            sol = solve(S, ng, particular=True, quick=False)\n            newsol.append((c_hat.subs(sol), d_hat.subs(sol)))\n        (c, d) = min(newsol, key=lambda x: len(x[0].terms()) + len(x[1].terms()))\n    if not domain.is_Field:\n        (cn, c) = c.clear_denoms(convert=True)\n        (dn, d) = d.clear_denoms(convert=True)\n        r = Rational(cn, dn)\n    else:\n        r = Rational(1)\n    return c * r.q / (d * r.p)",
        "mutated": [
            "def ratsimpmodprime(expr, G, *gens, quick=True, polynomial=False, **args):\n    if False:\n        i = 10\n    \"\\n    Simplifies a rational expression ``expr`` modulo the prime ideal\\n    generated by ``G``.  ``G`` should be a Groebner basis of the\\n    ideal.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify.ratsimp import ratsimpmodprime\\n    >>> from sympy.abc import x, y\\n    >>> eq = (x + y**5 + y)/(x - y)\\n    >>> ratsimpmodprime(eq, [x*y**5 - x - y], x, y, order='lex')\\n    (-x**2 - x*y - x - y)/(-x**2 + x*y)\\n\\n    If ``polynomial`` is ``False``, the algorithm computes a rational\\n    simplification which minimizes the sum of the total degrees of\\n    the numerator and the denominator.\\n\\n    If ``polynomial`` is ``True``, this function just brings numerator and\\n    denominator into a canonical form. This is much faster, but has\\n    potentially worse results.\\n\\n    References\\n    ==========\\n\\n    .. [1] M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial\\n        Ideal, https://dl.acm.org/doi/pdf/10.1145/1145768.1145809\\n        (specifically, the second algorithm)\\n    \"\n    from sympy.solvers.solvers import solve\n    debug('ratsimpmodprime', expr)\n    (num, denom) = cancel(expr).as_numer_denom()\n    try:\n        (polys, opt) = parallel_poly_from_expr([num, denom] + G, *gens, **args)\n    except PolificationFailed:\n        return expr\n    domain = opt.domain\n    if domain.has_assoc_Field:\n        opt.domain = domain.get_field()\n    else:\n        raise DomainError('Cannot compute rational simplification over %s' % domain)\n    leading_monomials = [g.LM(opt.order) for g in polys[2:]]\n    tested = set()\n\n    def staircase(n):\n        \"\"\"\n        Compute all monomials with degree less than ``n`` that are\n        not divisible by any element of ``leading_monomials``.\n        \"\"\"\n        if n == 0:\n            return [1]\n        S = []\n        for mi in combinations_with_replacement(range(len(opt.gens)), n):\n            m = [0] * len(opt.gens)\n            for i in mi:\n                m[i] += 1\n            if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n                S.append(m)\n        return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)\n\n    def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n        \"\"\"\n        Computes a rational simplification of ``a/b`` which minimizes\n        the sum of the total degrees of the numerator and the denominator.\n\n        Explanation\n        ===========\n\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\n        less than ``a`` and ``b`` respectively.\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\n        the coefficients of the normalform of ``a * d - b * c`` are\n        linear polynomials in these indeterminates.\n        If these linear polynomials, considered as system of\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\n        by construction, the degree of ``c`` and ``d`` is less than\n        the degree of ``a`` and ``b``, so a simpler representation\n        has been found.\n        After a simpler representation has been found, the algorithm\n        tries to reduce the degree of the numerator and denominator\n        and returns the result afterwards.\n\n        As an extension, if quick=False, we look at all possible degrees such\n        that the total degree is less than *or equal to* the best current\n        solution. We retain a list of all solutions of minimal degree, and try\n        to find the best one at the end.\n        \"\"\"\n        (c, d) = (a, b)\n        steps = 0\n        maxdeg = a.total_degree() + b.total_degree()\n        if quick:\n            bound = maxdeg - 1\n        else:\n            bound = maxdeg\n        while N + D <= bound:\n            if (N, D) in tested:\n                break\n            tested.add((N, D))\n            M1 = staircase(N)\n            M2 = staircase(D)\n            debugf('%s / %s: %s, %s', (N, D, M1, M2))\n            Cs = symbols('c:%d' % len(M1), cls=Dummy)\n            Ds = symbols('d:%d' % len(M2), cls=Dummy)\n            ng = Cs + Ds\n            c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n            d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n            r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n            S = Poly(r, gens=opt.gens).coeffs()\n            sol = solve(S, Cs + Ds, particular=True, quick=True)\n            if sol and (not all((s == 0 for s in sol.values()))):\n                c = c_hat.subs(sol)\n                d = d_hat.subs(sol)\n                c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                c = Poly(c, opt.gens)\n                d = Poly(d, opt.gens)\n                if d == 0:\n                    raise ValueError('Ideal not prime?')\n                allsol.append((c_hat, d_hat, S, Cs + Ds))\n                if N + D != maxdeg:\n                    allsol = [allsol[-1]]\n                break\n            steps += 1\n            N += 1\n            D += 1\n        if steps > 0:\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n        return (c, d, allsol)\n    num = reduced(num, G, opt.gens, order=opt.order)[1]\n    denom = reduced(denom, G, opt.gens, order=opt.order)[1]\n    if polynomial:\n        return (num / denom).cancel()\n    (c, d, allsol) = _ratsimpmodprime(Poly(num, opt.gens, domain=opt.domain), Poly(denom, opt.gens, domain=opt.domain), [])\n    if not quick and allsol:\n        debugf('Looking for best minimal solution. Got: %s', len(allsol))\n        newsol = []\n        for (c_hat, d_hat, S, ng) in allsol:\n            sol = solve(S, ng, particular=True, quick=False)\n            newsol.append((c_hat.subs(sol), d_hat.subs(sol)))\n        (c, d) = min(newsol, key=lambda x: len(x[0].terms()) + len(x[1].terms()))\n    if not domain.is_Field:\n        (cn, c) = c.clear_denoms(convert=True)\n        (dn, d) = d.clear_denoms(convert=True)\n        r = Rational(cn, dn)\n    else:\n        r = Rational(1)\n    return c * r.q / (d * r.p)",
            "def ratsimpmodprime(expr, G, *gens, quick=True, polynomial=False, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Simplifies a rational expression ``expr`` modulo the prime ideal\\n    generated by ``G``.  ``G`` should be a Groebner basis of the\\n    ideal.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify.ratsimp import ratsimpmodprime\\n    >>> from sympy.abc import x, y\\n    >>> eq = (x + y**5 + y)/(x - y)\\n    >>> ratsimpmodprime(eq, [x*y**5 - x - y], x, y, order='lex')\\n    (-x**2 - x*y - x - y)/(-x**2 + x*y)\\n\\n    If ``polynomial`` is ``False``, the algorithm computes a rational\\n    simplification which minimizes the sum of the total degrees of\\n    the numerator and the denominator.\\n\\n    If ``polynomial`` is ``True``, this function just brings numerator and\\n    denominator into a canonical form. This is much faster, but has\\n    potentially worse results.\\n\\n    References\\n    ==========\\n\\n    .. [1] M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial\\n        Ideal, https://dl.acm.org/doi/pdf/10.1145/1145768.1145809\\n        (specifically, the second algorithm)\\n    \"\n    from sympy.solvers.solvers import solve\n    debug('ratsimpmodprime', expr)\n    (num, denom) = cancel(expr).as_numer_denom()\n    try:\n        (polys, opt) = parallel_poly_from_expr([num, denom] + G, *gens, **args)\n    except PolificationFailed:\n        return expr\n    domain = opt.domain\n    if domain.has_assoc_Field:\n        opt.domain = domain.get_field()\n    else:\n        raise DomainError('Cannot compute rational simplification over %s' % domain)\n    leading_monomials = [g.LM(opt.order) for g in polys[2:]]\n    tested = set()\n\n    def staircase(n):\n        \"\"\"\n        Compute all monomials with degree less than ``n`` that are\n        not divisible by any element of ``leading_monomials``.\n        \"\"\"\n        if n == 0:\n            return [1]\n        S = []\n        for mi in combinations_with_replacement(range(len(opt.gens)), n):\n            m = [0] * len(opt.gens)\n            for i in mi:\n                m[i] += 1\n            if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n                S.append(m)\n        return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)\n\n    def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n        \"\"\"\n        Computes a rational simplification of ``a/b`` which minimizes\n        the sum of the total degrees of the numerator and the denominator.\n\n        Explanation\n        ===========\n\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\n        less than ``a`` and ``b`` respectively.\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\n        the coefficients of the normalform of ``a * d - b * c`` are\n        linear polynomials in these indeterminates.\n        If these linear polynomials, considered as system of\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\n        by construction, the degree of ``c`` and ``d`` is less than\n        the degree of ``a`` and ``b``, so a simpler representation\n        has been found.\n        After a simpler representation has been found, the algorithm\n        tries to reduce the degree of the numerator and denominator\n        and returns the result afterwards.\n\n        As an extension, if quick=False, we look at all possible degrees such\n        that the total degree is less than *or equal to* the best current\n        solution. We retain a list of all solutions of minimal degree, and try\n        to find the best one at the end.\n        \"\"\"\n        (c, d) = (a, b)\n        steps = 0\n        maxdeg = a.total_degree() + b.total_degree()\n        if quick:\n            bound = maxdeg - 1\n        else:\n            bound = maxdeg\n        while N + D <= bound:\n            if (N, D) in tested:\n                break\n            tested.add((N, D))\n            M1 = staircase(N)\n            M2 = staircase(D)\n            debugf('%s / %s: %s, %s', (N, D, M1, M2))\n            Cs = symbols('c:%d' % len(M1), cls=Dummy)\n            Ds = symbols('d:%d' % len(M2), cls=Dummy)\n            ng = Cs + Ds\n            c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n            d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n            r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n            S = Poly(r, gens=opt.gens).coeffs()\n            sol = solve(S, Cs + Ds, particular=True, quick=True)\n            if sol and (not all((s == 0 for s in sol.values()))):\n                c = c_hat.subs(sol)\n                d = d_hat.subs(sol)\n                c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                c = Poly(c, opt.gens)\n                d = Poly(d, opt.gens)\n                if d == 0:\n                    raise ValueError('Ideal not prime?')\n                allsol.append((c_hat, d_hat, S, Cs + Ds))\n                if N + D != maxdeg:\n                    allsol = [allsol[-1]]\n                break\n            steps += 1\n            N += 1\n            D += 1\n        if steps > 0:\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n        return (c, d, allsol)\n    num = reduced(num, G, opt.gens, order=opt.order)[1]\n    denom = reduced(denom, G, opt.gens, order=opt.order)[1]\n    if polynomial:\n        return (num / denom).cancel()\n    (c, d, allsol) = _ratsimpmodprime(Poly(num, opt.gens, domain=opt.domain), Poly(denom, opt.gens, domain=opt.domain), [])\n    if not quick and allsol:\n        debugf('Looking for best minimal solution. Got: %s', len(allsol))\n        newsol = []\n        for (c_hat, d_hat, S, ng) in allsol:\n            sol = solve(S, ng, particular=True, quick=False)\n            newsol.append((c_hat.subs(sol), d_hat.subs(sol)))\n        (c, d) = min(newsol, key=lambda x: len(x[0].terms()) + len(x[1].terms()))\n    if not domain.is_Field:\n        (cn, c) = c.clear_denoms(convert=True)\n        (dn, d) = d.clear_denoms(convert=True)\n        r = Rational(cn, dn)\n    else:\n        r = Rational(1)\n    return c * r.q / (d * r.p)",
            "def ratsimpmodprime(expr, G, *gens, quick=True, polynomial=False, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Simplifies a rational expression ``expr`` modulo the prime ideal\\n    generated by ``G``.  ``G`` should be a Groebner basis of the\\n    ideal.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify.ratsimp import ratsimpmodprime\\n    >>> from sympy.abc import x, y\\n    >>> eq = (x + y**5 + y)/(x - y)\\n    >>> ratsimpmodprime(eq, [x*y**5 - x - y], x, y, order='lex')\\n    (-x**2 - x*y - x - y)/(-x**2 + x*y)\\n\\n    If ``polynomial`` is ``False``, the algorithm computes a rational\\n    simplification which minimizes the sum of the total degrees of\\n    the numerator and the denominator.\\n\\n    If ``polynomial`` is ``True``, this function just brings numerator and\\n    denominator into a canonical form. This is much faster, but has\\n    potentially worse results.\\n\\n    References\\n    ==========\\n\\n    .. [1] M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial\\n        Ideal, https://dl.acm.org/doi/pdf/10.1145/1145768.1145809\\n        (specifically, the second algorithm)\\n    \"\n    from sympy.solvers.solvers import solve\n    debug('ratsimpmodprime', expr)\n    (num, denom) = cancel(expr).as_numer_denom()\n    try:\n        (polys, opt) = parallel_poly_from_expr([num, denom] + G, *gens, **args)\n    except PolificationFailed:\n        return expr\n    domain = opt.domain\n    if domain.has_assoc_Field:\n        opt.domain = domain.get_field()\n    else:\n        raise DomainError('Cannot compute rational simplification over %s' % domain)\n    leading_monomials = [g.LM(opt.order) for g in polys[2:]]\n    tested = set()\n\n    def staircase(n):\n        \"\"\"\n        Compute all monomials with degree less than ``n`` that are\n        not divisible by any element of ``leading_monomials``.\n        \"\"\"\n        if n == 0:\n            return [1]\n        S = []\n        for mi in combinations_with_replacement(range(len(opt.gens)), n):\n            m = [0] * len(opt.gens)\n            for i in mi:\n                m[i] += 1\n            if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n                S.append(m)\n        return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)\n\n    def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n        \"\"\"\n        Computes a rational simplification of ``a/b`` which minimizes\n        the sum of the total degrees of the numerator and the denominator.\n\n        Explanation\n        ===========\n\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\n        less than ``a`` and ``b`` respectively.\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\n        the coefficients of the normalform of ``a * d - b * c`` are\n        linear polynomials in these indeterminates.\n        If these linear polynomials, considered as system of\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\n        by construction, the degree of ``c`` and ``d`` is less than\n        the degree of ``a`` and ``b``, so a simpler representation\n        has been found.\n        After a simpler representation has been found, the algorithm\n        tries to reduce the degree of the numerator and denominator\n        and returns the result afterwards.\n\n        As an extension, if quick=False, we look at all possible degrees such\n        that the total degree is less than *or equal to* the best current\n        solution. We retain a list of all solutions of minimal degree, and try\n        to find the best one at the end.\n        \"\"\"\n        (c, d) = (a, b)\n        steps = 0\n        maxdeg = a.total_degree() + b.total_degree()\n        if quick:\n            bound = maxdeg - 1\n        else:\n            bound = maxdeg\n        while N + D <= bound:\n            if (N, D) in tested:\n                break\n            tested.add((N, D))\n            M1 = staircase(N)\n            M2 = staircase(D)\n            debugf('%s / %s: %s, %s', (N, D, M1, M2))\n            Cs = symbols('c:%d' % len(M1), cls=Dummy)\n            Ds = symbols('d:%d' % len(M2), cls=Dummy)\n            ng = Cs + Ds\n            c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n            d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n            r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n            S = Poly(r, gens=opt.gens).coeffs()\n            sol = solve(S, Cs + Ds, particular=True, quick=True)\n            if sol and (not all((s == 0 for s in sol.values()))):\n                c = c_hat.subs(sol)\n                d = d_hat.subs(sol)\n                c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                c = Poly(c, opt.gens)\n                d = Poly(d, opt.gens)\n                if d == 0:\n                    raise ValueError('Ideal not prime?')\n                allsol.append((c_hat, d_hat, S, Cs + Ds))\n                if N + D != maxdeg:\n                    allsol = [allsol[-1]]\n                break\n            steps += 1\n            N += 1\n            D += 1\n        if steps > 0:\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n        return (c, d, allsol)\n    num = reduced(num, G, opt.gens, order=opt.order)[1]\n    denom = reduced(denom, G, opt.gens, order=opt.order)[1]\n    if polynomial:\n        return (num / denom).cancel()\n    (c, d, allsol) = _ratsimpmodprime(Poly(num, opt.gens, domain=opt.domain), Poly(denom, opt.gens, domain=opt.domain), [])\n    if not quick and allsol:\n        debugf('Looking for best minimal solution. Got: %s', len(allsol))\n        newsol = []\n        for (c_hat, d_hat, S, ng) in allsol:\n            sol = solve(S, ng, particular=True, quick=False)\n            newsol.append((c_hat.subs(sol), d_hat.subs(sol)))\n        (c, d) = min(newsol, key=lambda x: len(x[0].terms()) + len(x[1].terms()))\n    if not domain.is_Field:\n        (cn, c) = c.clear_denoms(convert=True)\n        (dn, d) = d.clear_denoms(convert=True)\n        r = Rational(cn, dn)\n    else:\n        r = Rational(1)\n    return c * r.q / (d * r.p)",
            "def ratsimpmodprime(expr, G, *gens, quick=True, polynomial=False, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Simplifies a rational expression ``expr`` modulo the prime ideal\\n    generated by ``G``.  ``G`` should be a Groebner basis of the\\n    ideal.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify.ratsimp import ratsimpmodprime\\n    >>> from sympy.abc import x, y\\n    >>> eq = (x + y**5 + y)/(x - y)\\n    >>> ratsimpmodprime(eq, [x*y**5 - x - y], x, y, order='lex')\\n    (-x**2 - x*y - x - y)/(-x**2 + x*y)\\n\\n    If ``polynomial`` is ``False``, the algorithm computes a rational\\n    simplification which minimizes the sum of the total degrees of\\n    the numerator and the denominator.\\n\\n    If ``polynomial`` is ``True``, this function just brings numerator and\\n    denominator into a canonical form. This is much faster, but has\\n    potentially worse results.\\n\\n    References\\n    ==========\\n\\n    .. [1] M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial\\n        Ideal, https://dl.acm.org/doi/pdf/10.1145/1145768.1145809\\n        (specifically, the second algorithm)\\n    \"\n    from sympy.solvers.solvers import solve\n    debug('ratsimpmodprime', expr)\n    (num, denom) = cancel(expr).as_numer_denom()\n    try:\n        (polys, opt) = parallel_poly_from_expr([num, denom] + G, *gens, **args)\n    except PolificationFailed:\n        return expr\n    domain = opt.domain\n    if domain.has_assoc_Field:\n        opt.domain = domain.get_field()\n    else:\n        raise DomainError('Cannot compute rational simplification over %s' % domain)\n    leading_monomials = [g.LM(opt.order) for g in polys[2:]]\n    tested = set()\n\n    def staircase(n):\n        \"\"\"\n        Compute all monomials with degree less than ``n`` that are\n        not divisible by any element of ``leading_monomials``.\n        \"\"\"\n        if n == 0:\n            return [1]\n        S = []\n        for mi in combinations_with_replacement(range(len(opt.gens)), n):\n            m = [0] * len(opt.gens)\n            for i in mi:\n                m[i] += 1\n            if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n                S.append(m)\n        return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)\n\n    def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n        \"\"\"\n        Computes a rational simplification of ``a/b`` which minimizes\n        the sum of the total degrees of the numerator and the denominator.\n\n        Explanation\n        ===========\n\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\n        less than ``a`` and ``b`` respectively.\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\n        the coefficients of the normalform of ``a * d - b * c`` are\n        linear polynomials in these indeterminates.\n        If these linear polynomials, considered as system of\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\n        by construction, the degree of ``c`` and ``d`` is less than\n        the degree of ``a`` and ``b``, so a simpler representation\n        has been found.\n        After a simpler representation has been found, the algorithm\n        tries to reduce the degree of the numerator and denominator\n        and returns the result afterwards.\n\n        As an extension, if quick=False, we look at all possible degrees such\n        that the total degree is less than *or equal to* the best current\n        solution. We retain a list of all solutions of minimal degree, and try\n        to find the best one at the end.\n        \"\"\"\n        (c, d) = (a, b)\n        steps = 0\n        maxdeg = a.total_degree() + b.total_degree()\n        if quick:\n            bound = maxdeg - 1\n        else:\n            bound = maxdeg\n        while N + D <= bound:\n            if (N, D) in tested:\n                break\n            tested.add((N, D))\n            M1 = staircase(N)\n            M2 = staircase(D)\n            debugf('%s / %s: %s, %s', (N, D, M1, M2))\n            Cs = symbols('c:%d' % len(M1), cls=Dummy)\n            Ds = symbols('d:%d' % len(M2), cls=Dummy)\n            ng = Cs + Ds\n            c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n            d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n            r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n            S = Poly(r, gens=opt.gens).coeffs()\n            sol = solve(S, Cs + Ds, particular=True, quick=True)\n            if sol and (not all((s == 0 for s in sol.values()))):\n                c = c_hat.subs(sol)\n                d = d_hat.subs(sol)\n                c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                c = Poly(c, opt.gens)\n                d = Poly(d, opt.gens)\n                if d == 0:\n                    raise ValueError('Ideal not prime?')\n                allsol.append((c_hat, d_hat, S, Cs + Ds))\n                if N + D != maxdeg:\n                    allsol = [allsol[-1]]\n                break\n            steps += 1\n            N += 1\n            D += 1\n        if steps > 0:\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n        return (c, d, allsol)\n    num = reduced(num, G, opt.gens, order=opt.order)[1]\n    denom = reduced(denom, G, opt.gens, order=opt.order)[1]\n    if polynomial:\n        return (num / denom).cancel()\n    (c, d, allsol) = _ratsimpmodprime(Poly(num, opt.gens, domain=opt.domain), Poly(denom, opt.gens, domain=opt.domain), [])\n    if not quick and allsol:\n        debugf('Looking for best minimal solution. Got: %s', len(allsol))\n        newsol = []\n        for (c_hat, d_hat, S, ng) in allsol:\n            sol = solve(S, ng, particular=True, quick=False)\n            newsol.append((c_hat.subs(sol), d_hat.subs(sol)))\n        (c, d) = min(newsol, key=lambda x: len(x[0].terms()) + len(x[1].terms()))\n    if not domain.is_Field:\n        (cn, c) = c.clear_denoms(convert=True)\n        (dn, d) = d.clear_denoms(convert=True)\n        r = Rational(cn, dn)\n    else:\n        r = Rational(1)\n    return c * r.q / (d * r.p)",
            "def ratsimpmodprime(expr, G, *gens, quick=True, polynomial=False, **args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Simplifies a rational expression ``expr`` modulo the prime ideal\\n    generated by ``G``.  ``G`` should be a Groebner basis of the\\n    ideal.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.simplify.ratsimp import ratsimpmodprime\\n    >>> from sympy.abc import x, y\\n    >>> eq = (x + y**5 + y)/(x - y)\\n    >>> ratsimpmodprime(eq, [x*y**5 - x - y], x, y, order='lex')\\n    (-x**2 - x*y - x - y)/(-x**2 + x*y)\\n\\n    If ``polynomial`` is ``False``, the algorithm computes a rational\\n    simplification which minimizes the sum of the total degrees of\\n    the numerator and the denominator.\\n\\n    If ``polynomial`` is ``True``, this function just brings numerator and\\n    denominator into a canonical form. This is much faster, but has\\n    potentially worse results.\\n\\n    References\\n    ==========\\n\\n    .. [1] M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial\\n        Ideal, https://dl.acm.org/doi/pdf/10.1145/1145768.1145809\\n        (specifically, the second algorithm)\\n    \"\n    from sympy.solvers.solvers import solve\n    debug('ratsimpmodprime', expr)\n    (num, denom) = cancel(expr).as_numer_denom()\n    try:\n        (polys, opt) = parallel_poly_from_expr([num, denom] + G, *gens, **args)\n    except PolificationFailed:\n        return expr\n    domain = opt.domain\n    if domain.has_assoc_Field:\n        opt.domain = domain.get_field()\n    else:\n        raise DomainError('Cannot compute rational simplification over %s' % domain)\n    leading_monomials = [g.LM(opt.order) for g in polys[2:]]\n    tested = set()\n\n    def staircase(n):\n        \"\"\"\n        Compute all monomials with degree less than ``n`` that are\n        not divisible by any element of ``leading_monomials``.\n        \"\"\"\n        if n == 0:\n            return [1]\n        S = []\n        for mi in combinations_with_replacement(range(len(opt.gens)), n):\n            m = [0] * len(opt.gens)\n            for i in mi:\n                m[i] += 1\n            if all((monomial_div(m, lmg) is None for lmg in leading_monomials)):\n                S.append(m)\n        return [Monomial(s).as_expr(*opt.gens) for s in S] + staircase(n - 1)\n\n    def _ratsimpmodprime(a, b, allsol, N=0, D=0):\n        \"\"\"\n        Computes a rational simplification of ``a/b`` which minimizes\n        the sum of the total degrees of the numerator and the denominator.\n\n        Explanation\n        ===========\n\n        The algorithm proceeds by looking at ``a * d - b * c`` modulo\n        the ideal generated by ``G`` for some ``c`` and ``d`` with degree\n        less than ``a`` and ``b`` respectively.\n        The coefficients of ``c`` and ``d`` are indeterminates and thus\n        the coefficients of the normalform of ``a * d - b * c`` are\n        linear polynomials in these indeterminates.\n        If these linear polynomials, considered as system of\n        equations, have a nontrivial solution, then `\\\\frac{a}{b}\n        \\\\equiv \\\\frac{c}{d}` modulo the ideal generated by ``G``. So,\n        by construction, the degree of ``c`` and ``d`` is less than\n        the degree of ``a`` and ``b``, so a simpler representation\n        has been found.\n        After a simpler representation has been found, the algorithm\n        tries to reduce the degree of the numerator and denominator\n        and returns the result afterwards.\n\n        As an extension, if quick=False, we look at all possible degrees such\n        that the total degree is less than *or equal to* the best current\n        solution. We retain a list of all solutions of minimal degree, and try\n        to find the best one at the end.\n        \"\"\"\n        (c, d) = (a, b)\n        steps = 0\n        maxdeg = a.total_degree() + b.total_degree()\n        if quick:\n            bound = maxdeg - 1\n        else:\n            bound = maxdeg\n        while N + D <= bound:\n            if (N, D) in tested:\n                break\n            tested.add((N, D))\n            M1 = staircase(N)\n            M2 = staircase(D)\n            debugf('%s / %s: %s, %s', (N, D, M1, M2))\n            Cs = symbols('c:%d' % len(M1), cls=Dummy)\n            Ds = symbols('d:%d' % len(M2), cls=Dummy)\n            ng = Cs + Ds\n            c_hat = Poly(sum([Cs[i] * M1[i] for i in range(len(M1))]), opt.gens + ng)\n            d_hat = Poly(sum([Ds[i] * M2[i] for i in range(len(M2))]), opt.gens + ng)\n            r = reduced(a * d_hat - b * c_hat, G, opt.gens + ng, order=opt.order, polys=True)[1]\n            S = Poly(r, gens=opt.gens).coeffs()\n            sol = solve(S, Cs + Ds, particular=True, quick=True)\n            if sol and (not all((s == 0 for s in sol.values()))):\n                c = c_hat.subs(sol)\n                d = d_hat.subs(sol)\n                c = c.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                d = d.subs(dict(list(zip(Cs + Ds, [1] * (len(Cs) + len(Ds))))))\n                c = Poly(c, opt.gens)\n                d = Poly(d, opt.gens)\n                if d == 0:\n                    raise ValueError('Ideal not prime?')\n                allsol.append((c_hat, d_hat, S, Cs + Ds))\n                if N + D != maxdeg:\n                    allsol = [allsol[-1]]\n                break\n            steps += 1\n            N += 1\n            D += 1\n        if steps > 0:\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N, D - steps)\n            (c, d, allsol) = _ratsimpmodprime(c, d, allsol, N - steps, D)\n        return (c, d, allsol)\n    num = reduced(num, G, opt.gens, order=opt.order)[1]\n    denom = reduced(denom, G, opt.gens, order=opt.order)[1]\n    if polynomial:\n        return (num / denom).cancel()\n    (c, d, allsol) = _ratsimpmodprime(Poly(num, opt.gens, domain=opt.domain), Poly(denom, opt.gens, domain=opt.domain), [])\n    if not quick and allsol:\n        debugf('Looking for best minimal solution. Got: %s', len(allsol))\n        newsol = []\n        for (c_hat, d_hat, S, ng) in allsol:\n            sol = solve(S, ng, particular=True, quick=False)\n            newsol.append((c_hat.subs(sol), d_hat.subs(sol)))\n        (c, d) = min(newsol, key=lambda x: len(x[0].terms()) + len(x[1].terms()))\n    if not domain.is_Field:\n        (cn, c) = c.clear_denoms(convert=True)\n        (dn, d) = d.clear_denoms(convert=True)\n        r = Rational(cn, dn)\n    else:\n        r = Rational(1)\n    return c * r.q / (d * r.p)"
        ]
    }
]