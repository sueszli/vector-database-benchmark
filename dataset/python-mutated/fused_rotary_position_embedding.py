from paddle import _C_ops
from paddle.base.layer_helper import LayerHelper
from paddle.framework import in_dynamic_mode

def fused_rotary_position_embedding(q, k=None, v=None, sin=None, cos=None, position_ids=None, use_neox_rotary_style=True):
    if False:
        i = 10
        return i + 15
    "\n    Fused rotary position embedding.\n\n    Args:\n        q (Tensor): The input tensor. The data type is bfloat16, float16, float32 or float64. The shape of q must be [batch_size, seq_len, num_heads, head_dim] and head_dim must be a multiple of 2.\n        k (Tensor, optional): The input tensor. The data type is bfloat16, float16, float32 or float64. The shape of k must be [batch_size, seq_len, num_heads, head_dim] and head_dim must be a multiple of 2.\n        v (Tensor, optional): The input tensor. The data type is bfloat16, float16, float32 or float64. The shape of v must be [batch_size, seq_len, num_heads, head_dim] and head_dim must be a multiple of 2.\n        sin (Tensor, optional): The input tensor. The data type is bfloat16, float16, float32 or float64. The shape of sin must be [seq_len, head_dim] or [1, seq_len, 1, head_dim] and head_dim must be a multiple of 2.\n        cos (Tensor, optional): The input tensor. The data type is bfloat16, float16, float32 or float64. The shape of cos must be [seq_len, head_dim] or [1, seq_len, 1, head_dim] and head_dim must be a multiple of 2.\n        position_ids (Tensor, optional): The input tensor. The data type is int64. The shape of position_ids must be [batch_size, seq_len].\n        use_neox_rotary_style(optional|bool): When the use_neox_rotary_style is True, every two adjacent numbers are calculated. When the use_neox_rotary_style is False, the numbers corresponding to the positions of the front half and back half segments are calculated. Default True.\n\n    Returns:\n        out_q/out_k/out_v Tensor representing the fused rotary position embedding, has same shape and data type as `q` .\n\n\n    Examples:\n\n        .. code-block:: python\n\n            >>> # doctest: +REQUIRES(env:GPU)\n            >>> import paddle\n            >>> from paddle.incubate.nn.functional import fused_rotary_position_embedding\n\n            >>> paddle.set_device('gpu')\n\n            >>> # batch_size = 2\n            >>> # seq_len = 2\n            >>> # num_heads = 2\n            >>> # head_dim = 2\n\n            >>> paddle.seed(1204)\n\n            >>> # q, k, v: [batch_size, seq_len, num_heads, head_dim]\n            >>> q = paddle.randn([2, 2, 2, 2], dtype='float16')\n            >>> k = paddle.randn([2, 2, 2, 2], dtype='float16')\n            >>> v = paddle.randn([2, 2, 2, 2], dtype='float16')\n\n            >>> # sin, cos: [1, seq_len, 1, head_dim]\n            >>> x = paddle.randn([1, 2, 1, 2], dtype='float16')\n            >>> y = paddle.randn([1, 2, 1, 2], dtype='float16')\n            >>> sin = paddle.sin(x)\n            >>> cos = paddle.cos(y)\n\n            >>> # position_ids: [batch_size, seq_len]\n            >>> position_ids = paddle.randint(high=2, shape=[2, 2], dtype='int64')\n\n            >>> # out_q, out_k, out_v: [batch_size, seq_len, num_heads, head_dim]\n            >>> out_q, out_k, out_v = fused_rotary_position_embedding(q, k, v, sin=sin, cos=cos, position_ids=position_ids, use_neox_rotary_style=False)\n            >>> print(out_q)\n            Tensor(shape=[2, 2, 2, 2], dtype=float16, place=Place(gpu:0), stop_gradient=True,\n            [[[[-0.54931641,  0.64990234],\n               [-1.08691406,  1.18261719]],\n              [[ 0.57812500,  0.11749268],\n               [-0.63281250,  0.15551758]]],\n             [[[-0.77050781,  0.07733154],\n               [-0.73730469, -0.16735840]],\n              [[ 0.07116699, -0.90966797],\n               [-0.03628540, -0.20202637]]]])\n    "
    if in_dynamic_mode():
        return _C_ops.fused_rotary_position_embedding(q, k, v, sin, cos, position_ids, use_neox_rotary_style)
    helper = LayerHelper('fused_rotary_position_embedding', **locals())
    out_q = helper.create_variable_for_type_inference(dtype=q.dtype)
    out_k = helper.create_variable_for_type_inference(dtype=k.dtype) if k else None
    out_v = helper.create_variable_for_type_inference(dtype=v.dtype) if v else None
    helper.append_op(type='fused_rotary_position_embedding', inputs={'q': q, 'k': k, 'v': v, 'sin': sin, 'cos': cos, 'position_ids': position_ids}, outputs={'out_q': out_q, 'out_k': out_k, 'out_v': out_v}, attrs={'use_neox_rotary_style': use_neox_rotary_style})
    return (out_q, out_k, out_v)