[
    {
        "func_name": "_report_nonhermitian",
        "original": "def _report_nonhermitian(M, name):\n    \"\"\"\n    Report if `M` is not a Hermitian matrix given its type.\n    \"\"\"\n    from scipy.linalg import norm\n    md = M - M.T.conj()\n    nmd = norm(md, 1)\n    tol = 10 * np.finfo(M.dtype).eps\n    tol = max(tol, tol * norm(M, 1))\n    if nmd > tol:\n        warnings.warn(f'Matrix {name} of the type {M.dtype} is not Hermitian: condition: {nmd} < {tol} fails.', UserWarning, stacklevel=4)",
        "mutated": [
            "def _report_nonhermitian(M, name):\n    if False:\n        i = 10\n    '\\n    Report if `M` is not a Hermitian matrix given its type.\\n    '\n    from scipy.linalg import norm\n    md = M - M.T.conj()\n    nmd = norm(md, 1)\n    tol = 10 * np.finfo(M.dtype).eps\n    tol = max(tol, tol * norm(M, 1))\n    if nmd > tol:\n        warnings.warn(f'Matrix {name} of the type {M.dtype} is not Hermitian: condition: {nmd} < {tol} fails.', UserWarning, stacklevel=4)",
            "def _report_nonhermitian(M, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Report if `M` is not a Hermitian matrix given its type.\\n    '\n    from scipy.linalg import norm\n    md = M - M.T.conj()\n    nmd = norm(md, 1)\n    tol = 10 * np.finfo(M.dtype).eps\n    tol = max(tol, tol * norm(M, 1))\n    if nmd > tol:\n        warnings.warn(f'Matrix {name} of the type {M.dtype} is not Hermitian: condition: {nmd} < {tol} fails.', UserWarning, stacklevel=4)",
            "def _report_nonhermitian(M, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Report if `M` is not a Hermitian matrix given its type.\\n    '\n    from scipy.linalg import norm\n    md = M - M.T.conj()\n    nmd = norm(md, 1)\n    tol = 10 * np.finfo(M.dtype).eps\n    tol = max(tol, tol * norm(M, 1))\n    if nmd > tol:\n        warnings.warn(f'Matrix {name} of the type {M.dtype} is not Hermitian: condition: {nmd} < {tol} fails.', UserWarning, stacklevel=4)",
            "def _report_nonhermitian(M, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Report if `M` is not a Hermitian matrix given its type.\\n    '\n    from scipy.linalg import norm\n    md = M - M.T.conj()\n    nmd = norm(md, 1)\n    tol = 10 * np.finfo(M.dtype).eps\n    tol = max(tol, tol * norm(M, 1))\n    if nmd > tol:\n        warnings.warn(f'Matrix {name} of the type {M.dtype} is not Hermitian: condition: {nmd} < {tol} fails.', UserWarning, stacklevel=4)",
            "def _report_nonhermitian(M, name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Report if `M` is not a Hermitian matrix given its type.\\n    '\n    from scipy.linalg import norm\n    md = M - M.T.conj()\n    nmd = norm(md, 1)\n    tol = 10 * np.finfo(M.dtype).eps\n    tol = max(tol, tol * norm(M, 1))\n    if nmd > tol:\n        warnings.warn(f'Matrix {name} of the type {M.dtype} is not Hermitian: condition: {nmd} < {tol} fails.', UserWarning, stacklevel=4)"
        ]
    },
    {
        "func_name": "_as2d",
        "original": "def _as2d(ar):\n    \"\"\"\n    If the input array is 2D return it, if it is 1D, append a dimension,\n    making it a column vector.\n    \"\"\"\n    if ar.ndim == 2:\n        return ar\n    else:\n        aux = np.array(ar, copy=False)\n        aux.shape = (ar.shape[0], 1)\n        return aux",
        "mutated": [
            "def _as2d(ar):\n    if False:\n        i = 10\n    '\\n    If the input array is 2D return it, if it is 1D, append a dimension,\\n    making it a column vector.\\n    '\n    if ar.ndim == 2:\n        return ar\n    else:\n        aux = np.array(ar, copy=False)\n        aux.shape = (ar.shape[0], 1)\n        return aux",
            "def _as2d(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    If the input array is 2D return it, if it is 1D, append a dimension,\\n    making it a column vector.\\n    '\n    if ar.ndim == 2:\n        return ar\n    else:\n        aux = np.array(ar, copy=False)\n        aux.shape = (ar.shape[0], 1)\n        return aux",
            "def _as2d(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    If the input array is 2D return it, if it is 1D, append a dimension,\\n    making it a column vector.\\n    '\n    if ar.ndim == 2:\n        return ar\n    else:\n        aux = np.array(ar, copy=False)\n        aux.shape = (ar.shape[0], 1)\n        return aux",
            "def _as2d(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    If the input array is 2D return it, if it is 1D, append a dimension,\\n    making it a column vector.\\n    '\n    if ar.ndim == 2:\n        return ar\n    else:\n        aux = np.array(ar, copy=False)\n        aux.shape = (ar.shape[0], 1)\n        return aux",
            "def _as2d(ar):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    If the input array is 2D return it, if it is 1D, append a dimension,\\n    making it a column vector.\\n    '\n    if ar.ndim == 2:\n        return ar\n    else:\n        aux = np.array(ar, copy=False)\n        aux.shape = (ar.shape[0], 1)\n        return aux"
        ]
    },
    {
        "func_name": "_makeMatMat",
        "original": "def _makeMatMat(m):\n    if m is None:\n        return None\n    elif callable(m):\n        return lambda v: m(v)\n    else:\n        return lambda v: m @ v",
        "mutated": [
            "def _makeMatMat(m):\n    if False:\n        i = 10\n    if m is None:\n        return None\n    elif callable(m):\n        return lambda v: m(v)\n    else:\n        return lambda v: m @ v",
            "def _makeMatMat(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if m is None:\n        return None\n    elif callable(m):\n        return lambda v: m(v)\n    else:\n        return lambda v: m @ v",
            "def _makeMatMat(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if m is None:\n        return None\n    elif callable(m):\n        return lambda v: m(v)\n    else:\n        return lambda v: m @ v",
            "def _makeMatMat(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if m is None:\n        return None\n    elif callable(m):\n        return lambda v: m(v)\n    else:\n        return lambda v: m @ v",
            "def _makeMatMat(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if m is None:\n        return None\n    elif callable(m):\n        return lambda v: m(v)\n    else:\n        return lambda v: m @ v"
        ]
    },
    {
        "func_name": "_matmul_inplace",
        "original": "def _matmul_inplace(x, y, verbosityLevel=0):\n    \"\"\"Perform 'np.matmul' in-place if possible.\n\n    If some sufficient conditions for inplace matmul are met, do so.\n    Otherwise try inplace update and fall back to overwrite if that fails.\n    \"\"\"\n    if x.flags['CARRAY'] and x.shape[1] == y.shape[1] and (x.dtype == y.dtype):\n        np.matmul(x, y, out=x)\n    else:\n        try:\n            np.matmul(x, y, out=x)\n        except Exception:\n            if verbosityLevel:\n                warnings.warn('Inplace update of x = x @ y failed, x needs to be overwritten.', UserWarning, stacklevel=3)\n            x = x @ y\n    return x",
        "mutated": [
            "def _matmul_inplace(x, y, verbosityLevel=0):\n    if False:\n        i = 10\n    \"Perform 'np.matmul' in-place if possible.\\n\\n    If some sufficient conditions for inplace matmul are met, do so.\\n    Otherwise try inplace update and fall back to overwrite if that fails.\\n    \"\n    if x.flags['CARRAY'] and x.shape[1] == y.shape[1] and (x.dtype == y.dtype):\n        np.matmul(x, y, out=x)\n    else:\n        try:\n            np.matmul(x, y, out=x)\n        except Exception:\n            if verbosityLevel:\n                warnings.warn('Inplace update of x = x @ y failed, x needs to be overwritten.', UserWarning, stacklevel=3)\n            x = x @ y\n    return x",
            "def _matmul_inplace(x, y, verbosityLevel=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Perform 'np.matmul' in-place if possible.\\n\\n    If some sufficient conditions for inplace matmul are met, do so.\\n    Otherwise try inplace update and fall back to overwrite if that fails.\\n    \"\n    if x.flags['CARRAY'] and x.shape[1] == y.shape[1] and (x.dtype == y.dtype):\n        np.matmul(x, y, out=x)\n    else:\n        try:\n            np.matmul(x, y, out=x)\n        except Exception:\n            if verbosityLevel:\n                warnings.warn('Inplace update of x = x @ y failed, x needs to be overwritten.', UserWarning, stacklevel=3)\n            x = x @ y\n    return x",
            "def _matmul_inplace(x, y, verbosityLevel=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Perform 'np.matmul' in-place if possible.\\n\\n    If some sufficient conditions for inplace matmul are met, do so.\\n    Otherwise try inplace update and fall back to overwrite if that fails.\\n    \"\n    if x.flags['CARRAY'] and x.shape[1] == y.shape[1] and (x.dtype == y.dtype):\n        np.matmul(x, y, out=x)\n    else:\n        try:\n            np.matmul(x, y, out=x)\n        except Exception:\n            if verbosityLevel:\n                warnings.warn('Inplace update of x = x @ y failed, x needs to be overwritten.', UserWarning, stacklevel=3)\n            x = x @ y\n    return x",
            "def _matmul_inplace(x, y, verbosityLevel=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Perform 'np.matmul' in-place if possible.\\n\\n    If some sufficient conditions for inplace matmul are met, do so.\\n    Otherwise try inplace update and fall back to overwrite if that fails.\\n    \"\n    if x.flags['CARRAY'] and x.shape[1] == y.shape[1] and (x.dtype == y.dtype):\n        np.matmul(x, y, out=x)\n    else:\n        try:\n            np.matmul(x, y, out=x)\n        except Exception:\n            if verbosityLevel:\n                warnings.warn('Inplace update of x = x @ y failed, x needs to be overwritten.', UserWarning, stacklevel=3)\n            x = x @ y\n    return x",
            "def _matmul_inplace(x, y, verbosityLevel=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Perform 'np.matmul' in-place if possible.\\n\\n    If some sufficient conditions for inplace matmul are met, do so.\\n    Otherwise try inplace update and fall back to overwrite if that fails.\\n    \"\n    if x.flags['CARRAY'] and x.shape[1] == y.shape[1] and (x.dtype == y.dtype):\n        np.matmul(x, y, out=x)\n    else:\n        try:\n            np.matmul(x, y, out=x)\n        except Exception:\n            if verbosityLevel:\n                warnings.warn('Inplace update of x = x @ y failed, x needs to be overwritten.', UserWarning, stacklevel=3)\n            x = x @ y\n    return x"
        ]
    },
    {
        "func_name": "_applyConstraints",
        "original": "def _applyConstraints(blockVectorV, factYBY, blockVectorBY, blockVectorY):\n    \"\"\"Changes blockVectorV in-place.\"\"\"\n    YBV = blockVectorBY.T.conj() @ blockVectorV\n    tmp = cho_solve(factYBY, YBV)\n    blockVectorV -= blockVectorY @ tmp",
        "mutated": [
            "def _applyConstraints(blockVectorV, factYBY, blockVectorBY, blockVectorY):\n    if False:\n        i = 10\n    'Changes blockVectorV in-place.'\n    YBV = blockVectorBY.T.conj() @ blockVectorV\n    tmp = cho_solve(factYBY, YBV)\n    blockVectorV -= blockVectorY @ tmp",
            "def _applyConstraints(blockVectorV, factYBY, blockVectorBY, blockVectorY):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Changes blockVectorV in-place.'\n    YBV = blockVectorBY.T.conj() @ blockVectorV\n    tmp = cho_solve(factYBY, YBV)\n    blockVectorV -= blockVectorY @ tmp",
            "def _applyConstraints(blockVectorV, factYBY, blockVectorBY, blockVectorY):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Changes blockVectorV in-place.'\n    YBV = blockVectorBY.T.conj() @ blockVectorV\n    tmp = cho_solve(factYBY, YBV)\n    blockVectorV -= blockVectorY @ tmp",
            "def _applyConstraints(blockVectorV, factYBY, blockVectorBY, blockVectorY):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Changes blockVectorV in-place.'\n    YBV = blockVectorBY.T.conj() @ blockVectorV\n    tmp = cho_solve(factYBY, YBV)\n    blockVectorV -= blockVectorY @ tmp",
            "def _applyConstraints(blockVectorV, factYBY, blockVectorBY, blockVectorY):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Changes blockVectorV in-place.'\n    YBV = blockVectorBY.T.conj() @ blockVectorV\n    tmp = cho_solve(factYBY, YBV)\n    blockVectorV -= blockVectorY @ tmp"
        ]
    },
    {
        "func_name": "_b_orthonormalize",
        "original": "def _b_orthonormalize(B, blockVectorV, blockVectorBV=None, verbosityLevel=0):\n    \"\"\"in-place B-orthonormalize the given block vector using Cholesky.\"\"\"\n    if blockVectorBV is None:\n        if B is None:\n            blockVectorBV = blockVectorV\n        else:\n            try:\n                blockVectorBV = B(blockVectorV)\n            except Exception as e:\n                if verbosityLevel:\n                    warnings.warn(f'Secondary MatMul call failed with error\\n{e}\\n', UserWarning, stacklevel=3)\n                    return (None, None, None)\n            if blockVectorBV.shape != blockVectorV.shape:\n                raise ValueError(f'The shape {blockVectorV.shape} of the orthogonalized matrix not preserved\\nand changed to {blockVectorBV.shape} after multiplying by the secondary matrix.\\n')\n    VBV = blockVectorV.T.conj() @ blockVectorBV\n    try:\n        VBV = cholesky(VBV, overwrite_a=True)\n        VBV = inv(VBV, overwrite_a=True)\n        blockVectorV = _matmul_inplace(blockVectorV, VBV, verbosityLevel=verbosityLevel)\n        if B is not None:\n            blockVectorBV = _matmul_inplace(blockVectorBV, VBV, verbosityLevel=verbosityLevel)\n        return (blockVectorV, blockVectorBV, VBV)\n    except LinAlgError:\n        if verbosityLevel:\n            warnings.warn('Cholesky has failed.', UserWarning, stacklevel=3)\n        return (None, None, None)",
        "mutated": [
            "def _b_orthonormalize(B, blockVectorV, blockVectorBV=None, verbosityLevel=0):\n    if False:\n        i = 10\n    'in-place B-orthonormalize the given block vector using Cholesky.'\n    if blockVectorBV is None:\n        if B is None:\n            blockVectorBV = blockVectorV\n        else:\n            try:\n                blockVectorBV = B(blockVectorV)\n            except Exception as e:\n                if verbosityLevel:\n                    warnings.warn(f'Secondary MatMul call failed with error\\n{e}\\n', UserWarning, stacklevel=3)\n                    return (None, None, None)\n            if blockVectorBV.shape != blockVectorV.shape:\n                raise ValueError(f'The shape {blockVectorV.shape} of the orthogonalized matrix not preserved\\nand changed to {blockVectorBV.shape} after multiplying by the secondary matrix.\\n')\n    VBV = blockVectorV.T.conj() @ blockVectorBV\n    try:\n        VBV = cholesky(VBV, overwrite_a=True)\n        VBV = inv(VBV, overwrite_a=True)\n        blockVectorV = _matmul_inplace(blockVectorV, VBV, verbosityLevel=verbosityLevel)\n        if B is not None:\n            blockVectorBV = _matmul_inplace(blockVectorBV, VBV, verbosityLevel=verbosityLevel)\n        return (blockVectorV, blockVectorBV, VBV)\n    except LinAlgError:\n        if verbosityLevel:\n            warnings.warn('Cholesky has failed.', UserWarning, stacklevel=3)\n        return (None, None, None)",
            "def _b_orthonormalize(B, blockVectorV, blockVectorBV=None, verbosityLevel=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'in-place B-orthonormalize the given block vector using Cholesky.'\n    if blockVectorBV is None:\n        if B is None:\n            blockVectorBV = blockVectorV\n        else:\n            try:\n                blockVectorBV = B(blockVectorV)\n            except Exception as e:\n                if verbosityLevel:\n                    warnings.warn(f'Secondary MatMul call failed with error\\n{e}\\n', UserWarning, stacklevel=3)\n                    return (None, None, None)\n            if blockVectorBV.shape != blockVectorV.shape:\n                raise ValueError(f'The shape {blockVectorV.shape} of the orthogonalized matrix not preserved\\nand changed to {blockVectorBV.shape} after multiplying by the secondary matrix.\\n')\n    VBV = blockVectorV.T.conj() @ blockVectorBV\n    try:\n        VBV = cholesky(VBV, overwrite_a=True)\n        VBV = inv(VBV, overwrite_a=True)\n        blockVectorV = _matmul_inplace(blockVectorV, VBV, verbosityLevel=verbosityLevel)\n        if B is not None:\n            blockVectorBV = _matmul_inplace(blockVectorBV, VBV, verbosityLevel=verbosityLevel)\n        return (blockVectorV, blockVectorBV, VBV)\n    except LinAlgError:\n        if verbosityLevel:\n            warnings.warn('Cholesky has failed.', UserWarning, stacklevel=3)\n        return (None, None, None)",
            "def _b_orthonormalize(B, blockVectorV, blockVectorBV=None, verbosityLevel=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'in-place B-orthonormalize the given block vector using Cholesky.'\n    if blockVectorBV is None:\n        if B is None:\n            blockVectorBV = blockVectorV\n        else:\n            try:\n                blockVectorBV = B(blockVectorV)\n            except Exception as e:\n                if verbosityLevel:\n                    warnings.warn(f'Secondary MatMul call failed with error\\n{e}\\n', UserWarning, stacklevel=3)\n                    return (None, None, None)\n            if blockVectorBV.shape != blockVectorV.shape:\n                raise ValueError(f'The shape {blockVectorV.shape} of the orthogonalized matrix not preserved\\nand changed to {blockVectorBV.shape} after multiplying by the secondary matrix.\\n')\n    VBV = blockVectorV.T.conj() @ blockVectorBV\n    try:\n        VBV = cholesky(VBV, overwrite_a=True)\n        VBV = inv(VBV, overwrite_a=True)\n        blockVectorV = _matmul_inplace(blockVectorV, VBV, verbosityLevel=verbosityLevel)\n        if B is not None:\n            blockVectorBV = _matmul_inplace(blockVectorBV, VBV, verbosityLevel=verbosityLevel)\n        return (blockVectorV, blockVectorBV, VBV)\n    except LinAlgError:\n        if verbosityLevel:\n            warnings.warn('Cholesky has failed.', UserWarning, stacklevel=3)\n        return (None, None, None)",
            "def _b_orthonormalize(B, blockVectorV, blockVectorBV=None, verbosityLevel=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'in-place B-orthonormalize the given block vector using Cholesky.'\n    if blockVectorBV is None:\n        if B is None:\n            blockVectorBV = blockVectorV\n        else:\n            try:\n                blockVectorBV = B(blockVectorV)\n            except Exception as e:\n                if verbosityLevel:\n                    warnings.warn(f'Secondary MatMul call failed with error\\n{e}\\n', UserWarning, stacklevel=3)\n                    return (None, None, None)\n            if blockVectorBV.shape != blockVectorV.shape:\n                raise ValueError(f'The shape {blockVectorV.shape} of the orthogonalized matrix not preserved\\nand changed to {blockVectorBV.shape} after multiplying by the secondary matrix.\\n')\n    VBV = blockVectorV.T.conj() @ blockVectorBV\n    try:\n        VBV = cholesky(VBV, overwrite_a=True)\n        VBV = inv(VBV, overwrite_a=True)\n        blockVectorV = _matmul_inplace(blockVectorV, VBV, verbosityLevel=verbosityLevel)\n        if B is not None:\n            blockVectorBV = _matmul_inplace(blockVectorBV, VBV, verbosityLevel=verbosityLevel)\n        return (blockVectorV, blockVectorBV, VBV)\n    except LinAlgError:\n        if verbosityLevel:\n            warnings.warn('Cholesky has failed.', UserWarning, stacklevel=3)\n        return (None, None, None)",
            "def _b_orthonormalize(B, blockVectorV, blockVectorBV=None, verbosityLevel=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'in-place B-orthonormalize the given block vector using Cholesky.'\n    if blockVectorBV is None:\n        if B is None:\n            blockVectorBV = blockVectorV\n        else:\n            try:\n                blockVectorBV = B(blockVectorV)\n            except Exception as e:\n                if verbosityLevel:\n                    warnings.warn(f'Secondary MatMul call failed with error\\n{e}\\n', UserWarning, stacklevel=3)\n                    return (None, None, None)\n            if blockVectorBV.shape != blockVectorV.shape:\n                raise ValueError(f'The shape {blockVectorV.shape} of the orthogonalized matrix not preserved\\nand changed to {blockVectorBV.shape} after multiplying by the secondary matrix.\\n')\n    VBV = blockVectorV.T.conj() @ blockVectorBV\n    try:\n        VBV = cholesky(VBV, overwrite_a=True)\n        VBV = inv(VBV, overwrite_a=True)\n        blockVectorV = _matmul_inplace(blockVectorV, VBV, verbosityLevel=verbosityLevel)\n        if B is not None:\n            blockVectorBV = _matmul_inplace(blockVectorBV, VBV, verbosityLevel=verbosityLevel)\n        return (blockVectorV, blockVectorBV, VBV)\n    except LinAlgError:\n        if verbosityLevel:\n            warnings.warn('Cholesky has failed.', UserWarning, stacklevel=3)\n        return (None, None, None)"
        ]
    },
    {
        "func_name": "_get_indx",
        "original": "def _get_indx(_lambda, num, largest):\n    \"\"\"Get `num` indices into `_lambda` depending on `largest` option.\"\"\"\n    ii = np.argsort(_lambda)\n    if largest:\n        ii = ii[:-num - 1:-1]\n    else:\n        ii = ii[:num]\n    return ii",
        "mutated": [
            "def _get_indx(_lambda, num, largest):\n    if False:\n        i = 10\n    'Get `num` indices into `_lambda` depending on `largest` option.'\n    ii = np.argsort(_lambda)\n    if largest:\n        ii = ii[:-num - 1:-1]\n    else:\n        ii = ii[:num]\n    return ii",
            "def _get_indx(_lambda, num, largest):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Get `num` indices into `_lambda` depending on `largest` option.'\n    ii = np.argsort(_lambda)\n    if largest:\n        ii = ii[:-num - 1:-1]\n    else:\n        ii = ii[:num]\n    return ii",
            "def _get_indx(_lambda, num, largest):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Get `num` indices into `_lambda` depending on `largest` option.'\n    ii = np.argsort(_lambda)\n    if largest:\n        ii = ii[:-num - 1:-1]\n    else:\n        ii = ii[:num]\n    return ii",
            "def _get_indx(_lambda, num, largest):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Get `num` indices into `_lambda` depending on `largest` option.'\n    ii = np.argsort(_lambda)\n    if largest:\n        ii = ii[:-num - 1:-1]\n    else:\n        ii = ii[:num]\n    return ii",
            "def _get_indx(_lambda, num, largest):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Get `num` indices into `_lambda` depending on `largest` option.'\n    ii = np.argsort(_lambda)\n    if largest:\n        ii = ii[:-num - 1:-1]\n    else:\n        ii = ii[:num]\n    return ii"
        ]
    },
    {
        "func_name": "_handle_gramA_gramB_verbosity",
        "original": "def _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel):\n    if verbosityLevel:\n        _report_nonhermitian(gramA, 'gramA')\n        _report_nonhermitian(gramB, 'gramB')",
        "mutated": [
            "def _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel):\n    if False:\n        i = 10\n    if verbosityLevel:\n        _report_nonhermitian(gramA, 'gramA')\n        _report_nonhermitian(gramB, 'gramB')",
            "def _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if verbosityLevel:\n        _report_nonhermitian(gramA, 'gramA')\n        _report_nonhermitian(gramB, 'gramB')",
            "def _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if verbosityLevel:\n        _report_nonhermitian(gramA, 'gramA')\n        _report_nonhermitian(gramB, 'gramB')",
            "def _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if verbosityLevel:\n        _report_nonhermitian(gramA, 'gramA')\n        _report_nonhermitian(gramB, 'gramB')",
            "def _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if verbosityLevel:\n        _report_nonhermitian(gramA, 'gramA')\n        _report_nonhermitian(gramB, 'gramB')"
        ]
    },
    {
        "func_name": "lobpcg",
        "original": "def lobpcg(A, X, B=None, M=None, Y=None, tol=None, maxiter=None, largest=True, verbosityLevel=0, retLambdaHistory=False, retResidualNormsHistory=False, restartControl=20):\n    \"\"\"Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG).\n\n    LOBPCG is a preconditioned eigensolver for large real symmetric and complex\n    Hermitian definite generalized eigenproblems.\n\n    Parameters\n    ----------\n    A : {sparse matrix, ndarray, LinearOperator, callable object}\n        The Hermitian linear operator of the problem, usually given by a\n        sparse matrix.  Often called the \"stiffness matrix\".\n    X : ndarray, float32 or float64\n        Initial approximation to the ``k`` eigenvectors (non-sparse).\n        If `A` has ``shape=(n,n)`` then `X` must have ``shape=(n,k)``.\n    B : {sparse matrix, ndarray, LinearOperator, callable object}\n        Optional. By default ``B = None``, which is equivalent to identity.\n        The right hand side operator in a generalized eigenproblem if present.\n        Often called the \"mass matrix\". Must be Hermitian positive definite.\n    M : {sparse matrix, ndarray, LinearOperator, callable object}\n        Optional. By default ``M = None``, which is equivalent to identity.\n        Preconditioner aiming to accelerate convergence.\n    Y : ndarray, float32 or float64, default: None\n        An ``n-by-sizeY`` ndarray of constraints with ``sizeY < n``.\n        The iterations will be performed in the ``B``-orthogonal complement\n        of the column-space of `Y`. `Y` must be full rank if present.\n    tol : scalar, optional\n        The default is ``tol=n*sqrt(eps)``.\n        Solver tolerance for the stopping criterion.\n    maxiter : int, default: 20\n        Maximum number of iterations.\n    largest : bool, default: True\n        When True, solve for the largest eigenvalues, otherwise the smallest.\n    verbosityLevel : int, optional\n        By default ``verbosityLevel=0`` no output.\n        Controls the solver standard/screen output.\n    retLambdaHistory : bool, default: False\n        Whether to return iterative eigenvalue history.\n    retResidualNormsHistory : bool, default: False\n        Whether to return iterative history of residual norms.\n    restartControl : int, optional.\n        Iterations restart if the residuals jump ``2**restartControl`` times\n        compared to the smallest recorded in ``retResidualNormsHistory``.\n        The default is ``restartControl=20``, making the restarts rare for\n        backward compatibility.\n\n    Returns\n    -------\n    lambda : ndarray of the shape ``(k, )``.\n        Array of ``k`` approximate eigenvalues.\n    v : ndarray of the same shape as ``X.shape``.\n        An array of ``k`` approximate eigenvectors.\n    lambdaHistory : ndarray, optional.\n        The eigenvalue history, if `retLambdaHistory` is ``True``.\n    ResidualNormsHistory : ndarray, optional.\n        The history of residual norms, if `retResidualNormsHistory`\n        is ``True``.\n\n    Notes\n    -----\n    The iterative loop runs ``maxit=maxiter`` (20 if ``maxit=None``)\n    iterations at most and finishes earler if the tolerance is met.\n    Breaking backward compatibility with the previous version, LOBPCG\n    now returns the block of iterative vectors with the best accuracy rather\n    than the last one iterated, as a cure for possible divergence.\n\n    If ``X.dtype == np.float32`` and user-provided operations/multiplications\n    by `A`, `B`, and `M` all preserve the ``np.float32`` data type,\n    all the calculations and the output are in ``np.float32``.\n\n    The size of the iteration history output equals to the number of the best\n    (limited by `maxit`) iterations plus 3: initial, final, and postprocessing.\n\n    If both `retLambdaHistory` and `retResidualNormsHistory` are ``True``,\n    the return tuple has the following format\n    ``(lambda, V, lambda history, residual norms history)``.\n\n    In the following ``n`` denotes the matrix size and ``k`` the number\n    of required eigenvalues (smallest or largest).\n\n    The LOBPCG code internally solves eigenproblems of the size ``3k`` on every\n    iteration by calling the dense eigensolver `eigh`, so if ``k`` is not\n    small enough compared to ``n``, it makes no sense to call the LOBPCG code.\n    Moreover, if one calls the LOBPCG algorithm for ``5k > n``, it would likely\n    break internally, so the code calls the standard function `eigh` instead.\n    It is not that ``n`` should be large for the LOBPCG to work, but rather the\n    ratio ``n / k`` should be large. It you call LOBPCG with ``k=1``\n    and ``n=10``, it works though ``n`` is small. The method is intended\n    for extremely large ``n / k``.\n\n    The convergence speed depends basically on three factors:\n\n    1. Quality of the initial approximations `X` to the seeking eigenvectors.\n       Randomly distributed around the origin vectors work well if no better\n       choice is known.\n\n    2. Relative separation of the desired eigenvalues from the rest\n       of the eigenvalues. One can vary ``k`` to improve the separation.\n\n    3. Proper preconditioning to shrink the spectral spread.\n       For example, a rod vibration test problem (under tests\n       directory) is ill-conditioned for large ``n``, so convergence will be\n       slow, unless efficient preconditioning is used. For this specific\n       problem, a good simple preconditioner function would be a linear solve\n       for `A`, which is easy to code since `A` is tridiagonal.\n\n    References\n    ----------\n    .. [1] A. V. Knyazev (2001),\n           Toward the Optimal Preconditioned Eigensolver: Locally Optimal\n           Block Preconditioned Conjugate Gradient Method.\n           SIAM Journal on Scientific Computing 23, no. 2,\n           pp. 517-541. :doi:`10.1137/S1064827500366124`\n\n    .. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov\n           (2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers\n           (BLOPEX) in hypre and PETSc. :arxiv:`0705.2626`\n\n    .. [3] A. V. Knyazev's C and MATLAB implementations:\n           https://github.com/lobpcg/blopex\n\n    Examples\n    --------\n    Our first example is minimalistic - find the largest eigenvalue of\n    a diagonal matrix by solving the non-generalized eigenvalue problem\n    ``A x = lambda x`` without constraints or preconditioning.\n\n    >>> import numpy as np\n    >>> from scipy.sparse import spdiags\n    >>> from scipy.sparse.linalg import LinearOperator, aslinearoperator\n    >>> from scipy.sparse.linalg import lobpcg\n\n    The square matrix size is\n\n    >>> n = 100\n\n    and its diagonal entries are 1, ..., 100 defined by\n\n    >>> vals = np.arange(1, n + 1).astype(np.int16)\n\n    The first mandatory input parameter in this test is\n    the sparse diagonal matrix `A`\n    of the eigenvalue problem ``A x = lambda x`` to solve.\n\n    >>> A = spdiags(vals, 0, n, n)\n    >>> A = A.astype(np.int16)\n    >>> A.toarray()\n    array([[  1,   0,   0, ...,   0,   0,   0],\n           [  0,   2,   0, ...,   0,   0,   0],\n           [  0,   0,   3, ...,   0,   0,   0],\n           ...,\n           [  0,   0,   0, ...,  98,   0,   0],\n           [  0,   0,   0, ...,   0,  99,   0],\n           [  0,   0,   0, ...,   0,   0, 100]], dtype=int16)\n\n    The second mandatory input parameter `X` is a 2D array with the\n    row dimension determining the number of requested eigenvalues.\n    `X` is an initial guess for targeted eigenvectors.\n    `X` must have linearly independent columns.\n    If no initial approximations available, randomly oriented vectors\n    commonly work best, e.g., with components normally distributed\n    around zero or uniformly distributed on the interval [-1 1].\n    Setting the initial approximations to dtype ``np.float32``\n    forces all iterative values to dtype ``np.float32`` speeding up\n    the run while still allowing accurate eigenvalue computations.\n\n    >>> k = 1\n    >>> rng = np.random.default_rng()\n    >>> X = rng.normal(size=(n, k))\n    >>> X = X.astype(np.float32)\n\n    >>> eigenvalues, _ = lobpcg(A, X, maxiter=60)\n    >>> eigenvalues\n    array([100.])\n    >>> eigenvalues.dtype\n    dtype('float32')\n\n    `lobpcg` needs only access the matrix product with `A` rather\n    then the matrix itself. Since the matrix `A` is diagonal in\n    this example, one can write a function of the matrix product\n    ``A @ X`` using the diagonal values ``vals`` only, e.g., by\n    element-wise multiplication with broadcasting in the lambda-function\n\n    >>> A_lambda = lambda X: vals[:, np.newaxis] * X\n\n    or the regular function\n\n    >>> def A_matmat(X):\n    ...     return vals[:, np.newaxis] * X\n\n    and use the handle to one of these callables as an input\n\n    >>> eigenvalues, _ = lobpcg(A_lambda, X, maxiter=60)\n    >>> eigenvalues\n    array([100.])\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, maxiter=60)\n    >>> eigenvalues\n    array([100.])\n\n    The traditional callable `LinearOperator` is no longer\n    necessary but still supported as the input to `lobpcg`.\n    Specifying ``matmat=A_matmat`` explicitely improves performance. \n\n    >>> A_lo = LinearOperator((n, n), matvec=A_matmat, matmat=A_matmat, dtype=np.int16)\n    >>> eigenvalues, _ = lobpcg(A_lo, X, maxiter=80)\n    >>> eigenvalues\n    array([100.])\n\n    The least efficient callable option is `aslinearoperator`:\n\n    >>> eigenvalues, _ = lobpcg(aslinearoperator(A), X, maxiter=80)\n    >>> eigenvalues\n    array([100.])\n\n    We now switch to computing the three smallest eigenvalues specifying\n\n    >>> k = 3\n    >>> X = np.random.default_rng().normal(size=(n, k))\n\n    and ``largest=False`` parameter\n\n    >>> eigenvalues, _ = lobpcg(A, X, largest=False, maxiter=80)\n    >>> print(eigenvalues)  \n    [1. 2. 3.]\n\n    The next example illustrates computing 3 smallest eigenvalues of\n    the same matrix `A` given by the function handle ``A_matmat`` but\n    with constraints and preconditioning.\n\n    Constraints - an optional input parameter is a 2D array comprising\n    of column vectors that the eigenvectors must be orthogonal to\n\n    >>> Y = np.eye(n, 3)\n\n    The preconditioner acts as the inverse of `A` in this example, but\n    in the reduced precision ``np.float32`` even though the initial `X`\n    and thus all iterates and the output are in full ``np.float64``.\n\n    >>> inv_vals = 1./vals\n    >>> inv_vals = inv_vals.astype(np.float32)\n    >>> M = lambda X: inv_vals[:, np.newaxis] * X\n\n    Let us now solve the eigenvalue problem for the matrix `A` first\n    without preconditioning requesting 80 iterations\n\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, largest=False, maxiter=80)\n    >>> eigenvalues\n    array([4., 5., 6.])\n    >>> eigenvalues.dtype\n    dtype('float64')\n\n    With preconditioning we need only 20 iterations from the same `X`\n\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, M=M, largest=False, maxiter=20)\n    >>> eigenvalues\n    array([4., 5., 6.])\n\n    Note that the vectors passed in `Y` are the eigenvectors of the 3\n    smallest eigenvalues. The results returned above are orthogonal to those.\n\n    The primary matrix `A` may be indefinite, e.g., after shifting\n    ``vals`` by 50 from 1, ..., 100 to -49, ..., 50, we still can compute\n    the 3 smallest or largest eigenvalues.\n\n    >>> vals = vals - 50\n    >>> X = rng.normal(size=(n, k))\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=False, maxiter=99)\n    >>> eigenvalues\n    array([-49., -48., -47.])\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=True, maxiter=99)\n    >>> eigenvalues\n    array([50., 49., 48.])\n\n    \"\"\"\n    blockVectorX = X\n    bestblockVectorX = blockVectorX\n    blockVectorY = Y\n    residualTolerance = tol\n    if maxiter is None:\n        maxiter = 20\n    bestIterationNumber = maxiter\n    sizeY = 0\n    if blockVectorY is not None:\n        if len(blockVectorY.shape) != 2:\n            warnings.warn(f'Expected rank-2 array for argument Y, instead got {len(blockVectorY.shape)}, so ignore it and use no constraints.', UserWarning, stacklevel=2)\n            blockVectorY = None\n        else:\n            sizeY = blockVectorY.shape[1]\n    if blockVectorX is None:\n        raise ValueError('The mandatory initial matrix X cannot be None')\n    if len(blockVectorX.shape) != 2:\n        raise ValueError('expected rank-2 array for argument X')\n    (n, sizeX) = blockVectorX.shape\n    if not np.issubdtype(blockVectorX.dtype, np.inexact):\n        warnings.warn(f'Data type for argument X is {blockVectorX.dtype}, which is not inexact, so casted to np.float32.', UserWarning, stacklevel=2)\n        blockVectorX = np.asarray(blockVectorX, dtype=np.float32)\n    if retLambdaHistory:\n        lambdaHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if retResidualNormsHistory:\n        residualNormsHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if verbosityLevel:\n        aux = 'Solving '\n        if B is None:\n            aux += 'standard'\n        else:\n            aux += 'generalized'\n        aux += ' eigenvalue problem with'\n        if M is None:\n            aux += 'out'\n        aux += ' preconditioning\\n\\n'\n        aux += 'matrix size %d\\n' % n\n        aux += 'block size %d\\n\\n' % sizeX\n        if blockVectorY is None:\n            aux += 'No constraints\\n\\n'\n        elif sizeY > 1:\n            aux += '%d constraints\\n\\n' % sizeY\n        else:\n            aux += '%d constraint\\n\\n' % sizeY\n        print(aux)\n    if n - sizeY < 5 * sizeX:\n        warnings.warn(f'The problem size {n} minus the constraints size {sizeY} is too small relative to the block size {sizeX}. Using a dense eigensolver instead of LOBPCG iterations.No output of the history of the iterations.', UserWarning, stacklevel=2)\n        sizeX = min(sizeX, n)\n        if blockVectorY is not None:\n            raise NotImplementedError('The dense eigensolver does not support constraints.')\n        if largest:\n            eigvals = (n - sizeX, n - 1)\n        else:\n            eigvals = (0, sizeX - 1)\n        try:\n            if isinstance(A, LinearOperator):\n                A = A(np.eye(n, dtype=int))\n            elif callable(A):\n                A = A(np.eye(n, dtype=int))\n                if A.shape != (n, n):\n                    raise ValueError(f'The shape {A.shape} of the primary matrix\\ndefined by a callable object is wrong.\\n')\n            elif issparse(A):\n                A = A.toarray()\n            else:\n                A = np.asarray(A)\n        except Exception as e:\n            raise Exception(f'Primary MatMul call failed with error\\n{e}\\n')\n        if B is not None:\n            try:\n                if isinstance(B, LinearOperator):\n                    B = B(np.eye(n, dtype=int))\n                elif callable(B):\n                    B = B(np.eye(n, dtype=int))\n                    if B.shape != (n, n):\n                        raise ValueError(f'The shape {B.shape} of the secondary matrix\\ndefined by a callable object is wrong.\\n')\n                elif issparse(B):\n                    B = B.toarray()\n                else:\n                    B = np.asarray(B)\n            except Exception as e:\n                raise Exception(f'Secondary MatMul call failed with error\\n{e}\\n')\n        try:\n            (vals, vecs) = eigh(A, B, subset_by_index=eigvals, check_finite=False)\n            if largest:\n                vals = vals[::-1]\n                vecs = vecs[:, ::-1]\n            return (vals, vecs)\n        except Exception as e:\n            raise Exception(f'Dense eigensolver failed with error\\n{e}\\n')\n    if residualTolerance is None or residualTolerance <= 0.0:\n        residualTolerance = np.sqrt(np.finfo(blockVectorX.dtype).eps) * n\n    A = _makeMatMat(A)\n    B = _makeMatMat(B)\n    M = _makeMatMat(M)\n    if blockVectorY is not None:\n        if B is not None:\n            blockVectorBY = B(blockVectorY)\n            if blockVectorBY.shape != blockVectorY.shape:\n                raise ValueError(f'The shape {blockVectorY.shape} of the constraint not preserved\\nand changed to {blockVectorBY.shape} after multiplying by the secondary matrix.\\n')\n        else:\n            blockVectorBY = blockVectorY\n        gramYBY = blockVectorY.T.conj() @ blockVectorBY\n        try:\n            gramYBY = cho_factor(gramYBY, overwrite_a=True)\n        except LinAlgError as e:\n            raise ValueError('Linearly dependent constraints') from e\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    (blockVectorX, blockVectorBX, _) = _b_orthonormalize(B, blockVectorX, verbosityLevel=verbosityLevel)\n    if blockVectorX is None:\n        raise ValueError('Linearly dependent initial approximations')\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the initial approximations not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = blockVectorX.T.conj() @ blockVectorAX\n    (_lambda, eigBlockVector) = eigh(gramXAX, check_finite=False)\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    if retLambdaHistory:\n        lambdaHistory[0, :] = _lambda\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = _matmul_inplace(blockVectorX, eigBlockVector, verbosityLevel=verbosityLevel)\n    blockVectorAX = _matmul_inplace(blockVectorAX, eigBlockVector, verbosityLevel=verbosityLevel)\n    if B is not None:\n        blockVectorBX = _matmul_inplace(blockVectorBX, eigBlockVector, verbosityLevel=verbosityLevel)\n    activeMask = np.ones((sizeX,), dtype=bool)\n    blockVectorP = None\n    blockVectorAP = None\n    blockVectorBP = None\n    smallestResidualNorm = np.abs(np.finfo(blockVectorX.dtype).max)\n    iterationNumber = -1\n    restart = True\n    forcedRestart = False\n    explicitGramFlag = False\n    while iterationNumber < maxiter:\n        iterationNumber += 1\n        if B is not None:\n            aux = blockVectorBX * _lambda[np.newaxis, :]\n        else:\n            aux = blockVectorX * _lambda[np.newaxis, :]\n        blockVectorR = blockVectorAX - aux\n        aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n        residualNorms = np.sqrt(np.abs(aux))\n        if retResidualNormsHistory:\n            residualNormsHistory[iterationNumber, :] = residualNorms\n        residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n        if residualNorm < smallestResidualNorm:\n            smallestResidualNorm = residualNorm\n            bestIterationNumber = iterationNumber\n            bestblockVectorX = blockVectorX\n        elif residualNorm > 2 ** restartControl * smallestResidualNorm:\n            forcedRestart = True\n            blockVectorAX = A(blockVectorX)\n            if blockVectorAX.shape != blockVectorX.shape:\n                raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n            if B is not None:\n                blockVectorBX = B(blockVectorX)\n                if blockVectorBX.shape != blockVectorX.shape:\n                    raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n        ii = np.where(residualNorms > residualTolerance, True, False)\n        activeMask = activeMask & ii\n        currentBlockSize = activeMask.sum()\n        if verbosityLevel:\n            print(f'iteration {iterationNumber}')\n            print(f'current block size: {currentBlockSize}')\n            print(f'eigenvalue(s):\\n{_lambda}')\n            print(f'residual norm(s):\\n{residualNorms}')\n        if currentBlockSize == 0:\n            break\n        activeBlockVectorR = _as2d(blockVectorR[:, activeMask])\n        if iterationNumber > 0:\n            activeBlockVectorP = _as2d(blockVectorP[:, activeMask])\n            activeBlockVectorAP = _as2d(blockVectorAP[:, activeMask])\n            if B is not None:\n                activeBlockVectorBP = _as2d(blockVectorBP[:, activeMask])\n        if M is not None:\n            activeBlockVectorR = M(activeBlockVectorR)\n        if blockVectorY is not None:\n            _applyConstraints(activeBlockVectorR, gramYBY, blockVectorBY, blockVectorY)\n        if B is not None:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorBX.T.conj() @ activeBlockVectorR)\n        else:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorX.T.conj() @ activeBlockVectorR)\n        aux = _b_orthonormalize(B, activeBlockVectorR, verbosityLevel=verbosityLevel)\n        (activeBlockVectorR, activeBlockVectorBR, _) = aux\n        if activeBlockVectorR is None:\n            warnings.warn(f'Failed at iteration {iterationNumber} with accuracies {residualNorms}\\n not reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n            break\n        activeBlockVectorAR = A(activeBlockVectorR)\n        if iterationNumber > 0:\n            if B is not None:\n                aux = _b_orthonormalize(B, activeBlockVectorP, activeBlockVectorBP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, activeBlockVectorBP, invR) = aux\n            else:\n                aux = _b_orthonormalize(B, activeBlockVectorP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, _, invR) = aux\n            if activeBlockVectorP is not None:\n                activeBlockVectorAP = _matmul_inplace(activeBlockVectorAP, invR, verbosityLevel=verbosityLevel)\n                restart = forcedRestart\n            else:\n                restart = True\n        if activeBlockVectorAR.dtype == 'float32':\n            myeps = 1\n        else:\n            myeps = np.sqrt(np.finfo(activeBlockVectorR.dtype).eps)\n        if residualNorms.max() > myeps and (not explicitGramFlag):\n            explicitGramFlag = False\n        else:\n            explicitGramFlag = True\n        if B is None:\n            blockVectorBX = blockVectorX\n            activeBlockVectorBR = activeBlockVectorR\n            if not restart:\n                activeBlockVectorBP = activeBlockVectorP\n        gramXAR = np.dot(blockVectorX.T.conj(), activeBlockVectorAR)\n        gramRAR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAR)\n        gramDtype = activeBlockVectorAR.dtype\n        if explicitGramFlag:\n            gramRAR = (gramRAR + gramRAR.T.conj()) / 2\n            gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n            gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n            gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n            gramRBR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBR)\n            gramXBR = np.dot(blockVectorX.T.conj(), activeBlockVectorBR)\n        else:\n            gramXAX = np.diag(_lambda).astype(gramDtype)\n            gramXBX = np.eye(sizeX, dtype=gramDtype)\n            gramRBR = np.eye(currentBlockSize, dtype=gramDtype)\n            gramXBR = np.zeros((sizeX, currentBlockSize), dtype=gramDtype)\n        if not restart:\n            gramXAP = np.dot(blockVectorX.T.conj(), activeBlockVectorAP)\n            gramRAP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAP)\n            gramPAP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorAP)\n            gramXBP = np.dot(blockVectorX.T.conj(), activeBlockVectorBP)\n            gramRBP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBP)\n            if explicitGramFlag:\n                gramPAP = (gramPAP + gramPAP.T.conj()) / 2\n                gramPBP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorBP)\n            else:\n                gramPBP = np.eye(currentBlockSize, dtype=gramDtype)\n            gramA = np.block([[gramXAX, gramXAR, gramXAP], [gramXAR.T.conj(), gramRAR, gramRAP], [gramXAP.T.conj(), gramRAP.T.conj(), gramPAP]])\n            gramB = np.block([[gramXBX, gramXBR, gramXBP], [gramXBR.T.conj(), gramRBR, gramRBP], [gramXBP.T.conj(), gramRBP.T.conj(), gramPBP]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                if verbosityLevel:\n                    warnings.warn(f'eigh failed at iteration {iterationNumber} \\nwith error {e} causing a restart.\\n', UserWarning, stacklevel=2)\n                restart = True\n        if restart:\n            gramA = np.block([[gramXAX, gramXAR], [gramXAR.T.conj(), gramRAR]])\n            gramB = np.block([[gramXBX, gramXBR], [gramXBR.T.conj(), gramRBR]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                warnings.warn(f'eigh failed at iteration {iterationNumber} with error\\n{e}\\n', UserWarning, stacklevel=2)\n                break\n        ii = _get_indx(_lambda, sizeX, largest)\n        _lambda = _lambda[ii]\n        eigBlockVector = eigBlockVector[:, ii]\n        if retLambdaHistory:\n            lambdaHistory[iterationNumber + 1, :] = _lambda\n        if B is not None:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n                bpp += np.dot(activeBlockVectorBP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            blockVectorBX = np.dot(blockVectorBX, eigBlockVectorX) + bpp\n            (blockVectorP, blockVectorAP, blockVectorBP) = (pp, app, bpp)\n        else:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            (blockVectorP, blockVectorAP) = (pp, app)\n    if B is not None:\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[iterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[iterationNumber + 1, :] = residualNorms\n    residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n    if residualNorm < smallestResidualNorm:\n        smallestResidualNorm = residualNorm\n        bestIterationNumber = iterationNumber + 1\n        bestblockVectorX = blockVectorX\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited at iteration {iterationNumber} with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.\\nUse iteration {bestIterationNumber} instead with accuracy \\n{smallestResidualNorm}.\\n', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final iterative eigenvalue(s):\\n{_lambda}')\n        print(f'Final iterative residual norm(s):\\n{residualNorms}')\n    blockVectorX = bestblockVectorX\n    if blockVectorY is not None:\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n    blockVectorBX = blockVectorX\n    if B is not None:\n        blockVectorBX = B(blockVectorX)\n        if blockVectorBX.shape != blockVectorX.shape:\n            raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n    gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n    _handle_gramA_gramB_verbosity(gramXAX, gramXBX, verbosityLevel)\n    gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n    gramXBX = (gramXBX + gramXBX.T.conj()) / 2\n    try:\n        (_lambda, eigBlockVector) = eigh(gramXAX, gramXBX, check_finite=False)\n    except LinAlgError as e:\n        raise ValueError('eigh has failed in lobpcg postprocessing') from e\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = np.dot(blockVectorX, eigBlockVector)\n    blockVectorAX = np.dot(blockVectorAX, eigBlockVector)\n    if B is not None:\n        blockVectorBX = np.dot(blockVectorBX, eigBlockVector)\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[bestIterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[bestIterationNumber + 1, :] = residualNorms\n    if retLambdaHistory:\n        lambdaHistory = lambdaHistory[:bestIterationNumber + 2, :]\n    if retResidualNormsHistory:\n        residualNormsHistory = residualNormsHistory[:bestIterationNumber + 2, :]\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited postprocessing with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final postprocessing eigenvalue(s):\\n{_lambda}')\n        print(f'Final residual norm(s):\\n{residualNorms}')\n    if retLambdaHistory:\n        lambdaHistory = np.vsplit(lambdaHistory, np.shape(lambdaHistory)[0])\n        lambdaHistory = [np.squeeze(i) for i in lambdaHistory]\n    if retResidualNormsHistory:\n        residualNormsHistory = np.vsplit(residualNormsHistory, np.shape(residualNormsHistory)[0])\n        residualNormsHistory = [np.squeeze(i) for i in residualNormsHistory]\n    if retLambdaHistory:\n        if retResidualNormsHistory:\n            return (_lambda, blockVectorX, lambdaHistory, residualNormsHistory)\n        else:\n            return (_lambda, blockVectorX, lambdaHistory)\n    elif retResidualNormsHistory:\n        return (_lambda, blockVectorX, residualNormsHistory)\n    else:\n        return (_lambda, blockVectorX)",
        "mutated": [
            "def lobpcg(A, X, B=None, M=None, Y=None, tol=None, maxiter=None, largest=True, verbosityLevel=0, retLambdaHistory=False, retResidualNormsHistory=False, restartControl=20):\n    if False:\n        i = 10\n    'Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG).\\n\\n    LOBPCG is a preconditioned eigensolver for large real symmetric and complex\\n    Hermitian definite generalized eigenproblems.\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator, callable object}\\n        The Hermitian linear operator of the problem, usually given by a\\n        sparse matrix.  Often called the \"stiffness matrix\".\\n    X : ndarray, float32 or float64\\n        Initial approximation to the ``k`` eigenvectors (non-sparse).\\n        If `A` has ``shape=(n,n)`` then `X` must have ``shape=(n,k)``.\\n    B : {sparse matrix, ndarray, LinearOperator, callable object}\\n        Optional. By default ``B = None``, which is equivalent to identity.\\n        The right hand side operator in a generalized eigenproblem if present.\\n        Often called the \"mass matrix\". Must be Hermitian positive definite.\\n    M : {sparse matrix, ndarray, LinearOperator, callable object}\\n        Optional. By default ``M = None``, which is equivalent to identity.\\n        Preconditioner aiming to accelerate convergence.\\n    Y : ndarray, float32 or float64, default: None\\n        An ``n-by-sizeY`` ndarray of constraints with ``sizeY < n``.\\n        The iterations will be performed in the ``B``-orthogonal complement\\n        of the column-space of `Y`. `Y` must be full rank if present.\\n    tol : scalar, optional\\n        The default is ``tol=n*sqrt(eps)``.\\n        Solver tolerance for the stopping criterion.\\n    maxiter : int, default: 20\\n        Maximum number of iterations.\\n    largest : bool, default: True\\n        When True, solve for the largest eigenvalues, otherwise the smallest.\\n    verbosityLevel : int, optional\\n        By default ``verbosityLevel=0`` no output.\\n        Controls the solver standard/screen output.\\n    retLambdaHistory : bool, default: False\\n        Whether to return iterative eigenvalue history.\\n    retResidualNormsHistory : bool, default: False\\n        Whether to return iterative history of residual norms.\\n    restartControl : int, optional.\\n        Iterations restart if the residuals jump ``2**restartControl`` times\\n        compared to the smallest recorded in ``retResidualNormsHistory``.\\n        The default is ``restartControl=20``, making the restarts rare for\\n        backward compatibility.\\n\\n    Returns\\n    -------\\n    lambda : ndarray of the shape ``(k, )``.\\n        Array of ``k`` approximate eigenvalues.\\n    v : ndarray of the same shape as ``X.shape``.\\n        An array of ``k`` approximate eigenvectors.\\n    lambdaHistory : ndarray, optional.\\n        The eigenvalue history, if `retLambdaHistory` is ``True``.\\n    ResidualNormsHistory : ndarray, optional.\\n        The history of residual norms, if `retResidualNormsHistory`\\n        is ``True``.\\n\\n    Notes\\n    -----\\n    The iterative loop runs ``maxit=maxiter`` (20 if ``maxit=None``)\\n    iterations at most and finishes earler if the tolerance is met.\\n    Breaking backward compatibility with the previous version, LOBPCG\\n    now returns the block of iterative vectors with the best accuracy rather\\n    than the last one iterated, as a cure for possible divergence.\\n\\n    If ``X.dtype == np.float32`` and user-provided operations/multiplications\\n    by `A`, `B`, and `M` all preserve the ``np.float32`` data type,\\n    all the calculations and the output are in ``np.float32``.\\n\\n    The size of the iteration history output equals to the number of the best\\n    (limited by `maxit`) iterations plus 3: initial, final, and postprocessing.\\n\\n    If both `retLambdaHistory` and `retResidualNormsHistory` are ``True``,\\n    the return tuple has the following format\\n    ``(lambda, V, lambda history, residual norms history)``.\\n\\n    In the following ``n`` denotes the matrix size and ``k`` the number\\n    of required eigenvalues (smallest or largest).\\n\\n    The LOBPCG code internally solves eigenproblems of the size ``3k`` on every\\n    iteration by calling the dense eigensolver `eigh`, so if ``k`` is not\\n    small enough compared to ``n``, it makes no sense to call the LOBPCG code.\\n    Moreover, if one calls the LOBPCG algorithm for ``5k > n``, it would likely\\n    break internally, so the code calls the standard function `eigh` instead.\\n    It is not that ``n`` should be large for the LOBPCG to work, but rather the\\n    ratio ``n / k`` should be large. It you call LOBPCG with ``k=1``\\n    and ``n=10``, it works though ``n`` is small. The method is intended\\n    for extremely large ``n / k``.\\n\\n    The convergence speed depends basically on three factors:\\n\\n    1. Quality of the initial approximations `X` to the seeking eigenvectors.\\n       Randomly distributed around the origin vectors work well if no better\\n       choice is known.\\n\\n    2. Relative separation of the desired eigenvalues from the rest\\n       of the eigenvalues. One can vary ``k`` to improve the separation.\\n\\n    3. Proper preconditioning to shrink the spectral spread.\\n       For example, a rod vibration test problem (under tests\\n       directory) is ill-conditioned for large ``n``, so convergence will be\\n       slow, unless efficient preconditioning is used. For this specific\\n       problem, a good simple preconditioner function would be a linear solve\\n       for `A`, which is easy to code since `A` is tridiagonal.\\n\\n    References\\n    ----------\\n    .. [1] A. V. Knyazev (2001),\\n           Toward the Optimal Preconditioned Eigensolver: Locally Optimal\\n           Block Preconditioned Conjugate Gradient Method.\\n           SIAM Journal on Scientific Computing 23, no. 2,\\n           pp. 517-541. :doi:`10.1137/S1064827500366124`\\n\\n    .. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov\\n           (2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers\\n           (BLOPEX) in hypre and PETSc. :arxiv:`0705.2626`\\n\\n    .. [3] A. V. Knyazev\\'s C and MATLAB implementations:\\n           https://github.com/lobpcg/blopex\\n\\n    Examples\\n    --------\\n    Our first example is minimalistic - find the largest eigenvalue of\\n    a diagonal matrix by solving the non-generalized eigenvalue problem\\n    ``A x = lambda x`` without constraints or preconditioning.\\n\\n    >>> import numpy as np\\n    >>> from scipy.sparse import spdiags\\n    >>> from scipy.sparse.linalg import LinearOperator, aslinearoperator\\n    >>> from scipy.sparse.linalg import lobpcg\\n\\n    The square matrix size is\\n\\n    >>> n = 100\\n\\n    and its diagonal entries are 1, ..., 100 defined by\\n\\n    >>> vals = np.arange(1, n + 1).astype(np.int16)\\n\\n    The first mandatory input parameter in this test is\\n    the sparse diagonal matrix `A`\\n    of the eigenvalue problem ``A x = lambda x`` to solve.\\n\\n    >>> A = spdiags(vals, 0, n, n)\\n    >>> A = A.astype(np.int16)\\n    >>> A.toarray()\\n    array([[  1,   0,   0, ...,   0,   0,   0],\\n           [  0,   2,   0, ...,   0,   0,   0],\\n           [  0,   0,   3, ...,   0,   0,   0],\\n           ...,\\n           [  0,   0,   0, ...,  98,   0,   0],\\n           [  0,   0,   0, ...,   0,  99,   0],\\n           [  0,   0,   0, ...,   0,   0, 100]], dtype=int16)\\n\\n    The second mandatory input parameter `X` is a 2D array with the\\n    row dimension determining the number of requested eigenvalues.\\n    `X` is an initial guess for targeted eigenvectors.\\n    `X` must have linearly independent columns.\\n    If no initial approximations available, randomly oriented vectors\\n    commonly work best, e.g., with components normally distributed\\n    around zero or uniformly distributed on the interval [-1 1].\\n    Setting the initial approximations to dtype ``np.float32``\\n    forces all iterative values to dtype ``np.float32`` speeding up\\n    the run while still allowing accurate eigenvalue computations.\\n\\n    >>> k = 1\\n    >>> rng = np.random.default_rng()\\n    >>> X = rng.normal(size=(n, k))\\n    >>> X = X.astype(np.float32)\\n\\n    >>> eigenvalues, _ = lobpcg(A, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n    >>> eigenvalues.dtype\\n    dtype(\\'float32\\')\\n\\n    `lobpcg` needs only access the matrix product with `A` rather\\n    then the matrix itself. Since the matrix `A` is diagonal in\\n    this example, one can write a function of the matrix product\\n    ``A @ X`` using the diagonal values ``vals`` only, e.g., by\\n    element-wise multiplication with broadcasting in the lambda-function\\n\\n    >>> A_lambda = lambda X: vals[:, np.newaxis] * X\\n\\n    or the regular function\\n\\n    >>> def A_matmat(X):\\n    ...     return vals[:, np.newaxis] * X\\n\\n    and use the handle to one of these callables as an input\\n\\n    >>> eigenvalues, _ = lobpcg(A_lambda, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    The traditional callable `LinearOperator` is no longer\\n    necessary but still supported as the input to `lobpcg`.\\n    Specifying ``matmat=A_matmat`` explicitely improves performance. \\n\\n    >>> A_lo = LinearOperator((n, n), matvec=A_matmat, matmat=A_matmat, dtype=np.int16)\\n    >>> eigenvalues, _ = lobpcg(A_lo, X, maxiter=80)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    The least efficient callable option is `aslinearoperator`:\\n\\n    >>> eigenvalues, _ = lobpcg(aslinearoperator(A), X, maxiter=80)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    We now switch to computing the three smallest eigenvalues specifying\\n\\n    >>> k = 3\\n    >>> X = np.random.default_rng().normal(size=(n, k))\\n\\n    and ``largest=False`` parameter\\n\\n    >>> eigenvalues, _ = lobpcg(A, X, largest=False, maxiter=80)\\n    >>> print(eigenvalues)  \\n    [1. 2. 3.]\\n\\n    The next example illustrates computing 3 smallest eigenvalues of\\n    the same matrix `A` given by the function handle ``A_matmat`` but\\n    with constraints and preconditioning.\\n\\n    Constraints - an optional input parameter is a 2D array comprising\\n    of column vectors that the eigenvectors must be orthogonal to\\n\\n    >>> Y = np.eye(n, 3)\\n\\n    The preconditioner acts as the inverse of `A` in this example, but\\n    in the reduced precision ``np.float32`` even though the initial `X`\\n    and thus all iterates and the output are in full ``np.float64``.\\n\\n    >>> inv_vals = 1./vals\\n    >>> inv_vals = inv_vals.astype(np.float32)\\n    >>> M = lambda X: inv_vals[:, np.newaxis] * X\\n\\n    Let us now solve the eigenvalue problem for the matrix `A` first\\n    without preconditioning requesting 80 iterations\\n\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, largest=False, maxiter=80)\\n    >>> eigenvalues\\n    array([4., 5., 6.])\\n    >>> eigenvalues.dtype\\n    dtype(\\'float64\\')\\n\\n    With preconditioning we need only 20 iterations from the same `X`\\n\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, M=M, largest=False, maxiter=20)\\n    >>> eigenvalues\\n    array([4., 5., 6.])\\n\\n    Note that the vectors passed in `Y` are the eigenvectors of the 3\\n    smallest eigenvalues. The results returned above are orthogonal to those.\\n\\n    The primary matrix `A` may be indefinite, e.g., after shifting\\n    ``vals`` by 50 from 1, ..., 100 to -49, ..., 50, we still can compute\\n    the 3 smallest or largest eigenvalues.\\n\\n    >>> vals = vals - 50\\n    >>> X = rng.normal(size=(n, k))\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=False, maxiter=99)\\n    >>> eigenvalues\\n    array([-49., -48., -47.])\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=True, maxiter=99)\\n    >>> eigenvalues\\n    array([50., 49., 48.])\\n\\n    '\n    blockVectorX = X\n    bestblockVectorX = blockVectorX\n    blockVectorY = Y\n    residualTolerance = tol\n    if maxiter is None:\n        maxiter = 20\n    bestIterationNumber = maxiter\n    sizeY = 0\n    if blockVectorY is not None:\n        if len(blockVectorY.shape) != 2:\n            warnings.warn(f'Expected rank-2 array for argument Y, instead got {len(blockVectorY.shape)}, so ignore it and use no constraints.', UserWarning, stacklevel=2)\n            blockVectorY = None\n        else:\n            sizeY = blockVectorY.shape[1]\n    if blockVectorX is None:\n        raise ValueError('The mandatory initial matrix X cannot be None')\n    if len(blockVectorX.shape) != 2:\n        raise ValueError('expected rank-2 array for argument X')\n    (n, sizeX) = blockVectorX.shape\n    if not np.issubdtype(blockVectorX.dtype, np.inexact):\n        warnings.warn(f'Data type for argument X is {blockVectorX.dtype}, which is not inexact, so casted to np.float32.', UserWarning, stacklevel=2)\n        blockVectorX = np.asarray(blockVectorX, dtype=np.float32)\n    if retLambdaHistory:\n        lambdaHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if retResidualNormsHistory:\n        residualNormsHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if verbosityLevel:\n        aux = 'Solving '\n        if B is None:\n            aux += 'standard'\n        else:\n            aux += 'generalized'\n        aux += ' eigenvalue problem with'\n        if M is None:\n            aux += 'out'\n        aux += ' preconditioning\\n\\n'\n        aux += 'matrix size %d\\n' % n\n        aux += 'block size %d\\n\\n' % sizeX\n        if blockVectorY is None:\n            aux += 'No constraints\\n\\n'\n        elif sizeY > 1:\n            aux += '%d constraints\\n\\n' % sizeY\n        else:\n            aux += '%d constraint\\n\\n' % sizeY\n        print(aux)\n    if n - sizeY < 5 * sizeX:\n        warnings.warn(f'The problem size {n} minus the constraints size {sizeY} is too small relative to the block size {sizeX}. Using a dense eigensolver instead of LOBPCG iterations.No output of the history of the iterations.', UserWarning, stacklevel=2)\n        sizeX = min(sizeX, n)\n        if blockVectorY is not None:\n            raise NotImplementedError('The dense eigensolver does not support constraints.')\n        if largest:\n            eigvals = (n - sizeX, n - 1)\n        else:\n            eigvals = (0, sizeX - 1)\n        try:\n            if isinstance(A, LinearOperator):\n                A = A(np.eye(n, dtype=int))\n            elif callable(A):\n                A = A(np.eye(n, dtype=int))\n                if A.shape != (n, n):\n                    raise ValueError(f'The shape {A.shape} of the primary matrix\\ndefined by a callable object is wrong.\\n')\n            elif issparse(A):\n                A = A.toarray()\n            else:\n                A = np.asarray(A)\n        except Exception as e:\n            raise Exception(f'Primary MatMul call failed with error\\n{e}\\n')\n        if B is not None:\n            try:\n                if isinstance(B, LinearOperator):\n                    B = B(np.eye(n, dtype=int))\n                elif callable(B):\n                    B = B(np.eye(n, dtype=int))\n                    if B.shape != (n, n):\n                        raise ValueError(f'The shape {B.shape} of the secondary matrix\\ndefined by a callable object is wrong.\\n')\n                elif issparse(B):\n                    B = B.toarray()\n                else:\n                    B = np.asarray(B)\n            except Exception as e:\n                raise Exception(f'Secondary MatMul call failed with error\\n{e}\\n')\n        try:\n            (vals, vecs) = eigh(A, B, subset_by_index=eigvals, check_finite=False)\n            if largest:\n                vals = vals[::-1]\n                vecs = vecs[:, ::-1]\n            return (vals, vecs)\n        except Exception as e:\n            raise Exception(f'Dense eigensolver failed with error\\n{e}\\n')\n    if residualTolerance is None or residualTolerance <= 0.0:\n        residualTolerance = np.sqrt(np.finfo(blockVectorX.dtype).eps) * n\n    A = _makeMatMat(A)\n    B = _makeMatMat(B)\n    M = _makeMatMat(M)\n    if blockVectorY is not None:\n        if B is not None:\n            blockVectorBY = B(blockVectorY)\n            if blockVectorBY.shape != blockVectorY.shape:\n                raise ValueError(f'The shape {blockVectorY.shape} of the constraint not preserved\\nand changed to {blockVectorBY.shape} after multiplying by the secondary matrix.\\n')\n        else:\n            blockVectorBY = blockVectorY\n        gramYBY = blockVectorY.T.conj() @ blockVectorBY\n        try:\n            gramYBY = cho_factor(gramYBY, overwrite_a=True)\n        except LinAlgError as e:\n            raise ValueError('Linearly dependent constraints') from e\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    (blockVectorX, blockVectorBX, _) = _b_orthonormalize(B, blockVectorX, verbosityLevel=verbosityLevel)\n    if blockVectorX is None:\n        raise ValueError('Linearly dependent initial approximations')\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the initial approximations not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = blockVectorX.T.conj() @ blockVectorAX\n    (_lambda, eigBlockVector) = eigh(gramXAX, check_finite=False)\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    if retLambdaHistory:\n        lambdaHistory[0, :] = _lambda\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = _matmul_inplace(blockVectorX, eigBlockVector, verbosityLevel=verbosityLevel)\n    blockVectorAX = _matmul_inplace(blockVectorAX, eigBlockVector, verbosityLevel=verbosityLevel)\n    if B is not None:\n        blockVectorBX = _matmul_inplace(blockVectorBX, eigBlockVector, verbosityLevel=verbosityLevel)\n    activeMask = np.ones((sizeX,), dtype=bool)\n    blockVectorP = None\n    blockVectorAP = None\n    blockVectorBP = None\n    smallestResidualNorm = np.abs(np.finfo(blockVectorX.dtype).max)\n    iterationNumber = -1\n    restart = True\n    forcedRestart = False\n    explicitGramFlag = False\n    while iterationNumber < maxiter:\n        iterationNumber += 1\n        if B is not None:\n            aux = blockVectorBX * _lambda[np.newaxis, :]\n        else:\n            aux = blockVectorX * _lambda[np.newaxis, :]\n        blockVectorR = blockVectorAX - aux\n        aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n        residualNorms = np.sqrt(np.abs(aux))\n        if retResidualNormsHistory:\n            residualNormsHistory[iterationNumber, :] = residualNorms\n        residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n        if residualNorm < smallestResidualNorm:\n            smallestResidualNorm = residualNorm\n            bestIterationNumber = iterationNumber\n            bestblockVectorX = blockVectorX\n        elif residualNorm > 2 ** restartControl * smallestResidualNorm:\n            forcedRestart = True\n            blockVectorAX = A(blockVectorX)\n            if blockVectorAX.shape != blockVectorX.shape:\n                raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n            if B is not None:\n                blockVectorBX = B(blockVectorX)\n                if blockVectorBX.shape != blockVectorX.shape:\n                    raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n        ii = np.where(residualNorms > residualTolerance, True, False)\n        activeMask = activeMask & ii\n        currentBlockSize = activeMask.sum()\n        if verbosityLevel:\n            print(f'iteration {iterationNumber}')\n            print(f'current block size: {currentBlockSize}')\n            print(f'eigenvalue(s):\\n{_lambda}')\n            print(f'residual norm(s):\\n{residualNorms}')\n        if currentBlockSize == 0:\n            break\n        activeBlockVectorR = _as2d(blockVectorR[:, activeMask])\n        if iterationNumber > 0:\n            activeBlockVectorP = _as2d(blockVectorP[:, activeMask])\n            activeBlockVectorAP = _as2d(blockVectorAP[:, activeMask])\n            if B is not None:\n                activeBlockVectorBP = _as2d(blockVectorBP[:, activeMask])\n        if M is not None:\n            activeBlockVectorR = M(activeBlockVectorR)\n        if blockVectorY is not None:\n            _applyConstraints(activeBlockVectorR, gramYBY, blockVectorBY, blockVectorY)\n        if B is not None:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorBX.T.conj() @ activeBlockVectorR)\n        else:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorX.T.conj() @ activeBlockVectorR)\n        aux = _b_orthonormalize(B, activeBlockVectorR, verbosityLevel=verbosityLevel)\n        (activeBlockVectorR, activeBlockVectorBR, _) = aux\n        if activeBlockVectorR is None:\n            warnings.warn(f'Failed at iteration {iterationNumber} with accuracies {residualNorms}\\n not reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n            break\n        activeBlockVectorAR = A(activeBlockVectorR)\n        if iterationNumber > 0:\n            if B is not None:\n                aux = _b_orthonormalize(B, activeBlockVectorP, activeBlockVectorBP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, activeBlockVectorBP, invR) = aux\n            else:\n                aux = _b_orthonormalize(B, activeBlockVectorP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, _, invR) = aux\n            if activeBlockVectorP is not None:\n                activeBlockVectorAP = _matmul_inplace(activeBlockVectorAP, invR, verbosityLevel=verbosityLevel)\n                restart = forcedRestart\n            else:\n                restart = True\n        if activeBlockVectorAR.dtype == 'float32':\n            myeps = 1\n        else:\n            myeps = np.sqrt(np.finfo(activeBlockVectorR.dtype).eps)\n        if residualNorms.max() > myeps and (not explicitGramFlag):\n            explicitGramFlag = False\n        else:\n            explicitGramFlag = True\n        if B is None:\n            blockVectorBX = blockVectorX\n            activeBlockVectorBR = activeBlockVectorR\n            if not restart:\n                activeBlockVectorBP = activeBlockVectorP\n        gramXAR = np.dot(blockVectorX.T.conj(), activeBlockVectorAR)\n        gramRAR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAR)\n        gramDtype = activeBlockVectorAR.dtype\n        if explicitGramFlag:\n            gramRAR = (gramRAR + gramRAR.T.conj()) / 2\n            gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n            gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n            gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n            gramRBR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBR)\n            gramXBR = np.dot(blockVectorX.T.conj(), activeBlockVectorBR)\n        else:\n            gramXAX = np.diag(_lambda).astype(gramDtype)\n            gramXBX = np.eye(sizeX, dtype=gramDtype)\n            gramRBR = np.eye(currentBlockSize, dtype=gramDtype)\n            gramXBR = np.zeros((sizeX, currentBlockSize), dtype=gramDtype)\n        if not restart:\n            gramXAP = np.dot(blockVectorX.T.conj(), activeBlockVectorAP)\n            gramRAP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAP)\n            gramPAP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorAP)\n            gramXBP = np.dot(blockVectorX.T.conj(), activeBlockVectorBP)\n            gramRBP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBP)\n            if explicitGramFlag:\n                gramPAP = (gramPAP + gramPAP.T.conj()) / 2\n                gramPBP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorBP)\n            else:\n                gramPBP = np.eye(currentBlockSize, dtype=gramDtype)\n            gramA = np.block([[gramXAX, gramXAR, gramXAP], [gramXAR.T.conj(), gramRAR, gramRAP], [gramXAP.T.conj(), gramRAP.T.conj(), gramPAP]])\n            gramB = np.block([[gramXBX, gramXBR, gramXBP], [gramXBR.T.conj(), gramRBR, gramRBP], [gramXBP.T.conj(), gramRBP.T.conj(), gramPBP]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                if verbosityLevel:\n                    warnings.warn(f'eigh failed at iteration {iterationNumber} \\nwith error {e} causing a restart.\\n', UserWarning, stacklevel=2)\n                restart = True\n        if restart:\n            gramA = np.block([[gramXAX, gramXAR], [gramXAR.T.conj(), gramRAR]])\n            gramB = np.block([[gramXBX, gramXBR], [gramXBR.T.conj(), gramRBR]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                warnings.warn(f'eigh failed at iteration {iterationNumber} with error\\n{e}\\n', UserWarning, stacklevel=2)\n                break\n        ii = _get_indx(_lambda, sizeX, largest)\n        _lambda = _lambda[ii]\n        eigBlockVector = eigBlockVector[:, ii]\n        if retLambdaHistory:\n            lambdaHistory[iterationNumber + 1, :] = _lambda\n        if B is not None:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n                bpp += np.dot(activeBlockVectorBP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            blockVectorBX = np.dot(blockVectorBX, eigBlockVectorX) + bpp\n            (blockVectorP, blockVectorAP, blockVectorBP) = (pp, app, bpp)\n        else:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            (blockVectorP, blockVectorAP) = (pp, app)\n    if B is not None:\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[iterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[iterationNumber + 1, :] = residualNorms\n    residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n    if residualNorm < smallestResidualNorm:\n        smallestResidualNorm = residualNorm\n        bestIterationNumber = iterationNumber + 1\n        bestblockVectorX = blockVectorX\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited at iteration {iterationNumber} with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.\\nUse iteration {bestIterationNumber} instead with accuracy \\n{smallestResidualNorm}.\\n', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final iterative eigenvalue(s):\\n{_lambda}')\n        print(f'Final iterative residual norm(s):\\n{residualNorms}')\n    blockVectorX = bestblockVectorX\n    if blockVectorY is not None:\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n    blockVectorBX = blockVectorX\n    if B is not None:\n        blockVectorBX = B(blockVectorX)\n        if blockVectorBX.shape != blockVectorX.shape:\n            raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n    gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n    _handle_gramA_gramB_verbosity(gramXAX, gramXBX, verbosityLevel)\n    gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n    gramXBX = (gramXBX + gramXBX.T.conj()) / 2\n    try:\n        (_lambda, eigBlockVector) = eigh(gramXAX, gramXBX, check_finite=False)\n    except LinAlgError as e:\n        raise ValueError('eigh has failed in lobpcg postprocessing') from e\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = np.dot(blockVectorX, eigBlockVector)\n    blockVectorAX = np.dot(blockVectorAX, eigBlockVector)\n    if B is not None:\n        blockVectorBX = np.dot(blockVectorBX, eigBlockVector)\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[bestIterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[bestIterationNumber + 1, :] = residualNorms\n    if retLambdaHistory:\n        lambdaHistory = lambdaHistory[:bestIterationNumber + 2, :]\n    if retResidualNormsHistory:\n        residualNormsHistory = residualNormsHistory[:bestIterationNumber + 2, :]\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited postprocessing with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final postprocessing eigenvalue(s):\\n{_lambda}')\n        print(f'Final residual norm(s):\\n{residualNorms}')\n    if retLambdaHistory:\n        lambdaHistory = np.vsplit(lambdaHistory, np.shape(lambdaHistory)[0])\n        lambdaHistory = [np.squeeze(i) for i in lambdaHistory]\n    if retResidualNormsHistory:\n        residualNormsHistory = np.vsplit(residualNormsHistory, np.shape(residualNormsHistory)[0])\n        residualNormsHistory = [np.squeeze(i) for i in residualNormsHistory]\n    if retLambdaHistory:\n        if retResidualNormsHistory:\n            return (_lambda, blockVectorX, lambdaHistory, residualNormsHistory)\n        else:\n            return (_lambda, blockVectorX, lambdaHistory)\n    elif retResidualNormsHistory:\n        return (_lambda, blockVectorX, residualNormsHistory)\n    else:\n        return (_lambda, blockVectorX)",
            "def lobpcg(A, X, B=None, M=None, Y=None, tol=None, maxiter=None, largest=True, verbosityLevel=0, retLambdaHistory=False, retResidualNormsHistory=False, restartControl=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG).\\n\\n    LOBPCG is a preconditioned eigensolver for large real symmetric and complex\\n    Hermitian definite generalized eigenproblems.\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator, callable object}\\n        The Hermitian linear operator of the problem, usually given by a\\n        sparse matrix.  Often called the \"stiffness matrix\".\\n    X : ndarray, float32 or float64\\n        Initial approximation to the ``k`` eigenvectors (non-sparse).\\n        If `A` has ``shape=(n,n)`` then `X` must have ``shape=(n,k)``.\\n    B : {sparse matrix, ndarray, LinearOperator, callable object}\\n        Optional. By default ``B = None``, which is equivalent to identity.\\n        The right hand side operator in a generalized eigenproblem if present.\\n        Often called the \"mass matrix\". Must be Hermitian positive definite.\\n    M : {sparse matrix, ndarray, LinearOperator, callable object}\\n        Optional. By default ``M = None``, which is equivalent to identity.\\n        Preconditioner aiming to accelerate convergence.\\n    Y : ndarray, float32 or float64, default: None\\n        An ``n-by-sizeY`` ndarray of constraints with ``sizeY < n``.\\n        The iterations will be performed in the ``B``-orthogonal complement\\n        of the column-space of `Y`. `Y` must be full rank if present.\\n    tol : scalar, optional\\n        The default is ``tol=n*sqrt(eps)``.\\n        Solver tolerance for the stopping criterion.\\n    maxiter : int, default: 20\\n        Maximum number of iterations.\\n    largest : bool, default: True\\n        When True, solve for the largest eigenvalues, otherwise the smallest.\\n    verbosityLevel : int, optional\\n        By default ``verbosityLevel=0`` no output.\\n        Controls the solver standard/screen output.\\n    retLambdaHistory : bool, default: False\\n        Whether to return iterative eigenvalue history.\\n    retResidualNormsHistory : bool, default: False\\n        Whether to return iterative history of residual norms.\\n    restartControl : int, optional.\\n        Iterations restart if the residuals jump ``2**restartControl`` times\\n        compared to the smallest recorded in ``retResidualNormsHistory``.\\n        The default is ``restartControl=20``, making the restarts rare for\\n        backward compatibility.\\n\\n    Returns\\n    -------\\n    lambda : ndarray of the shape ``(k, )``.\\n        Array of ``k`` approximate eigenvalues.\\n    v : ndarray of the same shape as ``X.shape``.\\n        An array of ``k`` approximate eigenvectors.\\n    lambdaHistory : ndarray, optional.\\n        The eigenvalue history, if `retLambdaHistory` is ``True``.\\n    ResidualNormsHistory : ndarray, optional.\\n        The history of residual norms, if `retResidualNormsHistory`\\n        is ``True``.\\n\\n    Notes\\n    -----\\n    The iterative loop runs ``maxit=maxiter`` (20 if ``maxit=None``)\\n    iterations at most and finishes earler if the tolerance is met.\\n    Breaking backward compatibility with the previous version, LOBPCG\\n    now returns the block of iterative vectors with the best accuracy rather\\n    than the last one iterated, as a cure for possible divergence.\\n\\n    If ``X.dtype == np.float32`` and user-provided operations/multiplications\\n    by `A`, `B`, and `M` all preserve the ``np.float32`` data type,\\n    all the calculations and the output are in ``np.float32``.\\n\\n    The size of the iteration history output equals to the number of the best\\n    (limited by `maxit`) iterations plus 3: initial, final, and postprocessing.\\n\\n    If both `retLambdaHistory` and `retResidualNormsHistory` are ``True``,\\n    the return tuple has the following format\\n    ``(lambda, V, lambda history, residual norms history)``.\\n\\n    In the following ``n`` denotes the matrix size and ``k`` the number\\n    of required eigenvalues (smallest or largest).\\n\\n    The LOBPCG code internally solves eigenproblems of the size ``3k`` on every\\n    iteration by calling the dense eigensolver `eigh`, so if ``k`` is not\\n    small enough compared to ``n``, it makes no sense to call the LOBPCG code.\\n    Moreover, if one calls the LOBPCG algorithm for ``5k > n``, it would likely\\n    break internally, so the code calls the standard function `eigh` instead.\\n    It is not that ``n`` should be large for the LOBPCG to work, but rather the\\n    ratio ``n / k`` should be large. It you call LOBPCG with ``k=1``\\n    and ``n=10``, it works though ``n`` is small. The method is intended\\n    for extremely large ``n / k``.\\n\\n    The convergence speed depends basically on three factors:\\n\\n    1. Quality of the initial approximations `X` to the seeking eigenvectors.\\n       Randomly distributed around the origin vectors work well if no better\\n       choice is known.\\n\\n    2. Relative separation of the desired eigenvalues from the rest\\n       of the eigenvalues. One can vary ``k`` to improve the separation.\\n\\n    3. Proper preconditioning to shrink the spectral spread.\\n       For example, a rod vibration test problem (under tests\\n       directory) is ill-conditioned for large ``n``, so convergence will be\\n       slow, unless efficient preconditioning is used. For this specific\\n       problem, a good simple preconditioner function would be a linear solve\\n       for `A`, which is easy to code since `A` is tridiagonal.\\n\\n    References\\n    ----------\\n    .. [1] A. V. Knyazev (2001),\\n           Toward the Optimal Preconditioned Eigensolver: Locally Optimal\\n           Block Preconditioned Conjugate Gradient Method.\\n           SIAM Journal on Scientific Computing 23, no. 2,\\n           pp. 517-541. :doi:`10.1137/S1064827500366124`\\n\\n    .. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov\\n           (2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers\\n           (BLOPEX) in hypre and PETSc. :arxiv:`0705.2626`\\n\\n    .. [3] A. V. Knyazev\\'s C and MATLAB implementations:\\n           https://github.com/lobpcg/blopex\\n\\n    Examples\\n    --------\\n    Our first example is minimalistic - find the largest eigenvalue of\\n    a diagonal matrix by solving the non-generalized eigenvalue problem\\n    ``A x = lambda x`` without constraints or preconditioning.\\n\\n    >>> import numpy as np\\n    >>> from scipy.sparse import spdiags\\n    >>> from scipy.sparse.linalg import LinearOperator, aslinearoperator\\n    >>> from scipy.sparse.linalg import lobpcg\\n\\n    The square matrix size is\\n\\n    >>> n = 100\\n\\n    and its diagonal entries are 1, ..., 100 defined by\\n\\n    >>> vals = np.arange(1, n + 1).astype(np.int16)\\n\\n    The first mandatory input parameter in this test is\\n    the sparse diagonal matrix `A`\\n    of the eigenvalue problem ``A x = lambda x`` to solve.\\n\\n    >>> A = spdiags(vals, 0, n, n)\\n    >>> A = A.astype(np.int16)\\n    >>> A.toarray()\\n    array([[  1,   0,   0, ...,   0,   0,   0],\\n           [  0,   2,   0, ...,   0,   0,   0],\\n           [  0,   0,   3, ...,   0,   0,   0],\\n           ...,\\n           [  0,   0,   0, ...,  98,   0,   0],\\n           [  0,   0,   0, ...,   0,  99,   0],\\n           [  0,   0,   0, ...,   0,   0, 100]], dtype=int16)\\n\\n    The second mandatory input parameter `X` is a 2D array with the\\n    row dimension determining the number of requested eigenvalues.\\n    `X` is an initial guess for targeted eigenvectors.\\n    `X` must have linearly independent columns.\\n    If no initial approximations available, randomly oriented vectors\\n    commonly work best, e.g., with components normally distributed\\n    around zero or uniformly distributed on the interval [-1 1].\\n    Setting the initial approximations to dtype ``np.float32``\\n    forces all iterative values to dtype ``np.float32`` speeding up\\n    the run while still allowing accurate eigenvalue computations.\\n\\n    >>> k = 1\\n    >>> rng = np.random.default_rng()\\n    >>> X = rng.normal(size=(n, k))\\n    >>> X = X.astype(np.float32)\\n\\n    >>> eigenvalues, _ = lobpcg(A, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n    >>> eigenvalues.dtype\\n    dtype(\\'float32\\')\\n\\n    `lobpcg` needs only access the matrix product with `A` rather\\n    then the matrix itself. Since the matrix `A` is diagonal in\\n    this example, one can write a function of the matrix product\\n    ``A @ X`` using the diagonal values ``vals`` only, e.g., by\\n    element-wise multiplication with broadcasting in the lambda-function\\n\\n    >>> A_lambda = lambda X: vals[:, np.newaxis] * X\\n\\n    or the regular function\\n\\n    >>> def A_matmat(X):\\n    ...     return vals[:, np.newaxis] * X\\n\\n    and use the handle to one of these callables as an input\\n\\n    >>> eigenvalues, _ = lobpcg(A_lambda, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    The traditional callable `LinearOperator` is no longer\\n    necessary but still supported as the input to `lobpcg`.\\n    Specifying ``matmat=A_matmat`` explicitely improves performance. \\n\\n    >>> A_lo = LinearOperator((n, n), matvec=A_matmat, matmat=A_matmat, dtype=np.int16)\\n    >>> eigenvalues, _ = lobpcg(A_lo, X, maxiter=80)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    The least efficient callable option is `aslinearoperator`:\\n\\n    >>> eigenvalues, _ = lobpcg(aslinearoperator(A), X, maxiter=80)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    We now switch to computing the three smallest eigenvalues specifying\\n\\n    >>> k = 3\\n    >>> X = np.random.default_rng().normal(size=(n, k))\\n\\n    and ``largest=False`` parameter\\n\\n    >>> eigenvalues, _ = lobpcg(A, X, largest=False, maxiter=80)\\n    >>> print(eigenvalues)  \\n    [1. 2. 3.]\\n\\n    The next example illustrates computing 3 smallest eigenvalues of\\n    the same matrix `A` given by the function handle ``A_matmat`` but\\n    with constraints and preconditioning.\\n\\n    Constraints - an optional input parameter is a 2D array comprising\\n    of column vectors that the eigenvectors must be orthogonal to\\n\\n    >>> Y = np.eye(n, 3)\\n\\n    The preconditioner acts as the inverse of `A` in this example, but\\n    in the reduced precision ``np.float32`` even though the initial `X`\\n    and thus all iterates and the output are in full ``np.float64``.\\n\\n    >>> inv_vals = 1./vals\\n    >>> inv_vals = inv_vals.astype(np.float32)\\n    >>> M = lambda X: inv_vals[:, np.newaxis] * X\\n\\n    Let us now solve the eigenvalue problem for the matrix `A` first\\n    without preconditioning requesting 80 iterations\\n\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, largest=False, maxiter=80)\\n    >>> eigenvalues\\n    array([4., 5., 6.])\\n    >>> eigenvalues.dtype\\n    dtype(\\'float64\\')\\n\\n    With preconditioning we need only 20 iterations from the same `X`\\n\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, M=M, largest=False, maxiter=20)\\n    >>> eigenvalues\\n    array([4., 5., 6.])\\n\\n    Note that the vectors passed in `Y` are the eigenvectors of the 3\\n    smallest eigenvalues. The results returned above are orthogonal to those.\\n\\n    The primary matrix `A` may be indefinite, e.g., after shifting\\n    ``vals`` by 50 from 1, ..., 100 to -49, ..., 50, we still can compute\\n    the 3 smallest or largest eigenvalues.\\n\\n    >>> vals = vals - 50\\n    >>> X = rng.normal(size=(n, k))\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=False, maxiter=99)\\n    >>> eigenvalues\\n    array([-49., -48., -47.])\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=True, maxiter=99)\\n    >>> eigenvalues\\n    array([50., 49., 48.])\\n\\n    '\n    blockVectorX = X\n    bestblockVectorX = blockVectorX\n    blockVectorY = Y\n    residualTolerance = tol\n    if maxiter is None:\n        maxiter = 20\n    bestIterationNumber = maxiter\n    sizeY = 0\n    if blockVectorY is not None:\n        if len(blockVectorY.shape) != 2:\n            warnings.warn(f'Expected rank-2 array for argument Y, instead got {len(blockVectorY.shape)}, so ignore it and use no constraints.', UserWarning, stacklevel=2)\n            blockVectorY = None\n        else:\n            sizeY = blockVectorY.shape[1]\n    if blockVectorX is None:\n        raise ValueError('The mandatory initial matrix X cannot be None')\n    if len(blockVectorX.shape) != 2:\n        raise ValueError('expected rank-2 array for argument X')\n    (n, sizeX) = blockVectorX.shape\n    if not np.issubdtype(blockVectorX.dtype, np.inexact):\n        warnings.warn(f'Data type for argument X is {blockVectorX.dtype}, which is not inexact, so casted to np.float32.', UserWarning, stacklevel=2)\n        blockVectorX = np.asarray(blockVectorX, dtype=np.float32)\n    if retLambdaHistory:\n        lambdaHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if retResidualNormsHistory:\n        residualNormsHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if verbosityLevel:\n        aux = 'Solving '\n        if B is None:\n            aux += 'standard'\n        else:\n            aux += 'generalized'\n        aux += ' eigenvalue problem with'\n        if M is None:\n            aux += 'out'\n        aux += ' preconditioning\\n\\n'\n        aux += 'matrix size %d\\n' % n\n        aux += 'block size %d\\n\\n' % sizeX\n        if blockVectorY is None:\n            aux += 'No constraints\\n\\n'\n        elif sizeY > 1:\n            aux += '%d constraints\\n\\n' % sizeY\n        else:\n            aux += '%d constraint\\n\\n' % sizeY\n        print(aux)\n    if n - sizeY < 5 * sizeX:\n        warnings.warn(f'The problem size {n} minus the constraints size {sizeY} is too small relative to the block size {sizeX}. Using a dense eigensolver instead of LOBPCG iterations.No output of the history of the iterations.', UserWarning, stacklevel=2)\n        sizeX = min(sizeX, n)\n        if blockVectorY is not None:\n            raise NotImplementedError('The dense eigensolver does not support constraints.')\n        if largest:\n            eigvals = (n - sizeX, n - 1)\n        else:\n            eigvals = (0, sizeX - 1)\n        try:\n            if isinstance(A, LinearOperator):\n                A = A(np.eye(n, dtype=int))\n            elif callable(A):\n                A = A(np.eye(n, dtype=int))\n                if A.shape != (n, n):\n                    raise ValueError(f'The shape {A.shape} of the primary matrix\\ndefined by a callable object is wrong.\\n')\n            elif issparse(A):\n                A = A.toarray()\n            else:\n                A = np.asarray(A)\n        except Exception as e:\n            raise Exception(f'Primary MatMul call failed with error\\n{e}\\n')\n        if B is not None:\n            try:\n                if isinstance(B, LinearOperator):\n                    B = B(np.eye(n, dtype=int))\n                elif callable(B):\n                    B = B(np.eye(n, dtype=int))\n                    if B.shape != (n, n):\n                        raise ValueError(f'The shape {B.shape} of the secondary matrix\\ndefined by a callable object is wrong.\\n')\n                elif issparse(B):\n                    B = B.toarray()\n                else:\n                    B = np.asarray(B)\n            except Exception as e:\n                raise Exception(f'Secondary MatMul call failed with error\\n{e}\\n')\n        try:\n            (vals, vecs) = eigh(A, B, subset_by_index=eigvals, check_finite=False)\n            if largest:\n                vals = vals[::-1]\n                vecs = vecs[:, ::-1]\n            return (vals, vecs)\n        except Exception as e:\n            raise Exception(f'Dense eigensolver failed with error\\n{e}\\n')\n    if residualTolerance is None or residualTolerance <= 0.0:\n        residualTolerance = np.sqrt(np.finfo(blockVectorX.dtype).eps) * n\n    A = _makeMatMat(A)\n    B = _makeMatMat(B)\n    M = _makeMatMat(M)\n    if blockVectorY is not None:\n        if B is not None:\n            blockVectorBY = B(blockVectorY)\n            if blockVectorBY.shape != blockVectorY.shape:\n                raise ValueError(f'The shape {blockVectorY.shape} of the constraint not preserved\\nand changed to {blockVectorBY.shape} after multiplying by the secondary matrix.\\n')\n        else:\n            blockVectorBY = blockVectorY\n        gramYBY = blockVectorY.T.conj() @ blockVectorBY\n        try:\n            gramYBY = cho_factor(gramYBY, overwrite_a=True)\n        except LinAlgError as e:\n            raise ValueError('Linearly dependent constraints') from e\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    (blockVectorX, blockVectorBX, _) = _b_orthonormalize(B, blockVectorX, verbosityLevel=verbosityLevel)\n    if blockVectorX is None:\n        raise ValueError('Linearly dependent initial approximations')\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the initial approximations not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = blockVectorX.T.conj() @ blockVectorAX\n    (_lambda, eigBlockVector) = eigh(gramXAX, check_finite=False)\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    if retLambdaHistory:\n        lambdaHistory[0, :] = _lambda\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = _matmul_inplace(blockVectorX, eigBlockVector, verbosityLevel=verbosityLevel)\n    blockVectorAX = _matmul_inplace(blockVectorAX, eigBlockVector, verbosityLevel=verbosityLevel)\n    if B is not None:\n        blockVectorBX = _matmul_inplace(blockVectorBX, eigBlockVector, verbosityLevel=verbosityLevel)\n    activeMask = np.ones((sizeX,), dtype=bool)\n    blockVectorP = None\n    blockVectorAP = None\n    blockVectorBP = None\n    smallestResidualNorm = np.abs(np.finfo(blockVectorX.dtype).max)\n    iterationNumber = -1\n    restart = True\n    forcedRestart = False\n    explicitGramFlag = False\n    while iterationNumber < maxiter:\n        iterationNumber += 1\n        if B is not None:\n            aux = blockVectorBX * _lambda[np.newaxis, :]\n        else:\n            aux = blockVectorX * _lambda[np.newaxis, :]\n        blockVectorR = blockVectorAX - aux\n        aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n        residualNorms = np.sqrt(np.abs(aux))\n        if retResidualNormsHistory:\n            residualNormsHistory[iterationNumber, :] = residualNorms\n        residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n        if residualNorm < smallestResidualNorm:\n            smallestResidualNorm = residualNorm\n            bestIterationNumber = iterationNumber\n            bestblockVectorX = blockVectorX\n        elif residualNorm > 2 ** restartControl * smallestResidualNorm:\n            forcedRestart = True\n            blockVectorAX = A(blockVectorX)\n            if blockVectorAX.shape != blockVectorX.shape:\n                raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n            if B is not None:\n                blockVectorBX = B(blockVectorX)\n                if blockVectorBX.shape != blockVectorX.shape:\n                    raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n        ii = np.where(residualNorms > residualTolerance, True, False)\n        activeMask = activeMask & ii\n        currentBlockSize = activeMask.sum()\n        if verbosityLevel:\n            print(f'iteration {iterationNumber}')\n            print(f'current block size: {currentBlockSize}')\n            print(f'eigenvalue(s):\\n{_lambda}')\n            print(f'residual norm(s):\\n{residualNorms}')\n        if currentBlockSize == 0:\n            break\n        activeBlockVectorR = _as2d(blockVectorR[:, activeMask])\n        if iterationNumber > 0:\n            activeBlockVectorP = _as2d(blockVectorP[:, activeMask])\n            activeBlockVectorAP = _as2d(blockVectorAP[:, activeMask])\n            if B is not None:\n                activeBlockVectorBP = _as2d(blockVectorBP[:, activeMask])\n        if M is not None:\n            activeBlockVectorR = M(activeBlockVectorR)\n        if blockVectorY is not None:\n            _applyConstraints(activeBlockVectorR, gramYBY, blockVectorBY, blockVectorY)\n        if B is not None:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorBX.T.conj() @ activeBlockVectorR)\n        else:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorX.T.conj() @ activeBlockVectorR)\n        aux = _b_orthonormalize(B, activeBlockVectorR, verbosityLevel=verbosityLevel)\n        (activeBlockVectorR, activeBlockVectorBR, _) = aux\n        if activeBlockVectorR is None:\n            warnings.warn(f'Failed at iteration {iterationNumber} with accuracies {residualNorms}\\n not reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n            break\n        activeBlockVectorAR = A(activeBlockVectorR)\n        if iterationNumber > 0:\n            if B is not None:\n                aux = _b_orthonormalize(B, activeBlockVectorP, activeBlockVectorBP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, activeBlockVectorBP, invR) = aux\n            else:\n                aux = _b_orthonormalize(B, activeBlockVectorP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, _, invR) = aux\n            if activeBlockVectorP is not None:\n                activeBlockVectorAP = _matmul_inplace(activeBlockVectorAP, invR, verbosityLevel=verbosityLevel)\n                restart = forcedRestart\n            else:\n                restart = True\n        if activeBlockVectorAR.dtype == 'float32':\n            myeps = 1\n        else:\n            myeps = np.sqrt(np.finfo(activeBlockVectorR.dtype).eps)\n        if residualNorms.max() > myeps and (not explicitGramFlag):\n            explicitGramFlag = False\n        else:\n            explicitGramFlag = True\n        if B is None:\n            blockVectorBX = blockVectorX\n            activeBlockVectorBR = activeBlockVectorR\n            if not restart:\n                activeBlockVectorBP = activeBlockVectorP\n        gramXAR = np.dot(blockVectorX.T.conj(), activeBlockVectorAR)\n        gramRAR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAR)\n        gramDtype = activeBlockVectorAR.dtype\n        if explicitGramFlag:\n            gramRAR = (gramRAR + gramRAR.T.conj()) / 2\n            gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n            gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n            gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n            gramRBR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBR)\n            gramXBR = np.dot(blockVectorX.T.conj(), activeBlockVectorBR)\n        else:\n            gramXAX = np.diag(_lambda).astype(gramDtype)\n            gramXBX = np.eye(sizeX, dtype=gramDtype)\n            gramRBR = np.eye(currentBlockSize, dtype=gramDtype)\n            gramXBR = np.zeros((sizeX, currentBlockSize), dtype=gramDtype)\n        if not restart:\n            gramXAP = np.dot(blockVectorX.T.conj(), activeBlockVectorAP)\n            gramRAP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAP)\n            gramPAP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorAP)\n            gramXBP = np.dot(blockVectorX.T.conj(), activeBlockVectorBP)\n            gramRBP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBP)\n            if explicitGramFlag:\n                gramPAP = (gramPAP + gramPAP.T.conj()) / 2\n                gramPBP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorBP)\n            else:\n                gramPBP = np.eye(currentBlockSize, dtype=gramDtype)\n            gramA = np.block([[gramXAX, gramXAR, gramXAP], [gramXAR.T.conj(), gramRAR, gramRAP], [gramXAP.T.conj(), gramRAP.T.conj(), gramPAP]])\n            gramB = np.block([[gramXBX, gramXBR, gramXBP], [gramXBR.T.conj(), gramRBR, gramRBP], [gramXBP.T.conj(), gramRBP.T.conj(), gramPBP]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                if verbosityLevel:\n                    warnings.warn(f'eigh failed at iteration {iterationNumber} \\nwith error {e} causing a restart.\\n', UserWarning, stacklevel=2)\n                restart = True\n        if restart:\n            gramA = np.block([[gramXAX, gramXAR], [gramXAR.T.conj(), gramRAR]])\n            gramB = np.block([[gramXBX, gramXBR], [gramXBR.T.conj(), gramRBR]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                warnings.warn(f'eigh failed at iteration {iterationNumber} with error\\n{e}\\n', UserWarning, stacklevel=2)\n                break\n        ii = _get_indx(_lambda, sizeX, largest)\n        _lambda = _lambda[ii]\n        eigBlockVector = eigBlockVector[:, ii]\n        if retLambdaHistory:\n            lambdaHistory[iterationNumber + 1, :] = _lambda\n        if B is not None:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n                bpp += np.dot(activeBlockVectorBP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            blockVectorBX = np.dot(blockVectorBX, eigBlockVectorX) + bpp\n            (blockVectorP, blockVectorAP, blockVectorBP) = (pp, app, bpp)\n        else:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            (blockVectorP, blockVectorAP) = (pp, app)\n    if B is not None:\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[iterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[iterationNumber + 1, :] = residualNorms\n    residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n    if residualNorm < smallestResidualNorm:\n        smallestResidualNorm = residualNorm\n        bestIterationNumber = iterationNumber + 1\n        bestblockVectorX = blockVectorX\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited at iteration {iterationNumber} with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.\\nUse iteration {bestIterationNumber} instead with accuracy \\n{smallestResidualNorm}.\\n', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final iterative eigenvalue(s):\\n{_lambda}')\n        print(f'Final iterative residual norm(s):\\n{residualNorms}')\n    blockVectorX = bestblockVectorX\n    if blockVectorY is not None:\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n    blockVectorBX = blockVectorX\n    if B is not None:\n        blockVectorBX = B(blockVectorX)\n        if blockVectorBX.shape != blockVectorX.shape:\n            raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n    gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n    _handle_gramA_gramB_verbosity(gramXAX, gramXBX, verbosityLevel)\n    gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n    gramXBX = (gramXBX + gramXBX.T.conj()) / 2\n    try:\n        (_lambda, eigBlockVector) = eigh(gramXAX, gramXBX, check_finite=False)\n    except LinAlgError as e:\n        raise ValueError('eigh has failed in lobpcg postprocessing') from e\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = np.dot(blockVectorX, eigBlockVector)\n    blockVectorAX = np.dot(blockVectorAX, eigBlockVector)\n    if B is not None:\n        blockVectorBX = np.dot(blockVectorBX, eigBlockVector)\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[bestIterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[bestIterationNumber + 1, :] = residualNorms\n    if retLambdaHistory:\n        lambdaHistory = lambdaHistory[:bestIterationNumber + 2, :]\n    if retResidualNormsHistory:\n        residualNormsHistory = residualNormsHistory[:bestIterationNumber + 2, :]\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited postprocessing with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final postprocessing eigenvalue(s):\\n{_lambda}')\n        print(f'Final residual norm(s):\\n{residualNorms}')\n    if retLambdaHistory:\n        lambdaHistory = np.vsplit(lambdaHistory, np.shape(lambdaHistory)[0])\n        lambdaHistory = [np.squeeze(i) for i in lambdaHistory]\n    if retResidualNormsHistory:\n        residualNormsHistory = np.vsplit(residualNormsHistory, np.shape(residualNormsHistory)[0])\n        residualNormsHistory = [np.squeeze(i) for i in residualNormsHistory]\n    if retLambdaHistory:\n        if retResidualNormsHistory:\n            return (_lambda, blockVectorX, lambdaHistory, residualNormsHistory)\n        else:\n            return (_lambda, blockVectorX, lambdaHistory)\n    elif retResidualNormsHistory:\n        return (_lambda, blockVectorX, residualNormsHistory)\n    else:\n        return (_lambda, blockVectorX)",
            "def lobpcg(A, X, B=None, M=None, Y=None, tol=None, maxiter=None, largest=True, verbosityLevel=0, retLambdaHistory=False, retResidualNormsHistory=False, restartControl=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG).\\n\\n    LOBPCG is a preconditioned eigensolver for large real symmetric and complex\\n    Hermitian definite generalized eigenproblems.\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator, callable object}\\n        The Hermitian linear operator of the problem, usually given by a\\n        sparse matrix.  Often called the \"stiffness matrix\".\\n    X : ndarray, float32 or float64\\n        Initial approximation to the ``k`` eigenvectors (non-sparse).\\n        If `A` has ``shape=(n,n)`` then `X` must have ``shape=(n,k)``.\\n    B : {sparse matrix, ndarray, LinearOperator, callable object}\\n        Optional. By default ``B = None``, which is equivalent to identity.\\n        The right hand side operator in a generalized eigenproblem if present.\\n        Often called the \"mass matrix\". Must be Hermitian positive definite.\\n    M : {sparse matrix, ndarray, LinearOperator, callable object}\\n        Optional. By default ``M = None``, which is equivalent to identity.\\n        Preconditioner aiming to accelerate convergence.\\n    Y : ndarray, float32 or float64, default: None\\n        An ``n-by-sizeY`` ndarray of constraints with ``sizeY < n``.\\n        The iterations will be performed in the ``B``-orthogonal complement\\n        of the column-space of `Y`. `Y` must be full rank if present.\\n    tol : scalar, optional\\n        The default is ``tol=n*sqrt(eps)``.\\n        Solver tolerance for the stopping criterion.\\n    maxiter : int, default: 20\\n        Maximum number of iterations.\\n    largest : bool, default: True\\n        When True, solve for the largest eigenvalues, otherwise the smallest.\\n    verbosityLevel : int, optional\\n        By default ``verbosityLevel=0`` no output.\\n        Controls the solver standard/screen output.\\n    retLambdaHistory : bool, default: False\\n        Whether to return iterative eigenvalue history.\\n    retResidualNormsHistory : bool, default: False\\n        Whether to return iterative history of residual norms.\\n    restartControl : int, optional.\\n        Iterations restart if the residuals jump ``2**restartControl`` times\\n        compared to the smallest recorded in ``retResidualNormsHistory``.\\n        The default is ``restartControl=20``, making the restarts rare for\\n        backward compatibility.\\n\\n    Returns\\n    -------\\n    lambda : ndarray of the shape ``(k, )``.\\n        Array of ``k`` approximate eigenvalues.\\n    v : ndarray of the same shape as ``X.shape``.\\n        An array of ``k`` approximate eigenvectors.\\n    lambdaHistory : ndarray, optional.\\n        The eigenvalue history, if `retLambdaHistory` is ``True``.\\n    ResidualNormsHistory : ndarray, optional.\\n        The history of residual norms, if `retResidualNormsHistory`\\n        is ``True``.\\n\\n    Notes\\n    -----\\n    The iterative loop runs ``maxit=maxiter`` (20 if ``maxit=None``)\\n    iterations at most and finishes earler if the tolerance is met.\\n    Breaking backward compatibility with the previous version, LOBPCG\\n    now returns the block of iterative vectors with the best accuracy rather\\n    than the last one iterated, as a cure for possible divergence.\\n\\n    If ``X.dtype == np.float32`` and user-provided operations/multiplications\\n    by `A`, `B`, and `M` all preserve the ``np.float32`` data type,\\n    all the calculations and the output are in ``np.float32``.\\n\\n    The size of the iteration history output equals to the number of the best\\n    (limited by `maxit`) iterations plus 3: initial, final, and postprocessing.\\n\\n    If both `retLambdaHistory` and `retResidualNormsHistory` are ``True``,\\n    the return tuple has the following format\\n    ``(lambda, V, lambda history, residual norms history)``.\\n\\n    In the following ``n`` denotes the matrix size and ``k`` the number\\n    of required eigenvalues (smallest or largest).\\n\\n    The LOBPCG code internally solves eigenproblems of the size ``3k`` on every\\n    iteration by calling the dense eigensolver `eigh`, so if ``k`` is not\\n    small enough compared to ``n``, it makes no sense to call the LOBPCG code.\\n    Moreover, if one calls the LOBPCG algorithm for ``5k > n``, it would likely\\n    break internally, so the code calls the standard function `eigh` instead.\\n    It is not that ``n`` should be large for the LOBPCG to work, but rather the\\n    ratio ``n / k`` should be large. It you call LOBPCG with ``k=1``\\n    and ``n=10``, it works though ``n`` is small. The method is intended\\n    for extremely large ``n / k``.\\n\\n    The convergence speed depends basically on three factors:\\n\\n    1. Quality of the initial approximations `X` to the seeking eigenvectors.\\n       Randomly distributed around the origin vectors work well if no better\\n       choice is known.\\n\\n    2. Relative separation of the desired eigenvalues from the rest\\n       of the eigenvalues. One can vary ``k`` to improve the separation.\\n\\n    3. Proper preconditioning to shrink the spectral spread.\\n       For example, a rod vibration test problem (under tests\\n       directory) is ill-conditioned for large ``n``, so convergence will be\\n       slow, unless efficient preconditioning is used. For this specific\\n       problem, a good simple preconditioner function would be a linear solve\\n       for `A`, which is easy to code since `A` is tridiagonal.\\n\\n    References\\n    ----------\\n    .. [1] A. V. Knyazev (2001),\\n           Toward the Optimal Preconditioned Eigensolver: Locally Optimal\\n           Block Preconditioned Conjugate Gradient Method.\\n           SIAM Journal on Scientific Computing 23, no. 2,\\n           pp. 517-541. :doi:`10.1137/S1064827500366124`\\n\\n    .. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov\\n           (2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers\\n           (BLOPEX) in hypre and PETSc. :arxiv:`0705.2626`\\n\\n    .. [3] A. V. Knyazev\\'s C and MATLAB implementations:\\n           https://github.com/lobpcg/blopex\\n\\n    Examples\\n    --------\\n    Our first example is minimalistic - find the largest eigenvalue of\\n    a diagonal matrix by solving the non-generalized eigenvalue problem\\n    ``A x = lambda x`` without constraints or preconditioning.\\n\\n    >>> import numpy as np\\n    >>> from scipy.sparse import spdiags\\n    >>> from scipy.sparse.linalg import LinearOperator, aslinearoperator\\n    >>> from scipy.sparse.linalg import lobpcg\\n\\n    The square matrix size is\\n\\n    >>> n = 100\\n\\n    and its diagonal entries are 1, ..., 100 defined by\\n\\n    >>> vals = np.arange(1, n + 1).astype(np.int16)\\n\\n    The first mandatory input parameter in this test is\\n    the sparse diagonal matrix `A`\\n    of the eigenvalue problem ``A x = lambda x`` to solve.\\n\\n    >>> A = spdiags(vals, 0, n, n)\\n    >>> A = A.astype(np.int16)\\n    >>> A.toarray()\\n    array([[  1,   0,   0, ...,   0,   0,   0],\\n           [  0,   2,   0, ...,   0,   0,   0],\\n           [  0,   0,   3, ...,   0,   0,   0],\\n           ...,\\n           [  0,   0,   0, ...,  98,   0,   0],\\n           [  0,   0,   0, ...,   0,  99,   0],\\n           [  0,   0,   0, ...,   0,   0, 100]], dtype=int16)\\n\\n    The second mandatory input parameter `X` is a 2D array with the\\n    row dimension determining the number of requested eigenvalues.\\n    `X` is an initial guess for targeted eigenvectors.\\n    `X` must have linearly independent columns.\\n    If no initial approximations available, randomly oriented vectors\\n    commonly work best, e.g., with components normally distributed\\n    around zero or uniformly distributed on the interval [-1 1].\\n    Setting the initial approximations to dtype ``np.float32``\\n    forces all iterative values to dtype ``np.float32`` speeding up\\n    the run while still allowing accurate eigenvalue computations.\\n\\n    >>> k = 1\\n    >>> rng = np.random.default_rng()\\n    >>> X = rng.normal(size=(n, k))\\n    >>> X = X.astype(np.float32)\\n\\n    >>> eigenvalues, _ = lobpcg(A, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n    >>> eigenvalues.dtype\\n    dtype(\\'float32\\')\\n\\n    `lobpcg` needs only access the matrix product with `A` rather\\n    then the matrix itself. Since the matrix `A` is diagonal in\\n    this example, one can write a function of the matrix product\\n    ``A @ X`` using the diagonal values ``vals`` only, e.g., by\\n    element-wise multiplication with broadcasting in the lambda-function\\n\\n    >>> A_lambda = lambda X: vals[:, np.newaxis] * X\\n\\n    or the regular function\\n\\n    >>> def A_matmat(X):\\n    ...     return vals[:, np.newaxis] * X\\n\\n    and use the handle to one of these callables as an input\\n\\n    >>> eigenvalues, _ = lobpcg(A_lambda, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    The traditional callable `LinearOperator` is no longer\\n    necessary but still supported as the input to `lobpcg`.\\n    Specifying ``matmat=A_matmat`` explicitely improves performance. \\n\\n    >>> A_lo = LinearOperator((n, n), matvec=A_matmat, matmat=A_matmat, dtype=np.int16)\\n    >>> eigenvalues, _ = lobpcg(A_lo, X, maxiter=80)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    The least efficient callable option is `aslinearoperator`:\\n\\n    >>> eigenvalues, _ = lobpcg(aslinearoperator(A), X, maxiter=80)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    We now switch to computing the three smallest eigenvalues specifying\\n\\n    >>> k = 3\\n    >>> X = np.random.default_rng().normal(size=(n, k))\\n\\n    and ``largest=False`` parameter\\n\\n    >>> eigenvalues, _ = lobpcg(A, X, largest=False, maxiter=80)\\n    >>> print(eigenvalues)  \\n    [1. 2. 3.]\\n\\n    The next example illustrates computing 3 smallest eigenvalues of\\n    the same matrix `A` given by the function handle ``A_matmat`` but\\n    with constraints and preconditioning.\\n\\n    Constraints - an optional input parameter is a 2D array comprising\\n    of column vectors that the eigenvectors must be orthogonal to\\n\\n    >>> Y = np.eye(n, 3)\\n\\n    The preconditioner acts as the inverse of `A` in this example, but\\n    in the reduced precision ``np.float32`` even though the initial `X`\\n    and thus all iterates and the output are in full ``np.float64``.\\n\\n    >>> inv_vals = 1./vals\\n    >>> inv_vals = inv_vals.astype(np.float32)\\n    >>> M = lambda X: inv_vals[:, np.newaxis] * X\\n\\n    Let us now solve the eigenvalue problem for the matrix `A` first\\n    without preconditioning requesting 80 iterations\\n\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, largest=False, maxiter=80)\\n    >>> eigenvalues\\n    array([4., 5., 6.])\\n    >>> eigenvalues.dtype\\n    dtype(\\'float64\\')\\n\\n    With preconditioning we need only 20 iterations from the same `X`\\n\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, M=M, largest=False, maxiter=20)\\n    >>> eigenvalues\\n    array([4., 5., 6.])\\n\\n    Note that the vectors passed in `Y` are the eigenvectors of the 3\\n    smallest eigenvalues. The results returned above are orthogonal to those.\\n\\n    The primary matrix `A` may be indefinite, e.g., after shifting\\n    ``vals`` by 50 from 1, ..., 100 to -49, ..., 50, we still can compute\\n    the 3 smallest or largest eigenvalues.\\n\\n    >>> vals = vals - 50\\n    >>> X = rng.normal(size=(n, k))\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=False, maxiter=99)\\n    >>> eigenvalues\\n    array([-49., -48., -47.])\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=True, maxiter=99)\\n    >>> eigenvalues\\n    array([50., 49., 48.])\\n\\n    '\n    blockVectorX = X\n    bestblockVectorX = blockVectorX\n    blockVectorY = Y\n    residualTolerance = tol\n    if maxiter is None:\n        maxiter = 20\n    bestIterationNumber = maxiter\n    sizeY = 0\n    if blockVectorY is not None:\n        if len(blockVectorY.shape) != 2:\n            warnings.warn(f'Expected rank-2 array for argument Y, instead got {len(blockVectorY.shape)}, so ignore it and use no constraints.', UserWarning, stacklevel=2)\n            blockVectorY = None\n        else:\n            sizeY = blockVectorY.shape[1]\n    if blockVectorX is None:\n        raise ValueError('The mandatory initial matrix X cannot be None')\n    if len(blockVectorX.shape) != 2:\n        raise ValueError('expected rank-2 array for argument X')\n    (n, sizeX) = blockVectorX.shape\n    if not np.issubdtype(blockVectorX.dtype, np.inexact):\n        warnings.warn(f'Data type for argument X is {blockVectorX.dtype}, which is not inexact, so casted to np.float32.', UserWarning, stacklevel=2)\n        blockVectorX = np.asarray(blockVectorX, dtype=np.float32)\n    if retLambdaHistory:\n        lambdaHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if retResidualNormsHistory:\n        residualNormsHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if verbosityLevel:\n        aux = 'Solving '\n        if B is None:\n            aux += 'standard'\n        else:\n            aux += 'generalized'\n        aux += ' eigenvalue problem with'\n        if M is None:\n            aux += 'out'\n        aux += ' preconditioning\\n\\n'\n        aux += 'matrix size %d\\n' % n\n        aux += 'block size %d\\n\\n' % sizeX\n        if blockVectorY is None:\n            aux += 'No constraints\\n\\n'\n        elif sizeY > 1:\n            aux += '%d constraints\\n\\n' % sizeY\n        else:\n            aux += '%d constraint\\n\\n' % sizeY\n        print(aux)\n    if n - sizeY < 5 * sizeX:\n        warnings.warn(f'The problem size {n} minus the constraints size {sizeY} is too small relative to the block size {sizeX}. Using a dense eigensolver instead of LOBPCG iterations.No output of the history of the iterations.', UserWarning, stacklevel=2)\n        sizeX = min(sizeX, n)\n        if blockVectorY is not None:\n            raise NotImplementedError('The dense eigensolver does not support constraints.')\n        if largest:\n            eigvals = (n - sizeX, n - 1)\n        else:\n            eigvals = (0, sizeX - 1)\n        try:\n            if isinstance(A, LinearOperator):\n                A = A(np.eye(n, dtype=int))\n            elif callable(A):\n                A = A(np.eye(n, dtype=int))\n                if A.shape != (n, n):\n                    raise ValueError(f'The shape {A.shape} of the primary matrix\\ndefined by a callable object is wrong.\\n')\n            elif issparse(A):\n                A = A.toarray()\n            else:\n                A = np.asarray(A)\n        except Exception as e:\n            raise Exception(f'Primary MatMul call failed with error\\n{e}\\n')\n        if B is not None:\n            try:\n                if isinstance(B, LinearOperator):\n                    B = B(np.eye(n, dtype=int))\n                elif callable(B):\n                    B = B(np.eye(n, dtype=int))\n                    if B.shape != (n, n):\n                        raise ValueError(f'The shape {B.shape} of the secondary matrix\\ndefined by a callable object is wrong.\\n')\n                elif issparse(B):\n                    B = B.toarray()\n                else:\n                    B = np.asarray(B)\n            except Exception as e:\n                raise Exception(f'Secondary MatMul call failed with error\\n{e}\\n')\n        try:\n            (vals, vecs) = eigh(A, B, subset_by_index=eigvals, check_finite=False)\n            if largest:\n                vals = vals[::-1]\n                vecs = vecs[:, ::-1]\n            return (vals, vecs)\n        except Exception as e:\n            raise Exception(f'Dense eigensolver failed with error\\n{e}\\n')\n    if residualTolerance is None or residualTolerance <= 0.0:\n        residualTolerance = np.sqrt(np.finfo(blockVectorX.dtype).eps) * n\n    A = _makeMatMat(A)\n    B = _makeMatMat(B)\n    M = _makeMatMat(M)\n    if blockVectorY is not None:\n        if B is not None:\n            blockVectorBY = B(blockVectorY)\n            if blockVectorBY.shape != blockVectorY.shape:\n                raise ValueError(f'The shape {blockVectorY.shape} of the constraint not preserved\\nand changed to {blockVectorBY.shape} after multiplying by the secondary matrix.\\n')\n        else:\n            blockVectorBY = blockVectorY\n        gramYBY = blockVectorY.T.conj() @ blockVectorBY\n        try:\n            gramYBY = cho_factor(gramYBY, overwrite_a=True)\n        except LinAlgError as e:\n            raise ValueError('Linearly dependent constraints') from e\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    (blockVectorX, blockVectorBX, _) = _b_orthonormalize(B, blockVectorX, verbosityLevel=verbosityLevel)\n    if blockVectorX is None:\n        raise ValueError('Linearly dependent initial approximations')\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the initial approximations not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = blockVectorX.T.conj() @ blockVectorAX\n    (_lambda, eigBlockVector) = eigh(gramXAX, check_finite=False)\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    if retLambdaHistory:\n        lambdaHistory[0, :] = _lambda\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = _matmul_inplace(blockVectorX, eigBlockVector, verbosityLevel=verbosityLevel)\n    blockVectorAX = _matmul_inplace(blockVectorAX, eigBlockVector, verbosityLevel=verbosityLevel)\n    if B is not None:\n        blockVectorBX = _matmul_inplace(blockVectorBX, eigBlockVector, verbosityLevel=verbosityLevel)\n    activeMask = np.ones((sizeX,), dtype=bool)\n    blockVectorP = None\n    blockVectorAP = None\n    blockVectorBP = None\n    smallestResidualNorm = np.abs(np.finfo(blockVectorX.dtype).max)\n    iterationNumber = -1\n    restart = True\n    forcedRestart = False\n    explicitGramFlag = False\n    while iterationNumber < maxiter:\n        iterationNumber += 1\n        if B is not None:\n            aux = blockVectorBX * _lambda[np.newaxis, :]\n        else:\n            aux = blockVectorX * _lambda[np.newaxis, :]\n        blockVectorR = blockVectorAX - aux\n        aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n        residualNorms = np.sqrt(np.abs(aux))\n        if retResidualNormsHistory:\n            residualNormsHistory[iterationNumber, :] = residualNorms\n        residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n        if residualNorm < smallestResidualNorm:\n            smallestResidualNorm = residualNorm\n            bestIterationNumber = iterationNumber\n            bestblockVectorX = blockVectorX\n        elif residualNorm > 2 ** restartControl * smallestResidualNorm:\n            forcedRestart = True\n            blockVectorAX = A(blockVectorX)\n            if blockVectorAX.shape != blockVectorX.shape:\n                raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n            if B is not None:\n                blockVectorBX = B(blockVectorX)\n                if blockVectorBX.shape != blockVectorX.shape:\n                    raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n        ii = np.where(residualNorms > residualTolerance, True, False)\n        activeMask = activeMask & ii\n        currentBlockSize = activeMask.sum()\n        if verbosityLevel:\n            print(f'iteration {iterationNumber}')\n            print(f'current block size: {currentBlockSize}')\n            print(f'eigenvalue(s):\\n{_lambda}')\n            print(f'residual norm(s):\\n{residualNorms}')\n        if currentBlockSize == 0:\n            break\n        activeBlockVectorR = _as2d(blockVectorR[:, activeMask])\n        if iterationNumber > 0:\n            activeBlockVectorP = _as2d(blockVectorP[:, activeMask])\n            activeBlockVectorAP = _as2d(blockVectorAP[:, activeMask])\n            if B is not None:\n                activeBlockVectorBP = _as2d(blockVectorBP[:, activeMask])\n        if M is not None:\n            activeBlockVectorR = M(activeBlockVectorR)\n        if blockVectorY is not None:\n            _applyConstraints(activeBlockVectorR, gramYBY, blockVectorBY, blockVectorY)\n        if B is not None:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorBX.T.conj() @ activeBlockVectorR)\n        else:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorX.T.conj() @ activeBlockVectorR)\n        aux = _b_orthonormalize(B, activeBlockVectorR, verbosityLevel=verbosityLevel)\n        (activeBlockVectorR, activeBlockVectorBR, _) = aux\n        if activeBlockVectorR is None:\n            warnings.warn(f'Failed at iteration {iterationNumber} with accuracies {residualNorms}\\n not reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n            break\n        activeBlockVectorAR = A(activeBlockVectorR)\n        if iterationNumber > 0:\n            if B is not None:\n                aux = _b_orthonormalize(B, activeBlockVectorP, activeBlockVectorBP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, activeBlockVectorBP, invR) = aux\n            else:\n                aux = _b_orthonormalize(B, activeBlockVectorP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, _, invR) = aux\n            if activeBlockVectorP is not None:\n                activeBlockVectorAP = _matmul_inplace(activeBlockVectorAP, invR, verbosityLevel=verbosityLevel)\n                restart = forcedRestart\n            else:\n                restart = True\n        if activeBlockVectorAR.dtype == 'float32':\n            myeps = 1\n        else:\n            myeps = np.sqrt(np.finfo(activeBlockVectorR.dtype).eps)\n        if residualNorms.max() > myeps and (not explicitGramFlag):\n            explicitGramFlag = False\n        else:\n            explicitGramFlag = True\n        if B is None:\n            blockVectorBX = blockVectorX\n            activeBlockVectorBR = activeBlockVectorR\n            if not restart:\n                activeBlockVectorBP = activeBlockVectorP\n        gramXAR = np.dot(blockVectorX.T.conj(), activeBlockVectorAR)\n        gramRAR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAR)\n        gramDtype = activeBlockVectorAR.dtype\n        if explicitGramFlag:\n            gramRAR = (gramRAR + gramRAR.T.conj()) / 2\n            gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n            gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n            gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n            gramRBR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBR)\n            gramXBR = np.dot(blockVectorX.T.conj(), activeBlockVectorBR)\n        else:\n            gramXAX = np.diag(_lambda).astype(gramDtype)\n            gramXBX = np.eye(sizeX, dtype=gramDtype)\n            gramRBR = np.eye(currentBlockSize, dtype=gramDtype)\n            gramXBR = np.zeros((sizeX, currentBlockSize), dtype=gramDtype)\n        if not restart:\n            gramXAP = np.dot(blockVectorX.T.conj(), activeBlockVectorAP)\n            gramRAP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAP)\n            gramPAP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorAP)\n            gramXBP = np.dot(blockVectorX.T.conj(), activeBlockVectorBP)\n            gramRBP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBP)\n            if explicitGramFlag:\n                gramPAP = (gramPAP + gramPAP.T.conj()) / 2\n                gramPBP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorBP)\n            else:\n                gramPBP = np.eye(currentBlockSize, dtype=gramDtype)\n            gramA = np.block([[gramXAX, gramXAR, gramXAP], [gramXAR.T.conj(), gramRAR, gramRAP], [gramXAP.T.conj(), gramRAP.T.conj(), gramPAP]])\n            gramB = np.block([[gramXBX, gramXBR, gramXBP], [gramXBR.T.conj(), gramRBR, gramRBP], [gramXBP.T.conj(), gramRBP.T.conj(), gramPBP]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                if verbosityLevel:\n                    warnings.warn(f'eigh failed at iteration {iterationNumber} \\nwith error {e} causing a restart.\\n', UserWarning, stacklevel=2)\n                restart = True\n        if restart:\n            gramA = np.block([[gramXAX, gramXAR], [gramXAR.T.conj(), gramRAR]])\n            gramB = np.block([[gramXBX, gramXBR], [gramXBR.T.conj(), gramRBR]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                warnings.warn(f'eigh failed at iteration {iterationNumber} with error\\n{e}\\n', UserWarning, stacklevel=2)\n                break\n        ii = _get_indx(_lambda, sizeX, largest)\n        _lambda = _lambda[ii]\n        eigBlockVector = eigBlockVector[:, ii]\n        if retLambdaHistory:\n            lambdaHistory[iterationNumber + 1, :] = _lambda\n        if B is not None:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n                bpp += np.dot(activeBlockVectorBP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            blockVectorBX = np.dot(blockVectorBX, eigBlockVectorX) + bpp\n            (blockVectorP, blockVectorAP, blockVectorBP) = (pp, app, bpp)\n        else:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            (blockVectorP, blockVectorAP) = (pp, app)\n    if B is not None:\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[iterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[iterationNumber + 1, :] = residualNorms\n    residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n    if residualNorm < smallestResidualNorm:\n        smallestResidualNorm = residualNorm\n        bestIterationNumber = iterationNumber + 1\n        bestblockVectorX = blockVectorX\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited at iteration {iterationNumber} with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.\\nUse iteration {bestIterationNumber} instead with accuracy \\n{smallestResidualNorm}.\\n', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final iterative eigenvalue(s):\\n{_lambda}')\n        print(f'Final iterative residual norm(s):\\n{residualNorms}')\n    blockVectorX = bestblockVectorX\n    if blockVectorY is not None:\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n    blockVectorBX = blockVectorX\n    if B is not None:\n        blockVectorBX = B(blockVectorX)\n        if blockVectorBX.shape != blockVectorX.shape:\n            raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n    gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n    _handle_gramA_gramB_verbosity(gramXAX, gramXBX, verbosityLevel)\n    gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n    gramXBX = (gramXBX + gramXBX.T.conj()) / 2\n    try:\n        (_lambda, eigBlockVector) = eigh(gramXAX, gramXBX, check_finite=False)\n    except LinAlgError as e:\n        raise ValueError('eigh has failed in lobpcg postprocessing') from e\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = np.dot(blockVectorX, eigBlockVector)\n    blockVectorAX = np.dot(blockVectorAX, eigBlockVector)\n    if B is not None:\n        blockVectorBX = np.dot(blockVectorBX, eigBlockVector)\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[bestIterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[bestIterationNumber + 1, :] = residualNorms\n    if retLambdaHistory:\n        lambdaHistory = lambdaHistory[:bestIterationNumber + 2, :]\n    if retResidualNormsHistory:\n        residualNormsHistory = residualNormsHistory[:bestIterationNumber + 2, :]\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited postprocessing with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final postprocessing eigenvalue(s):\\n{_lambda}')\n        print(f'Final residual norm(s):\\n{residualNorms}')\n    if retLambdaHistory:\n        lambdaHistory = np.vsplit(lambdaHistory, np.shape(lambdaHistory)[0])\n        lambdaHistory = [np.squeeze(i) for i in lambdaHistory]\n    if retResidualNormsHistory:\n        residualNormsHistory = np.vsplit(residualNormsHistory, np.shape(residualNormsHistory)[0])\n        residualNormsHistory = [np.squeeze(i) for i in residualNormsHistory]\n    if retLambdaHistory:\n        if retResidualNormsHistory:\n            return (_lambda, blockVectorX, lambdaHistory, residualNormsHistory)\n        else:\n            return (_lambda, blockVectorX, lambdaHistory)\n    elif retResidualNormsHistory:\n        return (_lambda, blockVectorX, residualNormsHistory)\n    else:\n        return (_lambda, blockVectorX)",
            "def lobpcg(A, X, B=None, M=None, Y=None, tol=None, maxiter=None, largest=True, verbosityLevel=0, retLambdaHistory=False, retResidualNormsHistory=False, restartControl=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG).\\n\\n    LOBPCG is a preconditioned eigensolver for large real symmetric and complex\\n    Hermitian definite generalized eigenproblems.\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator, callable object}\\n        The Hermitian linear operator of the problem, usually given by a\\n        sparse matrix.  Often called the \"stiffness matrix\".\\n    X : ndarray, float32 or float64\\n        Initial approximation to the ``k`` eigenvectors (non-sparse).\\n        If `A` has ``shape=(n,n)`` then `X` must have ``shape=(n,k)``.\\n    B : {sparse matrix, ndarray, LinearOperator, callable object}\\n        Optional. By default ``B = None``, which is equivalent to identity.\\n        The right hand side operator in a generalized eigenproblem if present.\\n        Often called the \"mass matrix\". Must be Hermitian positive definite.\\n    M : {sparse matrix, ndarray, LinearOperator, callable object}\\n        Optional. By default ``M = None``, which is equivalent to identity.\\n        Preconditioner aiming to accelerate convergence.\\n    Y : ndarray, float32 or float64, default: None\\n        An ``n-by-sizeY`` ndarray of constraints with ``sizeY < n``.\\n        The iterations will be performed in the ``B``-orthogonal complement\\n        of the column-space of `Y`. `Y` must be full rank if present.\\n    tol : scalar, optional\\n        The default is ``tol=n*sqrt(eps)``.\\n        Solver tolerance for the stopping criterion.\\n    maxiter : int, default: 20\\n        Maximum number of iterations.\\n    largest : bool, default: True\\n        When True, solve for the largest eigenvalues, otherwise the smallest.\\n    verbosityLevel : int, optional\\n        By default ``verbosityLevel=0`` no output.\\n        Controls the solver standard/screen output.\\n    retLambdaHistory : bool, default: False\\n        Whether to return iterative eigenvalue history.\\n    retResidualNormsHistory : bool, default: False\\n        Whether to return iterative history of residual norms.\\n    restartControl : int, optional.\\n        Iterations restart if the residuals jump ``2**restartControl`` times\\n        compared to the smallest recorded in ``retResidualNormsHistory``.\\n        The default is ``restartControl=20``, making the restarts rare for\\n        backward compatibility.\\n\\n    Returns\\n    -------\\n    lambda : ndarray of the shape ``(k, )``.\\n        Array of ``k`` approximate eigenvalues.\\n    v : ndarray of the same shape as ``X.shape``.\\n        An array of ``k`` approximate eigenvectors.\\n    lambdaHistory : ndarray, optional.\\n        The eigenvalue history, if `retLambdaHistory` is ``True``.\\n    ResidualNormsHistory : ndarray, optional.\\n        The history of residual norms, if `retResidualNormsHistory`\\n        is ``True``.\\n\\n    Notes\\n    -----\\n    The iterative loop runs ``maxit=maxiter`` (20 if ``maxit=None``)\\n    iterations at most and finishes earler if the tolerance is met.\\n    Breaking backward compatibility with the previous version, LOBPCG\\n    now returns the block of iterative vectors with the best accuracy rather\\n    than the last one iterated, as a cure for possible divergence.\\n\\n    If ``X.dtype == np.float32`` and user-provided operations/multiplications\\n    by `A`, `B`, and `M` all preserve the ``np.float32`` data type,\\n    all the calculations and the output are in ``np.float32``.\\n\\n    The size of the iteration history output equals to the number of the best\\n    (limited by `maxit`) iterations plus 3: initial, final, and postprocessing.\\n\\n    If both `retLambdaHistory` and `retResidualNormsHistory` are ``True``,\\n    the return tuple has the following format\\n    ``(lambda, V, lambda history, residual norms history)``.\\n\\n    In the following ``n`` denotes the matrix size and ``k`` the number\\n    of required eigenvalues (smallest or largest).\\n\\n    The LOBPCG code internally solves eigenproblems of the size ``3k`` on every\\n    iteration by calling the dense eigensolver `eigh`, so if ``k`` is not\\n    small enough compared to ``n``, it makes no sense to call the LOBPCG code.\\n    Moreover, if one calls the LOBPCG algorithm for ``5k > n``, it would likely\\n    break internally, so the code calls the standard function `eigh` instead.\\n    It is not that ``n`` should be large for the LOBPCG to work, but rather the\\n    ratio ``n / k`` should be large. It you call LOBPCG with ``k=1``\\n    and ``n=10``, it works though ``n`` is small. The method is intended\\n    for extremely large ``n / k``.\\n\\n    The convergence speed depends basically on three factors:\\n\\n    1. Quality of the initial approximations `X` to the seeking eigenvectors.\\n       Randomly distributed around the origin vectors work well if no better\\n       choice is known.\\n\\n    2. Relative separation of the desired eigenvalues from the rest\\n       of the eigenvalues. One can vary ``k`` to improve the separation.\\n\\n    3. Proper preconditioning to shrink the spectral spread.\\n       For example, a rod vibration test problem (under tests\\n       directory) is ill-conditioned for large ``n``, so convergence will be\\n       slow, unless efficient preconditioning is used. For this specific\\n       problem, a good simple preconditioner function would be a linear solve\\n       for `A`, which is easy to code since `A` is tridiagonal.\\n\\n    References\\n    ----------\\n    .. [1] A. V. Knyazev (2001),\\n           Toward the Optimal Preconditioned Eigensolver: Locally Optimal\\n           Block Preconditioned Conjugate Gradient Method.\\n           SIAM Journal on Scientific Computing 23, no. 2,\\n           pp. 517-541. :doi:`10.1137/S1064827500366124`\\n\\n    .. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov\\n           (2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers\\n           (BLOPEX) in hypre and PETSc. :arxiv:`0705.2626`\\n\\n    .. [3] A. V. Knyazev\\'s C and MATLAB implementations:\\n           https://github.com/lobpcg/blopex\\n\\n    Examples\\n    --------\\n    Our first example is minimalistic - find the largest eigenvalue of\\n    a diagonal matrix by solving the non-generalized eigenvalue problem\\n    ``A x = lambda x`` without constraints or preconditioning.\\n\\n    >>> import numpy as np\\n    >>> from scipy.sparse import spdiags\\n    >>> from scipy.sparse.linalg import LinearOperator, aslinearoperator\\n    >>> from scipy.sparse.linalg import lobpcg\\n\\n    The square matrix size is\\n\\n    >>> n = 100\\n\\n    and its diagonal entries are 1, ..., 100 defined by\\n\\n    >>> vals = np.arange(1, n + 1).astype(np.int16)\\n\\n    The first mandatory input parameter in this test is\\n    the sparse diagonal matrix `A`\\n    of the eigenvalue problem ``A x = lambda x`` to solve.\\n\\n    >>> A = spdiags(vals, 0, n, n)\\n    >>> A = A.astype(np.int16)\\n    >>> A.toarray()\\n    array([[  1,   0,   0, ...,   0,   0,   0],\\n           [  0,   2,   0, ...,   0,   0,   0],\\n           [  0,   0,   3, ...,   0,   0,   0],\\n           ...,\\n           [  0,   0,   0, ...,  98,   0,   0],\\n           [  0,   0,   0, ...,   0,  99,   0],\\n           [  0,   0,   0, ...,   0,   0, 100]], dtype=int16)\\n\\n    The second mandatory input parameter `X` is a 2D array with the\\n    row dimension determining the number of requested eigenvalues.\\n    `X` is an initial guess for targeted eigenvectors.\\n    `X` must have linearly independent columns.\\n    If no initial approximations available, randomly oriented vectors\\n    commonly work best, e.g., with components normally distributed\\n    around zero or uniformly distributed on the interval [-1 1].\\n    Setting the initial approximations to dtype ``np.float32``\\n    forces all iterative values to dtype ``np.float32`` speeding up\\n    the run while still allowing accurate eigenvalue computations.\\n\\n    >>> k = 1\\n    >>> rng = np.random.default_rng()\\n    >>> X = rng.normal(size=(n, k))\\n    >>> X = X.astype(np.float32)\\n\\n    >>> eigenvalues, _ = lobpcg(A, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n    >>> eigenvalues.dtype\\n    dtype(\\'float32\\')\\n\\n    `lobpcg` needs only access the matrix product with `A` rather\\n    then the matrix itself. Since the matrix `A` is diagonal in\\n    this example, one can write a function of the matrix product\\n    ``A @ X`` using the diagonal values ``vals`` only, e.g., by\\n    element-wise multiplication with broadcasting in the lambda-function\\n\\n    >>> A_lambda = lambda X: vals[:, np.newaxis] * X\\n\\n    or the regular function\\n\\n    >>> def A_matmat(X):\\n    ...     return vals[:, np.newaxis] * X\\n\\n    and use the handle to one of these callables as an input\\n\\n    >>> eigenvalues, _ = lobpcg(A_lambda, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    The traditional callable `LinearOperator` is no longer\\n    necessary but still supported as the input to `lobpcg`.\\n    Specifying ``matmat=A_matmat`` explicitely improves performance. \\n\\n    >>> A_lo = LinearOperator((n, n), matvec=A_matmat, matmat=A_matmat, dtype=np.int16)\\n    >>> eigenvalues, _ = lobpcg(A_lo, X, maxiter=80)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    The least efficient callable option is `aslinearoperator`:\\n\\n    >>> eigenvalues, _ = lobpcg(aslinearoperator(A), X, maxiter=80)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    We now switch to computing the three smallest eigenvalues specifying\\n\\n    >>> k = 3\\n    >>> X = np.random.default_rng().normal(size=(n, k))\\n\\n    and ``largest=False`` parameter\\n\\n    >>> eigenvalues, _ = lobpcg(A, X, largest=False, maxiter=80)\\n    >>> print(eigenvalues)  \\n    [1. 2. 3.]\\n\\n    The next example illustrates computing 3 smallest eigenvalues of\\n    the same matrix `A` given by the function handle ``A_matmat`` but\\n    with constraints and preconditioning.\\n\\n    Constraints - an optional input parameter is a 2D array comprising\\n    of column vectors that the eigenvectors must be orthogonal to\\n\\n    >>> Y = np.eye(n, 3)\\n\\n    The preconditioner acts as the inverse of `A` in this example, but\\n    in the reduced precision ``np.float32`` even though the initial `X`\\n    and thus all iterates and the output are in full ``np.float64``.\\n\\n    >>> inv_vals = 1./vals\\n    >>> inv_vals = inv_vals.astype(np.float32)\\n    >>> M = lambda X: inv_vals[:, np.newaxis] * X\\n\\n    Let us now solve the eigenvalue problem for the matrix `A` first\\n    without preconditioning requesting 80 iterations\\n\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, largest=False, maxiter=80)\\n    >>> eigenvalues\\n    array([4., 5., 6.])\\n    >>> eigenvalues.dtype\\n    dtype(\\'float64\\')\\n\\n    With preconditioning we need only 20 iterations from the same `X`\\n\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, M=M, largest=False, maxiter=20)\\n    >>> eigenvalues\\n    array([4., 5., 6.])\\n\\n    Note that the vectors passed in `Y` are the eigenvectors of the 3\\n    smallest eigenvalues. The results returned above are orthogonal to those.\\n\\n    The primary matrix `A` may be indefinite, e.g., after shifting\\n    ``vals`` by 50 from 1, ..., 100 to -49, ..., 50, we still can compute\\n    the 3 smallest or largest eigenvalues.\\n\\n    >>> vals = vals - 50\\n    >>> X = rng.normal(size=(n, k))\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=False, maxiter=99)\\n    >>> eigenvalues\\n    array([-49., -48., -47.])\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=True, maxiter=99)\\n    >>> eigenvalues\\n    array([50., 49., 48.])\\n\\n    '\n    blockVectorX = X\n    bestblockVectorX = blockVectorX\n    blockVectorY = Y\n    residualTolerance = tol\n    if maxiter is None:\n        maxiter = 20\n    bestIterationNumber = maxiter\n    sizeY = 0\n    if blockVectorY is not None:\n        if len(blockVectorY.shape) != 2:\n            warnings.warn(f'Expected rank-2 array for argument Y, instead got {len(blockVectorY.shape)}, so ignore it and use no constraints.', UserWarning, stacklevel=2)\n            blockVectorY = None\n        else:\n            sizeY = blockVectorY.shape[1]\n    if blockVectorX is None:\n        raise ValueError('The mandatory initial matrix X cannot be None')\n    if len(blockVectorX.shape) != 2:\n        raise ValueError('expected rank-2 array for argument X')\n    (n, sizeX) = blockVectorX.shape\n    if not np.issubdtype(blockVectorX.dtype, np.inexact):\n        warnings.warn(f'Data type for argument X is {blockVectorX.dtype}, which is not inexact, so casted to np.float32.', UserWarning, stacklevel=2)\n        blockVectorX = np.asarray(blockVectorX, dtype=np.float32)\n    if retLambdaHistory:\n        lambdaHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if retResidualNormsHistory:\n        residualNormsHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if verbosityLevel:\n        aux = 'Solving '\n        if B is None:\n            aux += 'standard'\n        else:\n            aux += 'generalized'\n        aux += ' eigenvalue problem with'\n        if M is None:\n            aux += 'out'\n        aux += ' preconditioning\\n\\n'\n        aux += 'matrix size %d\\n' % n\n        aux += 'block size %d\\n\\n' % sizeX\n        if blockVectorY is None:\n            aux += 'No constraints\\n\\n'\n        elif sizeY > 1:\n            aux += '%d constraints\\n\\n' % sizeY\n        else:\n            aux += '%d constraint\\n\\n' % sizeY\n        print(aux)\n    if n - sizeY < 5 * sizeX:\n        warnings.warn(f'The problem size {n} minus the constraints size {sizeY} is too small relative to the block size {sizeX}. Using a dense eigensolver instead of LOBPCG iterations.No output of the history of the iterations.', UserWarning, stacklevel=2)\n        sizeX = min(sizeX, n)\n        if blockVectorY is not None:\n            raise NotImplementedError('The dense eigensolver does not support constraints.')\n        if largest:\n            eigvals = (n - sizeX, n - 1)\n        else:\n            eigvals = (0, sizeX - 1)\n        try:\n            if isinstance(A, LinearOperator):\n                A = A(np.eye(n, dtype=int))\n            elif callable(A):\n                A = A(np.eye(n, dtype=int))\n                if A.shape != (n, n):\n                    raise ValueError(f'The shape {A.shape} of the primary matrix\\ndefined by a callable object is wrong.\\n')\n            elif issparse(A):\n                A = A.toarray()\n            else:\n                A = np.asarray(A)\n        except Exception as e:\n            raise Exception(f'Primary MatMul call failed with error\\n{e}\\n')\n        if B is not None:\n            try:\n                if isinstance(B, LinearOperator):\n                    B = B(np.eye(n, dtype=int))\n                elif callable(B):\n                    B = B(np.eye(n, dtype=int))\n                    if B.shape != (n, n):\n                        raise ValueError(f'The shape {B.shape} of the secondary matrix\\ndefined by a callable object is wrong.\\n')\n                elif issparse(B):\n                    B = B.toarray()\n                else:\n                    B = np.asarray(B)\n            except Exception as e:\n                raise Exception(f'Secondary MatMul call failed with error\\n{e}\\n')\n        try:\n            (vals, vecs) = eigh(A, B, subset_by_index=eigvals, check_finite=False)\n            if largest:\n                vals = vals[::-1]\n                vecs = vecs[:, ::-1]\n            return (vals, vecs)\n        except Exception as e:\n            raise Exception(f'Dense eigensolver failed with error\\n{e}\\n')\n    if residualTolerance is None or residualTolerance <= 0.0:\n        residualTolerance = np.sqrt(np.finfo(blockVectorX.dtype).eps) * n\n    A = _makeMatMat(A)\n    B = _makeMatMat(B)\n    M = _makeMatMat(M)\n    if blockVectorY is not None:\n        if B is not None:\n            blockVectorBY = B(blockVectorY)\n            if blockVectorBY.shape != blockVectorY.shape:\n                raise ValueError(f'The shape {blockVectorY.shape} of the constraint not preserved\\nand changed to {blockVectorBY.shape} after multiplying by the secondary matrix.\\n')\n        else:\n            blockVectorBY = blockVectorY\n        gramYBY = blockVectorY.T.conj() @ blockVectorBY\n        try:\n            gramYBY = cho_factor(gramYBY, overwrite_a=True)\n        except LinAlgError as e:\n            raise ValueError('Linearly dependent constraints') from e\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    (blockVectorX, blockVectorBX, _) = _b_orthonormalize(B, blockVectorX, verbosityLevel=verbosityLevel)\n    if blockVectorX is None:\n        raise ValueError('Linearly dependent initial approximations')\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the initial approximations not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = blockVectorX.T.conj() @ blockVectorAX\n    (_lambda, eigBlockVector) = eigh(gramXAX, check_finite=False)\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    if retLambdaHistory:\n        lambdaHistory[0, :] = _lambda\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = _matmul_inplace(blockVectorX, eigBlockVector, verbosityLevel=verbosityLevel)\n    blockVectorAX = _matmul_inplace(blockVectorAX, eigBlockVector, verbosityLevel=verbosityLevel)\n    if B is not None:\n        blockVectorBX = _matmul_inplace(blockVectorBX, eigBlockVector, verbosityLevel=verbosityLevel)\n    activeMask = np.ones((sizeX,), dtype=bool)\n    blockVectorP = None\n    blockVectorAP = None\n    blockVectorBP = None\n    smallestResidualNorm = np.abs(np.finfo(blockVectorX.dtype).max)\n    iterationNumber = -1\n    restart = True\n    forcedRestart = False\n    explicitGramFlag = False\n    while iterationNumber < maxiter:\n        iterationNumber += 1\n        if B is not None:\n            aux = blockVectorBX * _lambda[np.newaxis, :]\n        else:\n            aux = blockVectorX * _lambda[np.newaxis, :]\n        blockVectorR = blockVectorAX - aux\n        aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n        residualNorms = np.sqrt(np.abs(aux))\n        if retResidualNormsHistory:\n            residualNormsHistory[iterationNumber, :] = residualNorms\n        residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n        if residualNorm < smallestResidualNorm:\n            smallestResidualNorm = residualNorm\n            bestIterationNumber = iterationNumber\n            bestblockVectorX = blockVectorX\n        elif residualNorm > 2 ** restartControl * smallestResidualNorm:\n            forcedRestart = True\n            blockVectorAX = A(blockVectorX)\n            if blockVectorAX.shape != blockVectorX.shape:\n                raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n            if B is not None:\n                blockVectorBX = B(blockVectorX)\n                if blockVectorBX.shape != blockVectorX.shape:\n                    raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n        ii = np.where(residualNorms > residualTolerance, True, False)\n        activeMask = activeMask & ii\n        currentBlockSize = activeMask.sum()\n        if verbosityLevel:\n            print(f'iteration {iterationNumber}')\n            print(f'current block size: {currentBlockSize}')\n            print(f'eigenvalue(s):\\n{_lambda}')\n            print(f'residual norm(s):\\n{residualNorms}')\n        if currentBlockSize == 0:\n            break\n        activeBlockVectorR = _as2d(blockVectorR[:, activeMask])\n        if iterationNumber > 0:\n            activeBlockVectorP = _as2d(blockVectorP[:, activeMask])\n            activeBlockVectorAP = _as2d(blockVectorAP[:, activeMask])\n            if B is not None:\n                activeBlockVectorBP = _as2d(blockVectorBP[:, activeMask])\n        if M is not None:\n            activeBlockVectorR = M(activeBlockVectorR)\n        if blockVectorY is not None:\n            _applyConstraints(activeBlockVectorR, gramYBY, blockVectorBY, blockVectorY)\n        if B is not None:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorBX.T.conj() @ activeBlockVectorR)\n        else:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorX.T.conj() @ activeBlockVectorR)\n        aux = _b_orthonormalize(B, activeBlockVectorR, verbosityLevel=verbosityLevel)\n        (activeBlockVectorR, activeBlockVectorBR, _) = aux\n        if activeBlockVectorR is None:\n            warnings.warn(f'Failed at iteration {iterationNumber} with accuracies {residualNorms}\\n not reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n            break\n        activeBlockVectorAR = A(activeBlockVectorR)\n        if iterationNumber > 0:\n            if B is not None:\n                aux = _b_orthonormalize(B, activeBlockVectorP, activeBlockVectorBP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, activeBlockVectorBP, invR) = aux\n            else:\n                aux = _b_orthonormalize(B, activeBlockVectorP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, _, invR) = aux\n            if activeBlockVectorP is not None:\n                activeBlockVectorAP = _matmul_inplace(activeBlockVectorAP, invR, verbosityLevel=verbosityLevel)\n                restart = forcedRestart\n            else:\n                restart = True\n        if activeBlockVectorAR.dtype == 'float32':\n            myeps = 1\n        else:\n            myeps = np.sqrt(np.finfo(activeBlockVectorR.dtype).eps)\n        if residualNorms.max() > myeps and (not explicitGramFlag):\n            explicitGramFlag = False\n        else:\n            explicitGramFlag = True\n        if B is None:\n            blockVectorBX = blockVectorX\n            activeBlockVectorBR = activeBlockVectorR\n            if not restart:\n                activeBlockVectorBP = activeBlockVectorP\n        gramXAR = np.dot(blockVectorX.T.conj(), activeBlockVectorAR)\n        gramRAR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAR)\n        gramDtype = activeBlockVectorAR.dtype\n        if explicitGramFlag:\n            gramRAR = (gramRAR + gramRAR.T.conj()) / 2\n            gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n            gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n            gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n            gramRBR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBR)\n            gramXBR = np.dot(blockVectorX.T.conj(), activeBlockVectorBR)\n        else:\n            gramXAX = np.diag(_lambda).astype(gramDtype)\n            gramXBX = np.eye(sizeX, dtype=gramDtype)\n            gramRBR = np.eye(currentBlockSize, dtype=gramDtype)\n            gramXBR = np.zeros((sizeX, currentBlockSize), dtype=gramDtype)\n        if not restart:\n            gramXAP = np.dot(blockVectorX.T.conj(), activeBlockVectorAP)\n            gramRAP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAP)\n            gramPAP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorAP)\n            gramXBP = np.dot(blockVectorX.T.conj(), activeBlockVectorBP)\n            gramRBP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBP)\n            if explicitGramFlag:\n                gramPAP = (gramPAP + gramPAP.T.conj()) / 2\n                gramPBP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorBP)\n            else:\n                gramPBP = np.eye(currentBlockSize, dtype=gramDtype)\n            gramA = np.block([[gramXAX, gramXAR, gramXAP], [gramXAR.T.conj(), gramRAR, gramRAP], [gramXAP.T.conj(), gramRAP.T.conj(), gramPAP]])\n            gramB = np.block([[gramXBX, gramXBR, gramXBP], [gramXBR.T.conj(), gramRBR, gramRBP], [gramXBP.T.conj(), gramRBP.T.conj(), gramPBP]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                if verbosityLevel:\n                    warnings.warn(f'eigh failed at iteration {iterationNumber} \\nwith error {e} causing a restart.\\n', UserWarning, stacklevel=2)\n                restart = True\n        if restart:\n            gramA = np.block([[gramXAX, gramXAR], [gramXAR.T.conj(), gramRAR]])\n            gramB = np.block([[gramXBX, gramXBR], [gramXBR.T.conj(), gramRBR]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                warnings.warn(f'eigh failed at iteration {iterationNumber} with error\\n{e}\\n', UserWarning, stacklevel=2)\n                break\n        ii = _get_indx(_lambda, sizeX, largest)\n        _lambda = _lambda[ii]\n        eigBlockVector = eigBlockVector[:, ii]\n        if retLambdaHistory:\n            lambdaHistory[iterationNumber + 1, :] = _lambda\n        if B is not None:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n                bpp += np.dot(activeBlockVectorBP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            blockVectorBX = np.dot(blockVectorBX, eigBlockVectorX) + bpp\n            (blockVectorP, blockVectorAP, blockVectorBP) = (pp, app, bpp)\n        else:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            (blockVectorP, blockVectorAP) = (pp, app)\n    if B is not None:\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[iterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[iterationNumber + 1, :] = residualNorms\n    residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n    if residualNorm < smallestResidualNorm:\n        smallestResidualNorm = residualNorm\n        bestIterationNumber = iterationNumber + 1\n        bestblockVectorX = blockVectorX\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited at iteration {iterationNumber} with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.\\nUse iteration {bestIterationNumber} instead with accuracy \\n{smallestResidualNorm}.\\n', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final iterative eigenvalue(s):\\n{_lambda}')\n        print(f'Final iterative residual norm(s):\\n{residualNorms}')\n    blockVectorX = bestblockVectorX\n    if blockVectorY is not None:\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n    blockVectorBX = blockVectorX\n    if B is not None:\n        blockVectorBX = B(blockVectorX)\n        if blockVectorBX.shape != blockVectorX.shape:\n            raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n    gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n    _handle_gramA_gramB_verbosity(gramXAX, gramXBX, verbosityLevel)\n    gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n    gramXBX = (gramXBX + gramXBX.T.conj()) / 2\n    try:\n        (_lambda, eigBlockVector) = eigh(gramXAX, gramXBX, check_finite=False)\n    except LinAlgError as e:\n        raise ValueError('eigh has failed in lobpcg postprocessing') from e\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = np.dot(blockVectorX, eigBlockVector)\n    blockVectorAX = np.dot(blockVectorAX, eigBlockVector)\n    if B is not None:\n        blockVectorBX = np.dot(blockVectorBX, eigBlockVector)\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[bestIterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[bestIterationNumber + 1, :] = residualNorms\n    if retLambdaHistory:\n        lambdaHistory = lambdaHistory[:bestIterationNumber + 2, :]\n    if retResidualNormsHistory:\n        residualNormsHistory = residualNormsHistory[:bestIterationNumber + 2, :]\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited postprocessing with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final postprocessing eigenvalue(s):\\n{_lambda}')\n        print(f'Final residual norm(s):\\n{residualNorms}')\n    if retLambdaHistory:\n        lambdaHistory = np.vsplit(lambdaHistory, np.shape(lambdaHistory)[0])\n        lambdaHistory = [np.squeeze(i) for i in lambdaHistory]\n    if retResidualNormsHistory:\n        residualNormsHistory = np.vsplit(residualNormsHistory, np.shape(residualNormsHistory)[0])\n        residualNormsHistory = [np.squeeze(i) for i in residualNormsHistory]\n    if retLambdaHistory:\n        if retResidualNormsHistory:\n            return (_lambda, blockVectorX, lambdaHistory, residualNormsHistory)\n        else:\n            return (_lambda, blockVectorX, lambdaHistory)\n    elif retResidualNormsHistory:\n        return (_lambda, blockVectorX, residualNormsHistory)\n    else:\n        return (_lambda, blockVectorX)",
            "def lobpcg(A, X, B=None, M=None, Y=None, tol=None, maxiter=None, largest=True, verbosityLevel=0, retLambdaHistory=False, retResidualNormsHistory=False, restartControl=20):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG).\\n\\n    LOBPCG is a preconditioned eigensolver for large real symmetric and complex\\n    Hermitian definite generalized eigenproblems.\\n\\n    Parameters\\n    ----------\\n    A : {sparse matrix, ndarray, LinearOperator, callable object}\\n        The Hermitian linear operator of the problem, usually given by a\\n        sparse matrix.  Often called the \"stiffness matrix\".\\n    X : ndarray, float32 or float64\\n        Initial approximation to the ``k`` eigenvectors (non-sparse).\\n        If `A` has ``shape=(n,n)`` then `X` must have ``shape=(n,k)``.\\n    B : {sparse matrix, ndarray, LinearOperator, callable object}\\n        Optional. By default ``B = None``, which is equivalent to identity.\\n        The right hand side operator in a generalized eigenproblem if present.\\n        Often called the \"mass matrix\". Must be Hermitian positive definite.\\n    M : {sparse matrix, ndarray, LinearOperator, callable object}\\n        Optional. By default ``M = None``, which is equivalent to identity.\\n        Preconditioner aiming to accelerate convergence.\\n    Y : ndarray, float32 or float64, default: None\\n        An ``n-by-sizeY`` ndarray of constraints with ``sizeY < n``.\\n        The iterations will be performed in the ``B``-orthogonal complement\\n        of the column-space of `Y`. `Y` must be full rank if present.\\n    tol : scalar, optional\\n        The default is ``tol=n*sqrt(eps)``.\\n        Solver tolerance for the stopping criterion.\\n    maxiter : int, default: 20\\n        Maximum number of iterations.\\n    largest : bool, default: True\\n        When True, solve for the largest eigenvalues, otherwise the smallest.\\n    verbosityLevel : int, optional\\n        By default ``verbosityLevel=0`` no output.\\n        Controls the solver standard/screen output.\\n    retLambdaHistory : bool, default: False\\n        Whether to return iterative eigenvalue history.\\n    retResidualNormsHistory : bool, default: False\\n        Whether to return iterative history of residual norms.\\n    restartControl : int, optional.\\n        Iterations restart if the residuals jump ``2**restartControl`` times\\n        compared to the smallest recorded in ``retResidualNormsHistory``.\\n        The default is ``restartControl=20``, making the restarts rare for\\n        backward compatibility.\\n\\n    Returns\\n    -------\\n    lambda : ndarray of the shape ``(k, )``.\\n        Array of ``k`` approximate eigenvalues.\\n    v : ndarray of the same shape as ``X.shape``.\\n        An array of ``k`` approximate eigenvectors.\\n    lambdaHistory : ndarray, optional.\\n        The eigenvalue history, if `retLambdaHistory` is ``True``.\\n    ResidualNormsHistory : ndarray, optional.\\n        The history of residual norms, if `retResidualNormsHistory`\\n        is ``True``.\\n\\n    Notes\\n    -----\\n    The iterative loop runs ``maxit=maxiter`` (20 if ``maxit=None``)\\n    iterations at most and finishes earler if the tolerance is met.\\n    Breaking backward compatibility with the previous version, LOBPCG\\n    now returns the block of iterative vectors with the best accuracy rather\\n    than the last one iterated, as a cure for possible divergence.\\n\\n    If ``X.dtype == np.float32`` and user-provided operations/multiplications\\n    by `A`, `B`, and `M` all preserve the ``np.float32`` data type,\\n    all the calculations and the output are in ``np.float32``.\\n\\n    The size of the iteration history output equals to the number of the best\\n    (limited by `maxit`) iterations plus 3: initial, final, and postprocessing.\\n\\n    If both `retLambdaHistory` and `retResidualNormsHistory` are ``True``,\\n    the return tuple has the following format\\n    ``(lambda, V, lambda history, residual norms history)``.\\n\\n    In the following ``n`` denotes the matrix size and ``k`` the number\\n    of required eigenvalues (smallest or largest).\\n\\n    The LOBPCG code internally solves eigenproblems of the size ``3k`` on every\\n    iteration by calling the dense eigensolver `eigh`, so if ``k`` is not\\n    small enough compared to ``n``, it makes no sense to call the LOBPCG code.\\n    Moreover, if one calls the LOBPCG algorithm for ``5k > n``, it would likely\\n    break internally, so the code calls the standard function `eigh` instead.\\n    It is not that ``n`` should be large for the LOBPCG to work, but rather the\\n    ratio ``n / k`` should be large. It you call LOBPCG with ``k=1``\\n    and ``n=10``, it works though ``n`` is small. The method is intended\\n    for extremely large ``n / k``.\\n\\n    The convergence speed depends basically on three factors:\\n\\n    1. Quality of the initial approximations `X` to the seeking eigenvectors.\\n       Randomly distributed around the origin vectors work well if no better\\n       choice is known.\\n\\n    2. Relative separation of the desired eigenvalues from the rest\\n       of the eigenvalues. One can vary ``k`` to improve the separation.\\n\\n    3. Proper preconditioning to shrink the spectral spread.\\n       For example, a rod vibration test problem (under tests\\n       directory) is ill-conditioned for large ``n``, so convergence will be\\n       slow, unless efficient preconditioning is used. For this specific\\n       problem, a good simple preconditioner function would be a linear solve\\n       for `A`, which is easy to code since `A` is tridiagonal.\\n\\n    References\\n    ----------\\n    .. [1] A. V. Knyazev (2001),\\n           Toward the Optimal Preconditioned Eigensolver: Locally Optimal\\n           Block Preconditioned Conjugate Gradient Method.\\n           SIAM Journal on Scientific Computing 23, no. 2,\\n           pp. 517-541. :doi:`10.1137/S1064827500366124`\\n\\n    .. [2] A. V. Knyazev, I. Lashuk, M. E. Argentati, and E. Ovchinnikov\\n           (2007), Block Locally Optimal Preconditioned Eigenvalue Xolvers\\n           (BLOPEX) in hypre and PETSc. :arxiv:`0705.2626`\\n\\n    .. [3] A. V. Knyazev\\'s C and MATLAB implementations:\\n           https://github.com/lobpcg/blopex\\n\\n    Examples\\n    --------\\n    Our first example is minimalistic - find the largest eigenvalue of\\n    a diagonal matrix by solving the non-generalized eigenvalue problem\\n    ``A x = lambda x`` without constraints or preconditioning.\\n\\n    >>> import numpy as np\\n    >>> from scipy.sparse import spdiags\\n    >>> from scipy.sparse.linalg import LinearOperator, aslinearoperator\\n    >>> from scipy.sparse.linalg import lobpcg\\n\\n    The square matrix size is\\n\\n    >>> n = 100\\n\\n    and its diagonal entries are 1, ..., 100 defined by\\n\\n    >>> vals = np.arange(1, n + 1).astype(np.int16)\\n\\n    The first mandatory input parameter in this test is\\n    the sparse diagonal matrix `A`\\n    of the eigenvalue problem ``A x = lambda x`` to solve.\\n\\n    >>> A = spdiags(vals, 0, n, n)\\n    >>> A = A.astype(np.int16)\\n    >>> A.toarray()\\n    array([[  1,   0,   0, ...,   0,   0,   0],\\n           [  0,   2,   0, ...,   0,   0,   0],\\n           [  0,   0,   3, ...,   0,   0,   0],\\n           ...,\\n           [  0,   0,   0, ...,  98,   0,   0],\\n           [  0,   0,   0, ...,   0,  99,   0],\\n           [  0,   0,   0, ...,   0,   0, 100]], dtype=int16)\\n\\n    The second mandatory input parameter `X` is a 2D array with the\\n    row dimension determining the number of requested eigenvalues.\\n    `X` is an initial guess for targeted eigenvectors.\\n    `X` must have linearly independent columns.\\n    If no initial approximations available, randomly oriented vectors\\n    commonly work best, e.g., with components normally distributed\\n    around zero or uniformly distributed on the interval [-1 1].\\n    Setting the initial approximations to dtype ``np.float32``\\n    forces all iterative values to dtype ``np.float32`` speeding up\\n    the run while still allowing accurate eigenvalue computations.\\n\\n    >>> k = 1\\n    >>> rng = np.random.default_rng()\\n    >>> X = rng.normal(size=(n, k))\\n    >>> X = X.astype(np.float32)\\n\\n    >>> eigenvalues, _ = lobpcg(A, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n    >>> eigenvalues.dtype\\n    dtype(\\'float32\\')\\n\\n    `lobpcg` needs only access the matrix product with `A` rather\\n    then the matrix itself. Since the matrix `A` is diagonal in\\n    this example, one can write a function of the matrix product\\n    ``A @ X`` using the diagonal values ``vals`` only, e.g., by\\n    element-wise multiplication with broadcasting in the lambda-function\\n\\n    >>> A_lambda = lambda X: vals[:, np.newaxis] * X\\n\\n    or the regular function\\n\\n    >>> def A_matmat(X):\\n    ...     return vals[:, np.newaxis] * X\\n\\n    and use the handle to one of these callables as an input\\n\\n    >>> eigenvalues, _ = lobpcg(A_lambda, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, maxiter=60)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    The traditional callable `LinearOperator` is no longer\\n    necessary but still supported as the input to `lobpcg`.\\n    Specifying ``matmat=A_matmat`` explicitely improves performance. \\n\\n    >>> A_lo = LinearOperator((n, n), matvec=A_matmat, matmat=A_matmat, dtype=np.int16)\\n    >>> eigenvalues, _ = lobpcg(A_lo, X, maxiter=80)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    The least efficient callable option is `aslinearoperator`:\\n\\n    >>> eigenvalues, _ = lobpcg(aslinearoperator(A), X, maxiter=80)\\n    >>> eigenvalues\\n    array([100.])\\n\\n    We now switch to computing the three smallest eigenvalues specifying\\n\\n    >>> k = 3\\n    >>> X = np.random.default_rng().normal(size=(n, k))\\n\\n    and ``largest=False`` parameter\\n\\n    >>> eigenvalues, _ = lobpcg(A, X, largest=False, maxiter=80)\\n    >>> print(eigenvalues)  \\n    [1. 2. 3.]\\n\\n    The next example illustrates computing 3 smallest eigenvalues of\\n    the same matrix `A` given by the function handle ``A_matmat`` but\\n    with constraints and preconditioning.\\n\\n    Constraints - an optional input parameter is a 2D array comprising\\n    of column vectors that the eigenvectors must be orthogonal to\\n\\n    >>> Y = np.eye(n, 3)\\n\\n    The preconditioner acts as the inverse of `A` in this example, but\\n    in the reduced precision ``np.float32`` even though the initial `X`\\n    and thus all iterates and the output are in full ``np.float64``.\\n\\n    >>> inv_vals = 1./vals\\n    >>> inv_vals = inv_vals.astype(np.float32)\\n    >>> M = lambda X: inv_vals[:, np.newaxis] * X\\n\\n    Let us now solve the eigenvalue problem for the matrix `A` first\\n    without preconditioning requesting 80 iterations\\n\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, largest=False, maxiter=80)\\n    >>> eigenvalues\\n    array([4., 5., 6.])\\n    >>> eigenvalues.dtype\\n    dtype(\\'float64\\')\\n\\n    With preconditioning we need only 20 iterations from the same `X`\\n\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, Y=Y, M=M, largest=False, maxiter=20)\\n    >>> eigenvalues\\n    array([4., 5., 6.])\\n\\n    Note that the vectors passed in `Y` are the eigenvectors of the 3\\n    smallest eigenvalues. The results returned above are orthogonal to those.\\n\\n    The primary matrix `A` may be indefinite, e.g., after shifting\\n    ``vals`` by 50 from 1, ..., 100 to -49, ..., 50, we still can compute\\n    the 3 smallest or largest eigenvalues.\\n\\n    >>> vals = vals - 50\\n    >>> X = rng.normal(size=(n, k))\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=False, maxiter=99)\\n    >>> eigenvalues\\n    array([-49., -48., -47.])\\n    >>> eigenvalues, _ = lobpcg(A_matmat, X, largest=True, maxiter=99)\\n    >>> eigenvalues\\n    array([50., 49., 48.])\\n\\n    '\n    blockVectorX = X\n    bestblockVectorX = blockVectorX\n    blockVectorY = Y\n    residualTolerance = tol\n    if maxiter is None:\n        maxiter = 20\n    bestIterationNumber = maxiter\n    sizeY = 0\n    if blockVectorY is not None:\n        if len(blockVectorY.shape) != 2:\n            warnings.warn(f'Expected rank-2 array for argument Y, instead got {len(blockVectorY.shape)}, so ignore it and use no constraints.', UserWarning, stacklevel=2)\n            blockVectorY = None\n        else:\n            sizeY = blockVectorY.shape[1]\n    if blockVectorX is None:\n        raise ValueError('The mandatory initial matrix X cannot be None')\n    if len(blockVectorX.shape) != 2:\n        raise ValueError('expected rank-2 array for argument X')\n    (n, sizeX) = blockVectorX.shape\n    if not np.issubdtype(blockVectorX.dtype, np.inexact):\n        warnings.warn(f'Data type for argument X is {blockVectorX.dtype}, which is not inexact, so casted to np.float32.', UserWarning, stacklevel=2)\n        blockVectorX = np.asarray(blockVectorX, dtype=np.float32)\n    if retLambdaHistory:\n        lambdaHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if retResidualNormsHistory:\n        residualNormsHistory = np.zeros((maxiter + 3, sizeX), dtype=blockVectorX.dtype)\n    if verbosityLevel:\n        aux = 'Solving '\n        if B is None:\n            aux += 'standard'\n        else:\n            aux += 'generalized'\n        aux += ' eigenvalue problem with'\n        if M is None:\n            aux += 'out'\n        aux += ' preconditioning\\n\\n'\n        aux += 'matrix size %d\\n' % n\n        aux += 'block size %d\\n\\n' % sizeX\n        if blockVectorY is None:\n            aux += 'No constraints\\n\\n'\n        elif sizeY > 1:\n            aux += '%d constraints\\n\\n' % sizeY\n        else:\n            aux += '%d constraint\\n\\n' % sizeY\n        print(aux)\n    if n - sizeY < 5 * sizeX:\n        warnings.warn(f'The problem size {n} minus the constraints size {sizeY} is too small relative to the block size {sizeX}. Using a dense eigensolver instead of LOBPCG iterations.No output of the history of the iterations.', UserWarning, stacklevel=2)\n        sizeX = min(sizeX, n)\n        if blockVectorY is not None:\n            raise NotImplementedError('The dense eigensolver does not support constraints.')\n        if largest:\n            eigvals = (n - sizeX, n - 1)\n        else:\n            eigvals = (0, sizeX - 1)\n        try:\n            if isinstance(A, LinearOperator):\n                A = A(np.eye(n, dtype=int))\n            elif callable(A):\n                A = A(np.eye(n, dtype=int))\n                if A.shape != (n, n):\n                    raise ValueError(f'The shape {A.shape} of the primary matrix\\ndefined by a callable object is wrong.\\n')\n            elif issparse(A):\n                A = A.toarray()\n            else:\n                A = np.asarray(A)\n        except Exception as e:\n            raise Exception(f'Primary MatMul call failed with error\\n{e}\\n')\n        if B is not None:\n            try:\n                if isinstance(B, LinearOperator):\n                    B = B(np.eye(n, dtype=int))\n                elif callable(B):\n                    B = B(np.eye(n, dtype=int))\n                    if B.shape != (n, n):\n                        raise ValueError(f'The shape {B.shape} of the secondary matrix\\ndefined by a callable object is wrong.\\n')\n                elif issparse(B):\n                    B = B.toarray()\n                else:\n                    B = np.asarray(B)\n            except Exception as e:\n                raise Exception(f'Secondary MatMul call failed with error\\n{e}\\n')\n        try:\n            (vals, vecs) = eigh(A, B, subset_by_index=eigvals, check_finite=False)\n            if largest:\n                vals = vals[::-1]\n                vecs = vecs[:, ::-1]\n            return (vals, vecs)\n        except Exception as e:\n            raise Exception(f'Dense eigensolver failed with error\\n{e}\\n')\n    if residualTolerance is None or residualTolerance <= 0.0:\n        residualTolerance = np.sqrt(np.finfo(blockVectorX.dtype).eps) * n\n    A = _makeMatMat(A)\n    B = _makeMatMat(B)\n    M = _makeMatMat(M)\n    if blockVectorY is not None:\n        if B is not None:\n            blockVectorBY = B(blockVectorY)\n            if blockVectorBY.shape != blockVectorY.shape:\n                raise ValueError(f'The shape {blockVectorY.shape} of the constraint not preserved\\nand changed to {blockVectorBY.shape} after multiplying by the secondary matrix.\\n')\n        else:\n            blockVectorBY = blockVectorY\n        gramYBY = blockVectorY.T.conj() @ blockVectorBY\n        try:\n            gramYBY = cho_factor(gramYBY, overwrite_a=True)\n        except LinAlgError as e:\n            raise ValueError('Linearly dependent constraints') from e\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    (blockVectorX, blockVectorBX, _) = _b_orthonormalize(B, blockVectorX, verbosityLevel=verbosityLevel)\n    if blockVectorX is None:\n        raise ValueError('Linearly dependent initial approximations')\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the initial approximations not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = blockVectorX.T.conj() @ blockVectorAX\n    (_lambda, eigBlockVector) = eigh(gramXAX, check_finite=False)\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    if retLambdaHistory:\n        lambdaHistory[0, :] = _lambda\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = _matmul_inplace(blockVectorX, eigBlockVector, verbosityLevel=verbosityLevel)\n    blockVectorAX = _matmul_inplace(blockVectorAX, eigBlockVector, verbosityLevel=verbosityLevel)\n    if B is not None:\n        blockVectorBX = _matmul_inplace(blockVectorBX, eigBlockVector, verbosityLevel=verbosityLevel)\n    activeMask = np.ones((sizeX,), dtype=bool)\n    blockVectorP = None\n    blockVectorAP = None\n    blockVectorBP = None\n    smallestResidualNorm = np.abs(np.finfo(blockVectorX.dtype).max)\n    iterationNumber = -1\n    restart = True\n    forcedRestart = False\n    explicitGramFlag = False\n    while iterationNumber < maxiter:\n        iterationNumber += 1\n        if B is not None:\n            aux = blockVectorBX * _lambda[np.newaxis, :]\n        else:\n            aux = blockVectorX * _lambda[np.newaxis, :]\n        blockVectorR = blockVectorAX - aux\n        aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n        residualNorms = np.sqrt(np.abs(aux))\n        if retResidualNormsHistory:\n            residualNormsHistory[iterationNumber, :] = residualNorms\n        residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n        if residualNorm < smallestResidualNorm:\n            smallestResidualNorm = residualNorm\n            bestIterationNumber = iterationNumber\n            bestblockVectorX = blockVectorX\n        elif residualNorm > 2 ** restartControl * smallestResidualNorm:\n            forcedRestart = True\n            blockVectorAX = A(blockVectorX)\n            if blockVectorAX.shape != blockVectorX.shape:\n                raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n            if B is not None:\n                blockVectorBX = B(blockVectorX)\n                if blockVectorBX.shape != blockVectorX.shape:\n                    raise ValueError(f'The shape {blockVectorX.shape} of the restarted iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n        ii = np.where(residualNorms > residualTolerance, True, False)\n        activeMask = activeMask & ii\n        currentBlockSize = activeMask.sum()\n        if verbosityLevel:\n            print(f'iteration {iterationNumber}')\n            print(f'current block size: {currentBlockSize}')\n            print(f'eigenvalue(s):\\n{_lambda}')\n            print(f'residual norm(s):\\n{residualNorms}')\n        if currentBlockSize == 0:\n            break\n        activeBlockVectorR = _as2d(blockVectorR[:, activeMask])\n        if iterationNumber > 0:\n            activeBlockVectorP = _as2d(blockVectorP[:, activeMask])\n            activeBlockVectorAP = _as2d(blockVectorAP[:, activeMask])\n            if B is not None:\n                activeBlockVectorBP = _as2d(blockVectorBP[:, activeMask])\n        if M is not None:\n            activeBlockVectorR = M(activeBlockVectorR)\n        if blockVectorY is not None:\n            _applyConstraints(activeBlockVectorR, gramYBY, blockVectorBY, blockVectorY)\n        if B is not None:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorBX.T.conj() @ activeBlockVectorR)\n        else:\n            activeBlockVectorR = activeBlockVectorR - blockVectorX @ (blockVectorX.T.conj() @ activeBlockVectorR)\n        aux = _b_orthonormalize(B, activeBlockVectorR, verbosityLevel=verbosityLevel)\n        (activeBlockVectorR, activeBlockVectorBR, _) = aux\n        if activeBlockVectorR is None:\n            warnings.warn(f'Failed at iteration {iterationNumber} with accuracies {residualNorms}\\n not reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n            break\n        activeBlockVectorAR = A(activeBlockVectorR)\n        if iterationNumber > 0:\n            if B is not None:\n                aux = _b_orthonormalize(B, activeBlockVectorP, activeBlockVectorBP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, activeBlockVectorBP, invR) = aux\n            else:\n                aux = _b_orthonormalize(B, activeBlockVectorP, verbosityLevel=verbosityLevel)\n                (activeBlockVectorP, _, invR) = aux\n            if activeBlockVectorP is not None:\n                activeBlockVectorAP = _matmul_inplace(activeBlockVectorAP, invR, verbosityLevel=verbosityLevel)\n                restart = forcedRestart\n            else:\n                restart = True\n        if activeBlockVectorAR.dtype == 'float32':\n            myeps = 1\n        else:\n            myeps = np.sqrt(np.finfo(activeBlockVectorR.dtype).eps)\n        if residualNorms.max() > myeps and (not explicitGramFlag):\n            explicitGramFlag = False\n        else:\n            explicitGramFlag = True\n        if B is None:\n            blockVectorBX = blockVectorX\n            activeBlockVectorBR = activeBlockVectorR\n            if not restart:\n                activeBlockVectorBP = activeBlockVectorP\n        gramXAR = np.dot(blockVectorX.T.conj(), activeBlockVectorAR)\n        gramRAR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAR)\n        gramDtype = activeBlockVectorAR.dtype\n        if explicitGramFlag:\n            gramRAR = (gramRAR + gramRAR.T.conj()) / 2\n            gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n            gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n            gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n            gramRBR = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBR)\n            gramXBR = np.dot(blockVectorX.T.conj(), activeBlockVectorBR)\n        else:\n            gramXAX = np.diag(_lambda).astype(gramDtype)\n            gramXBX = np.eye(sizeX, dtype=gramDtype)\n            gramRBR = np.eye(currentBlockSize, dtype=gramDtype)\n            gramXBR = np.zeros((sizeX, currentBlockSize), dtype=gramDtype)\n        if not restart:\n            gramXAP = np.dot(blockVectorX.T.conj(), activeBlockVectorAP)\n            gramRAP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorAP)\n            gramPAP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorAP)\n            gramXBP = np.dot(blockVectorX.T.conj(), activeBlockVectorBP)\n            gramRBP = np.dot(activeBlockVectorR.T.conj(), activeBlockVectorBP)\n            if explicitGramFlag:\n                gramPAP = (gramPAP + gramPAP.T.conj()) / 2\n                gramPBP = np.dot(activeBlockVectorP.T.conj(), activeBlockVectorBP)\n            else:\n                gramPBP = np.eye(currentBlockSize, dtype=gramDtype)\n            gramA = np.block([[gramXAX, gramXAR, gramXAP], [gramXAR.T.conj(), gramRAR, gramRAP], [gramXAP.T.conj(), gramRAP.T.conj(), gramPAP]])\n            gramB = np.block([[gramXBX, gramXBR, gramXBP], [gramXBR.T.conj(), gramRBR, gramRBP], [gramXBP.T.conj(), gramRBP.T.conj(), gramPBP]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                if verbosityLevel:\n                    warnings.warn(f'eigh failed at iteration {iterationNumber} \\nwith error {e} causing a restart.\\n', UserWarning, stacklevel=2)\n                restart = True\n        if restart:\n            gramA = np.block([[gramXAX, gramXAR], [gramXAR.T.conj(), gramRAR]])\n            gramB = np.block([[gramXBX, gramXBR], [gramXBR.T.conj(), gramRBR]])\n            _handle_gramA_gramB_verbosity(gramA, gramB, verbosityLevel)\n            try:\n                (_lambda, eigBlockVector) = eigh(gramA, gramB, check_finite=False)\n            except LinAlgError as e:\n                warnings.warn(f'eigh failed at iteration {iterationNumber} with error\\n{e}\\n', UserWarning, stacklevel=2)\n                break\n        ii = _get_indx(_lambda, sizeX, largest)\n        _lambda = _lambda[ii]\n        eigBlockVector = eigBlockVector[:, ii]\n        if retLambdaHistory:\n            lambdaHistory[iterationNumber + 1, :] = _lambda\n        if B is not None:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n                bpp += np.dot(activeBlockVectorBP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                bpp = np.dot(activeBlockVectorBR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            blockVectorBX = np.dot(blockVectorBX, eigBlockVectorX) + bpp\n            (blockVectorP, blockVectorAP, blockVectorBP) = (pp, app, bpp)\n        else:\n            if not restart:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:sizeX + currentBlockSize]\n                eigBlockVectorP = eigBlockVector[sizeX + currentBlockSize:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                pp += np.dot(activeBlockVectorP, eigBlockVectorP)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n                app += np.dot(activeBlockVectorAP, eigBlockVectorP)\n            else:\n                eigBlockVectorX = eigBlockVector[:sizeX]\n                eigBlockVectorR = eigBlockVector[sizeX:]\n                pp = np.dot(activeBlockVectorR, eigBlockVectorR)\n                app = np.dot(activeBlockVectorAR, eigBlockVectorR)\n            blockVectorX = np.dot(blockVectorX, eigBlockVectorX) + pp\n            blockVectorAX = np.dot(blockVectorAX, eigBlockVectorX) + app\n            (blockVectorP, blockVectorAP) = (pp, app)\n    if B is not None:\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[iterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[iterationNumber + 1, :] = residualNorms\n    residualNorm = np.sum(np.abs(residualNorms)) / sizeX\n    if residualNorm < smallestResidualNorm:\n        smallestResidualNorm = residualNorm\n        bestIterationNumber = iterationNumber + 1\n        bestblockVectorX = blockVectorX\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited at iteration {iterationNumber} with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.\\nUse iteration {bestIterationNumber} instead with accuracy \\n{smallestResidualNorm}.\\n', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final iterative eigenvalue(s):\\n{_lambda}')\n        print(f'Final iterative residual norm(s):\\n{residualNorms}')\n    blockVectorX = bestblockVectorX\n    if blockVectorY is not None:\n        _applyConstraints(blockVectorX, gramYBY, blockVectorBY, blockVectorY)\n    blockVectorAX = A(blockVectorX)\n    if blockVectorAX.shape != blockVectorX.shape:\n        raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorAX.shape} after multiplying by the primary matrix.\\n')\n    gramXAX = np.dot(blockVectorX.T.conj(), blockVectorAX)\n    blockVectorBX = blockVectorX\n    if B is not None:\n        blockVectorBX = B(blockVectorX)\n        if blockVectorBX.shape != blockVectorX.shape:\n            raise ValueError(f'The shape {blockVectorX.shape} of the postprocessing iterate not preserved\\nand changed to {blockVectorBX.shape} after multiplying by the secondary matrix.\\n')\n    gramXBX = np.dot(blockVectorX.T.conj(), blockVectorBX)\n    _handle_gramA_gramB_verbosity(gramXAX, gramXBX, verbosityLevel)\n    gramXAX = (gramXAX + gramXAX.T.conj()) / 2\n    gramXBX = (gramXBX + gramXBX.T.conj()) / 2\n    try:\n        (_lambda, eigBlockVector) = eigh(gramXAX, gramXBX, check_finite=False)\n    except LinAlgError as e:\n        raise ValueError('eigh has failed in lobpcg postprocessing') from e\n    ii = _get_indx(_lambda, sizeX, largest)\n    _lambda = _lambda[ii]\n    eigBlockVector = np.asarray(eigBlockVector[:, ii])\n    blockVectorX = np.dot(blockVectorX, eigBlockVector)\n    blockVectorAX = np.dot(blockVectorAX, eigBlockVector)\n    if B is not None:\n        blockVectorBX = np.dot(blockVectorBX, eigBlockVector)\n        aux = blockVectorBX * _lambda[np.newaxis, :]\n    else:\n        aux = blockVectorX * _lambda[np.newaxis, :]\n    blockVectorR = blockVectorAX - aux\n    aux = np.sum(blockVectorR.conj() * blockVectorR, 0)\n    residualNorms = np.sqrt(np.abs(aux))\n    if retLambdaHistory:\n        lambdaHistory[bestIterationNumber + 1, :] = _lambda\n    if retResidualNormsHistory:\n        residualNormsHistory[bestIterationNumber + 1, :] = residualNorms\n    if retLambdaHistory:\n        lambdaHistory = lambdaHistory[:bestIterationNumber + 2, :]\n    if retResidualNormsHistory:\n        residualNormsHistory = residualNormsHistory[:bestIterationNumber + 2, :]\n    if np.max(np.abs(residualNorms)) > residualTolerance:\n        warnings.warn(f'Exited postprocessing with accuracies \\n{residualNorms}\\nnot reaching the requested tolerance {residualTolerance}.', UserWarning, stacklevel=2)\n    if verbosityLevel:\n        print(f'Final postprocessing eigenvalue(s):\\n{_lambda}')\n        print(f'Final residual norm(s):\\n{residualNorms}')\n    if retLambdaHistory:\n        lambdaHistory = np.vsplit(lambdaHistory, np.shape(lambdaHistory)[0])\n        lambdaHistory = [np.squeeze(i) for i in lambdaHistory]\n    if retResidualNormsHistory:\n        residualNormsHistory = np.vsplit(residualNormsHistory, np.shape(residualNormsHistory)[0])\n        residualNormsHistory = [np.squeeze(i) for i in residualNormsHistory]\n    if retLambdaHistory:\n        if retResidualNormsHistory:\n            return (_lambda, blockVectorX, lambdaHistory, residualNormsHistory)\n        else:\n            return (_lambda, blockVectorX, lambdaHistory)\n    elif retResidualNormsHistory:\n        return (_lambda, blockVectorX, residualNormsHistory)\n    else:\n        return (_lambda, blockVectorX)"
        ]
    }
]