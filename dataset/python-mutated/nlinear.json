[
    {
        "func_name": "_create_linear_layer",
        "original": "def _create_linear_layer(in_dim, out_dim):\n    layer = nn.Linear(in_dim, out_dim)\n    if self.const_init:\n        layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n    return layer",
        "mutated": [
            "def _create_linear_layer(in_dim, out_dim):\n    if False:\n        i = 10\n    layer = nn.Linear(in_dim, out_dim)\n    if self.const_init:\n        layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n    return layer",
            "def _create_linear_layer(in_dim, out_dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    layer = nn.Linear(in_dim, out_dim)\n    if self.const_init:\n        layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n    return layer",
            "def _create_linear_layer(in_dim, out_dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    layer = nn.Linear(in_dim, out_dim)\n    if self.const_init:\n        layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n    return layer",
            "def _create_linear_layer(in_dim, out_dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    layer = nn.Linear(in_dim, out_dim)\n    if self.const_init:\n        layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n    return layer",
            "def _create_linear_layer(in_dim, out_dim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    layer = nn.Linear(in_dim, out_dim)\n    if self.const_init:\n        layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n    return layer"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, input_dim, output_dim, future_cov_dim, static_cov_dim, nr_params, shared_weights, const_init, normalize, **kwargs):\n    \"\"\"PyTorch module implementing the N-HiTS architecture.\n\n        Parameters\n        ----------\n        input_dim\n            The number of input components (target + optional covariate)\n        output_dim\n            Number of output components in the target\n        future_cov_dim\n            Number of components in the future covariates\n        static_cov_dim\n            Dimensionality of the static covariates\n        nr_params\n            The number of parameters of the likelihood (or 1 if no likelihood is used).\n        shared_weights\n            Whether to use shared weights for the components of the series.\n            ** Ignores covariates when True. **\n        normalize\n            Whether to apply the \"normalization\" described in the paper.\n        const_init\n            Whether to initialize the weights to 1/in_len\n\n        **kwargs\n            all parameters required for :class:`darts.model.forecasting_models.PLForecastingModule` base class.\n\n        Inputs\n        ------\n        x of shape `(batch_size, input_chunk_length)`\n            Tensor containing the input sequence.\n\n        Outputs\n        -------\n        y of shape `(batch_size, output_chunk_length, target_size/output_dim, nr_params)`\n            Tensor containing the output of the NBEATS module.\n\n        \"\"\"\n    super().__init__(**kwargs)\n    self.input_dim = input_dim\n    self.output_dim = output_dim\n    self.future_cov_dim = future_cov_dim\n    self.static_cov_dim = static_cov_dim\n    self.nr_params = nr_params\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n\n    def _create_linear_layer(in_dim, out_dim):\n        layer = nn.Linear(in_dim, out_dim)\n        if self.const_init:\n            layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n        return layer\n    if self.shared_weights:\n        layer_in_dim = self.input_chunk_length\n        layer_out_dim = self.output_chunk_length * self.nr_params\n    else:\n        layer_in_dim = self.input_chunk_length * self.input_dim\n        layer_out_dim = self.output_chunk_length * self.output_dim * self.nr_params\n        layer_in_dim_static_cov = self.output_dim * self.static_cov_dim\n    self.layer = _create_linear_layer(layer_in_dim, layer_out_dim)\n    if self.future_cov_dim != 0:\n        self.linear_fut_cov = _create_linear_layer(self.future_cov_dim, self.output_dim * self.nr_params)\n    if self.static_cov_dim != 0:\n        self.linear_static_cov = _create_linear_layer(layer_in_dim_static_cov, layer_out_dim)",
        "mutated": [
            "def __init__(self, input_dim, output_dim, future_cov_dim, static_cov_dim, nr_params, shared_weights, const_init, normalize, **kwargs):\n    if False:\n        i = 10\n    'PyTorch module implementing the N-HiTS architecture.\\n\\n        Parameters\\n        ----------\\n        input_dim\\n            The number of input components (target + optional covariate)\\n        output_dim\\n            Number of output components in the target\\n        future_cov_dim\\n            Number of components in the future covariates\\n        static_cov_dim\\n            Dimensionality of the static covariates\\n        nr_params\\n            The number of parameters of the likelihood (or 1 if no likelihood is used).\\n        shared_weights\\n            Whether to use shared weights for the components of the series.\\n            ** Ignores covariates when True. **\\n        normalize\\n            Whether to apply the \"normalization\" described in the paper.\\n        const_init\\n            Whether to initialize the weights to 1/in_len\\n\\n        **kwargs\\n            all parameters required for :class:`darts.model.forecasting_models.PLForecastingModule` base class.\\n\\n        Inputs\\n        ------\\n        x of shape `(batch_size, input_chunk_length)`\\n            Tensor containing the input sequence.\\n\\n        Outputs\\n        -------\\n        y of shape `(batch_size, output_chunk_length, target_size/output_dim, nr_params)`\\n            Tensor containing the output of the NBEATS module.\\n\\n        '\n    super().__init__(**kwargs)\n    self.input_dim = input_dim\n    self.output_dim = output_dim\n    self.future_cov_dim = future_cov_dim\n    self.static_cov_dim = static_cov_dim\n    self.nr_params = nr_params\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n\n    def _create_linear_layer(in_dim, out_dim):\n        layer = nn.Linear(in_dim, out_dim)\n        if self.const_init:\n            layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n        return layer\n    if self.shared_weights:\n        layer_in_dim = self.input_chunk_length\n        layer_out_dim = self.output_chunk_length * self.nr_params\n    else:\n        layer_in_dim = self.input_chunk_length * self.input_dim\n        layer_out_dim = self.output_chunk_length * self.output_dim * self.nr_params\n        layer_in_dim_static_cov = self.output_dim * self.static_cov_dim\n    self.layer = _create_linear_layer(layer_in_dim, layer_out_dim)\n    if self.future_cov_dim != 0:\n        self.linear_fut_cov = _create_linear_layer(self.future_cov_dim, self.output_dim * self.nr_params)\n    if self.static_cov_dim != 0:\n        self.linear_static_cov = _create_linear_layer(layer_in_dim_static_cov, layer_out_dim)",
            "def __init__(self, input_dim, output_dim, future_cov_dim, static_cov_dim, nr_params, shared_weights, const_init, normalize, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'PyTorch module implementing the N-HiTS architecture.\\n\\n        Parameters\\n        ----------\\n        input_dim\\n            The number of input components (target + optional covariate)\\n        output_dim\\n            Number of output components in the target\\n        future_cov_dim\\n            Number of components in the future covariates\\n        static_cov_dim\\n            Dimensionality of the static covariates\\n        nr_params\\n            The number of parameters of the likelihood (or 1 if no likelihood is used).\\n        shared_weights\\n            Whether to use shared weights for the components of the series.\\n            ** Ignores covariates when True. **\\n        normalize\\n            Whether to apply the \"normalization\" described in the paper.\\n        const_init\\n            Whether to initialize the weights to 1/in_len\\n\\n        **kwargs\\n            all parameters required for :class:`darts.model.forecasting_models.PLForecastingModule` base class.\\n\\n        Inputs\\n        ------\\n        x of shape `(batch_size, input_chunk_length)`\\n            Tensor containing the input sequence.\\n\\n        Outputs\\n        -------\\n        y of shape `(batch_size, output_chunk_length, target_size/output_dim, nr_params)`\\n            Tensor containing the output of the NBEATS module.\\n\\n        '\n    super().__init__(**kwargs)\n    self.input_dim = input_dim\n    self.output_dim = output_dim\n    self.future_cov_dim = future_cov_dim\n    self.static_cov_dim = static_cov_dim\n    self.nr_params = nr_params\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n\n    def _create_linear_layer(in_dim, out_dim):\n        layer = nn.Linear(in_dim, out_dim)\n        if self.const_init:\n            layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n        return layer\n    if self.shared_weights:\n        layer_in_dim = self.input_chunk_length\n        layer_out_dim = self.output_chunk_length * self.nr_params\n    else:\n        layer_in_dim = self.input_chunk_length * self.input_dim\n        layer_out_dim = self.output_chunk_length * self.output_dim * self.nr_params\n        layer_in_dim_static_cov = self.output_dim * self.static_cov_dim\n    self.layer = _create_linear_layer(layer_in_dim, layer_out_dim)\n    if self.future_cov_dim != 0:\n        self.linear_fut_cov = _create_linear_layer(self.future_cov_dim, self.output_dim * self.nr_params)\n    if self.static_cov_dim != 0:\n        self.linear_static_cov = _create_linear_layer(layer_in_dim_static_cov, layer_out_dim)",
            "def __init__(self, input_dim, output_dim, future_cov_dim, static_cov_dim, nr_params, shared_weights, const_init, normalize, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'PyTorch module implementing the N-HiTS architecture.\\n\\n        Parameters\\n        ----------\\n        input_dim\\n            The number of input components (target + optional covariate)\\n        output_dim\\n            Number of output components in the target\\n        future_cov_dim\\n            Number of components in the future covariates\\n        static_cov_dim\\n            Dimensionality of the static covariates\\n        nr_params\\n            The number of parameters of the likelihood (or 1 if no likelihood is used).\\n        shared_weights\\n            Whether to use shared weights for the components of the series.\\n            ** Ignores covariates when True. **\\n        normalize\\n            Whether to apply the \"normalization\" described in the paper.\\n        const_init\\n            Whether to initialize the weights to 1/in_len\\n\\n        **kwargs\\n            all parameters required for :class:`darts.model.forecasting_models.PLForecastingModule` base class.\\n\\n        Inputs\\n        ------\\n        x of shape `(batch_size, input_chunk_length)`\\n            Tensor containing the input sequence.\\n\\n        Outputs\\n        -------\\n        y of shape `(batch_size, output_chunk_length, target_size/output_dim, nr_params)`\\n            Tensor containing the output of the NBEATS module.\\n\\n        '\n    super().__init__(**kwargs)\n    self.input_dim = input_dim\n    self.output_dim = output_dim\n    self.future_cov_dim = future_cov_dim\n    self.static_cov_dim = static_cov_dim\n    self.nr_params = nr_params\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n\n    def _create_linear_layer(in_dim, out_dim):\n        layer = nn.Linear(in_dim, out_dim)\n        if self.const_init:\n            layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n        return layer\n    if self.shared_weights:\n        layer_in_dim = self.input_chunk_length\n        layer_out_dim = self.output_chunk_length * self.nr_params\n    else:\n        layer_in_dim = self.input_chunk_length * self.input_dim\n        layer_out_dim = self.output_chunk_length * self.output_dim * self.nr_params\n        layer_in_dim_static_cov = self.output_dim * self.static_cov_dim\n    self.layer = _create_linear_layer(layer_in_dim, layer_out_dim)\n    if self.future_cov_dim != 0:\n        self.linear_fut_cov = _create_linear_layer(self.future_cov_dim, self.output_dim * self.nr_params)\n    if self.static_cov_dim != 0:\n        self.linear_static_cov = _create_linear_layer(layer_in_dim_static_cov, layer_out_dim)",
            "def __init__(self, input_dim, output_dim, future_cov_dim, static_cov_dim, nr_params, shared_weights, const_init, normalize, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'PyTorch module implementing the N-HiTS architecture.\\n\\n        Parameters\\n        ----------\\n        input_dim\\n            The number of input components (target + optional covariate)\\n        output_dim\\n            Number of output components in the target\\n        future_cov_dim\\n            Number of components in the future covariates\\n        static_cov_dim\\n            Dimensionality of the static covariates\\n        nr_params\\n            The number of parameters of the likelihood (or 1 if no likelihood is used).\\n        shared_weights\\n            Whether to use shared weights for the components of the series.\\n            ** Ignores covariates when True. **\\n        normalize\\n            Whether to apply the \"normalization\" described in the paper.\\n        const_init\\n            Whether to initialize the weights to 1/in_len\\n\\n        **kwargs\\n            all parameters required for :class:`darts.model.forecasting_models.PLForecastingModule` base class.\\n\\n        Inputs\\n        ------\\n        x of shape `(batch_size, input_chunk_length)`\\n            Tensor containing the input sequence.\\n\\n        Outputs\\n        -------\\n        y of shape `(batch_size, output_chunk_length, target_size/output_dim, nr_params)`\\n            Tensor containing the output of the NBEATS module.\\n\\n        '\n    super().__init__(**kwargs)\n    self.input_dim = input_dim\n    self.output_dim = output_dim\n    self.future_cov_dim = future_cov_dim\n    self.static_cov_dim = static_cov_dim\n    self.nr_params = nr_params\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n\n    def _create_linear_layer(in_dim, out_dim):\n        layer = nn.Linear(in_dim, out_dim)\n        if self.const_init:\n            layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n        return layer\n    if self.shared_weights:\n        layer_in_dim = self.input_chunk_length\n        layer_out_dim = self.output_chunk_length * self.nr_params\n    else:\n        layer_in_dim = self.input_chunk_length * self.input_dim\n        layer_out_dim = self.output_chunk_length * self.output_dim * self.nr_params\n        layer_in_dim_static_cov = self.output_dim * self.static_cov_dim\n    self.layer = _create_linear_layer(layer_in_dim, layer_out_dim)\n    if self.future_cov_dim != 0:\n        self.linear_fut_cov = _create_linear_layer(self.future_cov_dim, self.output_dim * self.nr_params)\n    if self.static_cov_dim != 0:\n        self.linear_static_cov = _create_linear_layer(layer_in_dim_static_cov, layer_out_dim)",
            "def __init__(self, input_dim, output_dim, future_cov_dim, static_cov_dim, nr_params, shared_weights, const_init, normalize, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'PyTorch module implementing the N-HiTS architecture.\\n\\n        Parameters\\n        ----------\\n        input_dim\\n            The number of input components (target + optional covariate)\\n        output_dim\\n            Number of output components in the target\\n        future_cov_dim\\n            Number of components in the future covariates\\n        static_cov_dim\\n            Dimensionality of the static covariates\\n        nr_params\\n            The number of parameters of the likelihood (or 1 if no likelihood is used).\\n        shared_weights\\n            Whether to use shared weights for the components of the series.\\n            ** Ignores covariates when True. **\\n        normalize\\n            Whether to apply the \"normalization\" described in the paper.\\n        const_init\\n            Whether to initialize the weights to 1/in_len\\n\\n        **kwargs\\n            all parameters required for :class:`darts.model.forecasting_models.PLForecastingModule` base class.\\n\\n        Inputs\\n        ------\\n        x of shape `(batch_size, input_chunk_length)`\\n            Tensor containing the input sequence.\\n\\n        Outputs\\n        -------\\n        y of shape `(batch_size, output_chunk_length, target_size/output_dim, nr_params)`\\n            Tensor containing the output of the NBEATS module.\\n\\n        '\n    super().__init__(**kwargs)\n    self.input_dim = input_dim\n    self.output_dim = output_dim\n    self.future_cov_dim = future_cov_dim\n    self.static_cov_dim = static_cov_dim\n    self.nr_params = nr_params\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n\n    def _create_linear_layer(in_dim, out_dim):\n        layer = nn.Linear(in_dim, out_dim)\n        if self.const_init:\n            layer.weight = nn.Parameter(1.0 / in_dim * torch.ones(layer.weight.shape))\n        return layer\n    if self.shared_weights:\n        layer_in_dim = self.input_chunk_length\n        layer_out_dim = self.output_chunk_length * self.nr_params\n    else:\n        layer_in_dim = self.input_chunk_length * self.input_dim\n        layer_out_dim = self.output_chunk_length * self.output_dim * self.nr_params\n        layer_in_dim_static_cov = self.output_dim * self.static_cov_dim\n    self.layer = _create_linear_layer(layer_in_dim, layer_out_dim)\n    if self.future_cov_dim != 0:\n        self.linear_fut_cov = _create_linear_layer(self.future_cov_dim, self.output_dim * self.nr_params)\n    if self.static_cov_dim != 0:\n        self.linear_static_cov = _create_linear_layer(layer_in_dim_static_cov, layer_out_dim)"
        ]
    },
    {
        "func_name": "forward",
        "original": "@io_processor\ndef forward(self, x_in: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]]):\n    \"\"\"\n        x_in\n            comes as tuple `(x_past, x_future, x_static)` where `x_past` is the input/past chunk and `x_future`\n            is the output/future chunk. Input dimensions are `(n_samples, n_time_steps, n_variables)`\n        \"\"\"\n    (x, x_future, x_static) = x_in\n    (batch, _, _) = x.shape\n    if self.shared_weights:\n        x = x[:, :, :self.output_dim]\n        x = x.permute(0, 2, 1)\n        if self.normalize:\n            seq_last = x[:, :, -1:].detach()\n            x = x - seq_last\n        x = self.layer(x)\n        if self.normalize:\n            x = x + seq_last\n        x = x.view(batch, self.output_dim, self.output_chunk_length, self.nr_params)\n        x = x.permute(0, 2, 1, 3)\n    else:\n        if self.normalize:\n            seq_last = x[:, -1:, :self.output_dim].detach()\n            x = x - seq_last\n        x = self.layer(x.view(batch, -1))\n        x = x.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.future_cov_dim != 0:\n            x_future = torch.nn.functional.pad(input=x_future, pad=(0, 0, 0, self.output_chunk_length - x_future.shape[1]), mode='constant', value=0)\n            fut_cov_output = self.linear_fut_cov(x_future)\n            x = x + fut_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.static_cov_dim != 0:\n            static_cov_output = self.linear_static_cov(x_static.reshape(batch, -1))\n            x = x + static_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        x = x.view(batch, self.output_chunk_length, self.output_dim, self.nr_params)\n        if self.normalize:\n            x = x + seq_last.view(seq_last.shape + (1,))\n    return x",
        "mutated": [
            "@io_processor\ndef forward(self, x_in: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]]):\n    if False:\n        i = 10\n    '\\n        x_in\\n            comes as tuple `(x_past, x_future, x_static)` where `x_past` is the input/past chunk and `x_future`\\n            is the output/future chunk. Input dimensions are `(n_samples, n_time_steps, n_variables)`\\n        '\n    (x, x_future, x_static) = x_in\n    (batch, _, _) = x.shape\n    if self.shared_weights:\n        x = x[:, :, :self.output_dim]\n        x = x.permute(0, 2, 1)\n        if self.normalize:\n            seq_last = x[:, :, -1:].detach()\n            x = x - seq_last\n        x = self.layer(x)\n        if self.normalize:\n            x = x + seq_last\n        x = x.view(batch, self.output_dim, self.output_chunk_length, self.nr_params)\n        x = x.permute(0, 2, 1, 3)\n    else:\n        if self.normalize:\n            seq_last = x[:, -1:, :self.output_dim].detach()\n            x = x - seq_last\n        x = self.layer(x.view(batch, -1))\n        x = x.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.future_cov_dim != 0:\n            x_future = torch.nn.functional.pad(input=x_future, pad=(0, 0, 0, self.output_chunk_length - x_future.shape[1]), mode='constant', value=0)\n            fut_cov_output = self.linear_fut_cov(x_future)\n            x = x + fut_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.static_cov_dim != 0:\n            static_cov_output = self.linear_static_cov(x_static.reshape(batch, -1))\n            x = x + static_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        x = x.view(batch, self.output_chunk_length, self.output_dim, self.nr_params)\n        if self.normalize:\n            x = x + seq_last.view(seq_last.shape + (1,))\n    return x",
            "@io_processor\ndef forward(self, x_in: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        x_in\\n            comes as tuple `(x_past, x_future, x_static)` where `x_past` is the input/past chunk and `x_future`\\n            is the output/future chunk. Input dimensions are `(n_samples, n_time_steps, n_variables)`\\n        '\n    (x, x_future, x_static) = x_in\n    (batch, _, _) = x.shape\n    if self.shared_weights:\n        x = x[:, :, :self.output_dim]\n        x = x.permute(0, 2, 1)\n        if self.normalize:\n            seq_last = x[:, :, -1:].detach()\n            x = x - seq_last\n        x = self.layer(x)\n        if self.normalize:\n            x = x + seq_last\n        x = x.view(batch, self.output_dim, self.output_chunk_length, self.nr_params)\n        x = x.permute(0, 2, 1, 3)\n    else:\n        if self.normalize:\n            seq_last = x[:, -1:, :self.output_dim].detach()\n            x = x - seq_last\n        x = self.layer(x.view(batch, -1))\n        x = x.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.future_cov_dim != 0:\n            x_future = torch.nn.functional.pad(input=x_future, pad=(0, 0, 0, self.output_chunk_length - x_future.shape[1]), mode='constant', value=0)\n            fut_cov_output = self.linear_fut_cov(x_future)\n            x = x + fut_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.static_cov_dim != 0:\n            static_cov_output = self.linear_static_cov(x_static.reshape(batch, -1))\n            x = x + static_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        x = x.view(batch, self.output_chunk_length, self.output_dim, self.nr_params)\n        if self.normalize:\n            x = x + seq_last.view(seq_last.shape + (1,))\n    return x",
            "@io_processor\ndef forward(self, x_in: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        x_in\\n            comes as tuple `(x_past, x_future, x_static)` where `x_past` is the input/past chunk and `x_future`\\n            is the output/future chunk. Input dimensions are `(n_samples, n_time_steps, n_variables)`\\n        '\n    (x, x_future, x_static) = x_in\n    (batch, _, _) = x.shape\n    if self.shared_weights:\n        x = x[:, :, :self.output_dim]\n        x = x.permute(0, 2, 1)\n        if self.normalize:\n            seq_last = x[:, :, -1:].detach()\n            x = x - seq_last\n        x = self.layer(x)\n        if self.normalize:\n            x = x + seq_last\n        x = x.view(batch, self.output_dim, self.output_chunk_length, self.nr_params)\n        x = x.permute(0, 2, 1, 3)\n    else:\n        if self.normalize:\n            seq_last = x[:, -1:, :self.output_dim].detach()\n            x = x - seq_last\n        x = self.layer(x.view(batch, -1))\n        x = x.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.future_cov_dim != 0:\n            x_future = torch.nn.functional.pad(input=x_future, pad=(0, 0, 0, self.output_chunk_length - x_future.shape[1]), mode='constant', value=0)\n            fut_cov_output = self.linear_fut_cov(x_future)\n            x = x + fut_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.static_cov_dim != 0:\n            static_cov_output = self.linear_static_cov(x_static.reshape(batch, -1))\n            x = x + static_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        x = x.view(batch, self.output_chunk_length, self.output_dim, self.nr_params)\n        if self.normalize:\n            x = x + seq_last.view(seq_last.shape + (1,))\n    return x",
            "@io_processor\ndef forward(self, x_in: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        x_in\\n            comes as tuple `(x_past, x_future, x_static)` where `x_past` is the input/past chunk and `x_future`\\n            is the output/future chunk. Input dimensions are `(n_samples, n_time_steps, n_variables)`\\n        '\n    (x, x_future, x_static) = x_in\n    (batch, _, _) = x.shape\n    if self.shared_weights:\n        x = x[:, :, :self.output_dim]\n        x = x.permute(0, 2, 1)\n        if self.normalize:\n            seq_last = x[:, :, -1:].detach()\n            x = x - seq_last\n        x = self.layer(x)\n        if self.normalize:\n            x = x + seq_last\n        x = x.view(batch, self.output_dim, self.output_chunk_length, self.nr_params)\n        x = x.permute(0, 2, 1, 3)\n    else:\n        if self.normalize:\n            seq_last = x[:, -1:, :self.output_dim].detach()\n            x = x - seq_last\n        x = self.layer(x.view(batch, -1))\n        x = x.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.future_cov_dim != 0:\n            x_future = torch.nn.functional.pad(input=x_future, pad=(0, 0, 0, self.output_chunk_length - x_future.shape[1]), mode='constant', value=0)\n            fut_cov_output = self.linear_fut_cov(x_future)\n            x = x + fut_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.static_cov_dim != 0:\n            static_cov_output = self.linear_static_cov(x_static.reshape(batch, -1))\n            x = x + static_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        x = x.view(batch, self.output_chunk_length, self.output_dim, self.nr_params)\n        if self.normalize:\n            x = x + seq_last.view(seq_last.shape + (1,))\n    return x",
            "@io_processor\ndef forward(self, x_in: Tuple[torch.Tensor, Optional[torch.Tensor], Optional[torch.Tensor]]):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        x_in\\n            comes as tuple `(x_past, x_future, x_static)` where `x_past` is the input/past chunk and `x_future`\\n            is the output/future chunk. Input dimensions are `(n_samples, n_time_steps, n_variables)`\\n        '\n    (x, x_future, x_static) = x_in\n    (batch, _, _) = x.shape\n    if self.shared_weights:\n        x = x[:, :, :self.output_dim]\n        x = x.permute(0, 2, 1)\n        if self.normalize:\n            seq_last = x[:, :, -1:].detach()\n            x = x - seq_last\n        x = self.layer(x)\n        if self.normalize:\n            x = x + seq_last\n        x = x.view(batch, self.output_dim, self.output_chunk_length, self.nr_params)\n        x = x.permute(0, 2, 1, 3)\n    else:\n        if self.normalize:\n            seq_last = x[:, -1:, :self.output_dim].detach()\n            x = x - seq_last\n        x = self.layer(x.view(batch, -1))\n        x = x.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.future_cov_dim != 0:\n            x_future = torch.nn.functional.pad(input=x_future, pad=(0, 0, 0, self.output_chunk_length - x_future.shape[1]), mode='constant', value=0)\n            fut_cov_output = self.linear_fut_cov(x_future)\n            x = x + fut_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        if self.static_cov_dim != 0:\n            static_cov_output = self.linear_static_cov(x_static.reshape(batch, -1))\n            x = x + static_cov_output.view(batch, self.output_chunk_length, self.output_dim * self.nr_params)\n        x = x.view(batch, self.output_chunk_length, self.output_dim, self.nr_params)\n        if self.normalize:\n            x = x + seq_last.view(seq_last.shape + (1,))\n    return x"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, input_chunk_length: int, output_chunk_length: int, shared_weights: bool=False, const_init: bool=True, normalize: bool=False, use_static_covariates: bool=True, **kwargs):\n    \"\"\"An implementation of the NLinear model, as presented in [1]_.\n\n        This implementation is improved by allowing the optional use of past covariates,\n        future covariates and static covariates, and by making the model optionally probabilistic.\n\n        Parameters\n        ----------\n        input_chunk_length\n            The length of the input sequence fed to the model.\n        output_chunk_length\n            The length of the forecast of the model.\n        shared_weights\n            Whether to use shared weights for all components of multivariate series.\n\n            .. warning::\n                When set to True, covariates will be ignored as a 1-to-1 mapping is\n                required between input dimensions and output dimensions.\n            ..\n\n            Default: False.\n\n        const_init\n            Whether to initialize the weights to 1/in_len. If False, the default PyTorch\n            initialization is used (default='True').\n        normalize\n            Whether to apply the simple \"normalization\" proposed in the paper, which consists\n            in subtracting the last value of the input sequence from the input sequence. Default: False.\n\n            .. note::\n                This cannot be applied to probabilistic models.\n            ..\n        use_static_covariates\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\n        **kwargs\n            Optional arguments to initialize the pytorch_lightning.Module, pytorch_lightning.Trainer, and\n            Darts' :class:`TorchForecastingModel`.\n\n        loss_fn\n            PyTorch loss function used for training.\n            This parameter will be ignored for probabilistic models if the ``likelihood`` parameter is specified.\n            Default: ``torch.nn.MSELoss()``.\n        likelihood\n            One of Darts' :meth:`Likelihood <darts.utils.likelihood_models.Likelihood>` models to be used for\n            probabilistic forecasts. Default: ``None``.\n        torch_metrics\n            A torch metric or a ``MetricCollection`` used for evaluation. A full list of available metrics can be found\n            at https://torchmetrics.readthedocs.io/en/latest/. Default: ``None``.\n        optimizer_cls\n            The PyTorch optimizer class to be used. Default: ``torch.optim.Adam``.\n        optimizer_kwargs\n            Optionally, some keyword arguments for the PyTorch optimizer (e.g., ``{'lr': 1e-3}``\n            for specifying a learning rate). Otherwise, the default values of the selected ``optimizer_cls``\n            will be used. Default: ``None``.\n        lr_scheduler_cls\n            Optionally, the PyTorch learning rate scheduler class to be used. Specifying ``None`` corresponds\n            to using a constant learning rate. Default: ``None``.\n        lr_scheduler_kwargs\n            Optionally, some keyword arguments for the PyTorch learning rate scheduler. Default: ``None``.\n        use_reversible_instance_norm\n            Whether to use reversible instance normalization `RINorm` against distribution shift as shown in [2]_.\n            It is only applied to the features of the target series and not the covariates.\n        batch_size\n            Number of time series (input and output sequences) used in each training pass. Default: ``32``.\n        n_epochs\n            Number of epochs over which to train the model. Default: ``100``.\n        model_name\n            Name of the model. Used for creating checkpoints and saving tensorboard data. If not specified,\n            defaults to the following string ``\"YYYY-mm-dd_HH_MM_SS_torch_model_run_PID\"``, where the initial part\n            of the name is formatted with the local date and time, while PID is the processed ID (preventing models\n            spawned at the same time by different processes to share the same model_name). E.g.,\n            ``\"2021-06-14_09_53_32_torch_model_run_44607\"``.\n        work_dir\n            Path of the working directory, where to save checkpoints and Tensorboard summaries.\n            Default: current working directory.\n        log_tensorboard\n            If set, use Tensorboard to log the different parameters. The logs will be located in:\n            ``\"{work_dir}/darts_logs/{model_name}/logs/\"``. Default: ``False``.\n        nr_epochs_val_period\n            Number of epochs to wait before evaluating the validation loss (if a validation\n            ``TimeSeries`` is passed to the :func:`fit()` method). Default: ``1``.\n        force_reset\n            If set to ``True``, any previously-existing model with the same name will be reset (all checkpoints will\n            be discarded). Default: ``False``.\n        save_checkpoints\n            Whether or not to automatically save the untrained model and checkpoints from training.\n            To load the model from checkpoint, call :func:`MyModelClass.load_from_checkpoint()`, where\n            :class:`MyModelClass` is the :class:`TorchForecastingModel` class that was used (such as :class:`TFTModel`,\n            :class:`NBEATSModel`, etc.). If set to ``False``, the model can still be manually saved using\n            :func:`save()` and loaded using :func:`load()`. Default: ``False``.\n        add_encoders\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\n            will be used as index encoders. Additionally, a transformer such as Darts' :class:`Scaler` can be added to\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\n            model creation.\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\n\n            .. highlight:: python\n            .. code-block:: python\n\n                def encode_year(idx):\n                    return (idx.year - 1950) / 50\n\n                add_encoders={\n                    'cyclic': {'future': ['month']},\n                    'datetime_attribute': {'future': ['hour', 'dayofweek']},\n                    'position': {'past': ['relative'], 'future': ['relative']},\n                    'custom': {'past': [encode_year]},\n                    'transformer': Scaler(),\n                    'tz': 'CET'\n                }\n            ..\n        random_state\n            Control the randomness of the weights initialization. Check this\n            `link <https://scikit-learn.org/stable/glossary.html#term-random_state>`_ for more details.\n            Default: ``None``.\n        pl_trainer_kwargs\n            By default :class:`TorchForecastingModel` creates a PyTorch Lightning Trainer with several useful presets\n            that performs the training, validation and prediction processes. These presets include automatic\n            checkpointing, tensorboard logging, setting the torch device and more.\n            With ``pl_trainer_kwargs`` you can add additional kwargs to instantiate the PyTorch Lightning trainer\n            object. Check the `PL Trainer documentation\n            <https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html>`_ for more information about the\n            supported kwargs. Default: ``None``.\n            Running on GPU(s) is also possible using ``pl_trainer_kwargs`` by specifying keys ``\"accelerator\",\n            \"devices\", and \"auto_select_gpus\"``. Some examples for setting the devices inside the ``pl_trainer_kwargs``\n            dict:\n\n                - ``{\"accelerator\": \"cpu\"}`` for CPU,\n                - ``{\"accelerator\": \"gpu\", \"devices\": [i]}`` to use only GPU ``i`` (``i`` must be an integer),\n                - ``{\"accelerator\": \"gpu\", \"devices\": -1, \"auto_select_gpus\": True}`` to use all available GPUS.\n\n                For more info, see here:\n                https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#trainer-flags , and\n                https://pytorch-lightning.readthedocs.io/en/stable/accelerators/gpu_basic.html#train-on-multiple-gpus\n            With parameter ``\"callbacks\"`` you can add custom or PyTorch-Lightning built-in callbacks to Darts'\n            :class:`TorchForecastingModel`. Below is an example for adding EarlyStopping to the training process.\n            The model will stop training early if the validation loss `val_loss` does not improve beyond\n            specifications. For more information on callbacks, visit:\n            `PyTorch Lightning Callbacks\n            <https://pytorch-lightning.readthedocs.io/en/stable/extensions/callbacks.html>`_\n\n            .. highlight:: python\n            .. code-block:: python\n\n                from pytorch_lightning.callbacks.early_stopping import EarlyStopping\n\n                # stop training when validation loss does not decrease more than 0.05 (`min_delta`) over\n                # a period of 5 epochs (`patience`)\n                my_stopper = EarlyStopping(\n                    monitor=\"val_loss\",\n                    patience=5,\n                    min_delta=0.05,\n                    mode='min',\n                )\n\n                pl_trainer_kwargs={\"callbacks\": [my_stopper]}\n            ..\n\n            Note that you can also use a custom PyTorch Lightning Trainer for training and prediction with optional\n            parameter ``trainer`` in :func:`fit()` and :func:`predict()`.\n        show_warnings\n            whether to show warnings raised from PyTorch Lightning. Useful to detect potential issues of\n            your forecasting use case. Default: ``False``.\n\n        References\n        ----------\n        .. [1] Zeng, A., Chen, M., Zhang, L., & Xu, Q. (2022).\n               Are Transformers Effective for Time Series Forecasting?. arXiv preprint arXiv:2205.13504.\n        .. [2] T. Kim et al. \"Reversible Instance Normalization for Accurate Time-Series Forecasting against\n                Distribution Shift\", https://openreview.net/forum?id=cGDAkQo1C0p\n\n        Examples\n        --------\n        >>> from darts.datasets import WeatherDataset\n        >>> from darts.models import NLinearModel\n        >>> series = WeatherDataset().load()\n        >>> # predicting atmospheric pressure\n        >>> target = series['p (mbar)'][:100]\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\n        >>> past_cov = series['rain (mm)'][:100]\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\n        >>> future_cov = series['T (degC)'][:106]\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\n        >>> # values corresponding to the forecasted period\n        >>> model = NLinearModel(\n        >>>     input_chunk_length=6,\n        >>>     output_chunk_length=6,\n        >>>     n_epochs=20,\n        >>> )\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\n        >>> pred = model.predict(6)\n        >>> pred.values()\n        array([[429.56117169],\n               [428.93264096],\n               [428.35210616],\n               [428.13154426],\n               [427.98781641],\n               [428.00325481]])\n        \"\"\"\n    super().__init__(**self._extract_torch_model_params(**self.model_params))\n    self.pl_module_params = self._extract_pl_module_params(**self.model_params)\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n    self._considers_static_covariates = use_static_covariates\n    raise_if('likelihood' in self.model_params and self.model_params['likelihood'] is not None and self.normalize, 'normalize = True cannot be used with probabilistic NLinearModel')",
        "mutated": [
            "def __init__(self, input_chunk_length: int, output_chunk_length: int, shared_weights: bool=False, const_init: bool=True, normalize: bool=False, use_static_covariates: bool=True, **kwargs):\n    if False:\n        i = 10\n    'An implementation of the NLinear model, as presented in [1]_.\\n\\n        This implementation is improved by allowing the optional use of past covariates,\\n        future covariates and static covariates, and by making the model optionally probabilistic.\\n\\n        Parameters\\n        ----------\\n        input_chunk_length\\n            The length of the input sequence fed to the model.\\n        output_chunk_length\\n            The length of the forecast of the model.\\n        shared_weights\\n            Whether to use shared weights for all components of multivariate series.\\n\\n            .. warning::\\n                When set to True, covariates will be ignored as a 1-to-1 mapping is\\n                required between input dimensions and output dimensions.\\n            ..\\n\\n            Default: False.\\n\\n        const_init\\n            Whether to initialize the weights to 1/in_len. If False, the default PyTorch\\n            initialization is used (default=\\'True\\').\\n        normalize\\n            Whether to apply the simple \"normalization\" proposed in the paper, which consists\\n            in subtracting the last value of the input sequence from the input sequence. Default: False.\\n\\n            .. note::\\n                This cannot be applied to probabilistic models.\\n            ..\\n        use_static_covariates\\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\\n        **kwargs\\n            Optional arguments to initialize the pytorch_lightning.Module, pytorch_lightning.Trainer, and\\n            Darts\\' :class:`TorchForecastingModel`.\\n\\n        loss_fn\\n            PyTorch loss function used for training.\\n            This parameter will be ignored for probabilistic models if the ``likelihood`` parameter is specified.\\n            Default: ``torch.nn.MSELoss()``.\\n        likelihood\\n            One of Darts\\' :meth:`Likelihood <darts.utils.likelihood_models.Likelihood>` models to be used for\\n            probabilistic forecasts. Default: ``None``.\\n        torch_metrics\\n            A torch metric or a ``MetricCollection`` used for evaluation. A full list of available metrics can be found\\n            at https://torchmetrics.readthedocs.io/en/latest/. Default: ``None``.\\n        optimizer_cls\\n            The PyTorch optimizer class to be used. Default: ``torch.optim.Adam``.\\n        optimizer_kwargs\\n            Optionally, some keyword arguments for the PyTorch optimizer (e.g., ``{\\'lr\\': 1e-3}``\\n            for specifying a learning rate). Otherwise, the default values of the selected ``optimizer_cls``\\n            will be used. Default: ``None``.\\n        lr_scheduler_cls\\n            Optionally, the PyTorch learning rate scheduler class to be used. Specifying ``None`` corresponds\\n            to using a constant learning rate. Default: ``None``.\\n        lr_scheduler_kwargs\\n            Optionally, some keyword arguments for the PyTorch learning rate scheduler. Default: ``None``.\\n        use_reversible_instance_norm\\n            Whether to use reversible instance normalization `RINorm` against distribution shift as shown in [2]_.\\n            It is only applied to the features of the target series and not the covariates.\\n        batch_size\\n            Number of time series (input and output sequences) used in each training pass. Default: ``32``.\\n        n_epochs\\n            Number of epochs over which to train the model. Default: ``100``.\\n        model_name\\n            Name of the model. Used for creating checkpoints and saving tensorboard data. If not specified,\\n            defaults to the following string ``\"YYYY-mm-dd_HH_MM_SS_torch_model_run_PID\"``, where the initial part\\n            of the name is formatted with the local date and time, while PID is the processed ID (preventing models\\n            spawned at the same time by different processes to share the same model_name). E.g.,\\n            ``\"2021-06-14_09_53_32_torch_model_run_44607\"``.\\n        work_dir\\n            Path of the working directory, where to save checkpoints and Tensorboard summaries.\\n            Default: current working directory.\\n        log_tensorboard\\n            If set, use Tensorboard to log the different parameters. The logs will be located in:\\n            ``\"{work_dir}/darts_logs/{model_name}/logs/\"``. Default: ``False``.\\n        nr_epochs_val_period\\n            Number of epochs to wait before evaluating the validation loss (if a validation\\n            ``TimeSeries`` is passed to the :func:`fit()` method). Default: ``1``.\\n        force_reset\\n            If set to ``True``, any previously-existing model with the same name will be reset (all checkpoints will\\n            be discarded). Default: ``False``.\\n        save_checkpoints\\n            Whether or not to automatically save the untrained model and checkpoints from training.\\n            To load the model from checkpoint, call :func:`MyModelClass.load_from_checkpoint()`, where\\n            :class:`MyModelClass` is the :class:`TorchForecastingModel` class that was used (such as :class:`TFTModel`,\\n            :class:`NBEATSModel`, etc.). If set to ``False``, the model can still be manually saved using\\n            :func:`save()` and loaded using :func:`load()`. Default: ``False``.\\n        add_encoders\\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\\n            will be used as index encoders. Additionally, a transformer such as Darts\\' :class:`Scaler` can be added to\\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\\n            model creation.\\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                def encode_year(idx):\\n                    return (idx.year - 1950) / 50\\n\\n                add_encoders={\\n                    \\'cyclic\\': {\\'future\\': [\\'month\\']},\\n                    \\'datetime_attribute\\': {\\'future\\': [\\'hour\\', \\'dayofweek\\']},\\n                    \\'position\\': {\\'past\\': [\\'relative\\'], \\'future\\': [\\'relative\\']},\\n                    \\'custom\\': {\\'past\\': [encode_year]},\\n                    \\'transformer\\': Scaler(),\\n                    \\'tz\\': \\'CET\\'\\n                }\\n            ..\\n        random_state\\n            Control the randomness of the weights initialization. Check this\\n            `link <https://scikit-learn.org/stable/glossary.html#term-random_state>`_ for more details.\\n            Default: ``None``.\\n        pl_trainer_kwargs\\n            By default :class:`TorchForecastingModel` creates a PyTorch Lightning Trainer with several useful presets\\n            that performs the training, validation and prediction processes. These presets include automatic\\n            checkpointing, tensorboard logging, setting the torch device and more.\\n            With ``pl_trainer_kwargs`` you can add additional kwargs to instantiate the PyTorch Lightning trainer\\n            object. Check the `PL Trainer documentation\\n            <https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html>`_ for more information about the\\n            supported kwargs. Default: ``None``.\\n            Running on GPU(s) is also possible using ``pl_trainer_kwargs`` by specifying keys ``\"accelerator\",\\n            \"devices\", and \"auto_select_gpus\"``. Some examples for setting the devices inside the ``pl_trainer_kwargs``\\n            dict:\\n\\n                - ``{\"accelerator\": \"cpu\"}`` for CPU,\\n                - ``{\"accelerator\": \"gpu\", \"devices\": [i]}`` to use only GPU ``i`` (``i`` must be an integer),\\n                - ``{\"accelerator\": \"gpu\", \"devices\": -1, \"auto_select_gpus\": True}`` to use all available GPUS.\\n\\n                For more info, see here:\\n                https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#trainer-flags , and\\n                https://pytorch-lightning.readthedocs.io/en/stable/accelerators/gpu_basic.html#train-on-multiple-gpus\\n            With parameter ``\"callbacks\"`` you can add custom or PyTorch-Lightning built-in callbacks to Darts\\'\\n            :class:`TorchForecastingModel`. Below is an example for adding EarlyStopping to the training process.\\n            The model will stop training early if the validation loss `val_loss` does not improve beyond\\n            specifications. For more information on callbacks, visit:\\n            `PyTorch Lightning Callbacks\\n            <https://pytorch-lightning.readthedocs.io/en/stable/extensions/callbacks.html>`_\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                from pytorch_lightning.callbacks.early_stopping import EarlyStopping\\n\\n                # stop training when validation loss does not decrease more than 0.05 (`min_delta`) over\\n                # a period of 5 epochs (`patience`)\\n                my_stopper = EarlyStopping(\\n                    monitor=\"val_loss\",\\n                    patience=5,\\n                    min_delta=0.05,\\n                    mode=\\'min\\',\\n                )\\n\\n                pl_trainer_kwargs={\"callbacks\": [my_stopper]}\\n            ..\\n\\n            Note that you can also use a custom PyTorch Lightning Trainer for training and prediction with optional\\n            parameter ``trainer`` in :func:`fit()` and :func:`predict()`.\\n        show_warnings\\n            whether to show warnings raised from PyTorch Lightning. Useful to detect potential issues of\\n            your forecasting use case. Default: ``False``.\\n\\n        References\\n        ----------\\n        .. [1] Zeng, A., Chen, M., Zhang, L., & Xu, Q. (2022).\\n               Are Transformers Effective for Time Series Forecasting?. arXiv preprint arXiv:2205.13504.\\n        .. [2] T. Kim et al. \"Reversible Instance Normalization for Accurate Time-Series Forecasting against\\n                Distribution Shift\", https://openreview.net/forum?id=cGDAkQo1C0p\\n\\n        Examples\\n        --------\\n        >>> from darts.datasets import WeatherDataset\\n        >>> from darts.models import NLinearModel\\n        >>> series = WeatherDataset().load()\\n        >>> # predicting atmospheric pressure\\n        >>> target = series[\\'p (mbar)\\'][:100]\\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\\n        >>> past_cov = series[\\'rain (mm)\\'][:100]\\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\\n        >>> future_cov = series[\\'T (degC)\\'][:106]\\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\\n        >>> # values corresponding to the forecasted period\\n        >>> model = NLinearModel(\\n        >>>     input_chunk_length=6,\\n        >>>     output_chunk_length=6,\\n        >>>     n_epochs=20,\\n        >>> )\\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\\n        >>> pred = model.predict(6)\\n        >>> pred.values()\\n        array([[429.56117169],\\n               [428.93264096],\\n               [428.35210616],\\n               [428.13154426],\\n               [427.98781641],\\n               [428.00325481]])\\n        '\n    super().__init__(**self._extract_torch_model_params(**self.model_params))\n    self.pl_module_params = self._extract_pl_module_params(**self.model_params)\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n    self._considers_static_covariates = use_static_covariates\n    raise_if('likelihood' in self.model_params and self.model_params['likelihood'] is not None and self.normalize, 'normalize = True cannot be used with probabilistic NLinearModel')",
            "def __init__(self, input_chunk_length: int, output_chunk_length: int, shared_weights: bool=False, const_init: bool=True, normalize: bool=False, use_static_covariates: bool=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'An implementation of the NLinear model, as presented in [1]_.\\n\\n        This implementation is improved by allowing the optional use of past covariates,\\n        future covariates and static covariates, and by making the model optionally probabilistic.\\n\\n        Parameters\\n        ----------\\n        input_chunk_length\\n            The length of the input sequence fed to the model.\\n        output_chunk_length\\n            The length of the forecast of the model.\\n        shared_weights\\n            Whether to use shared weights for all components of multivariate series.\\n\\n            .. warning::\\n                When set to True, covariates will be ignored as a 1-to-1 mapping is\\n                required between input dimensions and output dimensions.\\n            ..\\n\\n            Default: False.\\n\\n        const_init\\n            Whether to initialize the weights to 1/in_len. If False, the default PyTorch\\n            initialization is used (default=\\'True\\').\\n        normalize\\n            Whether to apply the simple \"normalization\" proposed in the paper, which consists\\n            in subtracting the last value of the input sequence from the input sequence. Default: False.\\n\\n            .. note::\\n                This cannot be applied to probabilistic models.\\n            ..\\n        use_static_covariates\\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\\n        **kwargs\\n            Optional arguments to initialize the pytorch_lightning.Module, pytorch_lightning.Trainer, and\\n            Darts\\' :class:`TorchForecastingModel`.\\n\\n        loss_fn\\n            PyTorch loss function used for training.\\n            This parameter will be ignored for probabilistic models if the ``likelihood`` parameter is specified.\\n            Default: ``torch.nn.MSELoss()``.\\n        likelihood\\n            One of Darts\\' :meth:`Likelihood <darts.utils.likelihood_models.Likelihood>` models to be used for\\n            probabilistic forecasts. Default: ``None``.\\n        torch_metrics\\n            A torch metric or a ``MetricCollection`` used for evaluation. A full list of available metrics can be found\\n            at https://torchmetrics.readthedocs.io/en/latest/. Default: ``None``.\\n        optimizer_cls\\n            The PyTorch optimizer class to be used. Default: ``torch.optim.Adam``.\\n        optimizer_kwargs\\n            Optionally, some keyword arguments for the PyTorch optimizer (e.g., ``{\\'lr\\': 1e-3}``\\n            for specifying a learning rate). Otherwise, the default values of the selected ``optimizer_cls``\\n            will be used. Default: ``None``.\\n        lr_scheduler_cls\\n            Optionally, the PyTorch learning rate scheduler class to be used. Specifying ``None`` corresponds\\n            to using a constant learning rate. Default: ``None``.\\n        lr_scheduler_kwargs\\n            Optionally, some keyword arguments for the PyTorch learning rate scheduler. Default: ``None``.\\n        use_reversible_instance_norm\\n            Whether to use reversible instance normalization `RINorm` against distribution shift as shown in [2]_.\\n            It is only applied to the features of the target series and not the covariates.\\n        batch_size\\n            Number of time series (input and output sequences) used in each training pass. Default: ``32``.\\n        n_epochs\\n            Number of epochs over which to train the model. Default: ``100``.\\n        model_name\\n            Name of the model. Used for creating checkpoints and saving tensorboard data. If not specified,\\n            defaults to the following string ``\"YYYY-mm-dd_HH_MM_SS_torch_model_run_PID\"``, where the initial part\\n            of the name is formatted with the local date and time, while PID is the processed ID (preventing models\\n            spawned at the same time by different processes to share the same model_name). E.g.,\\n            ``\"2021-06-14_09_53_32_torch_model_run_44607\"``.\\n        work_dir\\n            Path of the working directory, where to save checkpoints and Tensorboard summaries.\\n            Default: current working directory.\\n        log_tensorboard\\n            If set, use Tensorboard to log the different parameters. The logs will be located in:\\n            ``\"{work_dir}/darts_logs/{model_name}/logs/\"``. Default: ``False``.\\n        nr_epochs_val_period\\n            Number of epochs to wait before evaluating the validation loss (if a validation\\n            ``TimeSeries`` is passed to the :func:`fit()` method). Default: ``1``.\\n        force_reset\\n            If set to ``True``, any previously-existing model with the same name will be reset (all checkpoints will\\n            be discarded). Default: ``False``.\\n        save_checkpoints\\n            Whether or not to automatically save the untrained model and checkpoints from training.\\n            To load the model from checkpoint, call :func:`MyModelClass.load_from_checkpoint()`, where\\n            :class:`MyModelClass` is the :class:`TorchForecastingModel` class that was used (such as :class:`TFTModel`,\\n            :class:`NBEATSModel`, etc.). If set to ``False``, the model can still be manually saved using\\n            :func:`save()` and loaded using :func:`load()`. Default: ``False``.\\n        add_encoders\\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\\n            will be used as index encoders. Additionally, a transformer such as Darts\\' :class:`Scaler` can be added to\\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\\n            model creation.\\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                def encode_year(idx):\\n                    return (idx.year - 1950) / 50\\n\\n                add_encoders={\\n                    \\'cyclic\\': {\\'future\\': [\\'month\\']},\\n                    \\'datetime_attribute\\': {\\'future\\': [\\'hour\\', \\'dayofweek\\']},\\n                    \\'position\\': {\\'past\\': [\\'relative\\'], \\'future\\': [\\'relative\\']},\\n                    \\'custom\\': {\\'past\\': [encode_year]},\\n                    \\'transformer\\': Scaler(),\\n                    \\'tz\\': \\'CET\\'\\n                }\\n            ..\\n        random_state\\n            Control the randomness of the weights initialization. Check this\\n            `link <https://scikit-learn.org/stable/glossary.html#term-random_state>`_ for more details.\\n            Default: ``None``.\\n        pl_trainer_kwargs\\n            By default :class:`TorchForecastingModel` creates a PyTorch Lightning Trainer with several useful presets\\n            that performs the training, validation and prediction processes. These presets include automatic\\n            checkpointing, tensorboard logging, setting the torch device and more.\\n            With ``pl_trainer_kwargs`` you can add additional kwargs to instantiate the PyTorch Lightning trainer\\n            object. Check the `PL Trainer documentation\\n            <https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html>`_ for more information about the\\n            supported kwargs. Default: ``None``.\\n            Running on GPU(s) is also possible using ``pl_trainer_kwargs`` by specifying keys ``\"accelerator\",\\n            \"devices\", and \"auto_select_gpus\"``. Some examples for setting the devices inside the ``pl_trainer_kwargs``\\n            dict:\\n\\n                - ``{\"accelerator\": \"cpu\"}`` for CPU,\\n                - ``{\"accelerator\": \"gpu\", \"devices\": [i]}`` to use only GPU ``i`` (``i`` must be an integer),\\n                - ``{\"accelerator\": \"gpu\", \"devices\": -1, \"auto_select_gpus\": True}`` to use all available GPUS.\\n\\n                For more info, see here:\\n                https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#trainer-flags , and\\n                https://pytorch-lightning.readthedocs.io/en/stable/accelerators/gpu_basic.html#train-on-multiple-gpus\\n            With parameter ``\"callbacks\"`` you can add custom or PyTorch-Lightning built-in callbacks to Darts\\'\\n            :class:`TorchForecastingModel`. Below is an example for adding EarlyStopping to the training process.\\n            The model will stop training early if the validation loss `val_loss` does not improve beyond\\n            specifications. For more information on callbacks, visit:\\n            `PyTorch Lightning Callbacks\\n            <https://pytorch-lightning.readthedocs.io/en/stable/extensions/callbacks.html>`_\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                from pytorch_lightning.callbacks.early_stopping import EarlyStopping\\n\\n                # stop training when validation loss does not decrease more than 0.05 (`min_delta`) over\\n                # a period of 5 epochs (`patience`)\\n                my_stopper = EarlyStopping(\\n                    monitor=\"val_loss\",\\n                    patience=5,\\n                    min_delta=0.05,\\n                    mode=\\'min\\',\\n                )\\n\\n                pl_trainer_kwargs={\"callbacks\": [my_stopper]}\\n            ..\\n\\n            Note that you can also use a custom PyTorch Lightning Trainer for training and prediction with optional\\n            parameter ``trainer`` in :func:`fit()` and :func:`predict()`.\\n        show_warnings\\n            whether to show warnings raised from PyTorch Lightning. Useful to detect potential issues of\\n            your forecasting use case. Default: ``False``.\\n\\n        References\\n        ----------\\n        .. [1] Zeng, A., Chen, M., Zhang, L., & Xu, Q. (2022).\\n               Are Transformers Effective for Time Series Forecasting?. arXiv preprint arXiv:2205.13504.\\n        .. [2] T. Kim et al. \"Reversible Instance Normalization for Accurate Time-Series Forecasting against\\n                Distribution Shift\", https://openreview.net/forum?id=cGDAkQo1C0p\\n\\n        Examples\\n        --------\\n        >>> from darts.datasets import WeatherDataset\\n        >>> from darts.models import NLinearModel\\n        >>> series = WeatherDataset().load()\\n        >>> # predicting atmospheric pressure\\n        >>> target = series[\\'p (mbar)\\'][:100]\\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\\n        >>> past_cov = series[\\'rain (mm)\\'][:100]\\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\\n        >>> future_cov = series[\\'T (degC)\\'][:106]\\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\\n        >>> # values corresponding to the forecasted period\\n        >>> model = NLinearModel(\\n        >>>     input_chunk_length=6,\\n        >>>     output_chunk_length=6,\\n        >>>     n_epochs=20,\\n        >>> )\\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\\n        >>> pred = model.predict(6)\\n        >>> pred.values()\\n        array([[429.56117169],\\n               [428.93264096],\\n               [428.35210616],\\n               [428.13154426],\\n               [427.98781641],\\n               [428.00325481]])\\n        '\n    super().__init__(**self._extract_torch_model_params(**self.model_params))\n    self.pl_module_params = self._extract_pl_module_params(**self.model_params)\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n    self._considers_static_covariates = use_static_covariates\n    raise_if('likelihood' in self.model_params and self.model_params['likelihood'] is not None and self.normalize, 'normalize = True cannot be used with probabilistic NLinearModel')",
            "def __init__(self, input_chunk_length: int, output_chunk_length: int, shared_weights: bool=False, const_init: bool=True, normalize: bool=False, use_static_covariates: bool=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'An implementation of the NLinear model, as presented in [1]_.\\n\\n        This implementation is improved by allowing the optional use of past covariates,\\n        future covariates and static covariates, and by making the model optionally probabilistic.\\n\\n        Parameters\\n        ----------\\n        input_chunk_length\\n            The length of the input sequence fed to the model.\\n        output_chunk_length\\n            The length of the forecast of the model.\\n        shared_weights\\n            Whether to use shared weights for all components of multivariate series.\\n\\n            .. warning::\\n                When set to True, covariates will be ignored as a 1-to-1 mapping is\\n                required between input dimensions and output dimensions.\\n            ..\\n\\n            Default: False.\\n\\n        const_init\\n            Whether to initialize the weights to 1/in_len. If False, the default PyTorch\\n            initialization is used (default=\\'True\\').\\n        normalize\\n            Whether to apply the simple \"normalization\" proposed in the paper, which consists\\n            in subtracting the last value of the input sequence from the input sequence. Default: False.\\n\\n            .. note::\\n                This cannot be applied to probabilistic models.\\n            ..\\n        use_static_covariates\\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\\n        **kwargs\\n            Optional arguments to initialize the pytorch_lightning.Module, pytorch_lightning.Trainer, and\\n            Darts\\' :class:`TorchForecastingModel`.\\n\\n        loss_fn\\n            PyTorch loss function used for training.\\n            This parameter will be ignored for probabilistic models if the ``likelihood`` parameter is specified.\\n            Default: ``torch.nn.MSELoss()``.\\n        likelihood\\n            One of Darts\\' :meth:`Likelihood <darts.utils.likelihood_models.Likelihood>` models to be used for\\n            probabilistic forecasts. Default: ``None``.\\n        torch_metrics\\n            A torch metric or a ``MetricCollection`` used for evaluation. A full list of available metrics can be found\\n            at https://torchmetrics.readthedocs.io/en/latest/. Default: ``None``.\\n        optimizer_cls\\n            The PyTorch optimizer class to be used. Default: ``torch.optim.Adam``.\\n        optimizer_kwargs\\n            Optionally, some keyword arguments for the PyTorch optimizer (e.g., ``{\\'lr\\': 1e-3}``\\n            for specifying a learning rate). Otherwise, the default values of the selected ``optimizer_cls``\\n            will be used. Default: ``None``.\\n        lr_scheduler_cls\\n            Optionally, the PyTorch learning rate scheduler class to be used. Specifying ``None`` corresponds\\n            to using a constant learning rate. Default: ``None``.\\n        lr_scheduler_kwargs\\n            Optionally, some keyword arguments for the PyTorch learning rate scheduler. Default: ``None``.\\n        use_reversible_instance_norm\\n            Whether to use reversible instance normalization `RINorm` against distribution shift as shown in [2]_.\\n            It is only applied to the features of the target series and not the covariates.\\n        batch_size\\n            Number of time series (input and output sequences) used in each training pass. Default: ``32``.\\n        n_epochs\\n            Number of epochs over which to train the model. Default: ``100``.\\n        model_name\\n            Name of the model. Used for creating checkpoints and saving tensorboard data. If not specified,\\n            defaults to the following string ``\"YYYY-mm-dd_HH_MM_SS_torch_model_run_PID\"``, where the initial part\\n            of the name is formatted with the local date and time, while PID is the processed ID (preventing models\\n            spawned at the same time by different processes to share the same model_name). E.g.,\\n            ``\"2021-06-14_09_53_32_torch_model_run_44607\"``.\\n        work_dir\\n            Path of the working directory, where to save checkpoints and Tensorboard summaries.\\n            Default: current working directory.\\n        log_tensorboard\\n            If set, use Tensorboard to log the different parameters. The logs will be located in:\\n            ``\"{work_dir}/darts_logs/{model_name}/logs/\"``. Default: ``False``.\\n        nr_epochs_val_period\\n            Number of epochs to wait before evaluating the validation loss (if a validation\\n            ``TimeSeries`` is passed to the :func:`fit()` method). Default: ``1``.\\n        force_reset\\n            If set to ``True``, any previously-existing model with the same name will be reset (all checkpoints will\\n            be discarded). Default: ``False``.\\n        save_checkpoints\\n            Whether or not to automatically save the untrained model and checkpoints from training.\\n            To load the model from checkpoint, call :func:`MyModelClass.load_from_checkpoint()`, where\\n            :class:`MyModelClass` is the :class:`TorchForecastingModel` class that was used (such as :class:`TFTModel`,\\n            :class:`NBEATSModel`, etc.). If set to ``False``, the model can still be manually saved using\\n            :func:`save()` and loaded using :func:`load()`. Default: ``False``.\\n        add_encoders\\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\\n            will be used as index encoders. Additionally, a transformer such as Darts\\' :class:`Scaler` can be added to\\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\\n            model creation.\\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                def encode_year(idx):\\n                    return (idx.year - 1950) / 50\\n\\n                add_encoders={\\n                    \\'cyclic\\': {\\'future\\': [\\'month\\']},\\n                    \\'datetime_attribute\\': {\\'future\\': [\\'hour\\', \\'dayofweek\\']},\\n                    \\'position\\': {\\'past\\': [\\'relative\\'], \\'future\\': [\\'relative\\']},\\n                    \\'custom\\': {\\'past\\': [encode_year]},\\n                    \\'transformer\\': Scaler(),\\n                    \\'tz\\': \\'CET\\'\\n                }\\n            ..\\n        random_state\\n            Control the randomness of the weights initialization. Check this\\n            `link <https://scikit-learn.org/stable/glossary.html#term-random_state>`_ for more details.\\n            Default: ``None``.\\n        pl_trainer_kwargs\\n            By default :class:`TorchForecastingModel` creates a PyTorch Lightning Trainer with several useful presets\\n            that performs the training, validation and prediction processes. These presets include automatic\\n            checkpointing, tensorboard logging, setting the torch device and more.\\n            With ``pl_trainer_kwargs`` you can add additional kwargs to instantiate the PyTorch Lightning trainer\\n            object. Check the `PL Trainer documentation\\n            <https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html>`_ for more information about the\\n            supported kwargs. Default: ``None``.\\n            Running on GPU(s) is also possible using ``pl_trainer_kwargs`` by specifying keys ``\"accelerator\",\\n            \"devices\", and \"auto_select_gpus\"``. Some examples for setting the devices inside the ``pl_trainer_kwargs``\\n            dict:\\n\\n                - ``{\"accelerator\": \"cpu\"}`` for CPU,\\n                - ``{\"accelerator\": \"gpu\", \"devices\": [i]}`` to use only GPU ``i`` (``i`` must be an integer),\\n                - ``{\"accelerator\": \"gpu\", \"devices\": -1, \"auto_select_gpus\": True}`` to use all available GPUS.\\n\\n                For more info, see here:\\n                https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#trainer-flags , and\\n                https://pytorch-lightning.readthedocs.io/en/stable/accelerators/gpu_basic.html#train-on-multiple-gpus\\n            With parameter ``\"callbacks\"`` you can add custom or PyTorch-Lightning built-in callbacks to Darts\\'\\n            :class:`TorchForecastingModel`. Below is an example for adding EarlyStopping to the training process.\\n            The model will stop training early if the validation loss `val_loss` does not improve beyond\\n            specifications. For more information on callbacks, visit:\\n            `PyTorch Lightning Callbacks\\n            <https://pytorch-lightning.readthedocs.io/en/stable/extensions/callbacks.html>`_\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                from pytorch_lightning.callbacks.early_stopping import EarlyStopping\\n\\n                # stop training when validation loss does not decrease more than 0.05 (`min_delta`) over\\n                # a period of 5 epochs (`patience`)\\n                my_stopper = EarlyStopping(\\n                    monitor=\"val_loss\",\\n                    patience=5,\\n                    min_delta=0.05,\\n                    mode=\\'min\\',\\n                )\\n\\n                pl_trainer_kwargs={\"callbacks\": [my_stopper]}\\n            ..\\n\\n            Note that you can also use a custom PyTorch Lightning Trainer for training and prediction with optional\\n            parameter ``trainer`` in :func:`fit()` and :func:`predict()`.\\n        show_warnings\\n            whether to show warnings raised from PyTorch Lightning. Useful to detect potential issues of\\n            your forecasting use case. Default: ``False``.\\n\\n        References\\n        ----------\\n        .. [1] Zeng, A., Chen, M., Zhang, L., & Xu, Q. (2022).\\n               Are Transformers Effective for Time Series Forecasting?. arXiv preprint arXiv:2205.13504.\\n        .. [2] T. Kim et al. \"Reversible Instance Normalization for Accurate Time-Series Forecasting against\\n                Distribution Shift\", https://openreview.net/forum?id=cGDAkQo1C0p\\n\\n        Examples\\n        --------\\n        >>> from darts.datasets import WeatherDataset\\n        >>> from darts.models import NLinearModel\\n        >>> series = WeatherDataset().load()\\n        >>> # predicting atmospheric pressure\\n        >>> target = series[\\'p (mbar)\\'][:100]\\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\\n        >>> past_cov = series[\\'rain (mm)\\'][:100]\\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\\n        >>> future_cov = series[\\'T (degC)\\'][:106]\\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\\n        >>> # values corresponding to the forecasted period\\n        >>> model = NLinearModel(\\n        >>>     input_chunk_length=6,\\n        >>>     output_chunk_length=6,\\n        >>>     n_epochs=20,\\n        >>> )\\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\\n        >>> pred = model.predict(6)\\n        >>> pred.values()\\n        array([[429.56117169],\\n               [428.93264096],\\n               [428.35210616],\\n               [428.13154426],\\n               [427.98781641],\\n               [428.00325481]])\\n        '\n    super().__init__(**self._extract_torch_model_params(**self.model_params))\n    self.pl_module_params = self._extract_pl_module_params(**self.model_params)\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n    self._considers_static_covariates = use_static_covariates\n    raise_if('likelihood' in self.model_params and self.model_params['likelihood'] is not None and self.normalize, 'normalize = True cannot be used with probabilistic NLinearModel')",
            "def __init__(self, input_chunk_length: int, output_chunk_length: int, shared_weights: bool=False, const_init: bool=True, normalize: bool=False, use_static_covariates: bool=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'An implementation of the NLinear model, as presented in [1]_.\\n\\n        This implementation is improved by allowing the optional use of past covariates,\\n        future covariates and static covariates, and by making the model optionally probabilistic.\\n\\n        Parameters\\n        ----------\\n        input_chunk_length\\n            The length of the input sequence fed to the model.\\n        output_chunk_length\\n            The length of the forecast of the model.\\n        shared_weights\\n            Whether to use shared weights for all components of multivariate series.\\n\\n            .. warning::\\n                When set to True, covariates will be ignored as a 1-to-1 mapping is\\n                required between input dimensions and output dimensions.\\n            ..\\n\\n            Default: False.\\n\\n        const_init\\n            Whether to initialize the weights to 1/in_len. If False, the default PyTorch\\n            initialization is used (default=\\'True\\').\\n        normalize\\n            Whether to apply the simple \"normalization\" proposed in the paper, which consists\\n            in subtracting the last value of the input sequence from the input sequence. Default: False.\\n\\n            .. note::\\n                This cannot be applied to probabilistic models.\\n            ..\\n        use_static_covariates\\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\\n        **kwargs\\n            Optional arguments to initialize the pytorch_lightning.Module, pytorch_lightning.Trainer, and\\n            Darts\\' :class:`TorchForecastingModel`.\\n\\n        loss_fn\\n            PyTorch loss function used for training.\\n            This parameter will be ignored for probabilistic models if the ``likelihood`` parameter is specified.\\n            Default: ``torch.nn.MSELoss()``.\\n        likelihood\\n            One of Darts\\' :meth:`Likelihood <darts.utils.likelihood_models.Likelihood>` models to be used for\\n            probabilistic forecasts. Default: ``None``.\\n        torch_metrics\\n            A torch metric or a ``MetricCollection`` used for evaluation. A full list of available metrics can be found\\n            at https://torchmetrics.readthedocs.io/en/latest/. Default: ``None``.\\n        optimizer_cls\\n            The PyTorch optimizer class to be used. Default: ``torch.optim.Adam``.\\n        optimizer_kwargs\\n            Optionally, some keyword arguments for the PyTorch optimizer (e.g., ``{\\'lr\\': 1e-3}``\\n            for specifying a learning rate). Otherwise, the default values of the selected ``optimizer_cls``\\n            will be used. Default: ``None``.\\n        lr_scheduler_cls\\n            Optionally, the PyTorch learning rate scheduler class to be used. Specifying ``None`` corresponds\\n            to using a constant learning rate. Default: ``None``.\\n        lr_scheduler_kwargs\\n            Optionally, some keyword arguments for the PyTorch learning rate scheduler. Default: ``None``.\\n        use_reversible_instance_norm\\n            Whether to use reversible instance normalization `RINorm` against distribution shift as shown in [2]_.\\n            It is only applied to the features of the target series and not the covariates.\\n        batch_size\\n            Number of time series (input and output sequences) used in each training pass. Default: ``32``.\\n        n_epochs\\n            Number of epochs over which to train the model. Default: ``100``.\\n        model_name\\n            Name of the model. Used for creating checkpoints and saving tensorboard data. If not specified,\\n            defaults to the following string ``\"YYYY-mm-dd_HH_MM_SS_torch_model_run_PID\"``, where the initial part\\n            of the name is formatted with the local date and time, while PID is the processed ID (preventing models\\n            spawned at the same time by different processes to share the same model_name). E.g.,\\n            ``\"2021-06-14_09_53_32_torch_model_run_44607\"``.\\n        work_dir\\n            Path of the working directory, where to save checkpoints and Tensorboard summaries.\\n            Default: current working directory.\\n        log_tensorboard\\n            If set, use Tensorboard to log the different parameters. The logs will be located in:\\n            ``\"{work_dir}/darts_logs/{model_name}/logs/\"``. Default: ``False``.\\n        nr_epochs_val_period\\n            Number of epochs to wait before evaluating the validation loss (if a validation\\n            ``TimeSeries`` is passed to the :func:`fit()` method). Default: ``1``.\\n        force_reset\\n            If set to ``True``, any previously-existing model with the same name will be reset (all checkpoints will\\n            be discarded). Default: ``False``.\\n        save_checkpoints\\n            Whether or not to automatically save the untrained model and checkpoints from training.\\n            To load the model from checkpoint, call :func:`MyModelClass.load_from_checkpoint()`, where\\n            :class:`MyModelClass` is the :class:`TorchForecastingModel` class that was used (such as :class:`TFTModel`,\\n            :class:`NBEATSModel`, etc.). If set to ``False``, the model can still be manually saved using\\n            :func:`save()` and loaded using :func:`load()`. Default: ``False``.\\n        add_encoders\\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\\n            will be used as index encoders. Additionally, a transformer such as Darts\\' :class:`Scaler` can be added to\\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\\n            model creation.\\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                def encode_year(idx):\\n                    return (idx.year - 1950) / 50\\n\\n                add_encoders={\\n                    \\'cyclic\\': {\\'future\\': [\\'month\\']},\\n                    \\'datetime_attribute\\': {\\'future\\': [\\'hour\\', \\'dayofweek\\']},\\n                    \\'position\\': {\\'past\\': [\\'relative\\'], \\'future\\': [\\'relative\\']},\\n                    \\'custom\\': {\\'past\\': [encode_year]},\\n                    \\'transformer\\': Scaler(),\\n                    \\'tz\\': \\'CET\\'\\n                }\\n            ..\\n        random_state\\n            Control the randomness of the weights initialization. Check this\\n            `link <https://scikit-learn.org/stable/glossary.html#term-random_state>`_ for more details.\\n            Default: ``None``.\\n        pl_trainer_kwargs\\n            By default :class:`TorchForecastingModel` creates a PyTorch Lightning Trainer with several useful presets\\n            that performs the training, validation and prediction processes. These presets include automatic\\n            checkpointing, tensorboard logging, setting the torch device and more.\\n            With ``pl_trainer_kwargs`` you can add additional kwargs to instantiate the PyTorch Lightning trainer\\n            object. Check the `PL Trainer documentation\\n            <https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html>`_ for more information about the\\n            supported kwargs. Default: ``None``.\\n            Running on GPU(s) is also possible using ``pl_trainer_kwargs`` by specifying keys ``\"accelerator\",\\n            \"devices\", and \"auto_select_gpus\"``. Some examples for setting the devices inside the ``pl_trainer_kwargs``\\n            dict:\\n\\n                - ``{\"accelerator\": \"cpu\"}`` for CPU,\\n                - ``{\"accelerator\": \"gpu\", \"devices\": [i]}`` to use only GPU ``i`` (``i`` must be an integer),\\n                - ``{\"accelerator\": \"gpu\", \"devices\": -1, \"auto_select_gpus\": True}`` to use all available GPUS.\\n\\n                For more info, see here:\\n                https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#trainer-flags , and\\n                https://pytorch-lightning.readthedocs.io/en/stable/accelerators/gpu_basic.html#train-on-multiple-gpus\\n            With parameter ``\"callbacks\"`` you can add custom or PyTorch-Lightning built-in callbacks to Darts\\'\\n            :class:`TorchForecastingModel`. Below is an example for adding EarlyStopping to the training process.\\n            The model will stop training early if the validation loss `val_loss` does not improve beyond\\n            specifications. For more information on callbacks, visit:\\n            `PyTorch Lightning Callbacks\\n            <https://pytorch-lightning.readthedocs.io/en/stable/extensions/callbacks.html>`_\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                from pytorch_lightning.callbacks.early_stopping import EarlyStopping\\n\\n                # stop training when validation loss does not decrease more than 0.05 (`min_delta`) over\\n                # a period of 5 epochs (`patience`)\\n                my_stopper = EarlyStopping(\\n                    monitor=\"val_loss\",\\n                    patience=5,\\n                    min_delta=0.05,\\n                    mode=\\'min\\',\\n                )\\n\\n                pl_trainer_kwargs={\"callbacks\": [my_stopper]}\\n            ..\\n\\n            Note that you can also use a custom PyTorch Lightning Trainer for training and prediction with optional\\n            parameter ``trainer`` in :func:`fit()` and :func:`predict()`.\\n        show_warnings\\n            whether to show warnings raised from PyTorch Lightning. Useful to detect potential issues of\\n            your forecasting use case. Default: ``False``.\\n\\n        References\\n        ----------\\n        .. [1] Zeng, A., Chen, M., Zhang, L., & Xu, Q. (2022).\\n               Are Transformers Effective for Time Series Forecasting?. arXiv preprint arXiv:2205.13504.\\n        .. [2] T. Kim et al. \"Reversible Instance Normalization for Accurate Time-Series Forecasting against\\n                Distribution Shift\", https://openreview.net/forum?id=cGDAkQo1C0p\\n\\n        Examples\\n        --------\\n        >>> from darts.datasets import WeatherDataset\\n        >>> from darts.models import NLinearModel\\n        >>> series = WeatherDataset().load()\\n        >>> # predicting atmospheric pressure\\n        >>> target = series[\\'p (mbar)\\'][:100]\\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\\n        >>> past_cov = series[\\'rain (mm)\\'][:100]\\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\\n        >>> future_cov = series[\\'T (degC)\\'][:106]\\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\\n        >>> # values corresponding to the forecasted period\\n        >>> model = NLinearModel(\\n        >>>     input_chunk_length=6,\\n        >>>     output_chunk_length=6,\\n        >>>     n_epochs=20,\\n        >>> )\\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\\n        >>> pred = model.predict(6)\\n        >>> pred.values()\\n        array([[429.56117169],\\n               [428.93264096],\\n               [428.35210616],\\n               [428.13154426],\\n               [427.98781641],\\n               [428.00325481]])\\n        '\n    super().__init__(**self._extract_torch_model_params(**self.model_params))\n    self.pl_module_params = self._extract_pl_module_params(**self.model_params)\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n    self._considers_static_covariates = use_static_covariates\n    raise_if('likelihood' in self.model_params and self.model_params['likelihood'] is not None and self.normalize, 'normalize = True cannot be used with probabilistic NLinearModel')",
            "def __init__(self, input_chunk_length: int, output_chunk_length: int, shared_weights: bool=False, const_init: bool=True, normalize: bool=False, use_static_covariates: bool=True, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'An implementation of the NLinear model, as presented in [1]_.\\n\\n        This implementation is improved by allowing the optional use of past covariates,\\n        future covariates and static covariates, and by making the model optionally probabilistic.\\n\\n        Parameters\\n        ----------\\n        input_chunk_length\\n            The length of the input sequence fed to the model.\\n        output_chunk_length\\n            The length of the forecast of the model.\\n        shared_weights\\n            Whether to use shared weights for all components of multivariate series.\\n\\n            .. warning::\\n                When set to True, covariates will be ignored as a 1-to-1 mapping is\\n                required between input dimensions and output dimensions.\\n            ..\\n\\n            Default: False.\\n\\n        const_init\\n            Whether to initialize the weights to 1/in_len. If False, the default PyTorch\\n            initialization is used (default=\\'True\\').\\n        normalize\\n            Whether to apply the simple \"normalization\" proposed in the paper, which consists\\n            in subtracting the last value of the input sequence from the input sequence. Default: False.\\n\\n            .. note::\\n                This cannot be applied to probabilistic models.\\n            ..\\n        use_static_covariates\\n            Whether the model should use static covariate information in case the input `series` passed to ``fit()``\\n            contain static covariates. If ``True``, and static covariates are available at fitting time, will enforce\\n            that all target `series` have the same static covariate dimensionality in ``fit()`` and ``predict()``.\\n        **kwargs\\n            Optional arguments to initialize the pytorch_lightning.Module, pytorch_lightning.Trainer, and\\n            Darts\\' :class:`TorchForecastingModel`.\\n\\n        loss_fn\\n            PyTorch loss function used for training.\\n            This parameter will be ignored for probabilistic models if the ``likelihood`` parameter is specified.\\n            Default: ``torch.nn.MSELoss()``.\\n        likelihood\\n            One of Darts\\' :meth:`Likelihood <darts.utils.likelihood_models.Likelihood>` models to be used for\\n            probabilistic forecasts. Default: ``None``.\\n        torch_metrics\\n            A torch metric or a ``MetricCollection`` used for evaluation. A full list of available metrics can be found\\n            at https://torchmetrics.readthedocs.io/en/latest/. Default: ``None``.\\n        optimizer_cls\\n            The PyTorch optimizer class to be used. Default: ``torch.optim.Adam``.\\n        optimizer_kwargs\\n            Optionally, some keyword arguments for the PyTorch optimizer (e.g., ``{\\'lr\\': 1e-3}``\\n            for specifying a learning rate). Otherwise, the default values of the selected ``optimizer_cls``\\n            will be used. Default: ``None``.\\n        lr_scheduler_cls\\n            Optionally, the PyTorch learning rate scheduler class to be used. Specifying ``None`` corresponds\\n            to using a constant learning rate. Default: ``None``.\\n        lr_scheduler_kwargs\\n            Optionally, some keyword arguments for the PyTorch learning rate scheduler. Default: ``None``.\\n        use_reversible_instance_norm\\n            Whether to use reversible instance normalization `RINorm` against distribution shift as shown in [2]_.\\n            It is only applied to the features of the target series and not the covariates.\\n        batch_size\\n            Number of time series (input and output sequences) used in each training pass. Default: ``32``.\\n        n_epochs\\n            Number of epochs over which to train the model. Default: ``100``.\\n        model_name\\n            Name of the model. Used for creating checkpoints and saving tensorboard data. If not specified,\\n            defaults to the following string ``\"YYYY-mm-dd_HH_MM_SS_torch_model_run_PID\"``, where the initial part\\n            of the name is formatted with the local date and time, while PID is the processed ID (preventing models\\n            spawned at the same time by different processes to share the same model_name). E.g.,\\n            ``\"2021-06-14_09_53_32_torch_model_run_44607\"``.\\n        work_dir\\n            Path of the working directory, where to save checkpoints and Tensorboard summaries.\\n            Default: current working directory.\\n        log_tensorboard\\n            If set, use Tensorboard to log the different parameters. The logs will be located in:\\n            ``\"{work_dir}/darts_logs/{model_name}/logs/\"``. Default: ``False``.\\n        nr_epochs_val_period\\n            Number of epochs to wait before evaluating the validation loss (if a validation\\n            ``TimeSeries`` is passed to the :func:`fit()` method). Default: ``1``.\\n        force_reset\\n            If set to ``True``, any previously-existing model with the same name will be reset (all checkpoints will\\n            be discarded). Default: ``False``.\\n        save_checkpoints\\n            Whether or not to automatically save the untrained model and checkpoints from training.\\n            To load the model from checkpoint, call :func:`MyModelClass.load_from_checkpoint()`, where\\n            :class:`MyModelClass` is the :class:`TorchForecastingModel` class that was used (such as :class:`TFTModel`,\\n            :class:`NBEATSModel`, etc.). If set to ``False``, the model can still be manually saved using\\n            :func:`save()` and loaded using :func:`load()`. Default: ``False``.\\n        add_encoders\\n            A large number of past and future covariates can be automatically generated with `add_encoders`.\\n            This can be done by adding multiple pre-defined index encoders and/or custom user-made functions that\\n            will be used as index encoders. Additionally, a transformer such as Darts\\' :class:`Scaler` can be added to\\n            transform the generated covariates. This happens all under one hood and only needs to be specified at\\n            model creation.\\n            Read :meth:`SequentialEncoder <darts.dataprocessing.encoders.SequentialEncoder>` to find out more about\\n            ``add_encoders``. Default: ``None``. An example showing some of ``add_encoders`` features:\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                def encode_year(idx):\\n                    return (idx.year - 1950) / 50\\n\\n                add_encoders={\\n                    \\'cyclic\\': {\\'future\\': [\\'month\\']},\\n                    \\'datetime_attribute\\': {\\'future\\': [\\'hour\\', \\'dayofweek\\']},\\n                    \\'position\\': {\\'past\\': [\\'relative\\'], \\'future\\': [\\'relative\\']},\\n                    \\'custom\\': {\\'past\\': [encode_year]},\\n                    \\'transformer\\': Scaler(),\\n                    \\'tz\\': \\'CET\\'\\n                }\\n            ..\\n        random_state\\n            Control the randomness of the weights initialization. Check this\\n            `link <https://scikit-learn.org/stable/glossary.html#term-random_state>`_ for more details.\\n            Default: ``None``.\\n        pl_trainer_kwargs\\n            By default :class:`TorchForecastingModel` creates a PyTorch Lightning Trainer with several useful presets\\n            that performs the training, validation and prediction processes. These presets include automatic\\n            checkpointing, tensorboard logging, setting the torch device and more.\\n            With ``pl_trainer_kwargs`` you can add additional kwargs to instantiate the PyTorch Lightning trainer\\n            object. Check the `PL Trainer documentation\\n            <https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html>`_ for more information about the\\n            supported kwargs. Default: ``None``.\\n            Running on GPU(s) is also possible using ``pl_trainer_kwargs`` by specifying keys ``\"accelerator\",\\n            \"devices\", and \"auto_select_gpus\"``. Some examples for setting the devices inside the ``pl_trainer_kwargs``\\n            dict:\\n\\n                - ``{\"accelerator\": \"cpu\"}`` for CPU,\\n                - ``{\"accelerator\": \"gpu\", \"devices\": [i]}`` to use only GPU ``i`` (``i`` must be an integer),\\n                - ``{\"accelerator\": \"gpu\", \"devices\": -1, \"auto_select_gpus\": True}`` to use all available GPUS.\\n\\n                For more info, see here:\\n                https://pytorch-lightning.readthedocs.io/en/stable/common/trainer.html#trainer-flags , and\\n                https://pytorch-lightning.readthedocs.io/en/stable/accelerators/gpu_basic.html#train-on-multiple-gpus\\n            With parameter ``\"callbacks\"`` you can add custom or PyTorch-Lightning built-in callbacks to Darts\\'\\n            :class:`TorchForecastingModel`. Below is an example for adding EarlyStopping to the training process.\\n            The model will stop training early if the validation loss `val_loss` does not improve beyond\\n            specifications. For more information on callbacks, visit:\\n            `PyTorch Lightning Callbacks\\n            <https://pytorch-lightning.readthedocs.io/en/stable/extensions/callbacks.html>`_\\n\\n            .. highlight:: python\\n            .. code-block:: python\\n\\n                from pytorch_lightning.callbacks.early_stopping import EarlyStopping\\n\\n                # stop training when validation loss does not decrease more than 0.05 (`min_delta`) over\\n                # a period of 5 epochs (`patience`)\\n                my_stopper = EarlyStopping(\\n                    monitor=\"val_loss\",\\n                    patience=5,\\n                    min_delta=0.05,\\n                    mode=\\'min\\',\\n                )\\n\\n                pl_trainer_kwargs={\"callbacks\": [my_stopper]}\\n            ..\\n\\n            Note that you can also use a custom PyTorch Lightning Trainer for training and prediction with optional\\n            parameter ``trainer`` in :func:`fit()` and :func:`predict()`.\\n        show_warnings\\n            whether to show warnings raised from PyTorch Lightning. Useful to detect potential issues of\\n            your forecasting use case. Default: ``False``.\\n\\n        References\\n        ----------\\n        .. [1] Zeng, A., Chen, M., Zhang, L., & Xu, Q. (2022).\\n               Are Transformers Effective for Time Series Forecasting?. arXiv preprint arXiv:2205.13504.\\n        .. [2] T. Kim et al. \"Reversible Instance Normalization for Accurate Time-Series Forecasting against\\n                Distribution Shift\", https://openreview.net/forum?id=cGDAkQo1C0p\\n\\n        Examples\\n        --------\\n        >>> from darts.datasets import WeatherDataset\\n        >>> from darts.models import NLinearModel\\n        >>> series = WeatherDataset().load()\\n        >>> # predicting atmospheric pressure\\n        >>> target = series[\\'p (mbar)\\'][:100]\\n        >>> # optionally, use past observed rainfall (pretending to be unknown beyond index 100)\\n        >>> past_cov = series[\\'rain (mm)\\'][:100]\\n        >>> # optionally, use future temperatures (pretending this component is a forecast)\\n        >>> future_cov = series[\\'T (degC)\\'][:106]\\n        >>> # predict 6 pressure values using the 12 past values of pressure and rainfall, as well as the 6 temperature\\n        >>> # values corresponding to the forecasted period\\n        >>> model = NLinearModel(\\n        >>>     input_chunk_length=6,\\n        >>>     output_chunk_length=6,\\n        >>>     n_epochs=20,\\n        >>> )\\n        >>> model.fit(target, past_covariates=past_cov, future_covariates=future_cov)\\n        >>> pred = model.predict(6)\\n        >>> pred.values()\\n        array([[429.56117169],\\n               [428.93264096],\\n               [428.35210616],\\n               [428.13154426],\\n               [427.98781641],\\n               [428.00325481]])\\n        '\n    super().__init__(**self._extract_torch_model_params(**self.model_params))\n    self.pl_module_params = self._extract_pl_module_params(**self.model_params)\n    self.shared_weights = shared_weights\n    self.const_init = const_init\n    self.normalize = normalize\n    self._considers_static_covariates = use_static_covariates\n    raise_if('likelihood' in self.model_params and self.model_params['likelihood'] is not None and self.normalize, 'normalize = True cannot be used with probabilistic NLinearModel')"
        ]
    },
    {
        "func_name": "_create_model",
        "original": "def _create_model(self, train_sample: Tuple[torch.Tensor]) -> torch.nn.Module:\n    raise_if(self.shared_weights and (train_sample[1] is not None or train_sample[2] is not None), 'Covariates have been provided, but the model has been built with shared_weights=True.' + 'Please set shared_weights=False to use covariates.')\n    input_dim = train_sample[0].shape[1] + sum((train_sample[i].shape[1] if train_sample[i] is not None else 0 for i in (1, 2)))\n    future_cov_dim = train_sample[3].shape[1] if train_sample[3] is not None else 0\n    static_cov_dim = train_sample[4].shape[1] if train_sample[4] is not None else 0\n    output_dim = train_sample[-1].shape[1]\n    nr_params = 1 if self.likelihood is None else self.likelihood.num_parameters\n    return _NLinearModule(input_dim=input_dim, output_dim=output_dim, future_cov_dim=future_cov_dim, static_cov_dim=static_cov_dim, nr_params=nr_params, shared_weights=self.shared_weights, const_init=self.const_init, normalize=self.normalize, **self.pl_module_params)",
        "mutated": [
            "def _create_model(self, train_sample: Tuple[torch.Tensor]) -> torch.nn.Module:\n    if False:\n        i = 10\n    raise_if(self.shared_weights and (train_sample[1] is not None or train_sample[2] is not None), 'Covariates have been provided, but the model has been built with shared_weights=True.' + 'Please set shared_weights=False to use covariates.')\n    input_dim = train_sample[0].shape[1] + sum((train_sample[i].shape[1] if train_sample[i] is not None else 0 for i in (1, 2)))\n    future_cov_dim = train_sample[3].shape[1] if train_sample[3] is not None else 0\n    static_cov_dim = train_sample[4].shape[1] if train_sample[4] is not None else 0\n    output_dim = train_sample[-1].shape[1]\n    nr_params = 1 if self.likelihood is None else self.likelihood.num_parameters\n    return _NLinearModule(input_dim=input_dim, output_dim=output_dim, future_cov_dim=future_cov_dim, static_cov_dim=static_cov_dim, nr_params=nr_params, shared_weights=self.shared_weights, const_init=self.const_init, normalize=self.normalize, **self.pl_module_params)",
            "def _create_model(self, train_sample: Tuple[torch.Tensor]) -> torch.nn.Module:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    raise_if(self.shared_weights and (train_sample[1] is not None or train_sample[2] is not None), 'Covariates have been provided, but the model has been built with shared_weights=True.' + 'Please set shared_weights=False to use covariates.')\n    input_dim = train_sample[0].shape[1] + sum((train_sample[i].shape[1] if train_sample[i] is not None else 0 for i in (1, 2)))\n    future_cov_dim = train_sample[3].shape[1] if train_sample[3] is not None else 0\n    static_cov_dim = train_sample[4].shape[1] if train_sample[4] is not None else 0\n    output_dim = train_sample[-1].shape[1]\n    nr_params = 1 if self.likelihood is None else self.likelihood.num_parameters\n    return _NLinearModule(input_dim=input_dim, output_dim=output_dim, future_cov_dim=future_cov_dim, static_cov_dim=static_cov_dim, nr_params=nr_params, shared_weights=self.shared_weights, const_init=self.const_init, normalize=self.normalize, **self.pl_module_params)",
            "def _create_model(self, train_sample: Tuple[torch.Tensor]) -> torch.nn.Module:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    raise_if(self.shared_weights and (train_sample[1] is not None or train_sample[2] is not None), 'Covariates have been provided, but the model has been built with shared_weights=True.' + 'Please set shared_weights=False to use covariates.')\n    input_dim = train_sample[0].shape[1] + sum((train_sample[i].shape[1] if train_sample[i] is not None else 0 for i in (1, 2)))\n    future_cov_dim = train_sample[3].shape[1] if train_sample[3] is not None else 0\n    static_cov_dim = train_sample[4].shape[1] if train_sample[4] is not None else 0\n    output_dim = train_sample[-1].shape[1]\n    nr_params = 1 if self.likelihood is None else self.likelihood.num_parameters\n    return _NLinearModule(input_dim=input_dim, output_dim=output_dim, future_cov_dim=future_cov_dim, static_cov_dim=static_cov_dim, nr_params=nr_params, shared_weights=self.shared_weights, const_init=self.const_init, normalize=self.normalize, **self.pl_module_params)",
            "def _create_model(self, train_sample: Tuple[torch.Tensor]) -> torch.nn.Module:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    raise_if(self.shared_weights and (train_sample[1] is not None or train_sample[2] is not None), 'Covariates have been provided, but the model has been built with shared_weights=True.' + 'Please set shared_weights=False to use covariates.')\n    input_dim = train_sample[0].shape[1] + sum((train_sample[i].shape[1] if train_sample[i] is not None else 0 for i in (1, 2)))\n    future_cov_dim = train_sample[3].shape[1] if train_sample[3] is not None else 0\n    static_cov_dim = train_sample[4].shape[1] if train_sample[4] is not None else 0\n    output_dim = train_sample[-1].shape[1]\n    nr_params = 1 if self.likelihood is None else self.likelihood.num_parameters\n    return _NLinearModule(input_dim=input_dim, output_dim=output_dim, future_cov_dim=future_cov_dim, static_cov_dim=static_cov_dim, nr_params=nr_params, shared_weights=self.shared_weights, const_init=self.const_init, normalize=self.normalize, **self.pl_module_params)",
            "def _create_model(self, train_sample: Tuple[torch.Tensor]) -> torch.nn.Module:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    raise_if(self.shared_weights and (train_sample[1] is not None or train_sample[2] is not None), 'Covariates have been provided, but the model has been built with shared_weights=True.' + 'Please set shared_weights=False to use covariates.')\n    input_dim = train_sample[0].shape[1] + sum((train_sample[i].shape[1] if train_sample[i] is not None else 0 for i in (1, 2)))\n    future_cov_dim = train_sample[3].shape[1] if train_sample[3] is not None else 0\n    static_cov_dim = train_sample[4].shape[1] if train_sample[4] is not None else 0\n    output_dim = train_sample[-1].shape[1]\n    nr_params = 1 if self.likelihood is None else self.likelihood.num_parameters\n    return _NLinearModule(input_dim=input_dim, output_dim=output_dim, future_cov_dim=future_cov_dim, static_cov_dim=static_cov_dim, nr_params=nr_params, shared_weights=self.shared_weights, const_init=self.const_init, normalize=self.normalize, **self.pl_module_params)"
        ]
    },
    {
        "func_name": "supports_multivariate",
        "original": "@property\ndef supports_multivariate(self) -> bool:\n    return True",
        "mutated": [
            "@property\ndef supports_multivariate(self) -> bool:\n    if False:\n        i = 10\n    return True",
            "@property\ndef supports_multivariate(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return True",
            "@property\ndef supports_multivariate(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return True",
            "@property\ndef supports_multivariate(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return True",
            "@property\ndef supports_multivariate(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return True"
        ]
    },
    {
        "func_name": "supports_static_covariates",
        "original": "@property\ndef supports_static_covariates(self) -> bool:\n    return True",
        "mutated": [
            "@property\ndef supports_static_covariates(self) -> bool:\n    if False:\n        i = 10\n    return True",
            "@property\ndef supports_static_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return True",
            "@property\ndef supports_static_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return True",
            "@property\ndef supports_static_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return True",
            "@property\ndef supports_static_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return True"
        ]
    },
    {
        "func_name": "supports_future_covariates",
        "original": "@property\ndef supports_future_covariates(self) -> bool:\n    return not self.shared_weights",
        "mutated": [
            "@property\ndef supports_future_covariates(self) -> bool:\n    if False:\n        i = 10\n    return not self.shared_weights",
            "@property\ndef supports_future_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return not self.shared_weights",
            "@property\ndef supports_future_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return not self.shared_weights",
            "@property\ndef supports_future_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return not self.shared_weights",
            "@property\ndef supports_future_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return not self.shared_weights"
        ]
    },
    {
        "func_name": "supports_past_covariates",
        "original": "@property\ndef supports_past_covariates(self) -> bool:\n    return not self.shared_weights",
        "mutated": [
            "@property\ndef supports_past_covariates(self) -> bool:\n    if False:\n        i = 10\n    return not self.shared_weights",
            "@property\ndef supports_past_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return not self.shared_weights",
            "@property\ndef supports_past_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return not self.shared_weights",
            "@property\ndef supports_past_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return not self.shared_weights",
            "@property\ndef supports_past_covariates(self) -> bool:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return not self.shared_weights"
        ]
    }
]