[
    {
        "func_name": "__init__",
        "original": "def __init__(self, data_root, info_file, ann_file, pipeline, load_interval=1, with_velocity=False, eval_version=None, version=None, **kwargs):\n    super().__init__(data_root=data_root, ann_file=ann_file, pipeline=pipeline, load_interval=load_interval, with_velocity=with_velocity, eval_version=eval_version, version=version, **kwargs)\n    self.anno_infos = mmcv.load(info_file)\n    self.bbox_code_size = 7",
        "mutated": [
            "def __init__(self, data_root, info_file, ann_file, pipeline, load_interval=1, with_velocity=False, eval_version=None, version=None, **kwargs):\n    if False:\n        i = 10\n    super().__init__(data_root=data_root, ann_file=ann_file, pipeline=pipeline, load_interval=load_interval, with_velocity=with_velocity, eval_version=eval_version, version=version, **kwargs)\n    self.anno_infos = mmcv.load(info_file)\n    self.bbox_code_size = 7",
            "def __init__(self, data_root, info_file, ann_file, pipeline, load_interval=1, with_velocity=False, eval_version=None, version=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__(data_root=data_root, ann_file=ann_file, pipeline=pipeline, load_interval=load_interval, with_velocity=with_velocity, eval_version=eval_version, version=version, **kwargs)\n    self.anno_infos = mmcv.load(info_file)\n    self.bbox_code_size = 7",
            "def __init__(self, data_root, info_file, ann_file, pipeline, load_interval=1, with_velocity=False, eval_version=None, version=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__(data_root=data_root, ann_file=ann_file, pipeline=pipeline, load_interval=load_interval, with_velocity=with_velocity, eval_version=eval_version, version=version, **kwargs)\n    self.anno_infos = mmcv.load(info_file)\n    self.bbox_code_size = 7",
            "def __init__(self, data_root, info_file, ann_file, pipeline, load_interval=1, with_velocity=False, eval_version=None, version=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__(data_root=data_root, ann_file=ann_file, pipeline=pipeline, load_interval=load_interval, with_velocity=with_velocity, eval_version=eval_version, version=version, **kwargs)\n    self.anno_infos = mmcv.load(info_file)\n    self.bbox_code_size = 7",
            "def __init__(self, data_root, info_file, ann_file, pipeline, load_interval=1, with_velocity=False, eval_version=None, version=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__(data_root=data_root, ann_file=ann_file, pipeline=pipeline, load_interval=load_interval, with_velocity=with_velocity, eval_version=eval_version, version=version, **kwargs)\n    self.anno_infos = mmcv.load(info_file)\n    self.bbox_code_size = 7"
        ]
    },
    {
        "func_name": "_parse_ann_info",
        "original": "def _parse_ann_info(self, img_info, ann_info):\n    \"\"\"Parse bbox and mask annotation.\n\n        Args:\n            ann_info (list[dict]): Annotation info of an image.\n            with_mask (bool): Whether to parse mask annotations.\n\n        Returns:\n            dict: A dict containing the following keys: bboxes, bboxes_ignore,\n                labels, masks, seg_map. \"masks\" are raw annotations and not\n                decoded into binary masks.\n        \"\"\"\n    gt_bboxes = []\n    gt_labels = []\n    gt_bboxes_ignore = []\n    gt_masks_ann = []\n    gt_bboxes_cam3d = []\n    centers2d = []\n    depths = []\n    for (i, ann) in enumerate(ann_info):\n        if ann.get('ignore', False):\n            continue\n        (x1, y1, w, h) = ann['bbox']\n        inter_w = max(0, min(x1 + w, img_info['width']) - max(x1, 0))\n        inter_h = max(0, min(y1 + h, img_info['height']) - max(y1, 0))\n        if inter_w * inter_h == 0:\n            continue\n        if ann['area'] <= 0 or w < 1 or h < 1:\n            continue\n        if ann['category_id'] not in self.cat_ids:\n            continue\n        bbox = [x1, y1, x1 + w, y1 + h]\n        if ann.get('iscrowd', False):\n            gt_bboxes_ignore.append(bbox)\n        else:\n            gt_bboxes.append(bbox)\n            gt_labels.append(self.cat2label[ann['category_id']])\n            gt_masks_ann.append(ann.get('segmentation', None))\n            bbox_cam3d = np.array(ann['bbox_cam3d']).reshape(-1)\n            gt_bboxes_cam3d.append(bbox_cam3d)\n            center2d = ann['center2d'][:2]\n            depth = ann['center2d'][2]\n            centers2d.append(center2d)\n            depths.append(depth)\n    if gt_bboxes:\n        gt_bboxes = np.array(gt_bboxes, dtype=np.float32)\n        gt_labels = np.array(gt_labels, dtype=np.int64)\n    else:\n        gt_bboxes = np.zeros((0, 4), dtype=np.float32)\n        gt_labels = np.array([], dtype=np.int64)\n    if gt_bboxes_cam3d:\n        gt_bboxes_cam3d = np.array(gt_bboxes_cam3d, dtype=np.float32)\n        centers2d = np.array(centers2d, dtype=np.float32)\n        depths = np.array(depths, dtype=np.float32)\n    else:\n        gt_bboxes_cam3d = np.zeros((0, self.bbox_code_size), dtype=np.float32)\n        centers2d = np.zeros((0, 2), dtype=np.float32)\n        depths = np.zeros(0, dtype=np.float32)\n    gt_bboxes_cam3d = CameraInstance3DBoxes(gt_bboxes_cam3d, box_dim=gt_bboxes_cam3d.shape[-1], origin=(0.5, 0.5, 0.5))\n    gt_labels_3d = copy.deepcopy(gt_labels)\n    if gt_bboxes_ignore:\n        gt_bboxes_ignore = np.array(gt_bboxes_ignore, dtype=np.float32)\n    else:\n        gt_bboxes_ignore = np.zeros((0, 4), dtype=np.float32)\n    seg_map = img_info['filename'].replace('jpg', 'png')\n    ann = dict(bboxes=gt_bboxes, labels=gt_labels, gt_bboxes_3d=gt_bboxes_cam3d, gt_labels_3d=gt_labels_3d, centers2d=centers2d, depths=depths, bboxes_ignore=gt_bboxes_ignore, masks=gt_masks_ann, seg_map=seg_map)\n    return ann",
        "mutated": [
            "def _parse_ann_info(self, img_info, ann_info):\n    if False:\n        i = 10\n    'Parse bbox and mask annotation.\\n\\n        Args:\\n            ann_info (list[dict]): Annotation info of an image.\\n            with_mask (bool): Whether to parse mask annotations.\\n\\n        Returns:\\n            dict: A dict containing the following keys: bboxes, bboxes_ignore,\\n                labels, masks, seg_map. \"masks\" are raw annotations and not\\n                decoded into binary masks.\\n        '\n    gt_bboxes = []\n    gt_labels = []\n    gt_bboxes_ignore = []\n    gt_masks_ann = []\n    gt_bboxes_cam3d = []\n    centers2d = []\n    depths = []\n    for (i, ann) in enumerate(ann_info):\n        if ann.get('ignore', False):\n            continue\n        (x1, y1, w, h) = ann['bbox']\n        inter_w = max(0, min(x1 + w, img_info['width']) - max(x1, 0))\n        inter_h = max(0, min(y1 + h, img_info['height']) - max(y1, 0))\n        if inter_w * inter_h == 0:\n            continue\n        if ann['area'] <= 0 or w < 1 or h < 1:\n            continue\n        if ann['category_id'] not in self.cat_ids:\n            continue\n        bbox = [x1, y1, x1 + w, y1 + h]\n        if ann.get('iscrowd', False):\n            gt_bboxes_ignore.append(bbox)\n        else:\n            gt_bboxes.append(bbox)\n            gt_labels.append(self.cat2label[ann['category_id']])\n            gt_masks_ann.append(ann.get('segmentation', None))\n            bbox_cam3d = np.array(ann['bbox_cam3d']).reshape(-1)\n            gt_bboxes_cam3d.append(bbox_cam3d)\n            center2d = ann['center2d'][:2]\n            depth = ann['center2d'][2]\n            centers2d.append(center2d)\n            depths.append(depth)\n    if gt_bboxes:\n        gt_bboxes = np.array(gt_bboxes, dtype=np.float32)\n        gt_labels = np.array(gt_labels, dtype=np.int64)\n    else:\n        gt_bboxes = np.zeros((0, 4), dtype=np.float32)\n        gt_labels = np.array([], dtype=np.int64)\n    if gt_bboxes_cam3d:\n        gt_bboxes_cam3d = np.array(gt_bboxes_cam3d, dtype=np.float32)\n        centers2d = np.array(centers2d, dtype=np.float32)\n        depths = np.array(depths, dtype=np.float32)\n    else:\n        gt_bboxes_cam3d = np.zeros((0, self.bbox_code_size), dtype=np.float32)\n        centers2d = np.zeros((0, 2), dtype=np.float32)\n        depths = np.zeros(0, dtype=np.float32)\n    gt_bboxes_cam3d = CameraInstance3DBoxes(gt_bboxes_cam3d, box_dim=gt_bboxes_cam3d.shape[-1], origin=(0.5, 0.5, 0.5))\n    gt_labels_3d = copy.deepcopy(gt_labels)\n    if gt_bboxes_ignore:\n        gt_bboxes_ignore = np.array(gt_bboxes_ignore, dtype=np.float32)\n    else:\n        gt_bboxes_ignore = np.zeros((0, 4), dtype=np.float32)\n    seg_map = img_info['filename'].replace('jpg', 'png')\n    ann = dict(bboxes=gt_bboxes, labels=gt_labels, gt_bboxes_3d=gt_bboxes_cam3d, gt_labels_3d=gt_labels_3d, centers2d=centers2d, depths=depths, bboxes_ignore=gt_bboxes_ignore, masks=gt_masks_ann, seg_map=seg_map)\n    return ann",
            "def _parse_ann_info(self, img_info, ann_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Parse bbox and mask annotation.\\n\\n        Args:\\n            ann_info (list[dict]): Annotation info of an image.\\n            with_mask (bool): Whether to parse mask annotations.\\n\\n        Returns:\\n            dict: A dict containing the following keys: bboxes, bboxes_ignore,\\n                labels, masks, seg_map. \"masks\" are raw annotations and not\\n                decoded into binary masks.\\n        '\n    gt_bboxes = []\n    gt_labels = []\n    gt_bboxes_ignore = []\n    gt_masks_ann = []\n    gt_bboxes_cam3d = []\n    centers2d = []\n    depths = []\n    for (i, ann) in enumerate(ann_info):\n        if ann.get('ignore', False):\n            continue\n        (x1, y1, w, h) = ann['bbox']\n        inter_w = max(0, min(x1 + w, img_info['width']) - max(x1, 0))\n        inter_h = max(0, min(y1 + h, img_info['height']) - max(y1, 0))\n        if inter_w * inter_h == 0:\n            continue\n        if ann['area'] <= 0 or w < 1 or h < 1:\n            continue\n        if ann['category_id'] not in self.cat_ids:\n            continue\n        bbox = [x1, y1, x1 + w, y1 + h]\n        if ann.get('iscrowd', False):\n            gt_bboxes_ignore.append(bbox)\n        else:\n            gt_bboxes.append(bbox)\n            gt_labels.append(self.cat2label[ann['category_id']])\n            gt_masks_ann.append(ann.get('segmentation', None))\n            bbox_cam3d = np.array(ann['bbox_cam3d']).reshape(-1)\n            gt_bboxes_cam3d.append(bbox_cam3d)\n            center2d = ann['center2d'][:2]\n            depth = ann['center2d'][2]\n            centers2d.append(center2d)\n            depths.append(depth)\n    if gt_bboxes:\n        gt_bboxes = np.array(gt_bboxes, dtype=np.float32)\n        gt_labels = np.array(gt_labels, dtype=np.int64)\n    else:\n        gt_bboxes = np.zeros((0, 4), dtype=np.float32)\n        gt_labels = np.array([], dtype=np.int64)\n    if gt_bboxes_cam3d:\n        gt_bboxes_cam3d = np.array(gt_bboxes_cam3d, dtype=np.float32)\n        centers2d = np.array(centers2d, dtype=np.float32)\n        depths = np.array(depths, dtype=np.float32)\n    else:\n        gt_bboxes_cam3d = np.zeros((0, self.bbox_code_size), dtype=np.float32)\n        centers2d = np.zeros((0, 2), dtype=np.float32)\n        depths = np.zeros(0, dtype=np.float32)\n    gt_bboxes_cam3d = CameraInstance3DBoxes(gt_bboxes_cam3d, box_dim=gt_bboxes_cam3d.shape[-1], origin=(0.5, 0.5, 0.5))\n    gt_labels_3d = copy.deepcopy(gt_labels)\n    if gt_bboxes_ignore:\n        gt_bboxes_ignore = np.array(gt_bboxes_ignore, dtype=np.float32)\n    else:\n        gt_bboxes_ignore = np.zeros((0, 4), dtype=np.float32)\n    seg_map = img_info['filename'].replace('jpg', 'png')\n    ann = dict(bboxes=gt_bboxes, labels=gt_labels, gt_bboxes_3d=gt_bboxes_cam3d, gt_labels_3d=gt_labels_3d, centers2d=centers2d, depths=depths, bboxes_ignore=gt_bboxes_ignore, masks=gt_masks_ann, seg_map=seg_map)\n    return ann",
            "def _parse_ann_info(self, img_info, ann_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Parse bbox and mask annotation.\\n\\n        Args:\\n            ann_info (list[dict]): Annotation info of an image.\\n            with_mask (bool): Whether to parse mask annotations.\\n\\n        Returns:\\n            dict: A dict containing the following keys: bboxes, bboxes_ignore,\\n                labels, masks, seg_map. \"masks\" are raw annotations and not\\n                decoded into binary masks.\\n        '\n    gt_bboxes = []\n    gt_labels = []\n    gt_bboxes_ignore = []\n    gt_masks_ann = []\n    gt_bboxes_cam3d = []\n    centers2d = []\n    depths = []\n    for (i, ann) in enumerate(ann_info):\n        if ann.get('ignore', False):\n            continue\n        (x1, y1, w, h) = ann['bbox']\n        inter_w = max(0, min(x1 + w, img_info['width']) - max(x1, 0))\n        inter_h = max(0, min(y1 + h, img_info['height']) - max(y1, 0))\n        if inter_w * inter_h == 0:\n            continue\n        if ann['area'] <= 0 or w < 1 or h < 1:\n            continue\n        if ann['category_id'] not in self.cat_ids:\n            continue\n        bbox = [x1, y1, x1 + w, y1 + h]\n        if ann.get('iscrowd', False):\n            gt_bboxes_ignore.append(bbox)\n        else:\n            gt_bboxes.append(bbox)\n            gt_labels.append(self.cat2label[ann['category_id']])\n            gt_masks_ann.append(ann.get('segmentation', None))\n            bbox_cam3d = np.array(ann['bbox_cam3d']).reshape(-1)\n            gt_bboxes_cam3d.append(bbox_cam3d)\n            center2d = ann['center2d'][:2]\n            depth = ann['center2d'][2]\n            centers2d.append(center2d)\n            depths.append(depth)\n    if gt_bboxes:\n        gt_bboxes = np.array(gt_bboxes, dtype=np.float32)\n        gt_labels = np.array(gt_labels, dtype=np.int64)\n    else:\n        gt_bboxes = np.zeros((0, 4), dtype=np.float32)\n        gt_labels = np.array([], dtype=np.int64)\n    if gt_bboxes_cam3d:\n        gt_bboxes_cam3d = np.array(gt_bboxes_cam3d, dtype=np.float32)\n        centers2d = np.array(centers2d, dtype=np.float32)\n        depths = np.array(depths, dtype=np.float32)\n    else:\n        gt_bboxes_cam3d = np.zeros((0, self.bbox_code_size), dtype=np.float32)\n        centers2d = np.zeros((0, 2), dtype=np.float32)\n        depths = np.zeros(0, dtype=np.float32)\n    gt_bboxes_cam3d = CameraInstance3DBoxes(gt_bboxes_cam3d, box_dim=gt_bboxes_cam3d.shape[-1], origin=(0.5, 0.5, 0.5))\n    gt_labels_3d = copy.deepcopy(gt_labels)\n    if gt_bboxes_ignore:\n        gt_bboxes_ignore = np.array(gt_bboxes_ignore, dtype=np.float32)\n    else:\n        gt_bboxes_ignore = np.zeros((0, 4), dtype=np.float32)\n    seg_map = img_info['filename'].replace('jpg', 'png')\n    ann = dict(bboxes=gt_bboxes, labels=gt_labels, gt_bboxes_3d=gt_bboxes_cam3d, gt_labels_3d=gt_labels_3d, centers2d=centers2d, depths=depths, bboxes_ignore=gt_bboxes_ignore, masks=gt_masks_ann, seg_map=seg_map)\n    return ann",
            "def _parse_ann_info(self, img_info, ann_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Parse bbox and mask annotation.\\n\\n        Args:\\n            ann_info (list[dict]): Annotation info of an image.\\n            with_mask (bool): Whether to parse mask annotations.\\n\\n        Returns:\\n            dict: A dict containing the following keys: bboxes, bboxes_ignore,\\n                labels, masks, seg_map. \"masks\" are raw annotations and not\\n                decoded into binary masks.\\n        '\n    gt_bboxes = []\n    gt_labels = []\n    gt_bboxes_ignore = []\n    gt_masks_ann = []\n    gt_bboxes_cam3d = []\n    centers2d = []\n    depths = []\n    for (i, ann) in enumerate(ann_info):\n        if ann.get('ignore', False):\n            continue\n        (x1, y1, w, h) = ann['bbox']\n        inter_w = max(0, min(x1 + w, img_info['width']) - max(x1, 0))\n        inter_h = max(0, min(y1 + h, img_info['height']) - max(y1, 0))\n        if inter_w * inter_h == 0:\n            continue\n        if ann['area'] <= 0 or w < 1 or h < 1:\n            continue\n        if ann['category_id'] not in self.cat_ids:\n            continue\n        bbox = [x1, y1, x1 + w, y1 + h]\n        if ann.get('iscrowd', False):\n            gt_bboxes_ignore.append(bbox)\n        else:\n            gt_bboxes.append(bbox)\n            gt_labels.append(self.cat2label[ann['category_id']])\n            gt_masks_ann.append(ann.get('segmentation', None))\n            bbox_cam3d = np.array(ann['bbox_cam3d']).reshape(-1)\n            gt_bboxes_cam3d.append(bbox_cam3d)\n            center2d = ann['center2d'][:2]\n            depth = ann['center2d'][2]\n            centers2d.append(center2d)\n            depths.append(depth)\n    if gt_bboxes:\n        gt_bboxes = np.array(gt_bboxes, dtype=np.float32)\n        gt_labels = np.array(gt_labels, dtype=np.int64)\n    else:\n        gt_bboxes = np.zeros((0, 4), dtype=np.float32)\n        gt_labels = np.array([], dtype=np.int64)\n    if gt_bboxes_cam3d:\n        gt_bboxes_cam3d = np.array(gt_bboxes_cam3d, dtype=np.float32)\n        centers2d = np.array(centers2d, dtype=np.float32)\n        depths = np.array(depths, dtype=np.float32)\n    else:\n        gt_bboxes_cam3d = np.zeros((0, self.bbox_code_size), dtype=np.float32)\n        centers2d = np.zeros((0, 2), dtype=np.float32)\n        depths = np.zeros(0, dtype=np.float32)\n    gt_bboxes_cam3d = CameraInstance3DBoxes(gt_bboxes_cam3d, box_dim=gt_bboxes_cam3d.shape[-1], origin=(0.5, 0.5, 0.5))\n    gt_labels_3d = copy.deepcopy(gt_labels)\n    if gt_bboxes_ignore:\n        gt_bboxes_ignore = np.array(gt_bboxes_ignore, dtype=np.float32)\n    else:\n        gt_bboxes_ignore = np.zeros((0, 4), dtype=np.float32)\n    seg_map = img_info['filename'].replace('jpg', 'png')\n    ann = dict(bboxes=gt_bboxes, labels=gt_labels, gt_bboxes_3d=gt_bboxes_cam3d, gt_labels_3d=gt_labels_3d, centers2d=centers2d, depths=depths, bboxes_ignore=gt_bboxes_ignore, masks=gt_masks_ann, seg_map=seg_map)\n    return ann",
            "def _parse_ann_info(self, img_info, ann_info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Parse bbox and mask annotation.\\n\\n        Args:\\n            ann_info (list[dict]): Annotation info of an image.\\n            with_mask (bool): Whether to parse mask annotations.\\n\\n        Returns:\\n            dict: A dict containing the following keys: bboxes, bboxes_ignore,\\n                labels, masks, seg_map. \"masks\" are raw annotations and not\\n                decoded into binary masks.\\n        '\n    gt_bboxes = []\n    gt_labels = []\n    gt_bboxes_ignore = []\n    gt_masks_ann = []\n    gt_bboxes_cam3d = []\n    centers2d = []\n    depths = []\n    for (i, ann) in enumerate(ann_info):\n        if ann.get('ignore', False):\n            continue\n        (x1, y1, w, h) = ann['bbox']\n        inter_w = max(0, min(x1 + w, img_info['width']) - max(x1, 0))\n        inter_h = max(0, min(y1 + h, img_info['height']) - max(y1, 0))\n        if inter_w * inter_h == 0:\n            continue\n        if ann['area'] <= 0 or w < 1 or h < 1:\n            continue\n        if ann['category_id'] not in self.cat_ids:\n            continue\n        bbox = [x1, y1, x1 + w, y1 + h]\n        if ann.get('iscrowd', False):\n            gt_bboxes_ignore.append(bbox)\n        else:\n            gt_bboxes.append(bbox)\n            gt_labels.append(self.cat2label[ann['category_id']])\n            gt_masks_ann.append(ann.get('segmentation', None))\n            bbox_cam3d = np.array(ann['bbox_cam3d']).reshape(-1)\n            gt_bboxes_cam3d.append(bbox_cam3d)\n            center2d = ann['center2d'][:2]\n            depth = ann['center2d'][2]\n            centers2d.append(center2d)\n            depths.append(depth)\n    if gt_bboxes:\n        gt_bboxes = np.array(gt_bboxes, dtype=np.float32)\n        gt_labels = np.array(gt_labels, dtype=np.int64)\n    else:\n        gt_bboxes = np.zeros((0, 4), dtype=np.float32)\n        gt_labels = np.array([], dtype=np.int64)\n    if gt_bboxes_cam3d:\n        gt_bboxes_cam3d = np.array(gt_bboxes_cam3d, dtype=np.float32)\n        centers2d = np.array(centers2d, dtype=np.float32)\n        depths = np.array(depths, dtype=np.float32)\n    else:\n        gt_bboxes_cam3d = np.zeros((0, self.bbox_code_size), dtype=np.float32)\n        centers2d = np.zeros((0, 2), dtype=np.float32)\n        depths = np.zeros(0, dtype=np.float32)\n    gt_bboxes_cam3d = CameraInstance3DBoxes(gt_bboxes_cam3d, box_dim=gt_bboxes_cam3d.shape[-1], origin=(0.5, 0.5, 0.5))\n    gt_labels_3d = copy.deepcopy(gt_labels)\n    if gt_bboxes_ignore:\n        gt_bboxes_ignore = np.array(gt_bboxes_ignore, dtype=np.float32)\n    else:\n        gt_bboxes_ignore = np.zeros((0, 4), dtype=np.float32)\n    seg_map = img_info['filename'].replace('jpg', 'png')\n    ann = dict(bboxes=gt_bboxes, labels=gt_labels, gt_bboxes_3d=gt_bboxes_cam3d, gt_labels_3d=gt_labels_3d, centers2d=centers2d, depths=depths, bboxes_ignore=gt_bboxes_ignore, masks=gt_masks_ann, seg_map=seg_map)\n    return ann"
        ]
    },
    {
        "func_name": "format_results",
        "original": "def format_results(self, outputs, pklfile_prefix=None, submission_prefix=None):\n    \"\"\"Format the results to pkl file.\n\n        Args:\n            outputs (list[dict]): Testing results of the dataset.\n            pklfile_prefix (str): The prefix of pkl files. It includes\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\n                If not specified, a temp file will be created. Default: None.\n            submission_prefix (str): The prefix of submitted files. It\n                includes the file path and the prefix of filename, e.g.,\n                \"a/b/prefix\". If not specified, a temp file will be created.\n                Default: None.\n\n        Returns:\n            tuple: (result_files, tmp_dir), result_files is a dict containing\n                the json filepaths, tmp_dir is the temporal directory created\n                for saving json files when jsonfile_prefix is not specified.\n        \"\"\"\n    if pklfile_prefix is None:\n        tmp_dir = tempfile.TemporaryDirectory()\n        pklfile_prefix = osp.join(tmp_dir.name, 'results')\n    else:\n        tmp_dir = None\n    if not isinstance(outputs[0], dict):\n        result_files = self.bbox2result_kitti2d(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    elif 'pts_bbox' in outputs[0] or 'img_bbox' in outputs[0] or 'img_bbox2d' in outputs[0]:\n        result_files = dict()\n        for name in outputs[0]:\n            results_ = [out[name] for out in outputs]\n            pklfile_prefix_ = pklfile_prefix + name\n            if submission_prefix is not None:\n                submission_prefix_ = submission_prefix + name\n            else:\n                submission_prefix_ = None\n            if '2d' in name:\n                result_files_ = self.bbox2result_kitti2d(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            else:\n                result_files_ = self.bbox2result_kitti(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            result_files[name] = result_files_\n    else:\n        result_files = self.bbox2result_kitti(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    return (result_files, tmp_dir)",
        "mutated": [
            "def format_results(self, outputs, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n    'Format the results to pkl file.\\n\\n        Args:\\n            outputs (list[dict]): Testing results of the dataset.\\n            pklfile_prefix (str): The prefix of pkl files. It includes\\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\\n                If not specified, a temp file will be created. Default: None.\\n            submission_prefix (str): The prefix of submitted files. It\\n                includes the file path and the prefix of filename, e.g.,\\n                \"a/b/prefix\". If not specified, a temp file will be created.\\n                Default: None.\\n\\n        Returns:\\n            tuple: (result_files, tmp_dir), result_files is a dict containing\\n                the json filepaths, tmp_dir is the temporal directory created\\n                for saving json files when jsonfile_prefix is not specified.\\n        '\n    if pklfile_prefix is None:\n        tmp_dir = tempfile.TemporaryDirectory()\n        pklfile_prefix = osp.join(tmp_dir.name, 'results')\n    else:\n        tmp_dir = None\n    if not isinstance(outputs[0], dict):\n        result_files = self.bbox2result_kitti2d(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    elif 'pts_bbox' in outputs[0] or 'img_bbox' in outputs[0] or 'img_bbox2d' in outputs[0]:\n        result_files = dict()\n        for name in outputs[0]:\n            results_ = [out[name] for out in outputs]\n            pklfile_prefix_ = pklfile_prefix + name\n            if submission_prefix is not None:\n                submission_prefix_ = submission_prefix + name\n            else:\n                submission_prefix_ = None\n            if '2d' in name:\n                result_files_ = self.bbox2result_kitti2d(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            else:\n                result_files_ = self.bbox2result_kitti(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            result_files[name] = result_files_\n    else:\n        result_files = self.bbox2result_kitti(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    return (result_files, tmp_dir)",
            "def format_results(self, outputs, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Format the results to pkl file.\\n\\n        Args:\\n            outputs (list[dict]): Testing results of the dataset.\\n            pklfile_prefix (str): The prefix of pkl files. It includes\\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\\n                If not specified, a temp file will be created. Default: None.\\n            submission_prefix (str): The prefix of submitted files. It\\n                includes the file path and the prefix of filename, e.g.,\\n                \"a/b/prefix\". If not specified, a temp file will be created.\\n                Default: None.\\n\\n        Returns:\\n            tuple: (result_files, tmp_dir), result_files is a dict containing\\n                the json filepaths, tmp_dir is the temporal directory created\\n                for saving json files when jsonfile_prefix is not specified.\\n        '\n    if pklfile_prefix is None:\n        tmp_dir = tempfile.TemporaryDirectory()\n        pklfile_prefix = osp.join(tmp_dir.name, 'results')\n    else:\n        tmp_dir = None\n    if not isinstance(outputs[0], dict):\n        result_files = self.bbox2result_kitti2d(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    elif 'pts_bbox' in outputs[0] or 'img_bbox' in outputs[0] or 'img_bbox2d' in outputs[0]:\n        result_files = dict()\n        for name in outputs[0]:\n            results_ = [out[name] for out in outputs]\n            pklfile_prefix_ = pklfile_prefix + name\n            if submission_prefix is not None:\n                submission_prefix_ = submission_prefix + name\n            else:\n                submission_prefix_ = None\n            if '2d' in name:\n                result_files_ = self.bbox2result_kitti2d(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            else:\n                result_files_ = self.bbox2result_kitti(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            result_files[name] = result_files_\n    else:\n        result_files = self.bbox2result_kitti(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    return (result_files, tmp_dir)",
            "def format_results(self, outputs, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Format the results to pkl file.\\n\\n        Args:\\n            outputs (list[dict]): Testing results of the dataset.\\n            pklfile_prefix (str): The prefix of pkl files. It includes\\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\\n                If not specified, a temp file will be created. Default: None.\\n            submission_prefix (str): The prefix of submitted files. It\\n                includes the file path and the prefix of filename, e.g.,\\n                \"a/b/prefix\". If not specified, a temp file will be created.\\n                Default: None.\\n\\n        Returns:\\n            tuple: (result_files, tmp_dir), result_files is a dict containing\\n                the json filepaths, tmp_dir is the temporal directory created\\n                for saving json files when jsonfile_prefix is not specified.\\n        '\n    if pklfile_prefix is None:\n        tmp_dir = tempfile.TemporaryDirectory()\n        pklfile_prefix = osp.join(tmp_dir.name, 'results')\n    else:\n        tmp_dir = None\n    if not isinstance(outputs[0], dict):\n        result_files = self.bbox2result_kitti2d(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    elif 'pts_bbox' in outputs[0] or 'img_bbox' in outputs[0] or 'img_bbox2d' in outputs[0]:\n        result_files = dict()\n        for name in outputs[0]:\n            results_ = [out[name] for out in outputs]\n            pklfile_prefix_ = pklfile_prefix + name\n            if submission_prefix is not None:\n                submission_prefix_ = submission_prefix + name\n            else:\n                submission_prefix_ = None\n            if '2d' in name:\n                result_files_ = self.bbox2result_kitti2d(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            else:\n                result_files_ = self.bbox2result_kitti(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            result_files[name] = result_files_\n    else:\n        result_files = self.bbox2result_kitti(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    return (result_files, tmp_dir)",
            "def format_results(self, outputs, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Format the results to pkl file.\\n\\n        Args:\\n            outputs (list[dict]): Testing results of the dataset.\\n            pklfile_prefix (str): The prefix of pkl files. It includes\\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\\n                If not specified, a temp file will be created. Default: None.\\n            submission_prefix (str): The prefix of submitted files. It\\n                includes the file path and the prefix of filename, e.g.,\\n                \"a/b/prefix\". If not specified, a temp file will be created.\\n                Default: None.\\n\\n        Returns:\\n            tuple: (result_files, tmp_dir), result_files is a dict containing\\n                the json filepaths, tmp_dir is the temporal directory created\\n                for saving json files when jsonfile_prefix is not specified.\\n        '\n    if pklfile_prefix is None:\n        tmp_dir = tempfile.TemporaryDirectory()\n        pklfile_prefix = osp.join(tmp_dir.name, 'results')\n    else:\n        tmp_dir = None\n    if not isinstance(outputs[0], dict):\n        result_files = self.bbox2result_kitti2d(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    elif 'pts_bbox' in outputs[0] or 'img_bbox' in outputs[0] or 'img_bbox2d' in outputs[0]:\n        result_files = dict()\n        for name in outputs[0]:\n            results_ = [out[name] for out in outputs]\n            pklfile_prefix_ = pklfile_prefix + name\n            if submission_prefix is not None:\n                submission_prefix_ = submission_prefix + name\n            else:\n                submission_prefix_ = None\n            if '2d' in name:\n                result_files_ = self.bbox2result_kitti2d(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            else:\n                result_files_ = self.bbox2result_kitti(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            result_files[name] = result_files_\n    else:\n        result_files = self.bbox2result_kitti(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    return (result_files, tmp_dir)",
            "def format_results(self, outputs, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Format the results to pkl file.\\n\\n        Args:\\n            outputs (list[dict]): Testing results of the dataset.\\n            pklfile_prefix (str): The prefix of pkl files. It includes\\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\\n                If not specified, a temp file will be created. Default: None.\\n            submission_prefix (str): The prefix of submitted files. It\\n                includes the file path and the prefix of filename, e.g.,\\n                \"a/b/prefix\". If not specified, a temp file will be created.\\n                Default: None.\\n\\n        Returns:\\n            tuple: (result_files, tmp_dir), result_files is a dict containing\\n                the json filepaths, tmp_dir is the temporal directory created\\n                for saving json files when jsonfile_prefix is not specified.\\n        '\n    if pklfile_prefix is None:\n        tmp_dir = tempfile.TemporaryDirectory()\n        pklfile_prefix = osp.join(tmp_dir.name, 'results')\n    else:\n        tmp_dir = None\n    if not isinstance(outputs[0], dict):\n        result_files = self.bbox2result_kitti2d(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    elif 'pts_bbox' in outputs[0] or 'img_bbox' in outputs[0] or 'img_bbox2d' in outputs[0]:\n        result_files = dict()\n        for name in outputs[0]:\n            results_ = [out[name] for out in outputs]\n            pklfile_prefix_ = pklfile_prefix + name\n            if submission_prefix is not None:\n                submission_prefix_ = submission_prefix + name\n            else:\n                submission_prefix_ = None\n            if '2d' in name:\n                result_files_ = self.bbox2result_kitti2d(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            else:\n                result_files_ = self.bbox2result_kitti(results_, self.CLASSES, pklfile_prefix_, submission_prefix_)\n            result_files[name] = result_files_\n    else:\n        result_files = self.bbox2result_kitti(outputs, self.CLASSES, pklfile_prefix, submission_prefix)\n    return (result_files, tmp_dir)"
        ]
    },
    {
        "func_name": "evaluate",
        "original": "def evaluate(self, results, metric=None, logger=None, pklfile_prefix=None, submission_prefix=None, show=False, out_dir=None, pipeline=None):\n    \"\"\"Evaluation in KITTI protocol.\n\n        Args:\n            results (list[dict]): Testing results of the dataset.\n            metric (str | list[str], optional): Metrics to be evaluated.\n                Defaults to None.\n            logger (logging.Logger | str, optional): Logger used for printing\n                related information during evaluation. Default: None.\n            pklfile_prefix (str, optional): The prefix of pkl files, including\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\n                If not specified, a temp file will be created. Default: None.\n            submission_prefix (str, optional): The prefix of submission data.\n                If not specified, the submission data will not be generated.\n            show (bool, optional): Whether to visualize.\n                Default: False.\n            out_dir (str, optional): Path to save the visualization results.\n                Default: None.\n            pipeline (list[dict], optional): raw data loading for showing.\n                Default: None.\n\n        Returns:\n            dict[str, float]: Results of each evaluation metric.\n        \"\"\"\n    (result_files, tmp_dir) = self.format_results(results, pklfile_prefix)\n    from mmdet3d.core.evaluation import kitti_eval\n    gt_annos = [info['annos'] for info in self.anno_infos]\n    if isinstance(result_files, dict):\n        ap_dict = dict()\n        for (name, result_files_) in result_files.items():\n            eval_types = ['bbox', 'bev', '3d']\n            if '2d' in name:\n                eval_types = ['bbox']\n            (ap_result_str, ap_dict_) = kitti_eval(gt_annos, result_files_, self.CLASSES, eval_types=eval_types)\n            for (ap_type, ap) in ap_dict_.items():\n                ap_dict[f'{name}/{ap_type}'] = float('{:.4f}'.format(ap))\n            print_log(f'Results of {name}:\\n' + ap_result_str, logger=logger)\n    else:\n        if metric == 'img_bbox2d':\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES, eval_types=['bbox'])\n        else:\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES)\n        print_log('\\n' + ap_result_str, logger=logger)\n    if tmp_dir is not None:\n        tmp_dir.cleanup()\n    if show or out_dir:\n        self.show(results, out_dir, show=show, pipeline=pipeline)\n    return ap_dict",
        "mutated": [
            "def evaluate(self, results, metric=None, logger=None, pklfile_prefix=None, submission_prefix=None, show=False, out_dir=None, pipeline=None):\n    if False:\n        i = 10\n    'Evaluation in KITTI protocol.\\n\\n        Args:\\n            results (list[dict]): Testing results of the dataset.\\n            metric (str | list[str], optional): Metrics to be evaluated.\\n                Defaults to None.\\n            logger (logging.Logger | str, optional): Logger used for printing\\n                related information during evaluation. Default: None.\\n            pklfile_prefix (str, optional): The prefix of pkl files, including\\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\\n                If not specified, a temp file will be created. Default: None.\\n            submission_prefix (str, optional): The prefix of submission data.\\n                If not specified, the submission data will not be generated.\\n            show (bool, optional): Whether to visualize.\\n                Default: False.\\n            out_dir (str, optional): Path to save the visualization results.\\n                Default: None.\\n            pipeline (list[dict], optional): raw data loading for showing.\\n                Default: None.\\n\\n        Returns:\\n            dict[str, float]: Results of each evaluation metric.\\n        '\n    (result_files, tmp_dir) = self.format_results(results, pklfile_prefix)\n    from mmdet3d.core.evaluation import kitti_eval\n    gt_annos = [info['annos'] for info in self.anno_infos]\n    if isinstance(result_files, dict):\n        ap_dict = dict()\n        for (name, result_files_) in result_files.items():\n            eval_types = ['bbox', 'bev', '3d']\n            if '2d' in name:\n                eval_types = ['bbox']\n            (ap_result_str, ap_dict_) = kitti_eval(gt_annos, result_files_, self.CLASSES, eval_types=eval_types)\n            for (ap_type, ap) in ap_dict_.items():\n                ap_dict[f'{name}/{ap_type}'] = float('{:.4f}'.format(ap))\n            print_log(f'Results of {name}:\\n' + ap_result_str, logger=logger)\n    else:\n        if metric == 'img_bbox2d':\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES, eval_types=['bbox'])\n        else:\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES)\n        print_log('\\n' + ap_result_str, logger=logger)\n    if tmp_dir is not None:\n        tmp_dir.cleanup()\n    if show or out_dir:\n        self.show(results, out_dir, show=show, pipeline=pipeline)\n    return ap_dict",
            "def evaluate(self, results, metric=None, logger=None, pklfile_prefix=None, submission_prefix=None, show=False, out_dir=None, pipeline=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Evaluation in KITTI protocol.\\n\\n        Args:\\n            results (list[dict]): Testing results of the dataset.\\n            metric (str | list[str], optional): Metrics to be evaluated.\\n                Defaults to None.\\n            logger (logging.Logger | str, optional): Logger used for printing\\n                related information during evaluation. Default: None.\\n            pklfile_prefix (str, optional): The prefix of pkl files, including\\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\\n                If not specified, a temp file will be created. Default: None.\\n            submission_prefix (str, optional): The prefix of submission data.\\n                If not specified, the submission data will not be generated.\\n            show (bool, optional): Whether to visualize.\\n                Default: False.\\n            out_dir (str, optional): Path to save the visualization results.\\n                Default: None.\\n            pipeline (list[dict], optional): raw data loading for showing.\\n                Default: None.\\n\\n        Returns:\\n            dict[str, float]: Results of each evaluation metric.\\n        '\n    (result_files, tmp_dir) = self.format_results(results, pklfile_prefix)\n    from mmdet3d.core.evaluation import kitti_eval\n    gt_annos = [info['annos'] for info in self.anno_infos]\n    if isinstance(result_files, dict):\n        ap_dict = dict()\n        for (name, result_files_) in result_files.items():\n            eval_types = ['bbox', 'bev', '3d']\n            if '2d' in name:\n                eval_types = ['bbox']\n            (ap_result_str, ap_dict_) = kitti_eval(gt_annos, result_files_, self.CLASSES, eval_types=eval_types)\n            for (ap_type, ap) in ap_dict_.items():\n                ap_dict[f'{name}/{ap_type}'] = float('{:.4f}'.format(ap))\n            print_log(f'Results of {name}:\\n' + ap_result_str, logger=logger)\n    else:\n        if metric == 'img_bbox2d':\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES, eval_types=['bbox'])\n        else:\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES)\n        print_log('\\n' + ap_result_str, logger=logger)\n    if tmp_dir is not None:\n        tmp_dir.cleanup()\n    if show or out_dir:\n        self.show(results, out_dir, show=show, pipeline=pipeline)\n    return ap_dict",
            "def evaluate(self, results, metric=None, logger=None, pklfile_prefix=None, submission_prefix=None, show=False, out_dir=None, pipeline=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Evaluation in KITTI protocol.\\n\\n        Args:\\n            results (list[dict]): Testing results of the dataset.\\n            metric (str | list[str], optional): Metrics to be evaluated.\\n                Defaults to None.\\n            logger (logging.Logger | str, optional): Logger used for printing\\n                related information during evaluation. Default: None.\\n            pklfile_prefix (str, optional): The prefix of pkl files, including\\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\\n                If not specified, a temp file will be created. Default: None.\\n            submission_prefix (str, optional): The prefix of submission data.\\n                If not specified, the submission data will not be generated.\\n            show (bool, optional): Whether to visualize.\\n                Default: False.\\n            out_dir (str, optional): Path to save the visualization results.\\n                Default: None.\\n            pipeline (list[dict], optional): raw data loading for showing.\\n                Default: None.\\n\\n        Returns:\\n            dict[str, float]: Results of each evaluation metric.\\n        '\n    (result_files, tmp_dir) = self.format_results(results, pklfile_prefix)\n    from mmdet3d.core.evaluation import kitti_eval\n    gt_annos = [info['annos'] for info in self.anno_infos]\n    if isinstance(result_files, dict):\n        ap_dict = dict()\n        for (name, result_files_) in result_files.items():\n            eval_types = ['bbox', 'bev', '3d']\n            if '2d' in name:\n                eval_types = ['bbox']\n            (ap_result_str, ap_dict_) = kitti_eval(gt_annos, result_files_, self.CLASSES, eval_types=eval_types)\n            for (ap_type, ap) in ap_dict_.items():\n                ap_dict[f'{name}/{ap_type}'] = float('{:.4f}'.format(ap))\n            print_log(f'Results of {name}:\\n' + ap_result_str, logger=logger)\n    else:\n        if metric == 'img_bbox2d':\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES, eval_types=['bbox'])\n        else:\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES)\n        print_log('\\n' + ap_result_str, logger=logger)\n    if tmp_dir is not None:\n        tmp_dir.cleanup()\n    if show or out_dir:\n        self.show(results, out_dir, show=show, pipeline=pipeline)\n    return ap_dict",
            "def evaluate(self, results, metric=None, logger=None, pklfile_prefix=None, submission_prefix=None, show=False, out_dir=None, pipeline=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Evaluation in KITTI protocol.\\n\\n        Args:\\n            results (list[dict]): Testing results of the dataset.\\n            metric (str | list[str], optional): Metrics to be evaluated.\\n                Defaults to None.\\n            logger (logging.Logger | str, optional): Logger used for printing\\n                related information during evaluation. Default: None.\\n            pklfile_prefix (str, optional): The prefix of pkl files, including\\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\\n                If not specified, a temp file will be created. Default: None.\\n            submission_prefix (str, optional): The prefix of submission data.\\n                If not specified, the submission data will not be generated.\\n            show (bool, optional): Whether to visualize.\\n                Default: False.\\n            out_dir (str, optional): Path to save the visualization results.\\n                Default: None.\\n            pipeline (list[dict], optional): raw data loading for showing.\\n                Default: None.\\n\\n        Returns:\\n            dict[str, float]: Results of each evaluation metric.\\n        '\n    (result_files, tmp_dir) = self.format_results(results, pklfile_prefix)\n    from mmdet3d.core.evaluation import kitti_eval\n    gt_annos = [info['annos'] for info in self.anno_infos]\n    if isinstance(result_files, dict):\n        ap_dict = dict()\n        for (name, result_files_) in result_files.items():\n            eval_types = ['bbox', 'bev', '3d']\n            if '2d' in name:\n                eval_types = ['bbox']\n            (ap_result_str, ap_dict_) = kitti_eval(gt_annos, result_files_, self.CLASSES, eval_types=eval_types)\n            for (ap_type, ap) in ap_dict_.items():\n                ap_dict[f'{name}/{ap_type}'] = float('{:.4f}'.format(ap))\n            print_log(f'Results of {name}:\\n' + ap_result_str, logger=logger)\n    else:\n        if metric == 'img_bbox2d':\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES, eval_types=['bbox'])\n        else:\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES)\n        print_log('\\n' + ap_result_str, logger=logger)\n    if tmp_dir is not None:\n        tmp_dir.cleanup()\n    if show or out_dir:\n        self.show(results, out_dir, show=show, pipeline=pipeline)\n    return ap_dict",
            "def evaluate(self, results, metric=None, logger=None, pklfile_prefix=None, submission_prefix=None, show=False, out_dir=None, pipeline=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Evaluation in KITTI protocol.\\n\\n        Args:\\n            results (list[dict]): Testing results of the dataset.\\n            metric (str | list[str], optional): Metrics to be evaluated.\\n                Defaults to None.\\n            logger (logging.Logger | str, optional): Logger used for printing\\n                related information during evaluation. Default: None.\\n            pklfile_prefix (str, optional): The prefix of pkl files, including\\n                the file path and the prefix of filename, e.g., \"a/b/prefix\".\\n                If not specified, a temp file will be created. Default: None.\\n            submission_prefix (str, optional): The prefix of submission data.\\n                If not specified, the submission data will not be generated.\\n            show (bool, optional): Whether to visualize.\\n                Default: False.\\n            out_dir (str, optional): Path to save the visualization results.\\n                Default: None.\\n            pipeline (list[dict], optional): raw data loading for showing.\\n                Default: None.\\n\\n        Returns:\\n            dict[str, float]: Results of each evaluation metric.\\n        '\n    (result_files, tmp_dir) = self.format_results(results, pklfile_prefix)\n    from mmdet3d.core.evaluation import kitti_eval\n    gt_annos = [info['annos'] for info in self.anno_infos]\n    if isinstance(result_files, dict):\n        ap_dict = dict()\n        for (name, result_files_) in result_files.items():\n            eval_types = ['bbox', 'bev', '3d']\n            if '2d' in name:\n                eval_types = ['bbox']\n            (ap_result_str, ap_dict_) = kitti_eval(gt_annos, result_files_, self.CLASSES, eval_types=eval_types)\n            for (ap_type, ap) in ap_dict_.items():\n                ap_dict[f'{name}/{ap_type}'] = float('{:.4f}'.format(ap))\n            print_log(f'Results of {name}:\\n' + ap_result_str, logger=logger)\n    else:\n        if metric == 'img_bbox2d':\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES, eval_types=['bbox'])\n        else:\n            (ap_result_str, ap_dict) = kitti_eval(gt_annos, result_files, self.CLASSES)\n        print_log('\\n' + ap_result_str, logger=logger)\n    if tmp_dir is not None:\n        tmp_dir.cleanup()\n    if show or out_dir:\n        self.show(results, out_dir, show=show, pipeline=pipeline)\n    return ap_dict"
        ]
    },
    {
        "func_name": "bbox2result_kitti",
        "original": "def bbox2result_kitti(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    \"\"\"Convert 3D detection results to kitti format for evaluation and test\n        submission.\n\n        Args:\n            net_outputs (list[np.ndarray]): List of array storing the\n                inferenced bounding boxes and scores.\n            class_names (list[String]): A list of class names.\n            pklfile_prefix (str): The prefix of pkl file.\n            submission_prefix (str): The prefix of submission file.\n\n        Returns:\n            list[dict]: A list of dictionaries with the kitti format.\n        \"\"\"\n    assert len(net_outputs) == len(self.anno_infos)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (idx, pred_dicts) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        info = self.anno_infos[idx]\n        sample_idx = info['image']['image_idx']\n        image_shape = info['image']['image_shape'][:2]\n        box_dict = self.convert_valid_bboxes(pred_dicts, info)\n        anno = {'name': [], 'truncated': [], 'occluded': [], 'alpha': [], 'bbox': [], 'dimensions': [], 'location': [], 'rotation_y': [], 'score': []}\n        if len(box_dict['bbox']) > 0:\n            box_2d_preds = box_dict['bbox']\n            box_preds = box_dict['box3d_camera']\n            scores = box_dict['scores']\n            box_preds_lidar = box_dict['box3d_lidar']\n            label_preds = box_dict['label_preds']\n            for (box, box_lidar, bbox, score, label) in zip(box_preds, box_preds_lidar, box_2d_preds, scores, label_preds):\n                bbox[2:] = np.minimum(bbox[2:], image_shape[::-1])\n                bbox[:2] = np.maximum(bbox[:2], [0, 0])\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-np.arctan2(box[0], box[2]) + box[6])\n                anno['bbox'].append(bbox)\n                anno['dimensions'].append(box[3:6])\n                anno['location'].append(box[:3])\n                anno['rotation_y'].append(box[6])\n                anno['score'].append(score)\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        else:\n            anno = {'name': np.array([]), 'truncated': np.array([]), 'occluded': np.array([]), 'alpha': np.array([]), 'bbox': np.zeros([0, 4]), 'dimensions': np.zeros([0, 3]), 'location': np.zeros([0, 3]), 'rotation_y': np.array([]), 'score': np.array([])}\n            annos.append(anno)\n        if submission_prefix is not None:\n            curr_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(curr_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions']\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f}'.format(anno['name'][idx], anno['alpha'][idx], bbox[idx][0], bbox[idx][1], bbox[idx][2], bbox[idx][3], dims[idx][1], dims[idx][2], dims[idx][0], loc[idx][0], loc[idx][1], loc[idx][2], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * len(annos[-1]['score']), dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    return det_annos",
        "mutated": [
            "def bbox2result_kitti(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n    'Convert 3D detection results to kitti format for evaluation and test\\n        submission.\\n\\n        Args:\\n            net_outputs (list[np.ndarray]): List of array storing the\\n                inferenced bounding boxes and scores.\\n            class_names (list[String]): A list of class names.\\n            pklfile_prefix (str): The prefix of pkl file.\\n            submission_prefix (str): The prefix of submission file.\\n\\n        Returns:\\n            list[dict]: A list of dictionaries with the kitti format.\\n        '\n    assert len(net_outputs) == len(self.anno_infos)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (idx, pred_dicts) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        info = self.anno_infos[idx]\n        sample_idx = info['image']['image_idx']\n        image_shape = info['image']['image_shape'][:2]\n        box_dict = self.convert_valid_bboxes(pred_dicts, info)\n        anno = {'name': [], 'truncated': [], 'occluded': [], 'alpha': [], 'bbox': [], 'dimensions': [], 'location': [], 'rotation_y': [], 'score': []}\n        if len(box_dict['bbox']) > 0:\n            box_2d_preds = box_dict['bbox']\n            box_preds = box_dict['box3d_camera']\n            scores = box_dict['scores']\n            box_preds_lidar = box_dict['box3d_lidar']\n            label_preds = box_dict['label_preds']\n            for (box, box_lidar, bbox, score, label) in zip(box_preds, box_preds_lidar, box_2d_preds, scores, label_preds):\n                bbox[2:] = np.minimum(bbox[2:], image_shape[::-1])\n                bbox[:2] = np.maximum(bbox[:2], [0, 0])\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-np.arctan2(box[0], box[2]) + box[6])\n                anno['bbox'].append(bbox)\n                anno['dimensions'].append(box[3:6])\n                anno['location'].append(box[:3])\n                anno['rotation_y'].append(box[6])\n                anno['score'].append(score)\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        else:\n            anno = {'name': np.array([]), 'truncated': np.array([]), 'occluded': np.array([]), 'alpha': np.array([]), 'bbox': np.zeros([0, 4]), 'dimensions': np.zeros([0, 3]), 'location': np.zeros([0, 3]), 'rotation_y': np.array([]), 'score': np.array([])}\n            annos.append(anno)\n        if submission_prefix is not None:\n            curr_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(curr_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions']\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f}'.format(anno['name'][idx], anno['alpha'][idx], bbox[idx][0], bbox[idx][1], bbox[idx][2], bbox[idx][3], dims[idx][1], dims[idx][2], dims[idx][0], loc[idx][0], loc[idx][1], loc[idx][2], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * len(annos[-1]['score']), dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    return det_annos",
            "def bbox2result_kitti(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert 3D detection results to kitti format for evaluation and test\\n        submission.\\n\\n        Args:\\n            net_outputs (list[np.ndarray]): List of array storing the\\n                inferenced bounding boxes and scores.\\n            class_names (list[String]): A list of class names.\\n            pklfile_prefix (str): The prefix of pkl file.\\n            submission_prefix (str): The prefix of submission file.\\n\\n        Returns:\\n            list[dict]: A list of dictionaries with the kitti format.\\n        '\n    assert len(net_outputs) == len(self.anno_infos)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (idx, pred_dicts) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        info = self.anno_infos[idx]\n        sample_idx = info['image']['image_idx']\n        image_shape = info['image']['image_shape'][:2]\n        box_dict = self.convert_valid_bboxes(pred_dicts, info)\n        anno = {'name': [], 'truncated': [], 'occluded': [], 'alpha': [], 'bbox': [], 'dimensions': [], 'location': [], 'rotation_y': [], 'score': []}\n        if len(box_dict['bbox']) > 0:\n            box_2d_preds = box_dict['bbox']\n            box_preds = box_dict['box3d_camera']\n            scores = box_dict['scores']\n            box_preds_lidar = box_dict['box3d_lidar']\n            label_preds = box_dict['label_preds']\n            for (box, box_lidar, bbox, score, label) in zip(box_preds, box_preds_lidar, box_2d_preds, scores, label_preds):\n                bbox[2:] = np.minimum(bbox[2:], image_shape[::-1])\n                bbox[:2] = np.maximum(bbox[:2], [0, 0])\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-np.arctan2(box[0], box[2]) + box[6])\n                anno['bbox'].append(bbox)\n                anno['dimensions'].append(box[3:6])\n                anno['location'].append(box[:3])\n                anno['rotation_y'].append(box[6])\n                anno['score'].append(score)\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        else:\n            anno = {'name': np.array([]), 'truncated': np.array([]), 'occluded': np.array([]), 'alpha': np.array([]), 'bbox': np.zeros([0, 4]), 'dimensions': np.zeros([0, 3]), 'location': np.zeros([0, 3]), 'rotation_y': np.array([]), 'score': np.array([])}\n            annos.append(anno)\n        if submission_prefix is not None:\n            curr_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(curr_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions']\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f}'.format(anno['name'][idx], anno['alpha'][idx], bbox[idx][0], bbox[idx][1], bbox[idx][2], bbox[idx][3], dims[idx][1], dims[idx][2], dims[idx][0], loc[idx][0], loc[idx][1], loc[idx][2], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * len(annos[-1]['score']), dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    return det_annos",
            "def bbox2result_kitti(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert 3D detection results to kitti format for evaluation and test\\n        submission.\\n\\n        Args:\\n            net_outputs (list[np.ndarray]): List of array storing the\\n                inferenced bounding boxes and scores.\\n            class_names (list[String]): A list of class names.\\n            pklfile_prefix (str): The prefix of pkl file.\\n            submission_prefix (str): The prefix of submission file.\\n\\n        Returns:\\n            list[dict]: A list of dictionaries with the kitti format.\\n        '\n    assert len(net_outputs) == len(self.anno_infos)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (idx, pred_dicts) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        info = self.anno_infos[idx]\n        sample_idx = info['image']['image_idx']\n        image_shape = info['image']['image_shape'][:2]\n        box_dict = self.convert_valid_bboxes(pred_dicts, info)\n        anno = {'name': [], 'truncated': [], 'occluded': [], 'alpha': [], 'bbox': [], 'dimensions': [], 'location': [], 'rotation_y': [], 'score': []}\n        if len(box_dict['bbox']) > 0:\n            box_2d_preds = box_dict['bbox']\n            box_preds = box_dict['box3d_camera']\n            scores = box_dict['scores']\n            box_preds_lidar = box_dict['box3d_lidar']\n            label_preds = box_dict['label_preds']\n            for (box, box_lidar, bbox, score, label) in zip(box_preds, box_preds_lidar, box_2d_preds, scores, label_preds):\n                bbox[2:] = np.minimum(bbox[2:], image_shape[::-1])\n                bbox[:2] = np.maximum(bbox[:2], [0, 0])\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-np.arctan2(box[0], box[2]) + box[6])\n                anno['bbox'].append(bbox)\n                anno['dimensions'].append(box[3:6])\n                anno['location'].append(box[:3])\n                anno['rotation_y'].append(box[6])\n                anno['score'].append(score)\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        else:\n            anno = {'name': np.array([]), 'truncated': np.array([]), 'occluded': np.array([]), 'alpha': np.array([]), 'bbox': np.zeros([0, 4]), 'dimensions': np.zeros([0, 3]), 'location': np.zeros([0, 3]), 'rotation_y': np.array([]), 'score': np.array([])}\n            annos.append(anno)\n        if submission_prefix is not None:\n            curr_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(curr_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions']\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f}'.format(anno['name'][idx], anno['alpha'][idx], bbox[idx][0], bbox[idx][1], bbox[idx][2], bbox[idx][3], dims[idx][1], dims[idx][2], dims[idx][0], loc[idx][0], loc[idx][1], loc[idx][2], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * len(annos[-1]['score']), dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    return det_annos",
            "def bbox2result_kitti(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert 3D detection results to kitti format for evaluation and test\\n        submission.\\n\\n        Args:\\n            net_outputs (list[np.ndarray]): List of array storing the\\n                inferenced bounding boxes and scores.\\n            class_names (list[String]): A list of class names.\\n            pklfile_prefix (str): The prefix of pkl file.\\n            submission_prefix (str): The prefix of submission file.\\n\\n        Returns:\\n            list[dict]: A list of dictionaries with the kitti format.\\n        '\n    assert len(net_outputs) == len(self.anno_infos)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (idx, pred_dicts) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        info = self.anno_infos[idx]\n        sample_idx = info['image']['image_idx']\n        image_shape = info['image']['image_shape'][:2]\n        box_dict = self.convert_valid_bboxes(pred_dicts, info)\n        anno = {'name': [], 'truncated': [], 'occluded': [], 'alpha': [], 'bbox': [], 'dimensions': [], 'location': [], 'rotation_y': [], 'score': []}\n        if len(box_dict['bbox']) > 0:\n            box_2d_preds = box_dict['bbox']\n            box_preds = box_dict['box3d_camera']\n            scores = box_dict['scores']\n            box_preds_lidar = box_dict['box3d_lidar']\n            label_preds = box_dict['label_preds']\n            for (box, box_lidar, bbox, score, label) in zip(box_preds, box_preds_lidar, box_2d_preds, scores, label_preds):\n                bbox[2:] = np.minimum(bbox[2:], image_shape[::-1])\n                bbox[:2] = np.maximum(bbox[:2], [0, 0])\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-np.arctan2(box[0], box[2]) + box[6])\n                anno['bbox'].append(bbox)\n                anno['dimensions'].append(box[3:6])\n                anno['location'].append(box[:3])\n                anno['rotation_y'].append(box[6])\n                anno['score'].append(score)\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        else:\n            anno = {'name': np.array([]), 'truncated': np.array([]), 'occluded': np.array([]), 'alpha': np.array([]), 'bbox': np.zeros([0, 4]), 'dimensions': np.zeros([0, 3]), 'location': np.zeros([0, 3]), 'rotation_y': np.array([]), 'score': np.array([])}\n            annos.append(anno)\n        if submission_prefix is not None:\n            curr_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(curr_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions']\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f}'.format(anno['name'][idx], anno['alpha'][idx], bbox[idx][0], bbox[idx][1], bbox[idx][2], bbox[idx][3], dims[idx][1], dims[idx][2], dims[idx][0], loc[idx][0], loc[idx][1], loc[idx][2], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * len(annos[-1]['score']), dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    return det_annos",
            "def bbox2result_kitti(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert 3D detection results to kitti format for evaluation and test\\n        submission.\\n\\n        Args:\\n            net_outputs (list[np.ndarray]): List of array storing the\\n                inferenced bounding boxes and scores.\\n            class_names (list[String]): A list of class names.\\n            pklfile_prefix (str): The prefix of pkl file.\\n            submission_prefix (str): The prefix of submission file.\\n\\n        Returns:\\n            list[dict]: A list of dictionaries with the kitti format.\\n        '\n    assert len(net_outputs) == len(self.anno_infos)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (idx, pred_dicts) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        info = self.anno_infos[idx]\n        sample_idx = info['image']['image_idx']\n        image_shape = info['image']['image_shape'][:2]\n        box_dict = self.convert_valid_bboxes(pred_dicts, info)\n        anno = {'name': [], 'truncated': [], 'occluded': [], 'alpha': [], 'bbox': [], 'dimensions': [], 'location': [], 'rotation_y': [], 'score': []}\n        if len(box_dict['bbox']) > 0:\n            box_2d_preds = box_dict['bbox']\n            box_preds = box_dict['box3d_camera']\n            scores = box_dict['scores']\n            box_preds_lidar = box_dict['box3d_lidar']\n            label_preds = box_dict['label_preds']\n            for (box, box_lidar, bbox, score, label) in zip(box_preds, box_preds_lidar, box_2d_preds, scores, label_preds):\n                bbox[2:] = np.minimum(bbox[2:], image_shape[::-1])\n                bbox[:2] = np.maximum(bbox[:2], [0, 0])\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-np.arctan2(box[0], box[2]) + box[6])\n                anno['bbox'].append(bbox)\n                anno['dimensions'].append(box[3:6])\n                anno['location'].append(box[:3])\n                anno['rotation_y'].append(box[6])\n                anno['score'].append(score)\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        else:\n            anno = {'name': np.array([]), 'truncated': np.array([]), 'occluded': np.array([]), 'alpha': np.array([]), 'bbox': np.zeros([0, 4]), 'dimensions': np.zeros([0, 3]), 'location': np.zeros([0, 3]), 'rotation_y': np.array([]), 'score': np.array([])}\n            annos.append(anno)\n        if submission_prefix is not None:\n            curr_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(curr_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions']\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f}'.format(anno['name'][idx], anno['alpha'][idx], bbox[idx][0], bbox[idx][1], bbox[idx][2], bbox[idx][3], dims[idx][1], dims[idx][2], dims[idx][0], loc[idx][0], loc[idx][1], loc[idx][2], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * len(annos[-1]['score']), dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    return det_annos"
        ]
    },
    {
        "func_name": "bbox2result_kitti2d",
        "original": "def bbox2result_kitti2d(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    \"\"\"Convert 2D detection results to kitti format for evaluation and test\n        submission.\n\n        Args:\n            net_outputs (list[np.ndarray]): List of array storing the\n                inferenced bounding boxes and scores.\n            class_names (list[String]): A list of class names.\n            pklfile_prefix (str): The prefix of pkl file.\n            submission_prefix (str): The prefix of submission file.\n\n        Returns:\n            list[dict]: A list of dictionaries have the kitti format\n        \"\"\"\n    assert len(net_outputs) == len(self.anno_infos)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (i, bboxes_per_sample) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        anno = dict(name=[], truncated=[], occluded=[], alpha=[], bbox=[], dimensions=[], location=[], rotation_y=[], score=[])\n        sample_idx = self.anno_infos[i]['image']['image_idx']\n        num_example = 0\n        for label in range(len(bboxes_per_sample)):\n            bbox = bboxes_per_sample[label]\n            for i in range(bbox.shape[0]):\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-10)\n                anno['bbox'].append(bbox[i, :4])\n                anno['dimensions'].append(np.zeros(shape=[3], dtype=np.float32))\n                anno['location'].append(np.ones(shape=[3], dtype=np.float32) * -1000.0)\n                anno['rotation_y'].append(0.0)\n                anno['score'].append(bbox[i, 4])\n                num_example += 1\n        if num_example == 0:\n            annos.append(dict(name=np.array([]), truncated=np.array([]), occluded=np.array([]), alpha=np.array([]), bbox=np.zeros([0, 4]), dimensions=np.zeros([0, 3]), location=np.zeros([0, 3]), rotation_y=np.array([]), score=np.array([])))\n        else:\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * num_example, dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n        print(f'Saving KITTI submission to {submission_prefix}')\n        for (i, anno) in enumerate(det_annos):\n            sample_idx = self.anno_infos[i]['image']['image_idx']\n            cur_det_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(cur_det_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions'][::-1]\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f}'.format(anno['name'][idx], anno['alpha'][idx], *bbox[idx], *dims[idx], *loc[idx], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        print(f'Result is saved to {submission_prefix}')\n    return det_annos",
        "mutated": [
            "def bbox2result_kitti2d(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n    'Convert 2D detection results to kitti format for evaluation and test\\n        submission.\\n\\n        Args:\\n            net_outputs (list[np.ndarray]): List of array storing the\\n                inferenced bounding boxes and scores.\\n            class_names (list[String]): A list of class names.\\n            pklfile_prefix (str): The prefix of pkl file.\\n            submission_prefix (str): The prefix of submission file.\\n\\n        Returns:\\n            list[dict]: A list of dictionaries have the kitti format\\n        '\n    assert len(net_outputs) == len(self.anno_infos)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (i, bboxes_per_sample) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        anno = dict(name=[], truncated=[], occluded=[], alpha=[], bbox=[], dimensions=[], location=[], rotation_y=[], score=[])\n        sample_idx = self.anno_infos[i]['image']['image_idx']\n        num_example = 0\n        for label in range(len(bboxes_per_sample)):\n            bbox = bboxes_per_sample[label]\n            for i in range(bbox.shape[0]):\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-10)\n                anno['bbox'].append(bbox[i, :4])\n                anno['dimensions'].append(np.zeros(shape=[3], dtype=np.float32))\n                anno['location'].append(np.ones(shape=[3], dtype=np.float32) * -1000.0)\n                anno['rotation_y'].append(0.0)\n                anno['score'].append(bbox[i, 4])\n                num_example += 1\n        if num_example == 0:\n            annos.append(dict(name=np.array([]), truncated=np.array([]), occluded=np.array([]), alpha=np.array([]), bbox=np.zeros([0, 4]), dimensions=np.zeros([0, 3]), location=np.zeros([0, 3]), rotation_y=np.array([]), score=np.array([])))\n        else:\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * num_example, dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n        print(f'Saving KITTI submission to {submission_prefix}')\n        for (i, anno) in enumerate(det_annos):\n            sample_idx = self.anno_infos[i]['image']['image_idx']\n            cur_det_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(cur_det_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions'][::-1]\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f}'.format(anno['name'][idx], anno['alpha'][idx], *bbox[idx], *dims[idx], *loc[idx], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        print(f'Result is saved to {submission_prefix}')\n    return det_annos",
            "def bbox2result_kitti2d(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert 2D detection results to kitti format for evaluation and test\\n        submission.\\n\\n        Args:\\n            net_outputs (list[np.ndarray]): List of array storing the\\n                inferenced bounding boxes and scores.\\n            class_names (list[String]): A list of class names.\\n            pklfile_prefix (str): The prefix of pkl file.\\n            submission_prefix (str): The prefix of submission file.\\n\\n        Returns:\\n            list[dict]: A list of dictionaries have the kitti format\\n        '\n    assert len(net_outputs) == len(self.anno_infos)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (i, bboxes_per_sample) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        anno = dict(name=[], truncated=[], occluded=[], alpha=[], bbox=[], dimensions=[], location=[], rotation_y=[], score=[])\n        sample_idx = self.anno_infos[i]['image']['image_idx']\n        num_example = 0\n        for label in range(len(bboxes_per_sample)):\n            bbox = bboxes_per_sample[label]\n            for i in range(bbox.shape[0]):\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-10)\n                anno['bbox'].append(bbox[i, :4])\n                anno['dimensions'].append(np.zeros(shape=[3], dtype=np.float32))\n                anno['location'].append(np.ones(shape=[3], dtype=np.float32) * -1000.0)\n                anno['rotation_y'].append(0.0)\n                anno['score'].append(bbox[i, 4])\n                num_example += 1\n        if num_example == 0:\n            annos.append(dict(name=np.array([]), truncated=np.array([]), occluded=np.array([]), alpha=np.array([]), bbox=np.zeros([0, 4]), dimensions=np.zeros([0, 3]), location=np.zeros([0, 3]), rotation_y=np.array([]), score=np.array([])))\n        else:\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * num_example, dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n        print(f'Saving KITTI submission to {submission_prefix}')\n        for (i, anno) in enumerate(det_annos):\n            sample_idx = self.anno_infos[i]['image']['image_idx']\n            cur_det_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(cur_det_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions'][::-1]\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f}'.format(anno['name'][idx], anno['alpha'][idx], *bbox[idx], *dims[idx], *loc[idx], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        print(f'Result is saved to {submission_prefix}')\n    return det_annos",
            "def bbox2result_kitti2d(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert 2D detection results to kitti format for evaluation and test\\n        submission.\\n\\n        Args:\\n            net_outputs (list[np.ndarray]): List of array storing the\\n                inferenced bounding boxes and scores.\\n            class_names (list[String]): A list of class names.\\n            pklfile_prefix (str): The prefix of pkl file.\\n            submission_prefix (str): The prefix of submission file.\\n\\n        Returns:\\n            list[dict]: A list of dictionaries have the kitti format\\n        '\n    assert len(net_outputs) == len(self.anno_infos)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (i, bboxes_per_sample) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        anno = dict(name=[], truncated=[], occluded=[], alpha=[], bbox=[], dimensions=[], location=[], rotation_y=[], score=[])\n        sample_idx = self.anno_infos[i]['image']['image_idx']\n        num_example = 0\n        for label in range(len(bboxes_per_sample)):\n            bbox = bboxes_per_sample[label]\n            for i in range(bbox.shape[0]):\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-10)\n                anno['bbox'].append(bbox[i, :4])\n                anno['dimensions'].append(np.zeros(shape=[3], dtype=np.float32))\n                anno['location'].append(np.ones(shape=[3], dtype=np.float32) * -1000.0)\n                anno['rotation_y'].append(0.0)\n                anno['score'].append(bbox[i, 4])\n                num_example += 1\n        if num_example == 0:\n            annos.append(dict(name=np.array([]), truncated=np.array([]), occluded=np.array([]), alpha=np.array([]), bbox=np.zeros([0, 4]), dimensions=np.zeros([0, 3]), location=np.zeros([0, 3]), rotation_y=np.array([]), score=np.array([])))\n        else:\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * num_example, dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n        print(f'Saving KITTI submission to {submission_prefix}')\n        for (i, anno) in enumerate(det_annos):\n            sample_idx = self.anno_infos[i]['image']['image_idx']\n            cur_det_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(cur_det_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions'][::-1]\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f}'.format(anno['name'][idx], anno['alpha'][idx], *bbox[idx], *dims[idx], *loc[idx], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        print(f'Result is saved to {submission_prefix}')\n    return det_annos",
            "def bbox2result_kitti2d(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert 2D detection results to kitti format for evaluation and test\\n        submission.\\n\\n        Args:\\n            net_outputs (list[np.ndarray]): List of array storing the\\n                inferenced bounding boxes and scores.\\n            class_names (list[String]): A list of class names.\\n            pklfile_prefix (str): The prefix of pkl file.\\n            submission_prefix (str): The prefix of submission file.\\n\\n        Returns:\\n            list[dict]: A list of dictionaries have the kitti format\\n        '\n    assert len(net_outputs) == len(self.anno_infos)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (i, bboxes_per_sample) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        anno = dict(name=[], truncated=[], occluded=[], alpha=[], bbox=[], dimensions=[], location=[], rotation_y=[], score=[])\n        sample_idx = self.anno_infos[i]['image']['image_idx']\n        num_example = 0\n        for label in range(len(bboxes_per_sample)):\n            bbox = bboxes_per_sample[label]\n            for i in range(bbox.shape[0]):\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-10)\n                anno['bbox'].append(bbox[i, :4])\n                anno['dimensions'].append(np.zeros(shape=[3], dtype=np.float32))\n                anno['location'].append(np.ones(shape=[3], dtype=np.float32) * -1000.0)\n                anno['rotation_y'].append(0.0)\n                anno['score'].append(bbox[i, 4])\n                num_example += 1\n        if num_example == 0:\n            annos.append(dict(name=np.array([]), truncated=np.array([]), occluded=np.array([]), alpha=np.array([]), bbox=np.zeros([0, 4]), dimensions=np.zeros([0, 3]), location=np.zeros([0, 3]), rotation_y=np.array([]), score=np.array([])))\n        else:\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * num_example, dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n        print(f'Saving KITTI submission to {submission_prefix}')\n        for (i, anno) in enumerate(det_annos):\n            sample_idx = self.anno_infos[i]['image']['image_idx']\n            cur_det_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(cur_det_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions'][::-1]\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f}'.format(anno['name'][idx], anno['alpha'][idx], *bbox[idx], *dims[idx], *loc[idx], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        print(f'Result is saved to {submission_prefix}')\n    return det_annos",
            "def bbox2result_kitti2d(self, net_outputs, class_names, pklfile_prefix=None, submission_prefix=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert 2D detection results to kitti format for evaluation and test\\n        submission.\\n\\n        Args:\\n            net_outputs (list[np.ndarray]): List of array storing the\\n                inferenced bounding boxes and scores.\\n            class_names (list[String]): A list of class names.\\n            pklfile_prefix (str): The prefix of pkl file.\\n            submission_prefix (str): The prefix of submission file.\\n\\n        Returns:\\n            list[dict]: A list of dictionaries have the kitti format\\n        '\n    assert len(net_outputs) == len(self.anno_infos)\n    det_annos = []\n    print('\\nConverting prediction to KITTI format')\n    for (i, bboxes_per_sample) in enumerate(mmcv.track_iter_progress(net_outputs)):\n        annos = []\n        anno = dict(name=[], truncated=[], occluded=[], alpha=[], bbox=[], dimensions=[], location=[], rotation_y=[], score=[])\n        sample_idx = self.anno_infos[i]['image']['image_idx']\n        num_example = 0\n        for label in range(len(bboxes_per_sample)):\n            bbox = bboxes_per_sample[label]\n            for i in range(bbox.shape[0]):\n                anno['name'].append(class_names[int(label)])\n                anno['truncated'].append(0.0)\n                anno['occluded'].append(0)\n                anno['alpha'].append(-10)\n                anno['bbox'].append(bbox[i, :4])\n                anno['dimensions'].append(np.zeros(shape=[3], dtype=np.float32))\n                anno['location'].append(np.ones(shape=[3], dtype=np.float32) * -1000.0)\n                anno['rotation_y'].append(0.0)\n                anno['score'].append(bbox[i, 4])\n                num_example += 1\n        if num_example == 0:\n            annos.append(dict(name=np.array([]), truncated=np.array([]), occluded=np.array([]), alpha=np.array([]), bbox=np.zeros([0, 4]), dimensions=np.zeros([0, 3]), location=np.zeros([0, 3]), rotation_y=np.array([]), score=np.array([])))\n        else:\n            anno = {k: np.stack(v) for (k, v) in anno.items()}\n            annos.append(anno)\n        annos[-1]['sample_idx'] = np.array([sample_idx] * num_example, dtype=np.int64)\n        det_annos += annos\n    if pklfile_prefix is not None:\n        if not pklfile_prefix.endswith(('.pkl', '.pickle')):\n            out = f'{pklfile_prefix}.pkl'\n        mmcv.dump(det_annos, out)\n        print('Result is saved to %s' % out)\n    if submission_prefix is not None:\n        mmcv.mkdir_or_exist(submission_prefix)\n        print(f'Saving KITTI submission to {submission_prefix}')\n        for (i, anno) in enumerate(det_annos):\n            sample_idx = self.anno_infos[i]['image']['image_idx']\n            cur_det_file = f'{submission_prefix}/{sample_idx:06d}.txt'\n            with open(cur_det_file, 'w') as f:\n                bbox = anno['bbox']\n                loc = anno['location']\n                dims = anno['dimensions'][::-1]\n                for idx in range(len(bbox)):\n                    print('{} -1 -1 {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f} {:4f}'.format(anno['name'][idx], anno['alpha'][idx], *bbox[idx], *dims[idx], *loc[idx], anno['rotation_y'][idx], anno['score'][idx]), file=f)\n        print(f'Result is saved to {submission_prefix}')\n    return det_annos"
        ]
    },
    {
        "func_name": "convert_valid_bboxes",
        "original": "def convert_valid_bboxes(self, box_dict, info):\n    \"\"\"Convert the predicted boxes into valid ones.\n\n        Args:\n            box_dict (dict): Box dictionaries to be converted.\n                - boxes_3d (:obj:`CameraInstance3DBoxes`): 3D bounding boxes.\n                - scores_3d (torch.Tensor): Scores of boxes.\n                - labels_3d (torch.Tensor): Class labels of boxes.\n            info (dict): Data info.\n\n        Returns:\n            dict: Valid predicted boxes.\n                - bbox (np.ndarray): 2D bounding boxes.\n                - box3d_camera (np.ndarray): 3D bounding boxes in\n                    camera coordinate.\n                - scores (np.ndarray): Scores of boxes.\n                - label_preds (np.ndarray): Class label predictions.\n                - sample_idx (int): Sample index.\n        \"\"\"\n    box_preds = box_dict['boxes_3d']\n    scores = box_dict['scores_3d']\n    labels = box_dict['labels_3d']\n    sample_idx = info['image']['image_idx']\n    if len(box_preds) == 0:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)\n    rect = info['calib']['R0_rect'].astype(np.float32)\n    Trv2c = info['calib']['Tr_velo_to_cam'].astype(np.float32)\n    P2 = info['calib']['P2'].astype(np.float32)\n    img_shape = info['image']['image_shape']\n    P2 = box_preds.tensor.new_tensor(P2)\n    box_preds_camera = box_preds\n    box_preds_lidar = box_preds.convert_to(Box3DMode.LIDAR, np.linalg.inv(rect @ Trv2c))\n    box_corners = box_preds_camera.corners\n    box_corners_in_image = points_cam2img(box_corners, P2)\n    minxy = torch.min(box_corners_in_image, dim=1)[0]\n    maxxy = torch.max(box_corners_in_image, dim=1)[0]\n    box_2d_preds = torch.cat([minxy, maxxy], dim=1)\n    image_shape = box_preds.tensor.new_tensor(img_shape)\n    valid_cam_inds = (box_2d_preds[:, 0] < image_shape[1]) & (box_2d_preds[:, 1] < image_shape[0]) & (box_2d_preds[:, 2] > 0) & (box_2d_preds[:, 3] > 0)\n    valid_inds = valid_cam_inds\n    if valid_inds.sum() > 0:\n        return dict(bbox=box_2d_preds[valid_inds, :].numpy(), box3d_camera=box_preds_camera[valid_inds].tensor.numpy(), box3d_lidar=box_preds_lidar[valid_inds].tensor.numpy(), scores=scores[valid_inds].numpy(), label_preds=labels[valid_inds].numpy(), sample_idx=sample_idx)\n    else:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), box3d_lidar=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)",
        "mutated": [
            "def convert_valid_bboxes(self, box_dict, info):\n    if False:\n        i = 10\n    'Convert the predicted boxes into valid ones.\\n\\n        Args:\\n            box_dict (dict): Box dictionaries to be converted.\\n                - boxes_3d (:obj:`CameraInstance3DBoxes`): 3D bounding boxes.\\n                - scores_3d (torch.Tensor): Scores of boxes.\\n                - labels_3d (torch.Tensor): Class labels of boxes.\\n            info (dict): Data info.\\n\\n        Returns:\\n            dict: Valid predicted boxes.\\n                - bbox (np.ndarray): 2D bounding boxes.\\n                - box3d_camera (np.ndarray): 3D bounding boxes in\\n                    camera coordinate.\\n                - scores (np.ndarray): Scores of boxes.\\n                - label_preds (np.ndarray): Class label predictions.\\n                - sample_idx (int): Sample index.\\n        '\n    box_preds = box_dict['boxes_3d']\n    scores = box_dict['scores_3d']\n    labels = box_dict['labels_3d']\n    sample_idx = info['image']['image_idx']\n    if len(box_preds) == 0:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)\n    rect = info['calib']['R0_rect'].astype(np.float32)\n    Trv2c = info['calib']['Tr_velo_to_cam'].astype(np.float32)\n    P2 = info['calib']['P2'].astype(np.float32)\n    img_shape = info['image']['image_shape']\n    P2 = box_preds.tensor.new_tensor(P2)\n    box_preds_camera = box_preds\n    box_preds_lidar = box_preds.convert_to(Box3DMode.LIDAR, np.linalg.inv(rect @ Trv2c))\n    box_corners = box_preds_camera.corners\n    box_corners_in_image = points_cam2img(box_corners, P2)\n    minxy = torch.min(box_corners_in_image, dim=1)[0]\n    maxxy = torch.max(box_corners_in_image, dim=1)[0]\n    box_2d_preds = torch.cat([minxy, maxxy], dim=1)\n    image_shape = box_preds.tensor.new_tensor(img_shape)\n    valid_cam_inds = (box_2d_preds[:, 0] < image_shape[1]) & (box_2d_preds[:, 1] < image_shape[0]) & (box_2d_preds[:, 2] > 0) & (box_2d_preds[:, 3] > 0)\n    valid_inds = valid_cam_inds\n    if valid_inds.sum() > 0:\n        return dict(bbox=box_2d_preds[valid_inds, :].numpy(), box3d_camera=box_preds_camera[valid_inds].tensor.numpy(), box3d_lidar=box_preds_lidar[valid_inds].tensor.numpy(), scores=scores[valid_inds].numpy(), label_preds=labels[valid_inds].numpy(), sample_idx=sample_idx)\n    else:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), box3d_lidar=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)",
            "def convert_valid_bboxes(self, box_dict, info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Convert the predicted boxes into valid ones.\\n\\n        Args:\\n            box_dict (dict): Box dictionaries to be converted.\\n                - boxes_3d (:obj:`CameraInstance3DBoxes`): 3D bounding boxes.\\n                - scores_3d (torch.Tensor): Scores of boxes.\\n                - labels_3d (torch.Tensor): Class labels of boxes.\\n            info (dict): Data info.\\n\\n        Returns:\\n            dict: Valid predicted boxes.\\n                - bbox (np.ndarray): 2D bounding boxes.\\n                - box3d_camera (np.ndarray): 3D bounding boxes in\\n                    camera coordinate.\\n                - scores (np.ndarray): Scores of boxes.\\n                - label_preds (np.ndarray): Class label predictions.\\n                - sample_idx (int): Sample index.\\n        '\n    box_preds = box_dict['boxes_3d']\n    scores = box_dict['scores_3d']\n    labels = box_dict['labels_3d']\n    sample_idx = info['image']['image_idx']\n    if len(box_preds) == 0:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)\n    rect = info['calib']['R0_rect'].astype(np.float32)\n    Trv2c = info['calib']['Tr_velo_to_cam'].astype(np.float32)\n    P2 = info['calib']['P2'].astype(np.float32)\n    img_shape = info['image']['image_shape']\n    P2 = box_preds.tensor.new_tensor(P2)\n    box_preds_camera = box_preds\n    box_preds_lidar = box_preds.convert_to(Box3DMode.LIDAR, np.linalg.inv(rect @ Trv2c))\n    box_corners = box_preds_camera.corners\n    box_corners_in_image = points_cam2img(box_corners, P2)\n    minxy = torch.min(box_corners_in_image, dim=1)[0]\n    maxxy = torch.max(box_corners_in_image, dim=1)[0]\n    box_2d_preds = torch.cat([minxy, maxxy], dim=1)\n    image_shape = box_preds.tensor.new_tensor(img_shape)\n    valid_cam_inds = (box_2d_preds[:, 0] < image_shape[1]) & (box_2d_preds[:, 1] < image_shape[0]) & (box_2d_preds[:, 2] > 0) & (box_2d_preds[:, 3] > 0)\n    valid_inds = valid_cam_inds\n    if valid_inds.sum() > 0:\n        return dict(bbox=box_2d_preds[valid_inds, :].numpy(), box3d_camera=box_preds_camera[valid_inds].tensor.numpy(), box3d_lidar=box_preds_lidar[valid_inds].tensor.numpy(), scores=scores[valid_inds].numpy(), label_preds=labels[valid_inds].numpy(), sample_idx=sample_idx)\n    else:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), box3d_lidar=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)",
            "def convert_valid_bboxes(self, box_dict, info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Convert the predicted boxes into valid ones.\\n\\n        Args:\\n            box_dict (dict): Box dictionaries to be converted.\\n                - boxes_3d (:obj:`CameraInstance3DBoxes`): 3D bounding boxes.\\n                - scores_3d (torch.Tensor): Scores of boxes.\\n                - labels_3d (torch.Tensor): Class labels of boxes.\\n            info (dict): Data info.\\n\\n        Returns:\\n            dict: Valid predicted boxes.\\n                - bbox (np.ndarray): 2D bounding boxes.\\n                - box3d_camera (np.ndarray): 3D bounding boxes in\\n                    camera coordinate.\\n                - scores (np.ndarray): Scores of boxes.\\n                - label_preds (np.ndarray): Class label predictions.\\n                - sample_idx (int): Sample index.\\n        '\n    box_preds = box_dict['boxes_3d']\n    scores = box_dict['scores_3d']\n    labels = box_dict['labels_3d']\n    sample_idx = info['image']['image_idx']\n    if len(box_preds) == 0:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)\n    rect = info['calib']['R0_rect'].astype(np.float32)\n    Trv2c = info['calib']['Tr_velo_to_cam'].astype(np.float32)\n    P2 = info['calib']['P2'].astype(np.float32)\n    img_shape = info['image']['image_shape']\n    P2 = box_preds.tensor.new_tensor(P2)\n    box_preds_camera = box_preds\n    box_preds_lidar = box_preds.convert_to(Box3DMode.LIDAR, np.linalg.inv(rect @ Trv2c))\n    box_corners = box_preds_camera.corners\n    box_corners_in_image = points_cam2img(box_corners, P2)\n    minxy = torch.min(box_corners_in_image, dim=1)[0]\n    maxxy = torch.max(box_corners_in_image, dim=1)[0]\n    box_2d_preds = torch.cat([minxy, maxxy], dim=1)\n    image_shape = box_preds.tensor.new_tensor(img_shape)\n    valid_cam_inds = (box_2d_preds[:, 0] < image_shape[1]) & (box_2d_preds[:, 1] < image_shape[0]) & (box_2d_preds[:, 2] > 0) & (box_2d_preds[:, 3] > 0)\n    valid_inds = valid_cam_inds\n    if valid_inds.sum() > 0:\n        return dict(bbox=box_2d_preds[valid_inds, :].numpy(), box3d_camera=box_preds_camera[valid_inds].tensor.numpy(), box3d_lidar=box_preds_lidar[valid_inds].tensor.numpy(), scores=scores[valid_inds].numpy(), label_preds=labels[valid_inds].numpy(), sample_idx=sample_idx)\n    else:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), box3d_lidar=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)",
            "def convert_valid_bboxes(self, box_dict, info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Convert the predicted boxes into valid ones.\\n\\n        Args:\\n            box_dict (dict): Box dictionaries to be converted.\\n                - boxes_3d (:obj:`CameraInstance3DBoxes`): 3D bounding boxes.\\n                - scores_3d (torch.Tensor): Scores of boxes.\\n                - labels_3d (torch.Tensor): Class labels of boxes.\\n            info (dict): Data info.\\n\\n        Returns:\\n            dict: Valid predicted boxes.\\n                - bbox (np.ndarray): 2D bounding boxes.\\n                - box3d_camera (np.ndarray): 3D bounding boxes in\\n                    camera coordinate.\\n                - scores (np.ndarray): Scores of boxes.\\n                - label_preds (np.ndarray): Class label predictions.\\n                - sample_idx (int): Sample index.\\n        '\n    box_preds = box_dict['boxes_3d']\n    scores = box_dict['scores_3d']\n    labels = box_dict['labels_3d']\n    sample_idx = info['image']['image_idx']\n    if len(box_preds) == 0:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)\n    rect = info['calib']['R0_rect'].astype(np.float32)\n    Trv2c = info['calib']['Tr_velo_to_cam'].astype(np.float32)\n    P2 = info['calib']['P2'].astype(np.float32)\n    img_shape = info['image']['image_shape']\n    P2 = box_preds.tensor.new_tensor(P2)\n    box_preds_camera = box_preds\n    box_preds_lidar = box_preds.convert_to(Box3DMode.LIDAR, np.linalg.inv(rect @ Trv2c))\n    box_corners = box_preds_camera.corners\n    box_corners_in_image = points_cam2img(box_corners, P2)\n    minxy = torch.min(box_corners_in_image, dim=1)[0]\n    maxxy = torch.max(box_corners_in_image, dim=1)[0]\n    box_2d_preds = torch.cat([minxy, maxxy], dim=1)\n    image_shape = box_preds.tensor.new_tensor(img_shape)\n    valid_cam_inds = (box_2d_preds[:, 0] < image_shape[1]) & (box_2d_preds[:, 1] < image_shape[0]) & (box_2d_preds[:, 2] > 0) & (box_2d_preds[:, 3] > 0)\n    valid_inds = valid_cam_inds\n    if valid_inds.sum() > 0:\n        return dict(bbox=box_2d_preds[valid_inds, :].numpy(), box3d_camera=box_preds_camera[valid_inds].tensor.numpy(), box3d_lidar=box_preds_lidar[valid_inds].tensor.numpy(), scores=scores[valid_inds].numpy(), label_preds=labels[valid_inds].numpy(), sample_idx=sample_idx)\n    else:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), box3d_lidar=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)",
            "def convert_valid_bboxes(self, box_dict, info):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Convert the predicted boxes into valid ones.\\n\\n        Args:\\n            box_dict (dict): Box dictionaries to be converted.\\n                - boxes_3d (:obj:`CameraInstance3DBoxes`): 3D bounding boxes.\\n                - scores_3d (torch.Tensor): Scores of boxes.\\n                - labels_3d (torch.Tensor): Class labels of boxes.\\n            info (dict): Data info.\\n\\n        Returns:\\n            dict: Valid predicted boxes.\\n                - bbox (np.ndarray): 2D bounding boxes.\\n                - box3d_camera (np.ndarray): 3D bounding boxes in\\n                    camera coordinate.\\n                - scores (np.ndarray): Scores of boxes.\\n                - label_preds (np.ndarray): Class label predictions.\\n                - sample_idx (int): Sample index.\\n        '\n    box_preds = box_dict['boxes_3d']\n    scores = box_dict['scores_3d']\n    labels = box_dict['labels_3d']\n    sample_idx = info['image']['image_idx']\n    if len(box_preds) == 0:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)\n    rect = info['calib']['R0_rect'].astype(np.float32)\n    Trv2c = info['calib']['Tr_velo_to_cam'].astype(np.float32)\n    P2 = info['calib']['P2'].astype(np.float32)\n    img_shape = info['image']['image_shape']\n    P2 = box_preds.tensor.new_tensor(P2)\n    box_preds_camera = box_preds\n    box_preds_lidar = box_preds.convert_to(Box3DMode.LIDAR, np.linalg.inv(rect @ Trv2c))\n    box_corners = box_preds_camera.corners\n    box_corners_in_image = points_cam2img(box_corners, P2)\n    minxy = torch.min(box_corners_in_image, dim=1)[0]\n    maxxy = torch.max(box_corners_in_image, dim=1)[0]\n    box_2d_preds = torch.cat([minxy, maxxy], dim=1)\n    image_shape = box_preds.tensor.new_tensor(img_shape)\n    valid_cam_inds = (box_2d_preds[:, 0] < image_shape[1]) & (box_2d_preds[:, 1] < image_shape[0]) & (box_2d_preds[:, 2] > 0) & (box_2d_preds[:, 3] > 0)\n    valid_inds = valid_cam_inds\n    if valid_inds.sum() > 0:\n        return dict(bbox=box_2d_preds[valid_inds, :].numpy(), box3d_camera=box_preds_camera[valid_inds].tensor.numpy(), box3d_lidar=box_preds_lidar[valid_inds].tensor.numpy(), scores=scores[valid_inds].numpy(), label_preds=labels[valid_inds].numpy(), sample_idx=sample_idx)\n    else:\n        return dict(bbox=np.zeros([0, 4]), box3d_camera=np.zeros([0, 7]), box3d_lidar=np.zeros([0, 7]), scores=np.zeros([0]), label_preds=np.zeros([0, 4]), sample_idx=sample_idx)"
        ]
    }
]