[
    {
        "func_name": "components",
        "original": "def components(f, x):\n    \"\"\"\n    Returns a set of all functional components of the given expression\n    which includes symbols, function applications and compositions and\n    non-integer powers. Fractional powers are collected with\n    minimal, positive exponents.\n\n    Examples\n    ========\n\n    >>> from sympy import cos, sin\n    >>> from sympy.abc import x\n    >>> from sympy.integrals.heurisch import components\n\n    >>> components(sin(x)*cos(x)**2, x)\n    {x, sin(x), cos(x)}\n\n    See Also\n    ========\n\n    heurisch\n    \"\"\"\n    result = set()\n    if f.has_free(x):\n        if f.is_symbol and f.is_commutative:\n            result.add(f)\n        elif f.is_Function or f.is_Derivative:\n            for g in f.args:\n                result |= components(g, x)\n            result.add(f)\n        elif f.is_Pow:\n            result |= components(f.base, x)\n            if not f.exp.is_Integer:\n                if f.exp.is_Rational:\n                    result.add(f.base ** Rational(1, f.exp.q))\n                else:\n                    result |= components(f.exp, x) | {f}\n        else:\n            for g in f.args:\n                result |= components(g, x)\n    return result",
        "mutated": [
            "def components(f, x):\n    if False:\n        i = 10\n    '\\n    Returns a set of all functional components of the given expression\\n    which includes symbols, function applications and compositions and\\n    non-integer powers. Fractional powers are collected with\\n    minimal, positive exponents.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import cos, sin\\n    >>> from sympy.abc import x\\n    >>> from sympy.integrals.heurisch import components\\n\\n    >>> components(sin(x)*cos(x)**2, x)\\n    {x, sin(x), cos(x)}\\n\\n    See Also\\n    ========\\n\\n    heurisch\\n    '\n    result = set()\n    if f.has_free(x):\n        if f.is_symbol and f.is_commutative:\n            result.add(f)\n        elif f.is_Function or f.is_Derivative:\n            for g in f.args:\n                result |= components(g, x)\n            result.add(f)\n        elif f.is_Pow:\n            result |= components(f.base, x)\n            if not f.exp.is_Integer:\n                if f.exp.is_Rational:\n                    result.add(f.base ** Rational(1, f.exp.q))\n                else:\n                    result |= components(f.exp, x) | {f}\n        else:\n            for g in f.args:\n                result |= components(g, x)\n    return result",
            "def components(f, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns a set of all functional components of the given expression\\n    which includes symbols, function applications and compositions and\\n    non-integer powers. Fractional powers are collected with\\n    minimal, positive exponents.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import cos, sin\\n    >>> from sympy.abc import x\\n    >>> from sympy.integrals.heurisch import components\\n\\n    >>> components(sin(x)*cos(x)**2, x)\\n    {x, sin(x), cos(x)}\\n\\n    See Also\\n    ========\\n\\n    heurisch\\n    '\n    result = set()\n    if f.has_free(x):\n        if f.is_symbol and f.is_commutative:\n            result.add(f)\n        elif f.is_Function or f.is_Derivative:\n            for g in f.args:\n                result |= components(g, x)\n            result.add(f)\n        elif f.is_Pow:\n            result |= components(f.base, x)\n            if not f.exp.is_Integer:\n                if f.exp.is_Rational:\n                    result.add(f.base ** Rational(1, f.exp.q))\n                else:\n                    result |= components(f.exp, x) | {f}\n        else:\n            for g in f.args:\n                result |= components(g, x)\n    return result",
            "def components(f, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns a set of all functional components of the given expression\\n    which includes symbols, function applications and compositions and\\n    non-integer powers. Fractional powers are collected with\\n    minimal, positive exponents.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import cos, sin\\n    >>> from sympy.abc import x\\n    >>> from sympy.integrals.heurisch import components\\n\\n    >>> components(sin(x)*cos(x)**2, x)\\n    {x, sin(x), cos(x)}\\n\\n    See Also\\n    ========\\n\\n    heurisch\\n    '\n    result = set()\n    if f.has_free(x):\n        if f.is_symbol and f.is_commutative:\n            result.add(f)\n        elif f.is_Function or f.is_Derivative:\n            for g in f.args:\n                result |= components(g, x)\n            result.add(f)\n        elif f.is_Pow:\n            result |= components(f.base, x)\n            if not f.exp.is_Integer:\n                if f.exp.is_Rational:\n                    result.add(f.base ** Rational(1, f.exp.q))\n                else:\n                    result |= components(f.exp, x) | {f}\n        else:\n            for g in f.args:\n                result |= components(g, x)\n    return result",
            "def components(f, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns a set of all functional components of the given expression\\n    which includes symbols, function applications and compositions and\\n    non-integer powers. Fractional powers are collected with\\n    minimal, positive exponents.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import cos, sin\\n    >>> from sympy.abc import x\\n    >>> from sympy.integrals.heurisch import components\\n\\n    >>> components(sin(x)*cos(x)**2, x)\\n    {x, sin(x), cos(x)}\\n\\n    See Also\\n    ========\\n\\n    heurisch\\n    '\n    result = set()\n    if f.has_free(x):\n        if f.is_symbol and f.is_commutative:\n            result.add(f)\n        elif f.is_Function or f.is_Derivative:\n            for g in f.args:\n                result |= components(g, x)\n            result.add(f)\n        elif f.is_Pow:\n            result |= components(f.base, x)\n            if not f.exp.is_Integer:\n                if f.exp.is_Rational:\n                    result.add(f.base ** Rational(1, f.exp.q))\n                else:\n                    result |= components(f.exp, x) | {f}\n        else:\n            for g in f.args:\n                result |= components(g, x)\n    return result",
            "def components(f, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns a set of all functional components of the given expression\\n    which includes symbols, function applications and compositions and\\n    non-integer powers. Fractional powers are collected with\\n    minimal, positive exponents.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import cos, sin\\n    >>> from sympy.abc import x\\n    >>> from sympy.integrals.heurisch import components\\n\\n    >>> components(sin(x)*cos(x)**2, x)\\n    {x, sin(x), cos(x)}\\n\\n    See Also\\n    ========\\n\\n    heurisch\\n    '\n    result = set()\n    if f.has_free(x):\n        if f.is_symbol and f.is_commutative:\n            result.add(f)\n        elif f.is_Function or f.is_Derivative:\n            for g in f.args:\n                result |= components(g, x)\n            result.add(f)\n        elif f.is_Pow:\n            result |= components(f.base, x)\n            if not f.exp.is_Integer:\n                if f.exp.is_Rational:\n                    result.add(f.base ** Rational(1, f.exp.q))\n                else:\n                    result |= components(f.exp, x) | {f}\n        else:\n            for g in f.args:\n                result |= components(g, x)\n    return result"
        ]
    },
    {
        "func_name": "_symbols",
        "original": "def _symbols(name, n):\n    \"\"\"get vector of symbols local to this module\"\"\"\n    try:\n        lsyms = _symbols_cache[name]\n    except KeyError:\n        lsyms = []\n        _symbols_cache[name] = lsyms\n    while len(lsyms) < n:\n        lsyms.append(Dummy('%s%i' % (name, len(lsyms))))\n    return lsyms[:n]",
        "mutated": [
            "def _symbols(name, n):\n    if False:\n        i = 10\n    'get vector of symbols local to this module'\n    try:\n        lsyms = _symbols_cache[name]\n    except KeyError:\n        lsyms = []\n        _symbols_cache[name] = lsyms\n    while len(lsyms) < n:\n        lsyms.append(Dummy('%s%i' % (name, len(lsyms))))\n    return lsyms[:n]",
            "def _symbols(name, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'get vector of symbols local to this module'\n    try:\n        lsyms = _symbols_cache[name]\n    except KeyError:\n        lsyms = []\n        _symbols_cache[name] = lsyms\n    while len(lsyms) < n:\n        lsyms.append(Dummy('%s%i' % (name, len(lsyms))))\n    return lsyms[:n]",
            "def _symbols(name, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'get vector of symbols local to this module'\n    try:\n        lsyms = _symbols_cache[name]\n    except KeyError:\n        lsyms = []\n        _symbols_cache[name] = lsyms\n    while len(lsyms) < n:\n        lsyms.append(Dummy('%s%i' % (name, len(lsyms))))\n    return lsyms[:n]",
            "def _symbols(name, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'get vector of symbols local to this module'\n    try:\n        lsyms = _symbols_cache[name]\n    except KeyError:\n        lsyms = []\n        _symbols_cache[name] = lsyms\n    while len(lsyms) < n:\n        lsyms.append(Dummy('%s%i' % (name, len(lsyms))))\n    return lsyms[:n]",
            "def _symbols(name, n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'get vector of symbols local to this module'\n    try:\n        lsyms = _symbols_cache[name]\n    except KeyError:\n        lsyms = []\n        _symbols_cache[name] = lsyms\n    while len(lsyms) < n:\n        lsyms.append(Dummy('%s%i' % (name, len(lsyms))))\n    return lsyms[:n]"
        ]
    },
    {
        "func_name": "heurisch_wrapper",
        "original": "def heurisch_wrapper(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    \"\"\"\n    A wrapper around the heurisch integration algorithm.\n\n    Explanation\n    ===========\n\n    This method takes the result from heurisch and checks for poles in the\n    denominator. For each of these poles, the integral is reevaluated, and\n    the final integration result is given in terms of a Piecewise.\n\n    Examples\n    ========\n\n    >>> from sympy import cos, symbols\n    >>> from sympy.integrals.heurisch import heurisch, heurisch_wrapper\n    >>> n, x = symbols('n x')\n    >>> heurisch(cos(n*x), x)\n    sin(n*x)/n\n    >>> heurisch_wrapper(cos(n*x), x)\n    Piecewise((sin(n*x)/n, Ne(n, 0)), (x, True))\n\n    See Also\n    ========\n\n    heurisch\n    \"\"\"\n    from sympy.solvers.solvers import solve, denoms\n    f = sympify(f)\n    if not f.has_free(x):\n        return f * x\n    res = heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n    if not isinstance(res, Basic):\n        return res\n    slns = []\n    for d in ordered(denoms(res)):\n        try:\n            slns += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    if not slns:\n        return res\n    slns = list(uniq(slns))\n    slns0 = []\n    for d in denoms(f):\n        try:\n            slns0 += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    slns = [s for s in slns if s not in slns0]\n    if not slns:\n        return res\n    if len(slns) > 1:\n        eqs = []\n        for sub_dict in slns:\n            eqs.extend([Eq(key, value) for (key, value) in sub_dict.items()])\n        slns = solve(eqs, dict=True, exclude=(x,)) + slns\n    pairs = []\n    for sub_dict in slns:\n        expr = heurisch(f.subs(sub_dict), x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n        cond = And(*[Eq(key, value) for (key, value) in sub_dict.items()])\n        generic = Or(*[Ne(key, value) for (key, value) in sub_dict.items()])\n        if expr is None:\n            expr = integrate(f.subs(sub_dict), x)\n        pairs.append((expr, cond))\n    if len(pairs) == 1:\n        pairs = [(heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), generic), (pairs[0][0], True)]\n    else:\n        pairs.append((heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), True))\n    return Piecewise(*pairs)",
        "mutated": [
            "def heurisch_wrapper(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    if False:\n        i = 10\n    \"\\n    A wrapper around the heurisch integration algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    This method takes the result from heurisch and checks for poles in the\\n    denominator. For each of these poles, the integral is reevaluated, and\\n    the final integration result is given in terms of a Piecewise.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import cos, symbols\\n    >>> from sympy.integrals.heurisch import heurisch, heurisch_wrapper\\n    >>> n, x = symbols('n x')\\n    >>> heurisch(cos(n*x), x)\\n    sin(n*x)/n\\n    >>> heurisch_wrapper(cos(n*x), x)\\n    Piecewise((sin(n*x)/n, Ne(n, 0)), (x, True))\\n\\n    See Also\\n    ========\\n\\n    heurisch\\n    \"\n    from sympy.solvers.solvers import solve, denoms\n    f = sympify(f)\n    if not f.has_free(x):\n        return f * x\n    res = heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n    if not isinstance(res, Basic):\n        return res\n    slns = []\n    for d in ordered(denoms(res)):\n        try:\n            slns += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    if not slns:\n        return res\n    slns = list(uniq(slns))\n    slns0 = []\n    for d in denoms(f):\n        try:\n            slns0 += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    slns = [s for s in slns if s not in slns0]\n    if not slns:\n        return res\n    if len(slns) > 1:\n        eqs = []\n        for sub_dict in slns:\n            eqs.extend([Eq(key, value) for (key, value) in sub_dict.items()])\n        slns = solve(eqs, dict=True, exclude=(x,)) + slns\n    pairs = []\n    for sub_dict in slns:\n        expr = heurisch(f.subs(sub_dict), x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n        cond = And(*[Eq(key, value) for (key, value) in sub_dict.items()])\n        generic = Or(*[Ne(key, value) for (key, value) in sub_dict.items()])\n        if expr is None:\n            expr = integrate(f.subs(sub_dict), x)\n        pairs.append((expr, cond))\n    if len(pairs) == 1:\n        pairs = [(heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), generic), (pairs[0][0], True)]\n    else:\n        pairs.append((heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), True))\n    return Piecewise(*pairs)",
            "def heurisch_wrapper(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    A wrapper around the heurisch integration algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    This method takes the result from heurisch and checks for poles in the\\n    denominator. For each of these poles, the integral is reevaluated, and\\n    the final integration result is given in terms of a Piecewise.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import cos, symbols\\n    >>> from sympy.integrals.heurisch import heurisch, heurisch_wrapper\\n    >>> n, x = symbols('n x')\\n    >>> heurisch(cos(n*x), x)\\n    sin(n*x)/n\\n    >>> heurisch_wrapper(cos(n*x), x)\\n    Piecewise((sin(n*x)/n, Ne(n, 0)), (x, True))\\n\\n    See Also\\n    ========\\n\\n    heurisch\\n    \"\n    from sympy.solvers.solvers import solve, denoms\n    f = sympify(f)\n    if not f.has_free(x):\n        return f * x\n    res = heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n    if not isinstance(res, Basic):\n        return res\n    slns = []\n    for d in ordered(denoms(res)):\n        try:\n            slns += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    if not slns:\n        return res\n    slns = list(uniq(slns))\n    slns0 = []\n    for d in denoms(f):\n        try:\n            slns0 += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    slns = [s for s in slns if s not in slns0]\n    if not slns:\n        return res\n    if len(slns) > 1:\n        eqs = []\n        for sub_dict in slns:\n            eqs.extend([Eq(key, value) for (key, value) in sub_dict.items()])\n        slns = solve(eqs, dict=True, exclude=(x,)) + slns\n    pairs = []\n    for sub_dict in slns:\n        expr = heurisch(f.subs(sub_dict), x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n        cond = And(*[Eq(key, value) for (key, value) in sub_dict.items()])\n        generic = Or(*[Ne(key, value) for (key, value) in sub_dict.items()])\n        if expr is None:\n            expr = integrate(f.subs(sub_dict), x)\n        pairs.append((expr, cond))\n    if len(pairs) == 1:\n        pairs = [(heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), generic), (pairs[0][0], True)]\n    else:\n        pairs.append((heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), True))\n    return Piecewise(*pairs)",
            "def heurisch_wrapper(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    A wrapper around the heurisch integration algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    This method takes the result from heurisch and checks for poles in the\\n    denominator. For each of these poles, the integral is reevaluated, and\\n    the final integration result is given in terms of a Piecewise.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import cos, symbols\\n    >>> from sympy.integrals.heurisch import heurisch, heurisch_wrapper\\n    >>> n, x = symbols('n x')\\n    >>> heurisch(cos(n*x), x)\\n    sin(n*x)/n\\n    >>> heurisch_wrapper(cos(n*x), x)\\n    Piecewise((sin(n*x)/n, Ne(n, 0)), (x, True))\\n\\n    See Also\\n    ========\\n\\n    heurisch\\n    \"\n    from sympy.solvers.solvers import solve, denoms\n    f = sympify(f)\n    if not f.has_free(x):\n        return f * x\n    res = heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n    if not isinstance(res, Basic):\n        return res\n    slns = []\n    for d in ordered(denoms(res)):\n        try:\n            slns += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    if not slns:\n        return res\n    slns = list(uniq(slns))\n    slns0 = []\n    for d in denoms(f):\n        try:\n            slns0 += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    slns = [s for s in slns if s not in slns0]\n    if not slns:\n        return res\n    if len(slns) > 1:\n        eqs = []\n        for sub_dict in slns:\n            eqs.extend([Eq(key, value) for (key, value) in sub_dict.items()])\n        slns = solve(eqs, dict=True, exclude=(x,)) + slns\n    pairs = []\n    for sub_dict in slns:\n        expr = heurisch(f.subs(sub_dict), x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n        cond = And(*[Eq(key, value) for (key, value) in sub_dict.items()])\n        generic = Or(*[Ne(key, value) for (key, value) in sub_dict.items()])\n        if expr is None:\n            expr = integrate(f.subs(sub_dict), x)\n        pairs.append((expr, cond))\n    if len(pairs) == 1:\n        pairs = [(heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), generic), (pairs[0][0], True)]\n    else:\n        pairs.append((heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), True))\n    return Piecewise(*pairs)",
            "def heurisch_wrapper(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    A wrapper around the heurisch integration algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    This method takes the result from heurisch and checks for poles in the\\n    denominator. For each of these poles, the integral is reevaluated, and\\n    the final integration result is given in terms of a Piecewise.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import cos, symbols\\n    >>> from sympy.integrals.heurisch import heurisch, heurisch_wrapper\\n    >>> n, x = symbols('n x')\\n    >>> heurisch(cos(n*x), x)\\n    sin(n*x)/n\\n    >>> heurisch_wrapper(cos(n*x), x)\\n    Piecewise((sin(n*x)/n, Ne(n, 0)), (x, True))\\n\\n    See Also\\n    ========\\n\\n    heurisch\\n    \"\n    from sympy.solvers.solvers import solve, denoms\n    f = sympify(f)\n    if not f.has_free(x):\n        return f * x\n    res = heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n    if not isinstance(res, Basic):\n        return res\n    slns = []\n    for d in ordered(denoms(res)):\n        try:\n            slns += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    if not slns:\n        return res\n    slns = list(uniq(slns))\n    slns0 = []\n    for d in denoms(f):\n        try:\n            slns0 += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    slns = [s for s in slns if s not in slns0]\n    if not slns:\n        return res\n    if len(slns) > 1:\n        eqs = []\n        for sub_dict in slns:\n            eqs.extend([Eq(key, value) for (key, value) in sub_dict.items()])\n        slns = solve(eqs, dict=True, exclude=(x,)) + slns\n    pairs = []\n    for sub_dict in slns:\n        expr = heurisch(f.subs(sub_dict), x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n        cond = And(*[Eq(key, value) for (key, value) in sub_dict.items()])\n        generic = Or(*[Ne(key, value) for (key, value) in sub_dict.items()])\n        if expr is None:\n            expr = integrate(f.subs(sub_dict), x)\n        pairs.append((expr, cond))\n    if len(pairs) == 1:\n        pairs = [(heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), generic), (pairs[0][0], True)]\n    else:\n        pairs.append((heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), True))\n    return Piecewise(*pairs)",
            "def heurisch_wrapper(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    A wrapper around the heurisch integration algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    This method takes the result from heurisch and checks for poles in the\\n    denominator. For each of these poles, the integral is reevaluated, and\\n    the final integration result is given in terms of a Piecewise.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import cos, symbols\\n    >>> from sympy.integrals.heurisch import heurisch, heurisch_wrapper\\n    >>> n, x = symbols('n x')\\n    >>> heurisch(cos(n*x), x)\\n    sin(n*x)/n\\n    >>> heurisch_wrapper(cos(n*x), x)\\n    Piecewise((sin(n*x)/n, Ne(n, 0)), (x, True))\\n\\n    See Also\\n    ========\\n\\n    heurisch\\n    \"\n    from sympy.solvers.solvers import solve, denoms\n    f = sympify(f)\n    if not f.has_free(x):\n        return f * x\n    res = heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n    if not isinstance(res, Basic):\n        return res\n    slns = []\n    for d in ordered(denoms(res)):\n        try:\n            slns += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    if not slns:\n        return res\n    slns = list(uniq(slns))\n    slns0 = []\n    for d in denoms(f):\n        try:\n            slns0 += solve([d], dict=True, exclude=(x,))\n        except NotImplementedError:\n            pass\n    slns = [s for s in slns if s not in slns0]\n    if not slns:\n        return res\n    if len(slns) > 1:\n        eqs = []\n        for sub_dict in slns:\n            eqs.extend([Eq(key, value) for (key, value) in sub_dict.items()])\n        slns = solve(eqs, dict=True, exclude=(x,)) + slns\n    pairs = []\n    for sub_dict in slns:\n        expr = heurisch(f.subs(sub_dict), x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch)\n        cond = And(*[Eq(key, value) for (key, value) in sub_dict.items()])\n        generic = Or(*[Ne(key, value) for (key, value) in sub_dict.items()])\n        if expr is None:\n            expr = integrate(f.subs(sub_dict), x)\n        pairs.append((expr, cond))\n    if len(pairs) == 1:\n        pairs = [(heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), generic), (pairs[0][0], True)]\n    else:\n        pairs.append((heurisch(f, x, rewrite, hints, mappings, retries, degree_offset, unnecessary_permutations, _try_heurisch), True))\n    return Piecewise(*pairs)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self.table = {}\n    self.n = Dummy('n')\n    self.z = Dummy('z')\n    self._create_table()",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self.table = {}\n    self.n = Dummy('n')\n    self.z = Dummy('z')\n    self._create_table()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.table = {}\n    self.n = Dummy('n')\n    self.z = Dummy('z')\n    self._create_table()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.table = {}\n    self.n = Dummy('n')\n    self.z = Dummy('z')\n    self._create_table()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.table = {}\n    self.n = Dummy('n')\n    self.z = Dummy('z')\n    self._create_table()",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.table = {}\n    self.n = Dummy('n')\n    self.z = Dummy('z')\n    self._create_table()"
        ]
    },
    {
        "func_name": "_create_table",
        "original": "def _create_table(t):\n    (table, n, z) = (t.table, t.n, t.z)\n    for f in (besselj, bessely, hankel1, hankel2):\n        table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    f = besseli\n    table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z + f(n, z))\n    f = besselk\n    table[f] = (-f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    for f in (jn, yn):\n        table[f] = (f(n - 1, z) - (n + 1) * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))",
        "mutated": [
            "def _create_table(t):\n    if False:\n        i = 10\n    (table, n, z) = (t.table, t.n, t.z)\n    for f in (besselj, bessely, hankel1, hankel2):\n        table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    f = besseli\n    table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z + f(n, z))\n    f = besselk\n    table[f] = (-f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    for f in (jn, yn):\n        table[f] = (f(n - 1, z) - (n + 1) * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))",
            "def _create_table(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (table, n, z) = (t.table, t.n, t.z)\n    for f in (besselj, bessely, hankel1, hankel2):\n        table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    f = besseli\n    table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z + f(n, z))\n    f = besselk\n    table[f] = (-f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    for f in (jn, yn):\n        table[f] = (f(n - 1, z) - (n + 1) * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))",
            "def _create_table(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (table, n, z) = (t.table, t.n, t.z)\n    for f in (besselj, bessely, hankel1, hankel2):\n        table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    f = besseli\n    table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z + f(n, z))\n    f = besselk\n    table[f] = (-f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    for f in (jn, yn):\n        table[f] = (f(n - 1, z) - (n + 1) * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))",
            "def _create_table(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (table, n, z) = (t.table, t.n, t.z)\n    for f in (besselj, bessely, hankel1, hankel2):\n        table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    f = besseli\n    table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z + f(n, z))\n    f = besselk\n    table[f] = (-f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    for f in (jn, yn):\n        table[f] = (f(n - 1, z) - (n + 1) * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))",
            "def _create_table(t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (table, n, z) = (t.table, t.n, t.z)\n    for f in (besselj, bessely, hankel1, hankel2):\n        table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    f = besseli\n    table[f] = (f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z + f(n, z))\n    f = besselk\n    table[f] = (-f(n - 1, z) - n * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))\n    for f in (jn, yn):\n        table[f] = (f(n - 1, z) - (n + 1) * f(n, z) / z, (n - 1) * f(n - 1, z) / z - f(n, z))"
        ]
    },
    {
        "func_name": "diffs",
        "original": "def diffs(t, f, n, z):\n    if f in t.table:\n        (diff0, diff1) = t.table[f]\n        repl = [(t.n, n), (t.z, z)]\n        return (diff0.subs(repl), diff1.subs(repl))",
        "mutated": [
            "def diffs(t, f, n, z):\n    if False:\n        i = 10\n    if f in t.table:\n        (diff0, diff1) = t.table[f]\n        repl = [(t.n, n), (t.z, z)]\n        return (diff0.subs(repl), diff1.subs(repl))",
            "def diffs(t, f, n, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if f in t.table:\n        (diff0, diff1) = t.table[f]\n        repl = [(t.n, n), (t.z, z)]\n        return (diff0.subs(repl), diff1.subs(repl))",
            "def diffs(t, f, n, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if f in t.table:\n        (diff0, diff1) = t.table[f]\n        repl = [(t.n, n), (t.z, z)]\n        return (diff0.subs(repl), diff1.subs(repl))",
            "def diffs(t, f, n, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if f in t.table:\n        (diff0, diff1) = t.table[f]\n        repl = [(t.n, n), (t.z, z)]\n        return (diff0.subs(repl), diff1.subs(repl))",
            "def diffs(t, f, n, z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if f in t.table:\n        (diff0, diff1) = t.table[f]\n        repl = [(t.n, n), (t.z, z)]\n        return (diff0.subs(repl), diff1.subs(repl))"
        ]
    },
    {
        "func_name": "has",
        "original": "def has(t, f):\n    return f in t.table",
        "mutated": [
            "def has(t, f):\n    if False:\n        i = 10\n    return f in t.table",
            "def has(t, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return f in t.table",
            "def has(t, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return f in t.table",
            "def has(t, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return f in t.table",
            "def has(t, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return f in t.table"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, x):\n    self.cache = {}\n    self.x = x\n    global _bessel_table\n    if not _bessel_table:\n        _bessel_table = BesselTable()",
        "mutated": [
            "def __init__(self, x):\n    if False:\n        i = 10\n    self.cache = {}\n    self.x = x\n    global _bessel_table\n    if not _bessel_table:\n        _bessel_table = BesselTable()",
            "def __init__(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.cache = {}\n    self.x = x\n    global _bessel_table\n    if not _bessel_table:\n        _bessel_table = BesselTable()",
            "def __init__(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.cache = {}\n    self.x = x\n    global _bessel_table\n    if not _bessel_table:\n        _bessel_table = BesselTable()",
            "def __init__(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.cache = {}\n    self.x = x\n    global _bessel_table\n    if not _bessel_table:\n        _bessel_table = BesselTable()",
            "def __init__(self, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.cache = {}\n    self.x = x\n    global _bessel_table\n    if not _bessel_table:\n        _bessel_table = BesselTable()"
        ]
    },
    {
        "func_name": "get_diff",
        "original": "def get_diff(self, f):\n    cache = self.cache\n    if f in cache:\n        pass\n    elif not hasattr(f, 'func') or not _bessel_table.has(f.func):\n        cache[f] = cancel(f.diff(self.x))\n    else:\n        (n, z) = f.args\n        (d0, d1) = _bessel_table.diffs(f.func, n, z)\n        dz = self.get_diff(z)\n        cache[f] = d0 * dz\n        cache[f.func(n - 1, z)] = d1 * dz\n    return cache[f]",
        "mutated": [
            "def get_diff(self, f):\n    if False:\n        i = 10\n    cache = self.cache\n    if f in cache:\n        pass\n    elif not hasattr(f, 'func') or not _bessel_table.has(f.func):\n        cache[f] = cancel(f.diff(self.x))\n    else:\n        (n, z) = f.args\n        (d0, d1) = _bessel_table.diffs(f.func, n, z)\n        dz = self.get_diff(z)\n        cache[f] = d0 * dz\n        cache[f.func(n - 1, z)] = d1 * dz\n    return cache[f]",
            "def get_diff(self, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    cache = self.cache\n    if f in cache:\n        pass\n    elif not hasattr(f, 'func') or not _bessel_table.has(f.func):\n        cache[f] = cancel(f.diff(self.x))\n    else:\n        (n, z) = f.args\n        (d0, d1) = _bessel_table.diffs(f.func, n, z)\n        dz = self.get_diff(z)\n        cache[f] = d0 * dz\n        cache[f.func(n - 1, z)] = d1 * dz\n    return cache[f]",
            "def get_diff(self, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    cache = self.cache\n    if f in cache:\n        pass\n    elif not hasattr(f, 'func') or not _bessel_table.has(f.func):\n        cache[f] = cancel(f.diff(self.x))\n    else:\n        (n, z) = f.args\n        (d0, d1) = _bessel_table.diffs(f.func, n, z)\n        dz = self.get_diff(z)\n        cache[f] = d0 * dz\n        cache[f.func(n - 1, z)] = d1 * dz\n    return cache[f]",
            "def get_diff(self, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    cache = self.cache\n    if f in cache:\n        pass\n    elif not hasattr(f, 'func') or not _bessel_table.has(f.func):\n        cache[f] = cancel(f.diff(self.x))\n    else:\n        (n, z) = f.args\n        (d0, d1) = _bessel_table.diffs(f.func, n, z)\n        dz = self.get_diff(z)\n        cache[f] = d0 * dz\n        cache[f.func(n - 1, z)] = d1 * dz\n    return cache[f]",
            "def get_diff(self, f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    cache = self.cache\n    if f in cache:\n        pass\n    elif not hasattr(f, 'func') or not _bessel_table.has(f.func):\n        cache[f] = cancel(f.diff(self.x))\n    else:\n        (n, z) = f.args\n        (d0, d1) = _bessel_table.diffs(f.func, n, z)\n        dz = self.get_diff(z)\n        cache[f] = d0 * dz\n        cache[f.func(n - 1, z)] = d1 * dz\n    return cache[f]"
        ]
    },
    {
        "func_name": "_substitute",
        "original": "def _substitute(expr):\n    return expr.subs(mapping)",
        "mutated": [
            "def _substitute(expr):\n    if False:\n        i = 10\n    return expr.subs(mapping)",
            "def _substitute(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return expr.subs(mapping)",
            "def _substitute(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return expr.subs(mapping)",
            "def _substitute(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return expr.subs(mapping)",
            "def _substitute(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return expr.subs(mapping)"
        ]
    },
    {
        "func_name": "_derivation",
        "original": "def _derivation(h):\n    return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])",
        "mutated": [
            "def _derivation(h):\n    if False:\n        i = 10\n    return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])",
            "def _derivation(h):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])",
            "def _derivation(h):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])",
            "def _derivation(h):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])",
            "def _derivation(h):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])"
        ]
    },
    {
        "func_name": "_deflation",
        "original": "def _deflation(p):\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(p) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n    return p",
        "mutated": [
            "def _deflation(p):\n    if False:\n        i = 10\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(p) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n    return p",
            "def _deflation(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(p) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n    return p",
            "def _deflation(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(p) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n    return p",
            "def _deflation(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(p) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n    return p",
            "def _deflation(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(p) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n    return p"
        ]
    },
    {
        "func_name": "_splitter",
        "original": "def _splitter(p):\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(y) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            q = q.as_expr()\n            h = gcd(q, _derivation(q), y)\n            s = quo(h, gcd(q, q.diff(y), y), y)\n            c_split = _splitter(c)\n            if s.as_poly(y).degree() == 0:\n                return (c_split[0], q * c_split[1])\n            q_split = _splitter(cancel(q / s))\n            return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n    return (S.One, p)",
        "mutated": [
            "def _splitter(p):\n    if False:\n        i = 10\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(y) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            q = q.as_expr()\n            h = gcd(q, _derivation(q), y)\n            s = quo(h, gcd(q, q.diff(y), y), y)\n            c_split = _splitter(c)\n            if s.as_poly(y).degree() == 0:\n                return (c_split[0], q * c_split[1])\n            q_split = _splitter(cancel(q / s))\n            return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n    return (S.One, p)",
            "def _splitter(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(y) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            q = q.as_expr()\n            h = gcd(q, _derivation(q), y)\n            s = quo(h, gcd(q, q.diff(y), y), y)\n            c_split = _splitter(c)\n            if s.as_poly(y).degree() == 0:\n                return (c_split[0], q * c_split[1])\n            q_split = _splitter(cancel(q / s))\n            return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n    return (S.One, p)",
            "def _splitter(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(y) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            q = q.as_expr()\n            h = gcd(q, _derivation(q), y)\n            s = quo(h, gcd(q, q.diff(y), y), y)\n            c_split = _splitter(c)\n            if s.as_poly(y).degree() == 0:\n                return (c_split[0], q * c_split[1])\n            q_split = _splitter(cancel(q / s))\n            return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n    return (S.One, p)",
            "def _splitter(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(y) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            q = q.as_expr()\n            h = gcd(q, _derivation(q), y)\n            s = quo(h, gcd(q, q.diff(y), y), y)\n            c_split = _splitter(c)\n            if s.as_poly(y).degree() == 0:\n                return (c_split[0], q * c_split[1])\n            q_split = _splitter(cancel(q / s))\n            return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n    return (S.One, p)",
            "def _splitter(p):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    for y in V:\n        if not p.has(y):\n            continue\n        if _derivation(y) is not S.Zero:\n            (c, q) = p.as_poly(y).primitive()\n            q = q.as_expr()\n            h = gcd(q, _derivation(q), y)\n            s = quo(h, gcd(q, q.diff(y), y), y)\n            c_split = _splitter(c)\n            if s.as_poly(y).degree() == 0:\n                return (c_split[0], q * c_split[1])\n            q_split = _splitter(cancel(q / s))\n            return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n    return (S.One, p)"
        ]
    },
    {
        "func_name": "_exponent",
        "original": "def _exponent(g):\n    if g.is_Pow:\n        if g.exp.is_Rational and g.exp.q != 1:\n            if g.exp.p > 0:\n                return g.exp.p + g.exp.q - 1\n            else:\n                return abs(g.exp.p + g.exp.q)\n        else:\n            return 1\n    elif not g.is_Atom and g.args:\n        return max([_exponent(h) for h in g.args])\n    else:\n        return 1",
        "mutated": [
            "def _exponent(g):\n    if False:\n        i = 10\n    if g.is_Pow:\n        if g.exp.is_Rational and g.exp.q != 1:\n            if g.exp.p > 0:\n                return g.exp.p + g.exp.q - 1\n            else:\n                return abs(g.exp.p + g.exp.q)\n        else:\n            return 1\n    elif not g.is_Atom and g.args:\n        return max([_exponent(h) for h in g.args])\n    else:\n        return 1",
            "def _exponent(g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if g.is_Pow:\n        if g.exp.is_Rational and g.exp.q != 1:\n            if g.exp.p > 0:\n                return g.exp.p + g.exp.q - 1\n            else:\n                return abs(g.exp.p + g.exp.q)\n        else:\n            return 1\n    elif not g.is_Atom and g.args:\n        return max([_exponent(h) for h in g.args])\n    else:\n        return 1",
            "def _exponent(g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if g.is_Pow:\n        if g.exp.is_Rational and g.exp.q != 1:\n            if g.exp.p > 0:\n                return g.exp.p + g.exp.q - 1\n            else:\n                return abs(g.exp.p + g.exp.q)\n        else:\n            return 1\n    elif not g.is_Atom and g.args:\n        return max([_exponent(h) for h in g.args])\n    else:\n        return 1",
            "def _exponent(g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if g.is_Pow:\n        if g.exp.is_Rational and g.exp.q != 1:\n            if g.exp.p > 0:\n                return g.exp.p + g.exp.q - 1\n            else:\n                return abs(g.exp.p + g.exp.q)\n        else:\n            return 1\n    elif not g.is_Atom and g.args:\n        return max([_exponent(h) for h in g.args])\n    else:\n        return 1",
            "def _exponent(g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if g.is_Pow:\n        if g.exp.is_Rational and g.exp.q != 1:\n            if g.exp.p > 0:\n                return g.exp.p + g.exp.q - 1\n            else:\n                return abs(g.exp.p + g.exp.q)\n        else:\n            return 1\n    elif not g.is_Atom and g.args:\n        return max([_exponent(h) for h in g.args])\n    else:\n        return 1"
        ]
    },
    {
        "func_name": "find_non_syms",
        "original": "def find_non_syms(expr):\n    if expr.is_Integer or expr.is_Rational:\n        pass\n    elif expr in syms:\n        pass\n    elif not expr.has_free(*syms):\n        non_syms.add(expr)\n    elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n        list(map(find_non_syms, expr.args))\n    else:\n        raise PolynomialError",
        "mutated": [
            "def find_non_syms(expr):\n    if False:\n        i = 10\n    if expr.is_Integer or expr.is_Rational:\n        pass\n    elif expr in syms:\n        pass\n    elif not expr.has_free(*syms):\n        non_syms.add(expr)\n    elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n        list(map(find_non_syms, expr.args))\n    else:\n        raise PolynomialError",
            "def find_non_syms(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if expr.is_Integer or expr.is_Rational:\n        pass\n    elif expr in syms:\n        pass\n    elif not expr.has_free(*syms):\n        non_syms.add(expr)\n    elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n        list(map(find_non_syms, expr.args))\n    else:\n        raise PolynomialError",
            "def find_non_syms(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if expr.is_Integer or expr.is_Rational:\n        pass\n    elif expr in syms:\n        pass\n    elif not expr.has_free(*syms):\n        non_syms.add(expr)\n    elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n        list(map(find_non_syms, expr.args))\n    else:\n        raise PolynomialError",
            "def find_non_syms(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if expr.is_Integer or expr.is_Rational:\n        pass\n    elif expr in syms:\n        pass\n    elif not expr.has_free(*syms):\n        non_syms.add(expr)\n    elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n        list(map(find_non_syms, expr.args))\n    else:\n        raise PolynomialError",
            "def find_non_syms(expr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if expr.is_Integer or expr.is_Rational:\n        pass\n    elif expr in syms:\n        pass\n    elif not expr.has_free(*syms):\n        non_syms.add(expr)\n    elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n        list(map(find_non_syms, expr.args))\n    else:\n        raise PolynomialError"
        ]
    },
    {
        "func_name": "_integrate",
        "original": "def _integrate(field=None):\n    atans = set()\n    pairs = set()\n    if field == 'Q':\n        irreducibles = set(reducibles)\n    else:\n        setV = set(V)\n        irreducibles = set()\n        for poly in ordered(reducibles):\n            zV = setV & set(iterfreeargs(poly))\n            for z in ordered(zV):\n                s = set(root_factors(poly, z, filter=field))\n                irreducibles |= s\n                break\n    (log_part, atan_part) = ([], [])\n    for poly in ordered(irreducibles):\n        m = collect(poly, I, evaluate=False)\n        y = m.get(I, S.Zero)\n        if y:\n            x = m.get(S.One, S.Zero)\n            if x.has(I) or y.has(I):\n                continue\n            pairs.add((x, y))\n            irreducibles.remove(poly)\n    while pairs:\n        (x, y) = pairs.pop()\n        if (x, -y) in pairs:\n            pairs.remove((x, -y))\n            if y.could_extract_minus_sign():\n                y = -y\n            irreducibles.add(x * x + y * y)\n            atans.add(atan(x / y))\n        else:\n            irreducibles.add(x + I * y)\n    B = _symbols('B', len(irreducibles))\n    C = _symbols('C', len(atans))\n    for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n        if poly.has(*V):\n            poly_coeffs.append(b)\n            log_part.append(b * log(poly))\n    for (poly, c) in reversed(list(zip(ordered(atans), C))):\n        if poly.has(*V):\n            poly_coeffs.append(c)\n            atan_part.append(c * poly)\n    candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n    h = F - _derivation(candidate) / denom\n    raw_numer = h.as_numer_denom()[0]\n    syms = set(poly_coeffs) | set(V)\n    non_syms = set()\n\n    def find_non_syms(expr):\n        if expr.is_Integer or expr.is_Rational:\n            pass\n        elif expr in syms:\n            pass\n        elif not expr.has_free(*syms):\n            non_syms.add(expr)\n        elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n            list(map(find_non_syms, expr.args))\n        else:\n            raise PolynomialError\n    try:\n        find_non_syms(raw_numer)\n    except PolynomialError:\n        return None\n    else:\n        (ground, _) = construct_domain(non_syms, field=True)\n    coeff_ring = PolyRing(poly_coeffs, ground)\n    ring = PolyRing(V, coeff_ring)\n    try:\n        numer = ring.from_expr(raw_numer)\n    except ValueError:\n        raise PolynomialError\n    solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n    if solution is None:\n        return None\n    else:\n        return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))",
        "mutated": [
            "def _integrate(field=None):\n    if False:\n        i = 10\n    atans = set()\n    pairs = set()\n    if field == 'Q':\n        irreducibles = set(reducibles)\n    else:\n        setV = set(V)\n        irreducibles = set()\n        for poly in ordered(reducibles):\n            zV = setV & set(iterfreeargs(poly))\n            for z in ordered(zV):\n                s = set(root_factors(poly, z, filter=field))\n                irreducibles |= s\n                break\n    (log_part, atan_part) = ([], [])\n    for poly in ordered(irreducibles):\n        m = collect(poly, I, evaluate=False)\n        y = m.get(I, S.Zero)\n        if y:\n            x = m.get(S.One, S.Zero)\n            if x.has(I) or y.has(I):\n                continue\n            pairs.add((x, y))\n            irreducibles.remove(poly)\n    while pairs:\n        (x, y) = pairs.pop()\n        if (x, -y) in pairs:\n            pairs.remove((x, -y))\n            if y.could_extract_minus_sign():\n                y = -y\n            irreducibles.add(x * x + y * y)\n            atans.add(atan(x / y))\n        else:\n            irreducibles.add(x + I * y)\n    B = _symbols('B', len(irreducibles))\n    C = _symbols('C', len(atans))\n    for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n        if poly.has(*V):\n            poly_coeffs.append(b)\n            log_part.append(b * log(poly))\n    for (poly, c) in reversed(list(zip(ordered(atans), C))):\n        if poly.has(*V):\n            poly_coeffs.append(c)\n            atan_part.append(c * poly)\n    candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n    h = F - _derivation(candidate) / denom\n    raw_numer = h.as_numer_denom()[0]\n    syms = set(poly_coeffs) | set(V)\n    non_syms = set()\n\n    def find_non_syms(expr):\n        if expr.is_Integer or expr.is_Rational:\n            pass\n        elif expr in syms:\n            pass\n        elif not expr.has_free(*syms):\n            non_syms.add(expr)\n        elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n            list(map(find_non_syms, expr.args))\n        else:\n            raise PolynomialError\n    try:\n        find_non_syms(raw_numer)\n    except PolynomialError:\n        return None\n    else:\n        (ground, _) = construct_domain(non_syms, field=True)\n    coeff_ring = PolyRing(poly_coeffs, ground)\n    ring = PolyRing(V, coeff_ring)\n    try:\n        numer = ring.from_expr(raw_numer)\n    except ValueError:\n        raise PolynomialError\n    solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n    if solution is None:\n        return None\n    else:\n        return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))",
            "def _integrate(field=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    atans = set()\n    pairs = set()\n    if field == 'Q':\n        irreducibles = set(reducibles)\n    else:\n        setV = set(V)\n        irreducibles = set()\n        for poly in ordered(reducibles):\n            zV = setV & set(iterfreeargs(poly))\n            for z in ordered(zV):\n                s = set(root_factors(poly, z, filter=field))\n                irreducibles |= s\n                break\n    (log_part, atan_part) = ([], [])\n    for poly in ordered(irreducibles):\n        m = collect(poly, I, evaluate=False)\n        y = m.get(I, S.Zero)\n        if y:\n            x = m.get(S.One, S.Zero)\n            if x.has(I) or y.has(I):\n                continue\n            pairs.add((x, y))\n            irreducibles.remove(poly)\n    while pairs:\n        (x, y) = pairs.pop()\n        if (x, -y) in pairs:\n            pairs.remove((x, -y))\n            if y.could_extract_minus_sign():\n                y = -y\n            irreducibles.add(x * x + y * y)\n            atans.add(atan(x / y))\n        else:\n            irreducibles.add(x + I * y)\n    B = _symbols('B', len(irreducibles))\n    C = _symbols('C', len(atans))\n    for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n        if poly.has(*V):\n            poly_coeffs.append(b)\n            log_part.append(b * log(poly))\n    for (poly, c) in reversed(list(zip(ordered(atans), C))):\n        if poly.has(*V):\n            poly_coeffs.append(c)\n            atan_part.append(c * poly)\n    candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n    h = F - _derivation(candidate) / denom\n    raw_numer = h.as_numer_denom()[0]\n    syms = set(poly_coeffs) | set(V)\n    non_syms = set()\n\n    def find_non_syms(expr):\n        if expr.is_Integer or expr.is_Rational:\n            pass\n        elif expr in syms:\n            pass\n        elif not expr.has_free(*syms):\n            non_syms.add(expr)\n        elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n            list(map(find_non_syms, expr.args))\n        else:\n            raise PolynomialError\n    try:\n        find_non_syms(raw_numer)\n    except PolynomialError:\n        return None\n    else:\n        (ground, _) = construct_domain(non_syms, field=True)\n    coeff_ring = PolyRing(poly_coeffs, ground)\n    ring = PolyRing(V, coeff_ring)\n    try:\n        numer = ring.from_expr(raw_numer)\n    except ValueError:\n        raise PolynomialError\n    solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n    if solution is None:\n        return None\n    else:\n        return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))",
            "def _integrate(field=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    atans = set()\n    pairs = set()\n    if field == 'Q':\n        irreducibles = set(reducibles)\n    else:\n        setV = set(V)\n        irreducibles = set()\n        for poly in ordered(reducibles):\n            zV = setV & set(iterfreeargs(poly))\n            for z in ordered(zV):\n                s = set(root_factors(poly, z, filter=field))\n                irreducibles |= s\n                break\n    (log_part, atan_part) = ([], [])\n    for poly in ordered(irreducibles):\n        m = collect(poly, I, evaluate=False)\n        y = m.get(I, S.Zero)\n        if y:\n            x = m.get(S.One, S.Zero)\n            if x.has(I) or y.has(I):\n                continue\n            pairs.add((x, y))\n            irreducibles.remove(poly)\n    while pairs:\n        (x, y) = pairs.pop()\n        if (x, -y) in pairs:\n            pairs.remove((x, -y))\n            if y.could_extract_minus_sign():\n                y = -y\n            irreducibles.add(x * x + y * y)\n            atans.add(atan(x / y))\n        else:\n            irreducibles.add(x + I * y)\n    B = _symbols('B', len(irreducibles))\n    C = _symbols('C', len(atans))\n    for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n        if poly.has(*V):\n            poly_coeffs.append(b)\n            log_part.append(b * log(poly))\n    for (poly, c) in reversed(list(zip(ordered(atans), C))):\n        if poly.has(*V):\n            poly_coeffs.append(c)\n            atan_part.append(c * poly)\n    candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n    h = F - _derivation(candidate) / denom\n    raw_numer = h.as_numer_denom()[0]\n    syms = set(poly_coeffs) | set(V)\n    non_syms = set()\n\n    def find_non_syms(expr):\n        if expr.is_Integer or expr.is_Rational:\n            pass\n        elif expr in syms:\n            pass\n        elif not expr.has_free(*syms):\n            non_syms.add(expr)\n        elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n            list(map(find_non_syms, expr.args))\n        else:\n            raise PolynomialError\n    try:\n        find_non_syms(raw_numer)\n    except PolynomialError:\n        return None\n    else:\n        (ground, _) = construct_domain(non_syms, field=True)\n    coeff_ring = PolyRing(poly_coeffs, ground)\n    ring = PolyRing(V, coeff_ring)\n    try:\n        numer = ring.from_expr(raw_numer)\n    except ValueError:\n        raise PolynomialError\n    solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n    if solution is None:\n        return None\n    else:\n        return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))",
            "def _integrate(field=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    atans = set()\n    pairs = set()\n    if field == 'Q':\n        irreducibles = set(reducibles)\n    else:\n        setV = set(V)\n        irreducibles = set()\n        for poly in ordered(reducibles):\n            zV = setV & set(iterfreeargs(poly))\n            for z in ordered(zV):\n                s = set(root_factors(poly, z, filter=field))\n                irreducibles |= s\n                break\n    (log_part, atan_part) = ([], [])\n    for poly in ordered(irreducibles):\n        m = collect(poly, I, evaluate=False)\n        y = m.get(I, S.Zero)\n        if y:\n            x = m.get(S.One, S.Zero)\n            if x.has(I) or y.has(I):\n                continue\n            pairs.add((x, y))\n            irreducibles.remove(poly)\n    while pairs:\n        (x, y) = pairs.pop()\n        if (x, -y) in pairs:\n            pairs.remove((x, -y))\n            if y.could_extract_minus_sign():\n                y = -y\n            irreducibles.add(x * x + y * y)\n            atans.add(atan(x / y))\n        else:\n            irreducibles.add(x + I * y)\n    B = _symbols('B', len(irreducibles))\n    C = _symbols('C', len(atans))\n    for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n        if poly.has(*V):\n            poly_coeffs.append(b)\n            log_part.append(b * log(poly))\n    for (poly, c) in reversed(list(zip(ordered(atans), C))):\n        if poly.has(*V):\n            poly_coeffs.append(c)\n            atan_part.append(c * poly)\n    candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n    h = F - _derivation(candidate) / denom\n    raw_numer = h.as_numer_denom()[0]\n    syms = set(poly_coeffs) | set(V)\n    non_syms = set()\n\n    def find_non_syms(expr):\n        if expr.is_Integer or expr.is_Rational:\n            pass\n        elif expr in syms:\n            pass\n        elif not expr.has_free(*syms):\n            non_syms.add(expr)\n        elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n            list(map(find_non_syms, expr.args))\n        else:\n            raise PolynomialError\n    try:\n        find_non_syms(raw_numer)\n    except PolynomialError:\n        return None\n    else:\n        (ground, _) = construct_domain(non_syms, field=True)\n    coeff_ring = PolyRing(poly_coeffs, ground)\n    ring = PolyRing(V, coeff_ring)\n    try:\n        numer = ring.from_expr(raw_numer)\n    except ValueError:\n        raise PolynomialError\n    solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n    if solution is None:\n        return None\n    else:\n        return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))",
            "def _integrate(field=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    atans = set()\n    pairs = set()\n    if field == 'Q':\n        irreducibles = set(reducibles)\n    else:\n        setV = set(V)\n        irreducibles = set()\n        for poly in ordered(reducibles):\n            zV = setV & set(iterfreeargs(poly))\n            for z in ordered(zV):\n                s = set(root_factors(poly, z, filter=field))\n                irreducibles |= s\n                break\n    (log_part, atan_part) = ([], [])\n    for poly in ordered(irreducibles):\n        m = collect(poly, I, evaluate=False)\n        y = m.get(I, S.Zero)\n        if y:\n            x = m.get(S.One, S.Zero)\n            if x.has(I) or y.has(I):\n                continue\n            pairs.add((x, y))\n            irreducibles.remove(poly)\n    while pairs:\n        (x, y) = pairs.pop()\n        if (x, -y) in pairs:\n            pairs.remove((x, -y))\n            if y.could_extract_minus_sign():\n                y = -y\n            irreducibles.add(x * x + y * y)\n            atans.add(atan(x / y))\n        else:\n            irreducibles.add(x + I * y)\n    B = _symbols('B', len(irreducibles))\n    C = _symbols('C', len(atans))\n    for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n        if poly.has(*V):\n            poly_coeffs.append(b)\n            log_part.append(b * log(poly))\n    for (poly, c) in reversed(list(zip(ordered(atans), C))):\n        if poly.has(*V):\n            poly_coeffs.append(c)\n            atan_part.append(c * poly)\n    candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n    h = F - _derivation(candidate) / denom\n    raw_numer = h.as_numer_denom()[0]\n    syms = set(poly_coeffs) | set(V)\n    non_syms = set()\n\n    def find_non_syms(expr):\n        if expr.is_Integer or expr.is_Rational:\n            pass\n        elif expr in syms:\n            pass\n        elif not expr.has_free(*syms):\n            non_syms.add(expr)\n        elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n            list(map(find_non_syms, expr.args))\n        else:\n            raise PolynomialError\n    try:\n        find_non_syms(raw_numer)\n    except PolynomialError:\n        return None\n    else:\n        (ground, _) = construct_domain(non_syms, field=True)\n    coeff_ring = PolyRing(poly_coeffs, ground)\n    ring = PolyRing(V, coeff_ring)\n    try:\n        numer = ring.from_expr(raw_numer)\n    except ValueError:\n        raise PolynomialError\n    solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n    if solution is None:\n        return None\n    else:\n        return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))"
        ]
    },
    {
        "func_name": "heurisch",
        "original": "def heurisch(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    \"\"\"\n    Compute indefinite integral using heuristic Risch algorithm.\n\n    Explanation\n    ===========\n\n    This is a heuristic approach to indefinite integration in finite\n    terms using the extended heuristic (parallel) Risch algorithm, based\n    on Manuel Bronstein's \"Poor Man's Integrator\".\n\n    The algorithm supports various classes of functions including\n    transcendental elementary or special functions like Airy,\n    Bessel, Whittaker and Lambert.\n\n    Note that this algorithm is not a decision procedure. If it isn't\n    able to compute the antiderivative for a given function, then this is\n    not a proof that such a functions does not exist.  One should use\n    recursive Risch algorithm in such case.  It's an open question if\n    this algorithm can be made a full decision procedure.\n\n    This is an internal integrator procedure. You should use top level\n    'integrate' function in most cases, as this procedure needs some\n    preprocessing steps and otherwise may fail.\n\n    Specification\n    =============\n\n     heurisch(f, x, rewrite=False, hints=None)\n\n       where\n         f : expression\n         x : symbol\n\n         rewrite -> force rewrite 'f' in terms of 'tan' and 'tanh'\n         hints   -> a list of functions that may appear in anti-derivate\n\n          - hints = None          --> no suggestions at all\n          - hints = [ ]           --> try to figure out\n          - hints = [f1, ..., fn] --> we know better\n\n    Examples\n    ========\n\n    >>> from sympy import tan\n    >>> from sympy.integrals.heurisch import heurisch\n    >>> from sympy.abc import x, y\n\n    >>> heurisch(y*tan(x), x)\n    y*log(tan(x)**2 + 1)/2\n\n    See Manuel Bronstein's \"Poor Man's Integrator\":\n\n    References\n    ==========\n\n    .. [1] https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html\n\n    For more information on the implemented algorithm refer to:\n\n    .. [2] K. Geddes, L. Stefanus, On the Risch-Norman Integration\n       Method and its Implementation in Maple, Proceedings of\n       ISSAC'89, ACM Press, 212-217.\n\n    .. [3] J. H. Davenport, On the Parallel Risch Algorithm (I),\n       Proceedings of EUROCAM'82, LNCS 144, Springer, 144-157.\n\n    .. [4] J. H. Davenport, On the Parallel Risch Algorithm (III):\n       Use of Tangents, SIGSAM Bulletin 16 (1982), 3-6.\n\n    .. [5] J. H. Davenport, B. M. Trager, On the Parallel Risch\n       Algorithm (II), ACM Transactions on Mathematical\n       Software 11 (1985), 356-362.\n\n    See Also\n    ========\n\n    sympy.integrals.integrals.Integral.doit\n    sympy.integrals.integrals.Integral\n    sympy.integrals.heurisch.components\n    \"\"\"\n    f = sympify(f)\n    if _try_heurisch is not True:\n        if f.has(Abs, re, im, sign, Heaviside, DiracDelta, floor, ceiling, arg):\n            return\n    if not f.has_free(x):\n        return f * x\n    if not f.is_Add:\n        (indep, f) = f.as_independent(x)\n    else:\n        indep = S.One\n    rewritables = {(sin, cos, cot): tan, (sinh, cosh, coth): tanh}\n    if rewrite:\n        for (candidates, rule) in rewritables.items():\n            f = f.rewrite(candidates, rule)\n    else:\n        for candidates in rewritables.keys():\n            if f.has(*candidates):\n                break\n        else:\n            rewrite = True\n    terms = components(f, x)\n    dcache = DiffCache(x)\n    if hints is not None:\n        if not hints:\n            a = Wild('a', exclude=[x])\n            b = Wild('b', exclude=[x])\n            c = Wild('c', exclude=[x])\n            for g in set(terms):\n                if g.is_Function:\n                    if isinstance(g, li):\n                        M = g.args[0].match(a * x ** b)\n                        if M is not None:\n                            terms.add(x * (li(M[a] * x ** M[b]) - (M[a] * x ** M[b]) ** (-1 / M[b]) * Ei((M[b] + 1) * log(M[a] * x ** M[b]) / M[b])))\n                    elif isinstance(g, exp):\n                        M = g.args[0].match(a * x ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * x))\n                            else:\n                                terms.add(erf(sqrt(-M[a]) * x))\n                        M = g.args[0].match(a * x ** 2 + b * x + c)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erfi(sqrt(M[a]) * x + M[b] / (2 * sqrt(M[a]))))\n                            elif M[a].is_negative:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erf(sqrt(-M[a]) * x - M[b] / (2 * sqrt(-M[a]))))\n                        M = g.args[0].match(a * log(x) ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * log(x) + 1 / (2 * sqrt(M[a]))))\n                            if M[a].is_negative:\n                                terms.add(erf(sqrt(-M[a]) * log(x) - 1 / (2 * sqrt(-M[a]))))\n                elif g.is_Pow:\n                    if g.exp.is_Rational and g.exp.q == 2:\n                        M = g.base.match(a * x ** 2 + b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                terms.add(asinh(sqrt(M[a] / M[b]) * x))\n                            elif M[a].is_negative:\n                                terms.add(asin(sqrt(-M[a] / M[b]) * x))\n                        M = g.base.match(a * x ** 2 - b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                dF = 1 / sqrt(M[a] * x ** 2 - M[b])\n                                F = log(2 * sqrt(M[a]) * sqrt(M[a] * x ** 2 - M[b]) + 2 * M[a] * x) / sqrt(M[a])\n                                dcache.cache[F] = dF\n                                terms.add(F)\n                            elif M[a].is_negative:\n                                terms.add(-M[b] / 2 * sqrt(-M[a]) * atan(sqrt(-M[a]) * x / sqrt(M[a] * x ** 2 - M[b])))\n        else:\n            terms |= set(hints)\n    for g in set(terms):\n        terms |= components(dcache.get_diff(g), x)\n    V = _symbols('x', len(terms))\n    mapping = list(reversed(list(zip(*ordered([(a[0].as_independent(x)[1], a) for a in zip(terms, V)])))[1]))\n    rev_mapping = {v: k for (k, v) in mapping}\n    if mappings is None:\n        assert mapping[-1][0] == x\n        unnecessary_permutations = [mapping.pop(-1)]\n        mappings = permutations(mapping)\n    else:\n        unnecessary_permutations = unnecessary_permutations or []\n\n    def _substitute(expr):\n        return expr.subs(mapping)\n    for mapping in mappings:\n        mapping = list(mapping)\n        mapping = mapping + unnecessary_permutations\n        diffs = [_substitute(dcache.get_diff(g)) for g in terms]\n        denoms = [g.as_numer_denom()[1] for g in diffs]\n        if all((h.is_polynomial(*V) for h in denoms)) and _substitute(f).is_rational_function(*V):\n            denom = reduce(lambda p, q: lcm(p, q, *V), denoms)\n            break\n    else:\n        if not rewrite:\n            result = heurisch(f, x, rewrite=True, hints=hints, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None\n    numers = [cancel(denom * g) for g in diffs]\n\n    def _derivation(h):\n        return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])\n\n    def _deflation(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(p) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n        return p\n\n    def _splitter(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(y) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                q = q.as_expr()\n                h = gcd(q, _derivation(q), y)\n                s = quo(h, gcd(q, q.diff(y), y), y)\n                c_split = _splitter(c)\n                if s.as_poly(y).degree() == 0:\n                    return (c_split[0], q * c_split[1])\n                q_split = _splitter(cancel(q / s))\n                return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n        return (S.One, p)\n    special = {}\n    for term in terms:\n        if term.is_Function:\n            if isinstance(term, tan):\n                special[1 + _substitute(term) ** 2] = False\n            elif isinstance(term, tanh):\n                special[1 + _substitute(term)] = False\n                special[1 - _substitute(term)] = False\n            elif isinstance(term, LambertW):\n                special[_substitute(term)] = True\n    F = _substitute(f)\n    (P, Q) = F.as_numer_denom()\n    u_split = _splitter(denom)\n    v_split = _splitter(Q)\n    polys = set(list(v_split) + [u_split[0]] + list(special.keys()))\n    s = u_split[0] * Mul(*[k for (k, v) in special.items() if v])\n    polified = [p.as_poly(*V) for p in [s, P, Q]]\n    if None in polified:\n        return None\n    (a, b, c) = [p.total_degree() for p in polified]\n    poly_denom = (s * v_split[0] * _deflation(v_split[1])).as_expr()\n\n    def _exponent(g):\n        if g.is_Pow:\n            if g.exp.is_Rational and g.exp.q != 1:\n                if g.exp.p > 0:\n                    return g.exp.p + g.exp.q - 1\n                else:\n                    return abs(g.exp.p + g.exp.q)\n            else:\n                return 1\n        elif not g.is_Atom and g.args:\n            return max([_exponent(h) for h in g.args])\n        else:\n            return 1\n    (A, B) = (_exponent(f), a + max(b, c))\n    if A > 1 and B > 1:\n        monoms = tuple(ordered(itermonomials(V, A + B - 1 + degree_offset)))\n    else:\n        monoms = tuple(ordered(itermonomials(V, A + B + degree_offset)))\n    poly_coeffs = _symbols('A', len(monoms))\n    poly_part = Add(*[poly_coeffs[i] * monomial for (i, monomial) in enumerate(monoms)])\n    reducibles = set()\n    for poly in ordered(polys):\n        (coeff, factors) = factor_list(poly, *V)\n        reducibles.add(coeff)\n        for (fact, mul) in factors:\n            reducibles.add(fact)\n\n    def _integrate(field=None):\n        atans = set()\n        pairs = set()\n        if field == 'Q':\n            irreducibles = set(reducibles)\n        else:\n            setV = set(V)\n            irreducibles = set()\n            for poly in ordered(reducibles):\n                zV = setV & set(iterfreeargs(poly))\n                for z in ordered(zV):\n                    s = set(root_factors(poly, z, filter=field))\n                    irreducibles |= s\n                    break\n        (log_part, atan_part) = ([], [])\n        for poly in ordered(irreducibles):\n            m = collect(poly, I, evaluate=False)\n            y = m.get(I, S.Zero)\n            if y:\n                x = m.get(S.One, S.Zero)\n                if x.has(I) or y.has(I):\n                    continue\n                pairs.add((x, y))\n                irreducibles.remove(poly)\n        while pairs:\n            (x, y) = pairs.pop()\n            if (x, -y) in pairs:\n                pairs.remove((x, -y))\n                if y.could_extract_minus_sign():\n                    y = -y\n                irreducibles.add(x * x + y * y)\n                atans.add(atan(x / y))\n            else:\n                irreducibles.add(x + I * y)\n        B = _symbols('B', len(irreducibles))\n        C = _symbols('C', len(atans))\n        for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n            if poly.has(*V):\n                poly_coeffs.append(b)\n                log_part.append(b * log(poly))\n        for (poly, c) in reversed(list(zip(ordered(atans), C))):\n            if poly.has(*V):\n                poly_coeffs.append(c)\n                atan_part.append(c * poly)\n        candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n        h = F - _derivation(candidate) / denom\n        raw_numer = h.as_numer_denom()[0]\n        syms = set(poly_coeffs) | set(V)\n        non_syms = set()\n\n        def find_non_syms(expr):\n            if expr.is_Integer or expr.is_Rational:\n                pass\n            elif expr in syms:\n                pass\n            elif not expr.has_free(*syms):\n                non_syms.add(expr)\n            elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n                list(map(find_non_syms, expr.args))\n            else:\n                raise PolynomialError\n        try:\n            find_non_syms(raw_numer)\n        except PolynomialError:\n            return None\n        else:\n            (ground, _) = construct_domain(non_syms, field=True)\n        coeff_ring = PolyRing(poly_coeffs, ground)\n        ring = PolyRing(V, coeff_ring)\n        try:\n            numer = ring.from_expr(raw_numer)\n        except ValueError:\n            raise PolynomialError\n        solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n        if solution is None:\n            return None\n        else:\n            return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))\n    if all((isinstance(_, Symbol) for _ in V)):\n        more_free = F.free_symbols - set(V)\n    else:\n        Fd = F.as_dummy()\n        more_free = Fd.xreplace(dict(zip(V, (Dummy() for _ in V)))).free_symbols & Fd.free_symbols\n    if not more_free:\n        solution = _integrate('Q')\n        if solution is None:\n            solution = _integrate()\n    else:\n        solution = _integrate()\n    if solution is not None:\n        antideriv = solution.subs(rev_mapping)\n        antideriv = cancel(antideriv).expand()\n        if antideriv.is_Add:\n            antideriv = antideriv.as_independent(x)[1]\n        return indep * antideriv\n    else:\n        if retries >= 0:\n            result = heurisch(f, x, mappings=mappings, rewrite=rewrite, hints=hints, retries=retries - 1, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None",
        "mutated": [
            "def heurisch(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    if False:\n        i = 10\n    '\\n    Compute indefinite integral using heuristic Risch algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    This is a heuristic approach to indefinite integration in finite\\n    terms using the extended heuristic (parallel) Risch algorithm, based\\n    on Manuel Bronstein\\'s \"Poor Man\\'s Integrator\".\\n\\n    The algorithm supports various classes of functions including\\n    transcendental elementary or special functions like Airy,\\n    Bessel, Whittaker and Lambert.\\n\\n    Note that this algorithm is not a decision procedure. If it isn\\'t\\n    able to compute the antiderivative for a given function, then this is\\n    not a proof that such a functions does not exist.  One should use\\n    recursive Risch algorithm in such case.  It\\'s an open question if\\n    this algorithm can be made a full decision procedure.\\n\\n    This is an internal integrator procedure. You should use top level\\n    \\'integrate\\' function in most cases, as this procedure needs some\\n    preprocessing steps and otherwise may fail.\\n\\n    Specification\\n    =============\\n\\n     heurisch(f, x, rewrite=False, hints=None)\\n\\n       where\\n         f : expression\\n         x : symbol\\n\\n         rewrite -> force rewrite \\'f\\' in terms of \\'tan\\' and \\'tanh\\'\\n         hints   -> a list of functions that may appear in anti-derivate\\n\\n          - hints = None          --> no suggestions at all\\n          - hints = [ ]           --> try to figure out\\n          - hints = [f1, ..., fn] --> we know better\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import tan\\n    >>> from sympy.integrals.heurisch import heurisch\\n    >>> from sympy.abc import x, y\\n\\n    >>> heurisch(y*tan(x), x)\\n    y*log(tan(x)**2 + 1)/2\\n\\n    See Manuel Bronstein\\'s \"Poor Man\\'s Integrator\":\\n\\n    References\\n    ==========\\n\\n    .. [1] https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html\\n\\n    For more information on the implemented algorithm refer to:\\n\\n    .. [2] K. Geddes, L. Stefanus, On the Risch-Norman Integration\\n       Method and its Implementation in Maple, Proceedings of\\n       ISSAC\\'89, ACM Press, 212-217.\\n\\n    .. [3] J. H. Davenport, On the Parallel Risch Algorithm (I),\\n       Proceedings of EUROCAM\\'82, LNCS 144, Springer, 144-157.\\n\\n    .. [4] J. H. Davenport, On the Parallel Risch Algorithm (III):\\n       Use of Tangents, SIGSAM Bulletin 16 (1982), 3-6.\\n\\n    .. [5] J. H. Davenport, B. M. Trager, On the Parallel Risch\\n       Algorithm (II), ACM Transactions on Mathematical\\n       Software 11 (1985), 356-362.\\n\\n    See Also\\n    ========\\n\\n    sympy.integrals.integrals.Integral.doit\\n    sympy.integrals.integrals.Integral\\n    sympy.integrals.heurisch.components\\n    '\n    f = sympify(f)\n    if _try_heurisch is not True:\n        if f.has(Abs, re, im, sign, Heaviside, DiracDelta, floor, ceiling, arg):\n            return\n    if not f.has_free(x):\n        return f * x\n    if not f.is_Add:\n        (indep, f) = f.as_independent(x)\n    else:\n        indep = S.One\n    rewritables = {(sin, cos, cot): tan, (sinh, cosh, coth): tanh}\n    if rewrite:\n        for (candidates, rule) in rewritables.items():\n            f = f.rewrite(candidates, rule)\n    else:\n        for candidates in rewritables.keys():\n            if f.has(*candidates):\n                break\n        else:\n            rewrite = True\n    terms = components(f, x)\n    dcache = DiffCache(x)\n    if hints is not None:\n        if not hints:\n            a = Wild('a', exclude=[x])\n            b = Wild('b', exclude=[x])\n            c = Wild('c', exclude=[x])\n            for g in set(terms):\n                if g.is_Function:\n                    if isinstance(g, li):\n                        M = g.args[0].match(a * x ** b)\n                        if M is not None:\n                            terms.add(x * (li(M[a] * x ** M[b]) - (M[a] * x ** M[b]) ** (-1 / M[b]) * Ei((M[b] + 1) * log(M[a] * x ** M[b]) / M[b])))\n                    elif isinstance(g, exp):\n                        M = g.args[0].match(a * x ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * x))\n                            else:\n                                terms.add(erf(sqrt(-M[a]) * x))\n                        M = g.args[0].match(a * x ** 2 + b * x + c)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erfi(sqrt(M[a]) * x + M[b] / (2 * sqrt(M[a]))))\n                            elif M[a].is_negative:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erf(sqrt(-M[a]) * x - M[b] / (2 * sqrt(-M[a]))))\n                        M = g.args[0].match(a * log(x) ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * log(x) + 1 / (2 * sqrt(M[a]))))\n                            if M[a].is_negative:\n                                terms.add(erf(sqrt(-M[a]) * log(x) - 1 / (2 * sqrt(-M[a]))))\n                elif g.is_Pow:\n                    if g.exp.is_Rational and g.exp.q == 2:\n                        M = g.base.match(a * x ** 2 + b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                terms.add(asinh(sqrt(M[a] / M[b]) * x))\n                            elif M[a].is_negative:\n                                terms.add(asin(sqrt(-M[a] / M[b]) * x))\n                        M = g.base.match(a * x ** 2 - b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                dF = 1 / sqrt(M[a] * x ** 2 - M[b])\n                                F = log(2 * sqrt(M[a]) * sqrt(M[a] * x ** 2 - M[b]) + 2 * M[a] * x) / sqrt(M[a])\n                                dcache.cache[F] = dF\n                                terms.add(F)\n                            elif M[a].is_negative:\n                                terms.add(-M[b] / 2 * sqrt(-M[a]) * atan(sqrt(-M[a]) * x / sqrt(M[a] * x ** 2 - M[b])))\n        else:\n            terms |= set(hints)\n    for g in set(terms):\n        terms |= components(dcache.get_diff(g), x)\n    V = _symbols('x', len(terms))\n    mapping = list(reversed(list(zip(*ordered([(a[0].as_independent(x)[1], a) for a in zip(terms, V)])))[1]))\n    rev_mapping = {v: k for (k, v) in mapping}\n    if mappings is None:\n        assert mapping[-1][0] == x\n        unnecessary_permutations = [mapping.pop(-1)]\n        mappings = permutations(mapping)\n    else:\n        unnecessary_permutations = unnecessary_permutations or []\n\n    def _substitute(expr):\n        return expr.subs(mapping)\n    for mapping in mappings:\n        mapping = list(mapping)\n        mapping = mapping + unnecessary_permutations\n        diffs = [_substitute(dcache.get_diff(g)) for g in terms]\n        denoms = [g.as_numer_denom()[1] for g in diffs]\n        if all((h.is_polynomial(*V) for h in denoms)) and _substitute(f).is_rational_function(*V):\n            denom = reduce(lambda p, q: lcm(p, q, *V), denoms)\n            break\n    else:\n        if not rewrite:\n            result = heurisch(f, x, rewrite=True, hints=hints, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None\n    numers = [cancel(denom * g) for g in diffs]\n\n    def _derivation(h):\n        return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])\n\n    def _deflation(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(p) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n        return p\n\n    def _splitter(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(y) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                q = q.as_expr()\n                h = gcd(q, _derivation(q), y)\n                s = quo(h, gcd(q, q.diff(y), y), y)\n                c_split = _splitter(c)\n                if s.as_poly(y).degree() == 0:\n                    return (c_split[0], q * c_split[1])\n                q_split = _splitter(cancel(q / s))\n                return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n        return (S.One, p)\n    special = {}\n    for term in terms:\n        if term.is_Function:\n            if isinstance(term, tan):\n                special[1 + _substitute(term) ** 2] = False\n            elif isinstance(term, tanh):\n                special[1 + _substitute(term)] = False\n                special[1 - _substitute(term)] = False\n            elif isinstance(term, LambertW):\n                special[_substitute(term)] = True\n    F = _substitute(f)\n    (P, Q) = F.as_numer_denom()\n    u_split = _splitter(denom)\n    v_split = _splitter(Q)\n    polys = set(list(v_split) + [u_split[0]] + list(special.keys()))\n    s = u_split[0] * Mul(*[k for (k, v) in special.items() if v])\n    polified = [p.as_poly(*V) for p in [s, P, Q]]\n    if None in polified:\n        return None\n    (a, b, c) = [p.total_degree() for p in polified]\n    poly_denom = (s * v_split[0] * _deflation(v_split[1])).as_expr()\n\n    def _exponent(g):\n        if g.is_Pow:\n            if g.exp.is_Rational and g.exp.q != 1:\n                if g.exp.p > 0:\n                    return g.exp.p + g.exp.q - 1\n                else:\n                    return abs(g.exp.p + g.exp.q)\n            else:\n                return 1\n        elif not g.is_Atom and g.args:\n            return max([_exponent(h) for h in g.args])\n        else:\n            return 1\n    (A, B) = (_exponent(f), a + max(b, c))\n    if A > 1 and B > 1:\n        monoms = tuple(ordered(itermonomials(V, A + B - 1 + degree_offset)))\n    else:\n        monoms = tuple(ordered(itermonomials(V, A + B + degree_offset)))\n    poly_coeffs = _symbols('A', len(monoms))\n    poly_part = Add(*[poly_coeffs[i] * monomial for (i, monomial) in enumerate(monoms)])\n    reducibles = set()\n    for poly in ordered(polys):\n        (coeff, factors) = factor_list(poly, *V)\n        reducibles.add(coeff)\n        for (fact, mul) in factors:\n            reducibles.add(fact)\n\n    def _integrate(field=None):\n        atans = set()\n        pairs = set()\n        if field == 'Q':\n            irreducibles = set(reducibles)\n        else:\n            setV = set(V)\n            irreducibles = set()\n            for poly in ordered(reducibles):\n                zV = setV & set(iterfreeargs(poly))\n                for z in ordered(zV):\n                    s = set(root_factors(poly, z, filter=field))\n                    irreducibles |= s\n                    break\n        (log_part, atan_part) = ([], [])\n        for poly in ordered(irreducibles):\n            m = collect(poly, I, evaluate=False)\n            y = m.get(I, S.Zero)\n            if y:\n                x = m.get(S.One, S.Zero)\n                if x.has(I) or y.has(I):\n                    continue\n                pairs.add((x, y))\n                irreducibles.remove(poly)\n        while pairs:\n            (x, y) = pairs.pop()\n            if (x, -y) in pairs:\n                pairs.remove((x, -y))\n                if y.could_extract_minus_sign():\n                    y = -y\n                irreducibles.add(x * x + y * y)\n                atans.add(atan(x / y))\n            else:\n                irreducibles.add(x + I * y)\n        B = _symbols('B', len(irreducibles))\n        C = _symbols('C', len(atans))\n        for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n            if poly.has(*V):\n                poly_coeffs.append(b)\n                log_part.append(b * log(poly))\n        for (poly, c) in reversed(list(zip(ordered(atans), C))):\n            if poly.has(*V):\n                poly_coeffs.append(c)\n                atan_part.append(c * poly)\n        candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n        h = F - _derivation(candidate) / denom\n        raw_numer = h.as_numer_denom()[0]\n        syms = set(poly_coeffs) | set(V)\n        non_syms = set()\n\n        def find_non_syms(expr):\n            if expr.is_Integer or expr.is_Rational:\n                pass\n            elif expr in syms:\n                pass\n            elif not expr.has_free(*syms):\n                non_syms.add(expr)\n            elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n                list(map(find_non_syms, expr.args))\n            else:\n                raise PolynomialError\n        try:\n            find_non_syms(raw_numer)\n        except PolynomialError:\n            return None\n        else:\n            (ground, _) = construct_domain(non_syms, field=True)\n        coeff_ring = PolyRing(poly_coeffs, ground)\n        ring = PolyRing(V, coeff_ring)\n        try:\n            numer = ring.from_expr(raw_numer)\n        except ValueError:\n            raise PolynomialError\n        solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n        if solution is None:\n            return None\n        else:\n            return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))\n    if all((isinstance(_, Symbol) for _ in V)):\n        more_free = F.free_symbols - set(V)\n    else:\n        Fd = F.as_dummy()\n        more_free = Fd.xreplace(dict(zip(V, (Dummy() for _ in V)))).free_symbols & Fd.free_symbols\n    if not more_free:\n        solution = _integrate('Q')\n        if solution is None:\n            solution = _integrate()\n    else:\n        solution = _integrate()\n    if solution is not None:\n        antideriv = solution.subs(rev_mapping)\n        antideriv = cancel(antideriv).expand()\n        if antideriv.is_Add:\n            antideriv = antideriv.as_independent(x)[1]\n        return indep * antideriv\n    else:\n        if retries >= 0:\n            result = heurisch(f, x, mappings=mappings, rewrite=rewrite, hints=hints, retries=retries - 1, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None",
            "def heurisch(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Compute indefinite integral using heuristic Risch algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    This is a heuristic approach to indefinite integration in finite\\n    terms using the extended heuristic (parallel) Risch algorithm, based\\n    on Manuel Bronstein\\'s \"Poor Man\\'s Integrator\".\\n\\n    The algorithm supports various classes of functions including\\n    transcendental elementary or special functions like Airy,\\n    Bessel, Whittaker and Lambert.\\n\\n    Note that this algorithm is not a decision procedure. If it isn\\'t\\n    able to compute the antiderivative for a given function, then this is\\n    not a proof that such a functions does not exist.  One should use\\n    recursive Risch algorithm in such case.  It\\'s an open question if\\n    this algorithm can be made a full decision procedure.\\n\\n    This is an internal integrator procedure. You should use top level\\n    \\'integrate\\' function in most cases, as this procedure needs some\\n    preprocessing steps and otherwise may fail.\\n\\n    Specification\\n    =============\\n\\n     heurisch(f, x, rewrite=False, hints=None)\\n\\n       where\\n         f : expression\\n         x : symbol\\n\\n         rewrite -> force rewrite \\'f\\' in terms of \\'tan\\' and \\'tanh\\'\\n         hints   -> a list of functions that may appear in anti-derivate\\n\\n          - hints = None          --> no suggestions at all\\n          - hints = [ ]           --> try to figure out\\n          - hints = [f1, ..., fn] --> we know better\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import tan\\n    >>> from sympy.integrals.heurisch import heurisch\\n    >>> from sympy.abc import x, y\\n\\n    >>> heurisch(y*tan(x), x)\\n    y*log(tan(x)**2 + 1)/2\\n\\n    See Manuel Bronstein\\'s \"Poor Man\\'s Integrator\":\\n\\n    References\\n    ==========\\n\\n    .. [1] https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html\\n\\n    For more information on the implemented algorithm refer to:\\n\\n    .. [2] K. Geddes, L. Stefanus, On the Risch-Norman Integration\\n       Method and its Implementation in Maple, Proceedings of\\n       ISSAC\\'89, ACM Press, 212-217.\\n\\n    .. [3] J. H. Davenport, On the Parallel Risch Algorithm (I),\\n       Proceedings of EUROCAM\\'82, LNCS 144, Springer, 144-157.\\n\\n    .. [4] J. H. Davenport, On the Parallel Risch Algorithm (III):\\n       Use of Tangents, SIGSAM Bulletin 16 (1982), 3-6.\\n\\n    .. [5] J. H. Davenport, B. M. Trager, On the Parallel Risch\\n       Algorithm (II), ACM Transactions on Mathematical\\n       Software 11 (1985), 356-362.\\n\\n    See Also\\n    ========\\n\\n    sympy.integrals.integrals.Integral.doit\\n    sympy.integrals.integrals.Integral\\n    sympy.integrals.heurisch.components\\n    '\n    f = sympify(f)\n    if _try_heurisch is not True:\n        if f.has(Abs, re, im, sign, Heaviside, DiracDelta, floor, ceiling, arg):\n            return\n    if not f.has_free(x):\n        return f * x\n    if not f.is_Add:\n        (indep, f) = f.as_independent(x)\n    else:\n        indep = S.One\n    rewritables = {(sin, cos, cot): tan, (sinh, cosh, coth): tanh}\n    if rewrite:\n        for (candidates, rule) in rewritables.items():\n            f = f.rewrite(candidates, rule)\n    else:\n        for candidates in rewritables.keys():\n            if f.has(*candidates):\n                break\n        else:\n            rewrite = True\n    terms = components(f, x)\n    dcache = DiffCache(x)\n    if hints is not None:\n        if not hints:\n            a = Wild('a', exclude=[x])\n            b = Wild('b', exclude=[x])\n            c = Wild('c', exclude=[x])\n            for g in set(terms):\n                if g.is_Function:\n                    if isinstance(g, li):\n                        M = g.args[0].match(a * x ** b)\n                        if M is not None:\n                            terms.add(x * (li(M[a] * x ** M[b]) - (M[a] * x ** M[b]) ** (-1 / M[b]) * Ei((M[b] + 1) * log(M[a] * x ** M[b]) / M[b])))\n                    elif isinstance(g, exp):\n                        M = g.args[0].match(a * x ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * x))\n                            else:\n                                terms.add(erf(sqrt(-M[a]) * x))\n                        M = g.args[0].match(a * x ** 2 + b * x + c)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erfi(sqrt(M[a]) * x + M[b] / (2 * sqrt(M[a]))))\n                            elif M[a].is_negative:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erf(sqrt(-M[a]) * x - M[b] / (2 * sqrt(-M[a]))))\n                        M = g.args[0].match(a * log(x) ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * log(x) + 1 / (2 * sqrt(M[a]))))\n                            if M[a].is_negative:\n                                terms.add(erf(sqrt(-M[a]) * log(x) - 1 / (2 * sqrt(-M[a]))))\n                elif g.is_Pow:\n                    if g.exp.is_Rational and g.exp.q == 2:\n                        M = g.base.match(a * x ** 2 + b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                terms.add(asinh(sqrt(M[a] / M[b]) * x))\n                            elif M[a].is_negative:\n                                terms.add(asin(sqrt(-M[a] / M[b]) * x))\n                        M = g.base.match(a * x ** 2 - b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                dF = 1 / sqrt(M[a] * x ** 2 - M[b])\n                                F = log(2 * sqrt(M[a]) * sqrt(M[a] * x ** 2 - M[b]) + 2 * M[a] * x) / sqrt(M[a])\n                                dcache.cache[F] = dF\n                                terms.add(F)\n                            elif M[a].is_negative:\n                                terms.add(-M[b] / 2 * sqrt(-M[a]) * atan(sqrt(-M[a]) * x / sqrt(M[a] * x ** 2 - M[b])))\n        else:\n            terms |= set(hints)\n    for g in set(terms):\n        terms |= components(dcache.get_diff(g), x)\n    V = _symbols('x', len(terms))\n    mapping = list(reversed(list(zip(*ordered([(a[0].as_independent(x)[1], a) for a in zip(terms, V)])))[1]))\n    rev_mapping = {v: k for (k, v) in mapping}\n    if mappings is None:\n        assert mapping[-1][0] == x\n        unnecessary_permutations = [mapping.pop(-1)]\n        mappings = permutations(mapping)\n    else:\n        unnecessary_permutations = unnecessary_permutations or []\n\n    def _substitute(expr):\n        return expr.subs(mapping)\n    for mapping in mappings:\n        mapping = list(mapping)\n        mapping = mapping + unnecessary_permutations\n        diffs = [_substitute(dcache.get_diff(g)) for g in terms]\n        denoms = [g.as_numer_denom()[1] for g in diffs]\n        if all((h.is_polynomial(*V) for h in denoms)) and _substitute(f).is_rational_function(*V):\n            denom = reduce(lambda p, q: lcm(p, q, *V), denoms)\n            break\n    else:\n        if not rewrite:\n            result = heurisch(f, x, rewrite=True, hints=hints, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None\n    numers = [cancel(denom * g) for g in diffs]\n\n    def _derivation(h):\n        return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])\n\n    def _deflation(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(p) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n        return p\n\n    def _splitter(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(y) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                q = q.as_expr()\n                h = gcd(q, _derivation(q), y)\n                s = quo(h, gcd(q, q.diff(y), y), y)\n                c_split = _splitter(c)\n                if s.as_poly(y).degree() == 0:\n                    return (c_split[0], q * c_split[1])\n                q_split = _splitter(cancel(q / s))\n                return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n        return (S.One, p)\n    special = {}\n    for term in terms:\n        if term.is_Function:\n            if isinstance(term, tan):\n                special[1 + _substitute(term) ** 2] = False\n            elif isinstance(term, tanh):\n                special[1 + _substitute(term)] = False\n                special[1 - _substitute(term)] = False\n            elif isinstance(term, LambertW):\n                special[_substitute(term)] = True\n    F = _substitute(f)\n    (P, Q) = F.as_numer_denom()\n    u_split = _splitter(denom)\n    v_split = _splitter(Q)\n    polys = set(list(v_split) + [u_split[0]] + list(special.keys()))\n    s = u_split[0] * Mul(*[k for (k, v) in special.items() if v])\n    polified = [p.as_poly(*V) for p in [s, P, Q]]\n    if None in polified:\n        return None\n    (a, b, c) = [p.total_degree() for p in polified]\n    poly_denom = (s * v_split[0] * _deflation(v_split[1])).as_expr()\n\n    def _exponent(g):\n        if g.is_Pow:\n            if g.exp.is_Rational and g.exp.q != 1:\n                if g.exp.p > 0:\n                    return g.exp.p + g.exp.q - 1\n                else:\n                    return abs(g.exp.p + g.exp.q)\n            else:\n                return 1\n        elif not g.is_Atom and g.args:\n            return max([_exponent(h) for h in g.args])\n        else:\n            return 1\n    (A, B) = (_exponent(f), a + max(b, c))\n    if A > 1 and B > 1:\n        monoms = tuple(ordered(itermonomials(V, A + B - 1 + degree_offset)))\n    else:\n        monoms = tuple(ordered(itermonomials(V, A + B + degree_offset)))\n    poly_coeffs = _symbols('A', len(monoms))\n    poly_part = Add(*[poly_coeffs[i] * monomial for (i, monomial) in enumerate(monoms)])\n    reducibles = set()\n    for poly in ordered(polys):\n        (coeff, factors) = factor_list(poly, *V)\n        reducibles.add(coeff)\n        for (fact, mul) in factors:\n            reducibles.add(fact)\n\n    def _integrate(field=None):\n        atans = set()\n        pairs = set()\n        if field == 'Q':\n            irreducibles = set(reducibles)\n        else:\n            setV = set(V)\n            irreducibles = set()\n            for poly in ordered(reducibles):\n                zV = setV & set(iterfreeargs(poly))\n                for z in ordered(zV):\n                    s = set(root_factors(poly, z, filter=field))\n                    irreducibles |= s\n                    break\n        (log_part, atan_part) = ([], [])\n        for poly in ordered(irreducibles):\n            m = collect(poly, I, evaluate=False)\n            y = m.get(I, S.Zero)\n            if y:\n                x = m.get(S.One, S.Zero)\n                if x.has(I) or y.has(I):\n                    continue\n                pairs.add((x, y))\n                irreducibles.remove(poly)\n        while pairs:\n            (x, y) = pairs.pop()\n            if (x, -y) in pairs:\n                pairs.remove((x, -y))\n                if y.could_extract_minus_sign():\n                    y = -y\n                irreducibles.add(x * x + y * y)\n                atans.add(atan(x / y))\n            else:\n                irreducibles.add(x + I * y)\n        B = _symbols('B', len(irreducibles))\n        C = _symbols('C', len(atans))\n        for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n            if poly.has(*V):\n                poly_coeffs.append(b)\n                log_part.append(b * log(poly))\n        for (poly, c) in reversed(list(zip(ordered(atans), C))):\n            if poly.has(*V):\n                poly_coeffs.append(c)\n                atan_part.append(c * poly)\n        candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n        h = F - _derivation(candidate) / denom\n        raw_numer = h.as_numer_denom()[0]\n        syms = set(poly_coeffs) | set(V)\n        non_syms = set()\n\n        def find_non_syms(expr):\n            if expr.is_Integer or expr.is_Rational:\n                pass\n            elif expr in syms:\n                pass\n            elif not expr.has_free(*syms):\n                non_syms.add(expr)\n            elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n                list(map(find_non_syms, expr.args))\n            else:\n                raise PolynomialError\n        try:\n            find_non_syms(raw_numer)\n        except PolynomialError:\n            return None\n        else:\n            (ground, _) = construct_domain(non_syms, field=True)\n        coeff_ring = PolyRing(poly_coeffs, ground)\n        ring = PolyRing(V, coeff_ring)\n        try:\n            numer = ring.from_expr(raw_numer)\n        except ValueError:\n            raise PolynomialError\n        solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n        if solution is None:\n            return None\n        else:\n            return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))\n    if all((isinstance(_, Symbol) for _ in V)):\n        more_free = F.free_symbols - set(V)\n    else:\n        Fd = F.as_dummy()\n        more_free = Fd.xreplace(dict(zip(V, (Dummy() for _ in V)))).free_symbols & Fd.free_symbols\n    if not more_free:\n        solution = _integrate('Q')\n        if solution is None:\n            solution = _integrate()\n    else:\n        solution = _integrate()\n    if solution is not None:\n        antideriv = solution.subs(rev_mapping)\n        antideriv = cancel(antideriv).expand()\n        if antideriv.is_Add:\n            antideriv = antideriv.as_independent(x)[1]\n        return indep * antideriv\n    else:\n        if retries >= 0:\n            result = heurisch(f, x, mappings=mappings, rewrite=rewrite, hints=hints, retries=retries - 1, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None",
            "def heurisch(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Compute indefinite integral using heuristic Risch algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    This is a heuristic approach to indefinite integration in finite\\n    terms using the extended heuristic (parallel) Risch algorithm, based\\n    on Manuel Bronstein\\'s \"Poor Man\\'s Integrator\".\\n\\n    The algorithm supports various classes of functions including\\n    transcendental elementary or special functions like Airy,\\n    Bessel, Whittaker and Lambert.\\n\\n    Note that this algorithm is not a decision procedure. If it isn\\'t\\n    able to compute the antiderivative for a given function, then this is\\n    not a proof that such a functions does not exist.  One should use\\n    recursive Risch algorithm in such case.  It\\'s an open question if\\n    this algorithm can be made a full decision procedure.\\n\\n    This is an internal integrator procedure. You should use top level\\n    \\'integrate\\' function in most cases, as this procedure needs some\\n    preprocessing steps and otherwise may fail.\\n\\n    Specification\\n    =============\\n\\n     heurisch(f, x, rewrite=False, hints=None)\\n\\n       where\\n         f : expression\\n         x : symbol\\n\\n         rewrite -> force rewrite \\'f\\' in terms of \\'tan\\' and \\'tanh\\'\\n         hints   -> a list of functions that may appear in anti-derivate\\n\\n          - hints = None          --> no suggestions at all\\n          - hints = [ ]           --> try to figure out\\n          - hints = [f1, ..., fn] --> we know better\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import tan\\n    >>> from sympy.integrals.heurisch import heurisch\\n    >>> from sympy.abc import x, y\\n\\n    >>> heurisch(y*tan(x), x)\\n    y*log(tan(x)**2 + 1)/2\\n\\n    See Manuel Bronstein\\'s \"Poor Man\\'s Integrator\":\\n\\n    References\\n    ==========\\n\\n    .. [1] https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html\\n\\n    For more information on the implemented algorithm refer to:\\n\\n    .. [2] K. Geddes, L. Stefanus, On the Risch-Norman Integration\\n       Method and its Implementation in Maple, Proceedings of\\n       ISSAC\\'89, ACM Press, 212-217.\\n\\n    .. [3] J. H. Davenport, On the Parallel Risch Algorithm (I),\\n       Proceedings of EUROCAM\\'82, LNCS 144, Springer, 144-157.\\n\\n    .. [4] J. H. Davenport, On the Parallel Risch Algorithm (III):\\n       Use of Tangents, SIGSAM Bulletin 16 (1982), 3-6.\\n\\n    .. [5] J. H. Davenport, B. M. Trager, On the Parallel Risch\\n       Algorithm (II), ACM Transactions on Mathematical\\n       Software 11 (1985), 356-362.\\n\\n    See Also\\n    ========\\n\\n    sympy.integrals.integrals.Integral.doit\\n    sympy.integrals.integrals.Integral\\n    sympy.integrals.heurisch.components\\n    '\n    f = sympify(f)\n    if _try_heurisch is not True:\n        if f.has(Abs, re, im, sign, Heaviside, DiracDelta, floor, ceiling, arg):\n            return\n    if not f.has_free(x):\n        return f * x\n    if not f.is_Add:\n        (indep, f) = f.as_independent(x)\n    else:\n        indep = S.One\n    rewritables = {(sin, cos, cot): tan, (sinh, cosh, coth): tanh}\n    if rewrite:\n        for (candidates, rule) in rewritables.items():\n            f = f.rewrite(candidates, rule)\n    else:\n        for candidates in rewritables.keys():\n            if f.has(*candidates):\n                break\n        else:\n            rewrite = True\n    terms = components(f, x)\n    dcache = DiffCache(x)\n    if hints is not None:\n        if not hints:\n            a = Wild('a', exclude=[x])\n            b = Wild('b', exclude=[x])\n            c = Wild('c', exclude=[x])\n            for g in set(terms):\n                if g.is_Function:\n                    if isinstance(g, li):\n                        M = g.args[0].match(a * x ** b)\n                        if M is not None:\n                            terms.add(x * (li(M[a] * x ** M[b]) - (M[a] * x ** M[b]) ** (-1 / M[b]) * Ei((M[b] + 1) * log(M[a] * x ** M[b]) / M[b])))\n                    elif isinstance(g, exp):\n                        M = g.args[0].match(a * x ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * x))\n                            else:\n                                terms.add(erf(sqrt(-M[a]) * x))\n                        M = g.args[0].match(a * x ** 2 + b * x + c)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erfi(sqrt(M[a]) * x + M[b] / (2 * sqrt(M[a]))))\n                            elif M[a].is_negative:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erf(sqrt(-M[a]) * x - M[b] / (2 * sqrt(-M[a]))))\n                        M = g.args[0].match(a * log(x) ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * log(x) + 1 / (2 * sqrt(M[a]))))\n                            if M[a].is_negative:\n                                terms.add(erf(sqrt(-M[a]) * log(x) - 1 / (2 * sqrt(-M[a]))))\n                elif g.is_Pow:\n                    if g.exp.is_Rational and g.exp.q == 2:\n                        M = g.base.match(a * x ** 2 + b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                terms.add(asinh(sqrt(M[a] / M[b]) * x))\n                            elif M[a].is_negative:\n                                terms.add(asin(sqrt(-M[a] / M[b]) * x))\n                        M = g.base.match(a * x ** 2 - b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                dF = 1 / sqrt(M[a] * x ** 2 - M[b])\n                                F = log(2 * sqrt(M[a]) * sqrt(M[a] * x ** 2 - M[b]) + 2 * M[a] * x) / sqrt(M[a])\n                                dcache.cache[F] = dF\n                                terms.add(F)\n                            elif M[a].is_negative:\n                                terms.add(-M[b] / 2 * sqrt(-M[a]) * atan(sqrt(-M[a]) * x / sqrt(M[a] * x ** 2 - M[b])))\n        else:\n            terms |= set(hints)\n    for g in set(terms):\n        terms |= components(dcache.get_diff(g), x)\n    V = _symbols('x', len(terms))\n    mapping = list(reversed(list(zip(*ordered([(a[0].as_independent(x)[1], a) for a in zip(terms, V)])))[1]))\n    rev_mapping = {v: k for (k, v) in mapping}\n    if mappings is None:\n        assert mapping[-1][0] == x\n        unnecessary_permutations = [mapping.pop(-1)]\n        mappings = permutations(mapping)\n    else:\n        unnecessary_permutations = unnecessary_permutations or []\n\n    def _substitute(expr):\n        return expr.subs(mapping)\n    for mapping in mappings:\n        mapping = list(mapping)\n        mapping = mapping + unnecessary_permutations\n        diffs = [_substitute(dcache.get_diff(g)) for g in terms]\n        denoms = [g.as_numer_denom()[1] for g in diffs]\n        if all((h.is_polynomial(*V) for h in denoms)) and _substitute(f).is_rational_function(*V):\n            denom = reduce(lambda p, q: lcm(p, q, *V), denoms)\n            break\n    else:\n        if not rewrite:\n            result = heurisch(f, x, rewrite=True, hints=hints, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None\n    numers = [cancel(denom * g) for g in diffs]\n\n    def _derivation(h):\n        return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])\n\n    def _deflation(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(p) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n        return p\n\n    def _splitter(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(y) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                q = q.as_expr()\n                h = gcd(q, _derivation(q), y)\n                s = quo(h, gcd(q, q.diff(y), y), y)\n                c_split = _splitter(c)\n                if s.as_poly(y).degree() == 0:\n                    return (c_split[0], q * c_split[1])\n                q_split = _splitter(cancel(q / s))\n                return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n        return (S.One, p)\n    special = {}\n    for term in terms:\n        if term.is_Function:\n            if isinstance(term, tan):\n                special[1 + _substitute(term) ** 2] = False\n            elif isinstance(term, tanh):\n                special[1 + _substitute(term)] = False\n                special[1 - _substitute(term)] = False\n            elif isinstance(term, LambertW):\n                special[_substitute(term)] = True\n    F = _substitute(f)\n    (P, Q) = F.as_numer_denom()\n    u_split = _splitter(denom)\n    v_split = _splitter(Q)\n    polys = set(list(v_split) + [u_split[0]] + list(special.keys()))\n    s = u_split[0] * Mul(*[k for (k, v) in special.items() if v])\n    polified = [p.as_poly(*V) for p in [s, P, Q]]\n    if None in polified:\n        return None\n    (a, b, c) = [p.total_degree() for p in polified]\n    poly_denom = (s * v_split[0] * _deflation(v_split[1])).as_expr()\n\n    def _exponent(g):\n        if g.is_Pow:\n            if g.exp.is_Rational and g.exp.q != 1:\n                if g.exp.p > 0:\n                    return g.exp.p + g.exp.q - 1\n                else:\n                    return abs(g.exp.p + g.exp.q)\n            else:\n                return 1\n        elif not g.is_Atom and g.args:\n            return max([_exponent(h) for h in g.args])\n        else:\n            return 1\n    (A, B) = (_exponent(f), a + max(b, c))\n    if A > 1 and B > 1:\n        monoms = tuple(ordered(itermonomials(V, A + B - 1 + degree_offset)))\n    else:\n        monoms = tuple(ordered(itermonomials(V, A + B + degree_offset)))\n    poly_coeffs = _symbols('A', len(monoms))\n    poly_part = Add(*[poly_coeffs[i] * monomial for (i, monomial) in enumerate(monoms)])\n    reducibles = set()\n    for poly in ordered(polys):\n        (coeff, factors) = factor_list(poly, *V)\n        reducibles.add(coeff)\n        for (fact, mul) in factors:\n            reducibles.add(fact)\n\n    def _integrate(field=None):\n        atans = set()\n        pairs = set()\n        if field == 'Q':\n            irreducibles = set(reducibles)\n        else:\n            setV = set(V)\n            irreducibles = set()\n            for poly in ordered(reducibles):\n                zV = setV & set(iterfreeargs(poly))\n                for z in ordered(zV):\n                    s = set(root_factors(poly, z, filter=field))\n                    irreducibles |= s\n                    break\n        (log_part, atan_part) = ([], [])\n        for poly in ordered(irreducibles):\n            m = collect(poly, I, evaluate=False)\n            y = m.get(I, S.Zero)\n            if y:\n                x = m.get(S.One, S.Zero)\n                if x.has(I) or y.has(I):\n                    continue\n                pairs.add((x, y))\n                irreducibles.remove(poly)\n        while pairs:\n            (x, y) = pairs.pop()\n            if (x, -y) in pairs:\n                pairs.remove((x, -y))\n                if y.could_extract_minus_sign():\n                    y = -y\n                irreducibles.add(x * x + y * y)\n                atans.add(atan(x / y))\n            else:\n                irreducibles.add(x + I * y)\n        B = _symbols('B', len(irreducibles))\n        C = _symbols('C', len(atans))\n        for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n            if poly.has(*V):\n                poly_coeffs.append(b)\n                log_part.append(b * log(poly))\n        for (poly, c) in reversed(list(zip(ordered(atans), C))):\n            if poly.has(*V):\n                poly_coeffs.append(c)\n                atan_part.append(c * poly)\n        candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n        h = F - _derivation(candidate) / denom\n        raw_numer = h.as_numer_denom()[0]\n        syms = set(poly_coeffs) | set(V)\n        non_syms = set()\n\n        def find_non_syms(expr):\n            if expr.is_Integer or expr.is_Rational:\n                pass\n            elif expr in syms:\n                pass\n            elif not expr.has_free(*syms):\n                non_syms.add(expr)\n            elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n                list(map(find_non_syms, expr.args))\n            else:\n                raise PolynomialError\n        try:\n            find_non_syms(raw_numer)\n        except PolynomialError:\n            return None\n        else:\n            (ground, _) = construct_domain(non_syms, field=True)\n        coeff_ring = PolyRing(poly_coeffs, ground)\n        ring = PolyRing(V, coeff_ring)\n        try:\n            numer = ring.from_expr(raw_numer)\n        except ValueError:\n            raise PolynomialError\n        solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n        if solution is None:\n            return None\n        else:\n            return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))\n    if all((isinstance(_, Symbol) for _ in V)):\n        more_free = F.free_symbols - set(V)\n    else:\n        Fd = F.as_dummy()\n        more_free = Fd.xreplace(dict(zip(V, (Dummy() for _ in V)))).free_symbols & Fd.free_symbols\n    if not more_free:\n        solution = _integrate('Q')\n        if solution is None:\n            solution = _integrate()\n    else:\n        solution = _integrate()\n    if solution is not None:\n        antideriv = solution.subs(rev_mapping)\n        antideriv = cancel(antideriv).expand()\n        if antideriv.is_Add:\n            antideriv = antideriv.as_independent(x)[1]\n        return indep * antideriv\n    else:\n        if retries >= 0:\n            result = heurisch(f, x, mappings=mappings, rewrite=rewrite, hints=hints, retries=retries - 1, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None",
            "def heurisch(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Compute indefinite integral using heuristic Risch algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    This is a heuristic approach to indefinite integration in finite\\n    terms using the extended heuristic (parallel) Risch algorithm, based\\n    on Manuel Bronstein\\'s \"Poor Man\\'s Integrator\".\\n\\n    The algorithm supports various classes of functions including\\n    transcendental elementary or special functions like Airy,\\n    Bessel, Whittaker and Lambert.\\n\\n    Note that this algorithm is not a decision procedure. If it isn\\'t\\n    able to compute the antiderivative for a given function, then this is\\n    not a proof that such a functions does not exist.  One should use\\n    recursive Risch algorithm in such case.  It\\'s an open question if\\n    this algorithm can be made a full decision procedure.\\n\\n    This is an internal integrator procedure. You should use top level\\n    \\'integrate\\' function in most cases, as this procedure needs some\\n    preprocessing steps and otherwise may fail.\\n\\n    Specification\\n    =============\\n\\n     heurisch(f, x, rewrite=False, hints=None)\\n\\n       where\\n         f : expression\\n         x : symbol\\n\\n         rewrite -> force rewrite \\'f\\' in terms of \\'tan\\' and \\'tanh\\'\\n         hints   -> a list of functions that may appear in anti-derivate\\n\\n          - hints = None          --> no suggestions at all\\n          - hints = [ ]           --> try to figure out\\n          - hints = [f1, ..., fn] --> we know better\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import tan\\n    >>> from sympy.integrals.heurisch import heurisch\\n    >>> from sympy.abc import x, y\\n\\n    >>> heurisch(y*tan(x), x)\\n    y*log(tan(x)**2 + 1)/2\\n\\n    See Manuel Bronstein\\'s \"Poor Man\\'s Integrator\":\\n\\n    References\\n    ==========\\n\\n    .. [1] https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html\\n\\n    For more information on the implemented algorithm refer to:\\n\\n    .. [2] K. Geddes, L. Stefanus, On the Risch-Norman Integration\\n       Method and its Implementation in Maple, Proceedings of\\n       ISSAC\\'89, ACM Press, 212-217.\\n\\n    .. [3] J. H. Davenport, On the Parallel Risch Algorithm (I),\\n       Proceedings of EUROCAM\\'82, LNCS 144, Springer, 144-157.\\n\\n    .. [4] J. H. Davenport, On the Parallel Risch Algorithm (III):\\n       Use of Tangents, SIGSAM Bulletin 16 (1982), 3-6.\\n\\n    .. [5] J. H. Davenport, B. M. Trager, On the Parallel Risch\\n       Algorithm (II), ACM Transactions on Mathematical\\n       Software 11 (1985), 356-362.\\n\\n    See Also\\n    ========\\n\\n    sympy.integrals.integrals.Integral.doit\\n    sympy.integrals.integrals.Integral\\n    sympy.integrals.heurisch.components\\n    '\n    f = sympify(f)\n    if _try_heurisch is not True:\n        if f.has(Abs, re, im, sign, Heaviside, DiracDelta, floor, ceiling, arg):\n            return\n    if not f.has_free(x):\n        return f * x\n    if not f.is_Add:\n        (indep, f) = f.as_independent(x)\n    else:\n        indep = S.One\n    rewritables = {(sin, cos, cot): tan, (sinh, cosh, coth): tanh}\n    if rewrite:\n        for (candidates, rule) in rewritables.items():\n            f = f.rewrite(candidates, rule)\n    else:\n        for candidates in rewritables.keys():\n            if f.has(*candidates):\n                break\n        else:\n            rewrite = True\n    terms = components(f, x)\n    dcache = DiffCache(x)\n    if hints is not None:\n        if not hints:\n            a = Wild('a', exclude=[x])\n            b = Wild('b', exclude=[x])\n            c = Wild('c', exclude=[x])\n            for g in set(terms):\n                if g.is_Function:\n                    if isinstance(g, li):\n                        M = g.args[0].match(a * x ** b)\n                        if M is not None:\n                            terms.add(x * (li(M[a] * x ** M[b]) - (M[a] * x ** M[b]) ** (-1 / M[b]) * Ei((M[b] + 1) * log(M[a] * x ** M[b]) / M[b])))\n                    elif isinstance(g, exp):\n                        M = g.args[0].match(a * x ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * x))\n                            else:\n                                terms.add(erf(sqrt(-M[a]) * x))\n                        M = g.args[0].match(a * x ** 2 + b * x + c)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erfi(sqrt(M[a]) * x + M[b] / (2 * sqrt(M[a]))))\n                            elif M[a].is_negative:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erf(sqrt(-M[a]) * x - M[b] / (2 * sqrt(-M[a]))))\n                        M = g.args[0].match(a * log(x) ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * log(x) + 1 / (2 * sqrt(M[a]))))\n                            if M[a].is_negative:\n                                terms.add(erf(sqrt(-M[a]) * log(x) - 1 / (2 * sqrt(-M[a]))))\n                elif g.is_Pow:\n                    if g.exp.is_Rational and g.exp.q == 2:\n                        M = g.base.match(a * x ** 2 + b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                terms.add(asinh(sqrt(M[a] / M[b]) * x))\n                            elif M[a].is_negative:\n                                terms.add(asin(sqrt(-M[a] / M[b]) * x))\n                        M = g.base.match(a * x ** 2 - b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                dF = 1 / sqrt(M[a] * x ** 2 - M[b])\n                                F = log(2 * sqrt(M[a]) * sqrt(M[a] * x ** 2 - M[b]) + 2 * M[a] * x) / sqrt(M[a])\n                                dcache.cache[F] = dF\n                                terms.add(F)\n                            elif M[a].is_negative:\n                                terms.add(-M[b] / 2 * sqrt(-M[a]) * atan(sqrt(-M[a]) * x / sqrt(M[a] * x ** 2 - M[b])))\n        else:\n            terms |= set(hints)\n    for g in set(terms):\n        terms |= components(dcache.get_diff(g), x)\n    V = _symbols('x', len(terms))\n    mapping = list(reversed(list(zip(*ordered([(a[0].as_independent(x)[1], a) for a in zip(terms, V)])))[1]))\n    rev_mapping = {v: k for (k, v) in mapping}\n    if mappings is None:\n        assert mapping[-1][0] == x\n        unnecessary_permutations = [mapping.pop(-1)]\n        mappings = permutations(mapping)\n    else:\n        unnecessary_permutations = unnecessary_permutations or []\n\n    def _substitute(expr):\n        return expr.subs(mapping)\n    for mapping in mappings:\n        mapping = list(mapping)\n        mapping = mapping + unnecessary_permutations\n        diffs = [_substitute(dcache.get_diff(g)) for g in terms]\n        denoms = [g.as_numer_denom()[1] for g in diffs]\n        if all((h.is_polynomial(*V) for h in denoms)) and _substitute(f).is_rational_function(*V):\n            denom = reduce(lambda p, q: lcm(p, q, *V), denoms)\n            break\n    else:\n        if not rewrite:\n            result = heurisch(f, x, rewrite=True, hints=hints, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None\n    numers = [cancel(denom * g) for g in diffs]\n\n    def _derivation(h):\n        return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])\n\n    def _deflation(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(p) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n        return p\n\n    def _splitter(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(y) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                q = q.as_expr()\n                h = gcd(q, _derivation(q), y)\n                s = quo(h, gcd(q, q.diff(y), y), y)\n                c_split = _splitter(c)\n                if s.as_poly(y).degree() == 0:\n                    return (c_split[0], q * c_split[1])\n                q_split = _splitter(cancel(q / s))\n                return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n        return (S.One, p)\n    special = {}\n    for term in terms:\n        if term.is_Function:\n            if isinstance(term, tan):\n                special[1 + _substitute(term) ** 2] = False\n            elif isinstance(term, tanh):\n                special[1 + _substitute(term)] = False\n                special[1 - _substitute(term)] = False\n            elif isinstance(term, LambertW):\n                special[_substitute(term)] = True\n    F = _substitute(f)\n    (P, Q) = F.as_numer_denom()\n    u_split = _splitter(denom)\n    v_split = _splitter(Q)\n    polys = set(list(v_split) + [u_split[0]] + list(special.keys()))\n    s = u_split[0] * Mul(*[k for (k, v) in special.items() if v])\n    polified = [p.as_poly(*V) for p in [s, P, Q]]\n    if None in polified:\n        return None\n    (a, b, c) = [p.total_degree() for p in polified]\n    poly_denom = (s * v_split[0] * _deflation(v_split[1])).as_expr()\n\n    def _exponent(g):\n        if g.is_Pow:\n            if g.exp.is_Rational and g.exp.q != 1:\n                if g.exp.p > 0:\n                    return g.exp.p + g.exp.q - 1\n                else:\n                    return abs(g.exp.p + g.exp.q)\n            else:\n                return 1\n        elif not g.is_Atom and g.args:\n            return max([_exponent(h) for h in g.args])\n        else:\n            return 1\n    (A, B) = (_exponent(f), a + max(b, c))\n    if A > 1 and B > 1:\n        monoms = tuple(ordered(itermonomials(V, A + B - 1 + degree_offset)))\n    else:\n        monoms = tuple(ordered(itermonomials(V, A + B + degree_offset)))\n    poly_coeffs = _symbols('A', len(monoms))\n    poly_part = Add(*[poly_coeffs[i] * monomial for (i, monomial) in enumerate(monoms)])\n    reducibles = set()\n    for poly in ordered(polys):\n        (coeff, factors) = factor_list(poly, *V)\n        reducibles.add(coeff)\n        for (fact, mul) in factors:\n            reducibles.add(fact)\n\n    def _integrate(field=None):\n        atans = set()\n        pairs = set()\n        if field == 'Q':\n            irreducibles = set(reducibles)\n        else:\n            setV = set(V)\n            irreducibles = set()\n            for poly in ordered(reducibles):\n                zV = setV & set(iterfreeargs(poly))\n                for z in ordered(zV):\n                    s = set(root_factors(poly, z, filter=field))\n                    irreducibles |= s\n                    break\n        (log_part, atan_part) = ([], [])\n        for poly in ordered(irreducibles):\n            m = collect(poly, I, evaluate=False)\n            y = m.get(I, S.Zero)\n            if y:\n                x = m.get(S.One, S.Zero)\n                if x.has(I) or y.has(I):\n                    continue\n                pairs.add((x, y))\n                irreducibles.remove(poly)\n        while pairs:\n            (x, y) = pairs.pop()\n            if (x, -y) in pairs:\n                pairs.remove((x, -y))\n                if y.could_extract_minus_sign():\n                    y = -y\n                irreducibles.add(x * x + y * y)\n                atans.add(atan(x / y))\n            else:\n                irreducibles.add(x + I * y)\n        B = _symbols('B', len(irreducibles))\n        C = _symbols('C', len(atans))\n        for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n            if poly.has(*V):\n                poly_coeffs.append(b)\n                log_part.append(b * log(poly))\n        for (poly, c) in reversed(list(zip(ordered(atans), C))):\n            if poly.has(*V):\n                poly_coeffs.append(c)\n                atan_part.append(c * poly)\n        candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n        h = F - _derivation(candidate) / denom\n        raw_numer = h.as_numer_denom()[0]\n        syms = set(poly_coeffs) | set(V)\n        non_syms = set()\n\n        def find_non_syms(expr):\n            if expr.is_Integer or expr.is_Rational:\n                pass\n            elif expr in syms:\n                pass\n            elif not expr.has_free(*syms):\n                non_syms.add(expr)\n            elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n                list(map(find_non_syms, expr.args))\n            else:\n                raise PolynomialError\n        try:\n            find_non_syms(raw_numer)\n        except PolynomialError:\n            return None\n        else:\n            (ground, _) = construct_domain(non_syms, field=True)\n        coeff_ring = PolyRing(poly_coeffs, ground)\n        ring = PolyRing(V, coeff_ring)\n        try:\n            numer = ring.from_expr(raw_numer)\n        except ValueError:\n            raise PolynomialError\n        solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n        if solution is None:\n            return None\n        else:\n            return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))\n    if all((isinstance(_, Symbol) for _ in V)):\n        more_free = F.free_symbols - set(V)\n    else:\n        Fd = F.as_dummy()\n        more_free = Fd.xreplace(dict(zip(V, (Dummy() for _ in V)))).free_symbols & Fd.free_symbols\n    if not more_free:\n        solution = _integrate('Q')\n        if solution is None:\n            solution = _integrate()\n    else:\n        solution = _integrate()\n    if solution is not None:\n        antideriv = solution.subs(rev_mapping)\n        antideriv = cancel(antideriv).expand()\n        if antideriv.is_Add:\n            antideriv = antideriv.as_independent(x)[1]\n        return indep * antideriv\n    else:\n        if retries >= 0:\n            result = heurisch(f, x, mappings=mappings, rewrite=rewrite, hints=hints, retries=retries - 1, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None",
            "def heurisch(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Compute indefinite integral using heuristic Risch algorithm.\\n\\n    Explanation\\n    ===========\\n\\n    This is a heuristic approach to indefinite integration in finite\\n    terms using the extended heuristic (parallel) Risch algorithm, based\\n    on Manuel Bronstein\\'s \"Poor Man\\'s Integrator\".\\n\\n    The algorithm supports various classes of functions including\\n    transcendental elementary or special functions like Airy,\\n    Bessel, Whittaker and Lambert.\\n\\n    Note that this algorithm is not a decision procedure. If it isn\\'t\\n    able to compute the antiderivative for a given function, then this is\\n    not a proof that such a functions does not exist.  One should use\\n    recursive Risch algorithm in such case.  It\\'s an open question if\\n    this algorithm can be made a full decision procedure.\\n\\n    This is an internal integrator procedure. You should use top level\\n    \\'integrate\\' function in most cases, as this procedure needs some\\n    preprocessing steps and otherwise may fail.\\n\\n    Specification\\n    =============\\n\\n     heurisch(f, x, rewrite=False, hints=None)\\n\\n       where\\n         f : expression\\n         x : symbol\\n\\n         rewrite -> force rewrite \\'f\\' in terms of \\'tan\\' and \\'tanh\\'\\n         hints   -> a list of functions that may appear in anti-derivate\\n\\n          - hints = None          --> no suggestions at all\\n          - hints = [ ]           --> try to figure out\\n          - hints = [f1, ..., fn] --> we know better\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy import tan\\n    >>> from sympy.integrals.heurisch import heurisch\\n    >>> from sympy.abc import x, y\\n\\n    >>> heurisch(y*tan(x), x)\\n    y*log(tan(x)**2 + 1)/2\\n\\n    See Manuel Bronstein\\'s \"Poor Man\\'s Integrator\":\\n\\n    References\\n    ==========\\n\\n    .. [1] https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html\\n\\n    For more information on the implemented algorithm refer to:\\n\\n    .. [2] K. Geddes, L. Stefanus, On the Risch-Norman Integration\\n       Method and its Implementation in Maple, Proceedings of\\n       ISSAC\\'89, ACM Press, 212-217.\\n\\n    .. [3] J. H. Davenport, On the Parallel Risch Algorithm (I),\\n       Proceedings of EUROCAM\\'82, LNCS 144, Springer, 144-157.\\n\\n    .. [4] J. H. Davenport, On the Parallel Risch Algorithm (III):\\n       Use of Tangents, SIGSAM Bulletin 16 (1982), 3-6.\\n\\n    .. [5] J. H. Davenport, B. M. Trager, On the Parallel Risch\\n       Algorithm (II), ACM Transactions on Mathematical\\n       Software 11 (1985), 356-362.\\n\\n    See Also\\n    ========\\n\\n    sympy.integrals.integrals.Integral.doit\\n    sympy.integrals.integrals.Integral\\n    sympy.integrals.heurisch.components\\n    '\n    f = sympify(f)\n    if _try_heurisch is not True:\n        if f.has(Abs, re, im, sign, Heaviside, DiracDelta, floor, ceiling, arg):\n            return\n    if not f.has_free(x):\n        return f * x\n    if not f.is_Add:\n        (indep, f) = f.as_independent(x)\n    else:\n        indep = S.One\n    rewritables = {(sin, cos, cot): tan, (sinh, cosh, coth): tanh}\n    if rewrite:\n        for (candidates, rule) in rewritables.items():\n            f = f.rewrite(candidates, rule)\n    else:\n        for candidates in rewritables.keys():\n            if f.has(*candidates):\n                break\n        else:\n            rewrite = True\n    terms = components(f, x)\n    dcache = DiffCache(x)\n    if hints is not None:\n        if not hints:\n            a = Wild('a', exclude=[x])\n            b = Wild('b', exclude=[x])\n            c = Wild('c', exclude=[x])\n            for g in set(terms):\n                if g.is_Function:\n                    if isinstance(g, li):\n                        M = g.args[0].match(a * x ** b)\n                        if M is not None:\n                            terms.add(x * (li(M[a] * x ** M[b]) - (M[a] * x ** M[b]) ** (-1 / M[b]) * Ei((M[b] + 1) * log(M[a] * x ** M[b]) / M[b])))\n                    elif isinstance(g, exp):\n                        M = g.args[0].match(a * x ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * x))\n                            else:\n                                terms.add(erf(sqrt(-M[a]) * x))\n                        M = g.args[0].match(a * x ** 2 + b * x + c)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erfi(sqrt(M[a]) * x + M[b] / (2 * sqrt(M[a]))))\n                            elif M[a].is_negative:\n                                terms.add(sqrt(pi / 4 * -M[a]) * exp(M[c] - M[b] ** 2 / (4 * M[a])) * erf(sqrt(-M[a]) * x - M[b] / (2 * sqrt(-M[a]))))\n                        M = g.args[0].match(a * log(x) ** 2)\n                        if M is not None:\n                            if M[a].is_positive:\n                                terms.add(erfi(sqrt(M[a]) * log(x) + 1 / (2 * sqrt(M[a]))))\n                            if M[a].is_negative:\n                                terms.add(erf(sqrt(-M[a]) * log(x) - 1 / (2 * sqrt(-M[a]))))\n                elif g.is_Pow:\n                    if g.exp.is_Rational and g.exp.q == 2:\n                        M = g.base.match(a * x ** 2 + b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                terms.add(asinh(sqrt(M[a] / M[b]) * x))\n                            elif M[a].is_negative:\n                                terms.add(asin(sqrt(-M[a] / M[b]) * x))\n                        M = g.base.match(a * x ** 2 - b)\n                        if M is not None and M[b].is_positive:\n                            if M[a].is_positive:\n                                dF = 1 / sqrt(M[a] * x ** 2 - M[b])\n                                F = log(2 * sqrt(M[a]) * sqrt(M[a] * x ** 2 - M[b]) + 2 * M[a] * x) / sqrt(M[a])\n                                dcache.cache[F] = dF\n                                terms.add(F)\n                            elif M[a].is_negative:\n                                terms.add(-M[b] / 2 * sqrt(-M[a]) * atan(sqrt(-M[a]) * x / sqrt(M[a] * x ** 2 - M[b])))\n        else:\n            terms |= set(hints)\n    for g in set(terms):\n        terms |= components(dcache.get_diff(g), x)\n    V = _symbols('x', len(terms))\n    mapping = list(reversed(list(zip(*ordered([(a[0].as_independent(x)[1], a) for a in zip(terms, V)])))[1]))\n    rev_mapping = {v: k for (k, v) in mapping}\n    if mappings is None:\n        assert mapping[-1][0] == x\n        unnecessary_permutations = [mapping.pop(-1)]\n        mappings = permutations(mapping)\n    else:\n        unnecessary_permutations = unnecessary_permutations or []\n\n    def _substitute(expr):\n        return expr.subs(mapping)\n    for mapping in mappings:\n        mapping = list(mapping)\n        mapping = mapping + unnecessary_permutations\n        diffs = [_substitute(dcache.get_diff(g)) for g in terms]\n        denoms = [g.as_numer_denom()[1] for g in diffs]\n        if all((h.is_polynomial(*V) for h in denoms)) and _substitute(f).is_rational_function(*V):\n            denom = reduce(lambda p, q: lcm(p, q, *V), denoms)\n            break\n    else:\n        if not rewrite:\n            result = heurisch(f, x, rewrite=True, hints=hints, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None\n    numers = [cancel(denom * g) for g in diffs]\n\n    def _derivation(h):\n        return Add(*[d * h.diff(v) for (d, v) in zip(numers, V)])\n\n    def _deflation(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(p) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                return _deflation(c) * gcd(q, q.diff(y)).as_expr()\n        return p\n\n    def _splitter(p):\n        for y in V:\n            if not p.has(y):\n                continue\n            if _derivation(y) is not S.Zero:\n                (c, q) = p.as_poly(y).primitive()\n                q = q.as_expr()\n                h = gcd(q, _derivation(q), y)\n                s = quo(h, gcd(q, q.diff(y), y), y)\n                c_split = _splitter(c)\n                if s.as_poly(y).degree() == 0:\n                    return (c_split[0], q * c_split[1])\n                q_split = _splitter(cancel(q / s))\n                return (c_split[0] * q_split[0] * s, c_split[1] * q_split[1])\n        return (S.One, p)\n    special = {}\n    for term in terms:\n        if term.is_Function:\n            if isinstance(term, tan):\n                special[1 + _substitute(term) ** 2] = False\n            elif isinstance(term, tanh):\n                special[1 + _substitute(term)] = False\n                special[1 - _substitute(term)] = False\n            elif isinstance(term, LambertW):\n                special[_substitute(term)] = True\n    F = _substitute(f)\n    (P, Q) = F.as_numer_denom()\n    u_split = _splitter(denom)\n    v_split = _splitter(Q)\n    polys = set(list(v_split) + [u_split[0]] + list(special.keys()))\n    s = u_split[0] * Mul(*[k for (k, v) in special.items() if v])\n    polified = [p.as_poly(*V) for p in [s, P, Q]]\n    if None in polified:\n        return None\n    (a, b, c) = [p.total_degree() for p in polified]\n    poly_denom = (s * v_split[0] * _deflation(v_split[1])).as_expr()\n\n    def _exponent(g):\n        if g.is_Pow:\n            if g.exp.is_Rational and g.exp.q != 1:\n                if g.exp.p > 0:\n                    return g.exp.p + g.exp.q - 1\n                else:\n                    return abs(g.exp.p + g.exp.q)\n            else:\n                return 1\n        elif not g.is_Atom and g.args:\n            return max([_exponent(h) for h in g.args])\n        else:\n            return 1\n    (A, B) = (_exponent(f), a + max(b, c))\n    if A > 1 and B > 1:\n        monoms = tuple(ordered(itermonomials(V, A + B - 1 + degree_offset)))\n    else:\n        monoms = tuple(ordered(itermonomials(V, A + B + degree_offset)))\n    poly_coeffs = _symbols('A', len(monoms))\n    poly_part = Add(*[poly_coeffs[i] * monomial for (i, monomial) in enumerate(monoms)])\n    reducibles = set()\n    for poly in ordered(polys):\n        (coeff, factors) = factor_list(poly, *V)\n        reducibles.add(coeff)\n        for (fact, mul) in factors:\n            reducibles.add(fact)\n\n    def _integrate(field=None):\n        atans = set()\n        pairs = set()\n        if field == 'Q':\n            irreducibles = set(reducibles)\n        else:\n            setV = set(V)\n            irreducibles = set()\n            for poly in ordered(reducibles):\n                zV = setV & set(iterfreeargs(poly))\n                for z in ordered(zV):\n                    s = set(root_factors(poly, z, filter=field))\n                    irreducibles |= s\n                    break\n        (log_part, atan_part) = ([], [])\n        for poly in ordered(irreducibles):\n            m = collect(poly, I, evaluate=False)\n            y = m.get(I, S.Zero)\n            if y:\n                x = m.get(S.One, S.Zero)\n                if x.has(I) or y.has(I):\n                    continue\n                pairs.add((x, y))\n                irreducibles.remove(poly)\n        while pairs:\n            (x, y) = pairs.pop()\n            if (x, -y) in pairs:\n                pairs.remove((x, -y))\n                if y.could_extract_minus_sign():\n                    y = -y\n                irreducibles.add(x * x + y * y)\n                atans.add(atan(x / y))\n            else:\n                irreducibles.add(x + I * y)\n        B = _symbols('B', len(irreducibles))\n        C = _symbols('C', len(atans))\n        for (poly, b) in reversed(list(zip(ordered(irreducibles), B))):\n            if poly.has(*V):\n                poly_coeffs.append(b)\n                log_part.append(b * log(poly))\n        for (poly, c) in reversed(list(zip(ordered(atans), C))):\n            if poly.has(*V):\n                poly_coeffs.append(c)\n                atan_part.append(c * poly)\n        candidate = poly_part / poly_denom + Add(*log_part) + Add(*atan_part)\n        h = F - _derivation(candidate) / denom\n        raw_numer = h.as_numer_denom()[0]\n        syms = set(poly_coeffs) | set(V)\n        non_syms = set()\n\n        def find_non_syms(expr):\n            if expr.is_Integer or expr.is_Rational:\n                pass\n            elif expr in syms:\n                pass\n            elif not expr.has_free(*syms):\n                non_syms.add(expr)\n            elif expr.is_Add or expr.is_Mul or expr.is_Pow:\n                list(map(find_non_syms, expr.args))\n            else:\n                raise PolynomialError\n        try:\n            find_non_syms(raw_numer)\n        except PolynomialError:\n            return None\n        else:\n            (ground, _) = construct_domain(non_syms, field=True)\n        coeff_ring = PolyRing(poly_coeffs, ground)\n        ring = PolyRing(V, coeff_ring)\n        try:\n            numer = ring.from_expr(raw_numer)\n        except ValueError:\n            raise PolynomialError\n        solution = solve_lin_sys(numer.coeffs(), coeff_ring, _raw=False)\n        if solution is None:\n            return None\n        else:\n            return candidate.xreplace(solution).xreplace(dict(zip(poly_coeffs, [S.Zero] * len(poly_coeffs))))\n    if all((isinstance(_, Symbol) for _ in V)):\n        more_free = F.free_symbols - set(V)\n    else:\n        Fd = F.as_dummy()\n        more_free = Fd.xreplace(dict(zip(V, (Dummy() for _ in V)))).free_symbols & Fd.free_symbols\n    if not more_free:\n        solution = _integrate('Q')\n        if solution is None:\n            solution = _integrate()\n    else:\n        solution = _integrate()\n    if solution is not None:\n        antideriv = solution.subs(rev_mapping)\n        antideriv = cancel(antideriv).expand()\n        if antideriv.is_Add:\n            antideriv = antideriv.as_independent(x)[1]\n        return indep * antideriv\n    else:\n        if retries >= 0:\n            result = heurisch(f, x, mappings=mappings, rewrite=rewrite, hints=hints, retries=retries - 1, unnecessary_permutations=unnecessary_permutations)\n            if result is not None:\n                return indep * result\n        return None"
        ]
    }
]