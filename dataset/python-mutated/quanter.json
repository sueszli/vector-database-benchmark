[
    {
        "func_name": "load_dict",
        "original": "def load_dict():\n    with open(VARS_MAPPING_TABLE, 'r') as file:\n        data = file.read()\n        data = json.loads(data)\n        return data",
        "mutated": [
            "def load_dict():\n    if False:\n        i = 10\n    with open(VARS_MAPPING_TABLE, 'r') as file:\n        data = file.read()\n        data = json.loads(data)\n        return data",
            "def load_dict():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(VARS_MAPPING_TABLE, 'r') as file:\n        data = file.read()\n        data = json.loads(data)\n        return data",
            "def load_dict():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(VARS_MAPPING_TABLE, 'r') as file:\n        data = file.read()\n        data = json.loads(data)\n        return data",
            "def load_dict():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(VARS_MAPPING_TABLE, 'r') as file:\n        data = file.read()\n        data = json.loads(data)\n        return data",
            "def load_dict():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(VARS_MAPPING_TABLE, 'r') as file:\n        data = file.read()\n        data = json.loads(data)\n        return data"
        ]
    },
    {
        "func_name": "save_dict",
        "original": "def save_dict(table):\n    with open(VARS_MAPPING_TABLE, 'w') as file:\n        file.write(json.dumps(table))",
        "mutated": [
            "def save_dict(table):\n    if False:\n        i = 10\n    with open(VARS_MAPPING_TABLE, 'w') as file:\n        file.write(json.dumps(table))",
            "def save_dict(table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    with open(VARS_MAPPING_TABLE, 'w') as file:\n        file.write(json.dumps(table))",
            "def save_dict(table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    with open(VARS_MAPPING_TABLE, 'w') as file:\n        file.write(json.dumps(table))",
            "def save_dict(table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    with open(VARS_MAPPING_TABLE, 'w') as file:\n        file.write(json.dumps(table))",
            "def save_dict(table):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    with open(VARS_MAPPING_TABLE, 'w') as file:\n        file.write(json.dumps(table))"
        ]
    },
    {
        "func_name": "_parse_configs",
        "original": "def _parse_configs(user_config):\n    \"\"\"\n    check if user's configs are valid.\n    Args:\n        user_config(dict): user's config.\n    Return:\n        configs(dict): final configs will be used.\n    \"\"\"\n    configs = copy.deepcopy(_quant_config_default)\n    configs.update(user_config)\n    assert isinstance(configs['for_tensorrt'], bool) and isinstance(configs['is_full_quantize'], bool), \"'for_tensorrt' and 'is_full_quantize' must both be bool'\"\n    if configs['for_tensorrt']:\n        weight_types = WEIGHT_QUANTIZATION_TYPES_TENSORRT\n        activation_types = ACTIVATION_QUANTIZATION_TYPES_TENSORRT\n        platform = 'TensorRT'\n    else:\n        weight_types = WEIGHT_QUANTIZATION_TYPES\n        activation_types = WEIGHT_QUANTIZATION_TYPES\n        platform = 'PaddleLite'\n    assert configs['weight_quantize_type'] in weight_types, 'Unknown weight_quantize_type: {}. {} only supports {} '.format(configs['weight_quantize_type'], platform, weight_types)\n    assert configs['activation_quantize_type'] in activation_types, 'Unknown activation_quantize_type: {}. {} only supports {}'.format(configs['activation_quantize_type'], platform, activation_types)\n    assert isinstance(configs['weight_bits'], int), 'weight_bits must be int value.'\n    assert configs['weight_bits'] >= 1 and configs['weight_bits'] <= 16, 'weight_bits should be between 1 and 16.'\n    assert isinstance(configs['activation_bits'], int), 'activation_bits must be int value.'\n    assert configs['activation_bits'] >= 1 and configs['activation_bits'] <= 16, 'activation_bits should be between 1 and 16.'\n    assert isinstance(configs['not_quant_pattern'], (list, str)), 'not_quant_pattern must be list or str'\n    assert isinstance(configs['quantize_op_types'], list), 'quantize_op_types must be a list'\n    if configs['for_tensorrt']:\n        configs['quantize_op_types'] = TENSORRT_OP_TYPES\n    elif configs['is_full_quantize']:\n        configs['quantize_op_types'] = TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES\n    else:\n        for op_type in configs['quantize_op_types']:\n            assert op_type in QUANT_DEQUANT_PASS_OP_TYPES or op_type in TRANSFORM_PASS_OP_TYPES, '{} is not support,                         now support op types are {}'.format(op_type, TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES)\n    assert isinstance(configs['dtype'], str), 'dtype must be a str.'\n    assert configs['dtype'] in VALID_DTYPES, 'dtype can only be ' + ' '.join(VALID_DTYPES)\n    assert isinstance(configs['window_size'], int), \"window_size must be int value, window size for 'range_abs_max' quantization, default is 10000.\"\n    assert isinstance(configs['moving_rate'], float), 'moving_rate must be float value, The decay coefficient of moving average, default is 0.9.'\n    return configs",
        "mutated": [
            "def _parse_configs(user_config):\n    if False:\n        i = 10\n    \"\\n    check if user's configs are valid.\\n    Args:\\n        user_config(dict): user's config.\\n    Return:\\n        configs(dict): final configs will be used.\\n    \"\n    configs = copy.deepcopy(_quant_config_default)\n    configs.update(user_config)\n    assert isinstance(configs['for_tensorrt'], bool) and isinstance(configs['is_full_quantize'], bool), \"'for_tensorrt' and 'is_full_quantize' must both be bool'\"\n    if configs['for_tensorrt']:\n        weight_types = WEIGHT_QUANTIZATION_TYPES_TENSORRT\n        activation_types = ACTIVATION_QUANTIZATION_TYPES_TENSORRT\n        platform = 'TensorRT'\n    else:\n        weight_types = WEIGHT_QUANTIZATION_TYPES\n        activation_types = WEIGHT_QUANTIZATION_TYPES\n        platform = 'PaddleLite'\n    assert configs['weight_quantize_type'] in weight_types, 'Unknown weight_quantize_type: {}. {} only supports {} '.format(configs['weight_quantize_type'], platform, weight_types)\n    assert configs['activation_quantize_type'] in activation_types, 'Unknown activation_quantize_type: {}. {} only supports {}'.format(configs['activation_quantize_type'], platform, activation_types)\n    assert isinstance(configs['weight_bits'], int), 'weight_bits must be int value.'\n    assert configs['weight_bits'] >= 1 and configs['weight_bits'] <= 16, 'weight_bits should be between 1 and 16.'\n    assert isinstance(configs['activation_bits'], int), 'activation_bits must be int value.'\n    assert configs['activation_bits'] >= 1 and configs['activation_bits'] <= 16, 'activation_bits should be between 1 and 16.'\n    assert isinstance(configs['not_quant_pattern'], (list, str)), 'not_quant_pattern must be list or str'\n    assert isinstance(configs['quantize_op_types'], list), 'quantize_op_types must be a list'\n    if configs['for_tensorrt']:\n        configs['quantize_op_types'] = TENSORRT_OP_TYPES\n    elif configs['is_full_quantize']:\n        configs['quantize_op_types'] = TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES\n    else:\n        for op_type in configs['quantize_op_types']:\n            assert op_type in QUANT_DEQUANT_PASS_OP_TYPES or op_type in TRANSFORM_PASS_OP_TYPES, '{} is not support,                         now support op types are {}'.format(op_type, TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES)\n    assert isinstance(configs['dtype'], str), 'dtype must be a str.'\n    assert configs['dtype'] in VALID_DTYPES, 'dtype can only be ' + ' '.join(VALID_DTYPES)\n    assert isinstance(configs['window_size'], int), \"window_size must be int value, window size for 'range_abs_max' quantization, default is 10000.\"\n    assert isinstance(configs['moving_rate'], float), 'moving_rate must be float value, The decay coefficient of moving average, default is 0.9.'\n    return configs",
            "def _parse_configs(user_config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    check if user's configs are valid.\\n    Args:\\n        user_config(dict): user's config.\\n    Return:\\n        configs(dict): final configs will be used.\\n    \"\n    configs = copy.deepcopy(_quant_config_default)\n    configs.update(user_config)\n    assert isinstance(configs['for_tensorrt'], bool) and isinstance(configs['is_full_quantize'], bool), \"'for_tensorrt' and 'is_full_quantize' must both be bool'\"\n    if configs['for_tensorrt']:\n        weight_types = WEIGHT_QUANTIZATION_TYPES_TENSORRT\n        activation_types = ACTIVATION_QUANTIZATION_TYPES_TENSORRT\n        platform = 'TensorRT'\n    else:\n        weight_types = WEIGHT_QUANTIZATION_TYPES\n        activation_types = WEIGHT_QUANTIZATION_TYPES\n        platform = 'PaddleLite'\n    assert configs['weight_quantize_type'] in weight_types, 'Unknown weight_quantize_type: {}. {} only supports {} '.format(configs['weight_quantize_type'], platform, weight_types)\n    assert configs['activation_quantize_type'] in activation_types, 'Unknown activation_quantize_type: {}. {} only supports {}'.format(configs['activation_quantize_type'], platform, activation_types)\n    assert isinstance(configs['weight_bits'], int), 'weight_bits must be int value.'\n    assert configs['weight_bits'] >= 1 and configs['weight_bits'] <= 16, 'weight_bits should be between 1 and 16.'\n    assert isinstance(configs['activation_bits'], int), 'activation_bits must be int value.'\n    assert configs['activation_bits'] >= 1 and configs['activation_bits'] <= 16, 'activation_bits should be between 1 and 16.'\n    assert isinstance(configs['not_quant_pattern'], (list, str)), 'not_quant_pattern must be list or str'\n    assert isinstance(configs['quantize_op_types'], list), 'quantize_op_types must be a list'\n    if configs['for_tensorrt']:\n        configs['quantize_op_types'] = TENSORRT_OP_TYPES\n    elif configs['is_full_quantize']:\n        configs['quantize_op_types'] = TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES\n    else:\n        for op_type in configs['quantize_op_types']:\n            assert op_type in QUANT_DEQUANT_PASS_OP_TYPES or op_type in TRANSFORM_PASS_OP_TYPES, '{} is not support,                         now support op types are {}'.format(op_type, TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES)\n    assert isinstance(configs['dtype'], str), 'dtype must be a str.'\n    assert configs['dtype'] in VALID_DTYPES, 'dtype can only be ' + ' '.join(VALID_DTYPES)\n    assert isinstance(configs['window_size'], int), \"window_size must be int value, window size for 'range_abs_max' quantization, default is 10000.\"\n    assert isinstance(configs['moving_rate'], float), 'moving_rate must be float value, The decay coefficient of moving average, default is 0.9.'\n    return configs",
            "def _parse_configs(user_config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    check if user's configs are valid.\\n    Args:\\n        user_config(dict): user's config.\\n    Return:\\n        configs(dict): final configs will be used.\\n    \"\n    configs = copy.deepcopy(_quant_config_default)\n    configs.update(user_config)\n    assert isinstance(configs['for_tensorrt'], bool) and isinstance(configs['is_full_quantize'], bool), \"'for_tensorrt' and 'is_full_quantize' must both be bool'\"\n    if configs['for_tensorrt']:\n        weight_types = WEIGHT_QUANTIZATION_TYPES_TENSORRT\n        activation_types = ACTIVATION_QUANTIZATION_TYPES_TENSORRT\n        platform = 'TensorRT'\n    else:\n        weight_types = WEIGHT_QUANTIZATION_TYPES\n        activation_types = WEIGHT_QUANTIZATION_TYPES\n        platform = 'PaddleLite'\n    assert configs['weight_quantize_type'] in weight_types, 'Unknown weight_quantize_type: {}. {} only supports {} '.format(configs['weight_quantize_type'], platform, weight_types)\n    assert configs['activation_quantize_type'] in activation_types, 'Unknown activation_quantize_type: {}. {} only supports {}'.format(configs['activation_quantize_type'], platform, activation_types)\n    assert isinstance(configs['weight_bits'], int), 'weight_bits must be int value.'\n    assert configs['weight_bits'] >= 1 and configs['weight_bits'] <= 16, 'weight_bits should be between 1 and 16.'\n    assert isinstance(configs['activation_bits'], int), 'activation_bits must be int value.'\n    assert configs['activation_bits'] >= 1 and configs['activation_bits'] <= 16, 'activation_bits should be between 1 and 16.'\n    assert isinstance(configs['not_quant_pattern'], (list, str)), 'not_quant_pattern must be list or str'\n    assert isinstance(configs['quantize_op_types'], list), 'quantize_op_types must be a list'\n    if configs['for_tensorrt']:\n        configs['quantize_op_types'] = TENSORRT_OP_TYPES\n    elif configs['is_full_quantize']:\n        configs['quantize_op_types'] = TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES\n    else:\n        for op_type in configs['quantize_op_types']:\n            assert op_type in QUANT_DEQUANT_PASS_OP_TYPES or op_type in TRANSFORM_PASS_OP_TYPES, '{} is not support,                         now support op types are {}'.format(op_type, TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES)\n    assert isinstance(configs['dtype'], str), 'dtype must be a str.'\n    assert configs['dtype'] in VALID_DTYPES, 'dtype can only be ' + ' '.join(VALID_DTYPES)\n    assert isinstance(configs['window_size'], int), \"window_size must be int value, window size for 'range_abs_max' quantization, default is 10000.\"\n    assert isinstance(configs['moving_rate'], float), 'moving_rate must be float value, The decay coefficient of moving average, default is 0.9.'\n    return configs",
            "def _parse_configs(user_config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    check if user's configs are valid.\\n    Args:\\n        user_config(dict): user's config.\\n    Return:\\n        configs(dict): final configs will be used.\\n    \"\n    configs = copy.deepcopy(_quant_config_default)\n    configs.update(user_config)\n    assert isinstance(configs['for_tensorrt'], bool) and isinstance(configs['is_full_quantize'], bool), \"'for_tensorrt' and 'is_full_quantize' must both be bool'\"\n    if configs['for_tensorrt']:\n        weight_types = WEIGHT_QUANTIZATION_TYPES_TENSORRT\n        activation_types = ACTIVATION_QUANTIZATION_TYPES_TENSORRT\n        platform = 'TensorRT'\n    else:\n        weight_types = WEIGHT_QUANTIZATION_TYPES\n        activation_types = WEIGHT_QUANTIZATION_TYPES\n        platform = 'PaddleLite'\n    assert configs['weight_quantize_type'] in weight_types, 'Unknown weight_quantize_type: {}. {} only supports {} '.format(configs['weight_quantize_type'], platform, weight_types)\n    assert configs['activation_quantize_type'] in activation_types, 'Unknown activation_quantize_type: {}. {} only supports {}'.format(configs['activation_quantize_type'], platform, activation_types)\n    assert isinstance(configs['weight_bits'], int), 'weight_bits must be int value.'\n    assert configs['weight_bits'] >= 1 and configs['weight_bits'] <= 16, 'weight_bits should be between 1 and 16.'\n    assert isinstance(configs['activation_bits'], int), 'activation_bits must be int value.'\n    assert configs['activation_bits'] >= 1 and configs['activation_bits'] <= 16, 'activation_bits should be between 1 and 16.'\n    assert isinstance(configs['not_quant_pattern'], (list, str)), 'not_quant_pattern must be list or str'\n    assert isinstance(configs['quantize_op_types'], list), 'quantize_op_types must be a list'\n    if configs['for_tensorrt']:\n        configs['quantize_op_types'] = TENSORRT_OP_TYPES\n    elif configs['is_full_quantize']:\n        configs['quantize_op_types'] = TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES\n    else:\n        for op_type in configs['quantize_op_types']:\n            assert op_type in QUANT_DEQUANT_PASS_OP_TYPES or op_type in TRANSFORM_PASS_OP_TYPES, '{} is not support,                         now support op types are {}'.format(op_type, TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES)\n    assert isinstance(configs['dtype'], str), 'dtype must be a str.'\n    assert configs['dtype'] in VALID_DTYPES, 'dtype can only be ' + ' '.join(VALID_DTYPES)\n    assert isinstance(configs['window_size'], int), \"window_size must be int value, window size for 'range_abs_max' quantization, default is 10000.\"\n    assert isinstance(configs['moving_rate'], float), 'moving_rate must be float value, The decay coefficient of moving average, default is 0.9.'\n    return configs",
            "def _parse_configs(user_config):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    check if user's configs are valid.\\n    Args:\\n        user_config(dict): user's config.\\n    Return:\\n        configs(dict): final configs will be used.\\n    \"\n    configs = copy.deepcopy(_quant_config_default)\n    configs.update(user_config)\n    assert isinstance(configs['for_tensorrt'], bool) and isinstance(configs['is_full_quantize'], bool), \"'for_tensorrt' and 'is_full_quantize' must both be bool'\"\n    if configs['for_tensorrt']:\n        weight_types = WEIGHT_QUANTIZATION_TYPES_TENSORRT\n        activation_types = ACTIVATION_QUANTIZATION_TYPES_TENSORRT\n        platform = 'TensorRT'\n    else:\n        weight_types = WEIGHT_QUANTIZATION_TYPES\n        activation_types = WEIGHT_QUANTIZATION_TYPES\n        platform = 'PaddleLite'\n    assert configs['weight_quantize_type'] in weight_types, 'Unknown weight_quantize_type: {}. {} only supports {} '.format(configs['weight_quantize_type'], platform, weight_types)\n    assert configs['activation_quantize_type'] in activation_types, 'Unknown activation_quantize_type: {}. {} only supports {}'.format(configs['activation_quantize_type'], platform, activation_types)\n    assert isinstance(configs['weight_bits'], int), 'weight_bits must be int value.'\n    assert configs['weight_bits'] >= 1 and configs['weight_bits'] <= 16, 'weight_bits should be between 1 and 16.'\n    assert isinstance(configs['activation_bits'], int), 'activation_bits must be int value.'\n    assert configs['activation_bits'] >= 1 and configs['activation_bits'] <= 16, 'activation_bits should be between 1 and 16.'\n    assert isinstance(configs['not_quant_pattern'], (list, str)), 'not_quant_pattern must be list or str'\n    assert isinstance(configs['quantize_op_types'], list), 'quantize_op_types must be a list'\n    if configs['for_tensorrt']:\n        configs['quantize_op_types'] = TENSORRT_OP_TYPES\n    elif configs['is_full_quantize']:\n        configs['quantize_op_types'] = TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES\n    else:\n        for op_type in configs['quantize_op_types']:\n            assert op_type in QUANT_DEQUANT_PASS_OP_TYPES or op_type in TRANSFORM_PASS_OP_TYPES, '{} is not support,                         now support op types are {}'.format(op_type, TRANSFORM_PASS_OP_TYPES + QUANT_DEQUANT_PASS_OP_TYPES)\n    assert isinstance(configs['dtype'], str), 'dtype must be a str.'\n    assert configs['dtype'] in VALID_DTYPES, 'dtype can only be ' + ' '.join(VALID_DTYPES)\n    assert isinstance(configs['window_size'], int), \"window_size must be int value, window size for 'range_abs_max' quantization, default is 10000.\"\n    assert isinstance(configs['moving_rate'], float), 'moving_rate must be float value, The decay coefficient of moving average, default is 0.9.'\n    return configs"
        ]
    },
    {
        "func_name": "quant_aware",
        "original": "def quant_aware(program, place, config=None, scope=None, for_test=False, weight_quantize_func=None, act_quantize_func=None, weight_preprocess_func=None, act_preprocess_func=None, optimizer_func=None, executor=None, return_program=False, calib_config={}, draw_graph=False, return_scale_dict=False, scale_dict=None, model_type=None, pattern_ops=None):\n    \"\"\"Add quantization  and dequantization operators to \"program\"\n    for quantization training or testing.\n    Args:\n        program(paddle.static.Program): training or testing ``program``.\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\n            the executor run on which device.\n        config(dict, optional): configs for quantization. if None, will use default config.\n            Default: None.\n        scope(paddle.static.Scope): Scope records the mapping between variable names and variables,\n            similar to brackets in programming languages. Usually users can use\n            `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\n            When ``None`` will use `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_ .\n            Default: ``None``.\n        for_test(bool): If the 'program' parameter is a test program, this parameter should be set to ``True``.\n            Otherwise, set to ``False``.Default: False\n        weight_quantize_func(function): Function that defines how to quantize weight. Using this\n                can quickly test if user's quantization method works or not. In this function, user should\n                both define quantization function and dequantization function, that is, the function's input\n                is non-quantized weight and function returns dequantized weight. If None, will use\n                quantization op defined by 'weight_quantize_type'.\n                Default is None.\n        act_quantize_func(function): Function that defines how to quantize activation. Using this\n                can quickly test if user's quantization method works or not. In this function, user should\n                both define quantization and dequantization process, that is, the function's input\n                is non-quantized activation and function returns dequantized activation. If None, will use\n                quantization op defined by 'activation_quantize_type'.\n                Default is None.\n        weight_preprocess_func(function): Function that defines how to preprocess weight before quantization. Using this\n                can quickly test if user's preprocess method works or not. The function's input\n                is non-quantized weight and function returns processed weight to be quantized. If None, the weight will\n                be quantized directly.\n                Default is None.\n        act_preprocess_func(function): Function that defines how to preprocess activation before quantization. Using this\n                can quickly test if user's preprocess method works or not. The function's input\n                is non-quantized activation and function returns processed activation to be quantized. If None, the activation will\n                be quantized directly.\n                Default is None.\n        optimizer_func(function): Fuction return a optimizer. When 'is_test' is False and user want to use self-defined\n            quantization function and preprocess function, this function must be set. Default is None.\n        exe(paddle.static.Executor): If user want to use self-defined quantization function and preprocess function, exe must be set for\n                initialization. Default is None.\n        return_program(bool): If user want return value is a Program rather than Compiled Program, This argument should be set True.\n                Default is False.\n        draw_graph(bool): whether to draw graph when quantization is initialized. In order to prevent cycle,\n                the ERNIE model needs to be set to True. Default is False.\n        return_scale_dict(bool): If user want to return scale dict, model_type and pattern_ops, this argument should be set True.\n                Default is False.\n        scale_dict(dict): Use scale dict to initialize scales in program. Default is None.\n        model_type(str): Model type can be 'transformer' or 'non-transformer'. If model type is transformer, patterns will be analyzed.\n                Default is None.\n        pattern_ops(dict): Pattern_ops contain pattern name and corresponding ops. Default is None.\n    Returns:\n        paddle.static.CompiledProgram | paddle.static.Program: Program with quantization and dequantization ``operators``\n    \"\"\"\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'quant_aware config {config}')\n    skip_tensor_list = []\n    same_scale_tensor_list = []\n    is_test = True if for_test else not config['scale_trainable']\n    if config['quant_post_first'] and for_test:\n        if 'quantizable_op_type' not in calib_config:\n            calib_config['quantizable_op_type'] = config['quantize_op_types']\n        exe = paddle.static.Executor() if executor is None else executor\n        post_training_quantization = PostTrainingQuantizationProgram(exe, program, freeze_model=False, skip_tensor_list=skip_tensor_list, same_scale_tensor_list=same_scale_tensor_list, batch_nums=10, scale_dict=scale_dict, return_graph=True, **calib_config)\n        main_graph = post_training_quantization.quantize()\n        scale_dict = post_training_quantization._scale_dict\n        sub_graphs = list(main_graph.all_sub_graphs())\n    else:\n        main_graph = IrGraph(core.Graph(program.desc), for_test=for_test)\n        sub_graphs = list(main_graph.all_sub_graphs())\n        transform_pass_ops = []\n        quant_dequant_ops = []\n        if 'quant_config' in config and config['quant_config']:\n            transform_pass_ops = config['quant_config'].weight_quant_operation_types\n            quant_dequant_ops = config['quant_config'].activation_quant_operation_types\n        else:\n            for op_type in config['quantize_op_types']:\n                if op_type in TRANSFORM_PASS_OP_TYPES:\n                    transform_pass_ops.append(op_type)\n                elif op_type in QUANT_DEQUANT_PASS_OP_TYPES:\n                    quant_dequant_ops.append(op_type)\n        if len(transform_pass_ops) > 0:\n            transform_func = QuantizationTransformPassV2 if config['onnx_format'] else QuantizationTransformPass\n            transform_pass = transform_func(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], activation_quantize_type=config['activation_quantize_type'], weight_quantize_type=config['weight_quantize_type'], window_size=config['window_size'], moving_rate=config['moving_rate'], quantizable_op_type=transform_pass_ops, skip_pattern=config['not_quant_pattern'], weight_quantize_func=weight_quantize_func, act_quantize_func=act_quantize_func, weight_preprocess_func=weight_preprocess_func, act_preprocess_func=act_preprocess_func, optimizer_func=optimizer_func, executor=executor, is_test=is_test)\n            for sub_graph in sub_graphs:\n                transform_pass.apply(sub_graph)\n        if len(quant_dequant_ops) > 0:\n            qdq_func = AddQuantDequantPassV2 if config['onnx_format'] else AddQuantDequantPass\n            quant_dequant_pass = qdq_func(scope=scope, place=place, moving_rate=config['moving_rate'], quant_bits=config['activation_bits'], skip_pattern=config['not_quant_pattern'], quantizable_op_type=quant_dequant_ops, is_test=is_test)\n            for sub_graph in sub_graphs:\n                quant_dequant_pass.apply(sub_graph)\n    out_scale_training_pass = OutScaleForTrainingPass(scope=scope, place=place, moving_rate=config['moving_rate'], is_test=is_test, scale_dict=scale_dict)\n    for sub_graph in sub_graphs:\n        out_scale_training_pass.apply(sub_graph)\n    if (weight_preprocess_func is not None or act_preprocess_func is not None) and (not for_test) and (not config['onnx_format']):\n        _logger.info('When a preprocess_func is used in quant_aware, Need to save a mapping table to match variable names in the convert phase.')\n        _logger.info(f\"The mapping table is saved as '{VARS_MAPPING_TABLE}'.\")\n        for sub_graph in sub_graphs:\n            save_dict(sub_graph.out_node_mapping_table)\n    if draw_graph:\n        main_graph.draw('./', 'graph.pdf')\n    if for_test or return_program:\n        quant_program = main_graph.to_program()\n    else:\n        quant_program = paddle.static.CompiledProgram(main_graph.graph)\n    if return_scale_dict:\n        return (quant_program, scale_dict, model_type, pattern_ops)\n    else:\n        return quant_program",
        "mutated": [
            "def quant_aware(program, place, config=None, scope=None, for_test=False, weight_quantize_func=None, act_quantize_func=None, weight_preprocess_func=None, act_preprocess_func=None, optimizer_func=None, executor=None, return_program=False, calib_config={}, draw_graph=False, return_scale_dict=False, scale_dict=None, model_type=None, pattern_ops=None):\n    if False:\n        i = 10\n    'Add quantization  and dequantization operators to \"program\"\\n    for quantization training or testing.\\n    Args:\\n        program(paddle.static.Program): training or testing ``program``.\\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\\n            the executor run on which device.\\n        config(dict, optional): configs for quantization. if None, will use default config.\\n            Default: None.\\n        scope(paddle.static.Scope): Scope records the mapping between variable names and variables,\\n            similar to brackets in programming languages. Usually users can use\\n            `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\\n            When ``None`` will use `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_ .\\n            Default: ``None``.\\n        for_test(bool): If the \\'program\\' parameter is a test program, this parameter should be set to ``True``.\\n            Otherwise, set to ``False``.Default: False\\n        weight_quantize_func(function): Function that defines how to quantize weight. Using this\\n                can quickly test if user\\'s quantization method works or not. In this function, user should\\n                both define quantization function and dequantization function, that is, the function\\'s input\\n                is non-quantized weight and function returns dequantized weight. If None, will use\\n                quantization op defined by \\'weight_quantize_type\\'.\\n                Default is None.\\n        act_quantize_func(function): Function that defines how to quantize activation. Using this\\n                can quickly test if user\\'s quantization method works or not. In this function, user should\\n                both define quantization and dequantization process, that is, the function\\'s input\\n                is non-quantized activation and function returns dequantized activation. If None, will use\\n                quantization op defined by \\'activation_quantize_type\\'.\\n                Default is None.\\n        weight_preprocess_func(function): Function that defines how to preprocess weight before quantization. Using this\\n                can quickly test if user\\'s preprocess method works or not. The function\\'s input\\n                is non-quantized weight and function returns processed weight to be quantized. If None, the weight will\\n                be quantized directly.\\n                Default is None.\\n        act_preprocess_func(function): Function that defines how to preprocess activation before quantization. Using this\\n                can quickly test if user\\'s preprocess method works or not. The function\\'s input\\n                is non-quantized activation and function returns processed activation to be quantized. If None, the activation will\\n                be quantized directly.\\n                Default is None.\\n        optimizer_func(function): Fuction return a optimizer. When \\'is_test\\' is False and user want to use self-defined\\n            quantization function and preprocess function, this function must be set. Default is None.\\n        exe(paddle.static.Executor): If user want to use self-defined quantization function and preprocess function, exe must be set for\\n                initialization. Default is None.\\n        return_program(bool): If user want return value is a Program rather than Compiled Program, This argument should be set True.\\n                Default is False.\\n        draw_graph(bool): whether to draw graph when quantization is initialized. In order to prevent cycle,\\n                the ERNIE model needs to be set to True. Default is False.\\n        return_scale_dict(bool): If user want to return scale dict, model_type and pattern_ops, this argument should be set True.\\n                Default is False.\\n        scale_dict(dict): Use scale dict to initialize scales in program. Default is None.\\n        model_type(str): Model type can be \\'transformer\\' or \\'non-transformer\\'. If model type is transformer, patterns will be analyzed.\\n                Default is None.\\n        pattern_ops(dict): Pattern_ops contain pattern name and corresponding ops. Default is None.\\n    Returns:\\n        paddle.static.CompiledProgram | paddle.static.Program: Program with quantization and dequantization ``operators``\\n    '\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'quant_aware config {config}')\n    skip_tensor_list = []\n    same_scale_tensor_list = []\n    is_test = True if for_test else not config['scale_trainable']\n    if config['quant_post_first'] and for_test:\n        if 'quantizable_op_type' not in calib_config:\n            calib_config['quantizable_op_type'] = config['quantize_op_types']\n        exe = paddle.static.Executor() if executor is None else executor\n        post_training_quantization = PostTrainingQuantizationProgram(exe, program, freeze_model=False, skip_tensor_list=skip_tensor_list, same_scale_tensor_list=same_scale_tensor_list, batch_nums=10, scale_dict=scale_dict, return_graph=True, **calib_config)\n        main_graph = post_training_quantization.quantize()\n        scale_dict = post_training_quantization._scale_dict\n        sub_graphs = list(main_graph.all_sub_graphs())\n    else:\n        main_graph = IrGraph(core.Graph(program.desc), for_test=for_test)\n        sub_graphs = list(main_graph.all_sub_graphs())\n        transform_pass_ops = []\n        quant_dequant_ops = []\n        if 'quant_config' in config and config['quant_config']:\n            transform_pass_ops = config['quant_config'].weight_quant_operation_types\n            quant_dequant_ops = config['quant_config'].activation_quant_operation_types\n        else:\n            for op_type in config['quantize_op_types']:\n                if op_type in TRANSFORM_PASS_OP_TYPES:\n                    transform_pass_ops.append(op_type)\n                elif op_type in QUANT_DEQUANT_PASS_OP_TYPES:\n                    quant_dequant_ops.append(op_type)\n        if len(transform_pass_ops) > 0:\n            transform_func = QuantizationTransformPassV2 if config['onnx_format'] else QuantizationTransformPass\n            transform_pass = transform_func(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], activation_quantize_type=config['activation_quantize_type'], weight_quantize_type=config['weight_quantize_type'], window_size=config['window_size'], moving_rate=config['moving_rate'], quantizable_op_type=transform_pass_ops, skip_pattern=config['not_quant_pattern'], weight_quantize_func=weight_quantize_func, act_quantize_func=act_quantize_func, weight_preprocess_func=weight_preprocess_func, act_preprocess_func=act_preprocess_func, optimizer_func=optimizer_func, executor=executor, is_test=is_test)\n            for sub_graph in sub_graphs:\n                transform_pass.apply(sub_graph)\n        if len(quant_dequant_ops) > 0:\n            qdq_func = AddQuantDequantPassV2 if config['onnx_format'] else AddQuantDequantPass\n            quant_dequant_pass = qdq_func(scope=scope, place=place, moving_rate=config['moving_rate'], quant_bits=config['activation_bits'], skip_pattern=config['not_quant_pattern'], quantizable_op_type=quant_dequant_ops, is_test=is_test)\n            for sub_graph in sub_graphs:\n                quant_dequant_pass.apply(sub_graph)\n    out_scale_training_pass = OutScaleForTrainingPass(scope=scope, place=place, moving_rate=config['moving_rate'], is_test=is_test, scale_dict=scale_dict)\n    for sub_graph in sub_graphs:\n        out_scale_training_pass.apply(sub_graph)\n    if (weight_preprocess_func is not None or act_preprocess_func is not None) and (not for_test) and (not config['onnx_format']):\n        _logger.info('When a preprocess_func is used in quant_aware, Need to save a mapping table to match variable names in the convert phase.')\n        _logger.info(f\"The mapping table is saved as '{VARS_MAPPING_TABLE}'.\")\n        for sub_graph in sub_graphs:\n            save_dict(sub_graph.out_node_mapping_table)\n    if draw_graph:\n        main_graph.draw('./', 'graph.pdf')\n    if for_test or return_program:\n        quant_program = main_graph.to_program()\n    else:\n        quant_program = paddle.static.CompiledProgram(main_graph.graph)\n    if return_scale_dict:\n        return (quant_program, scale_dict, model_type, pattern_ops)\n    else:\n        return quant_program",
            "def quant_aware(program, place, config=None, scope=None, for_test=False, weight_quantize_func=None, act_quantize_func=None, weight_preprocess_func=None, act_preprocess_func=None, optimizer_func=None, executor=None, return_program=False, calib_config={}, draw_graph=False, return_scale_dict=False, scale_dict=None, model_type=None, pattern_ops=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Add quantization  and dequantization operators to \"program\"\\n    for quantization training or testing.\\n    Args:\\n        program(paddle.static.Program): training or testing ``program``.\\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\\n            the executor run on which device.\\n        config(dict, optional): configs for quantization. if None, will use default config.\\n            Default: None.\\n        scope(paddle.static.Scope): Scope records the mapping between variable names and variables,\\n            similar to brackets in programming languages. Usually users can use\\n            `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\\n            When ``None`` will use `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_ .\\n            Default: ``None``.\\n        for_test(bool): If the \\'program\\' parameter is a test program, this parameter should be set to ``True``.\\n            Otherwise, set to ``False``.Default: False\\n        weight_quantize_func(function): Function that defines how to quantize weight. Using this\\n                can quickly test if user\\'s quantization method works or not. In this function, user should\\n                both define quantization function and dequantization function, that is, the function\\'s input\\n                is non-quantized weight and function returns dequantized weight. If None, will use\\n                quantization op defined by \\'weight_quantize_type\\'.\\n                Default is None.\\n        act_quantize_func(function): Function that defines how to quantize activation. Using this\\n                can quickly test if user\\'s quantization method works or not. In this function, user should\\n                both define quantization and dequantization process, that is, the function\\'s input\\n                is non-quantized activation and function returns dequantized activation. If None, will use\\n                quantization op defined by \\'activation_quantize_type\\'.\\n                Default is None.\\n        weight_preprocess_func(function): Function that defines how to preprocess weight before quantization. Using this\\n                can quickly test if user\\'s preprocess method works or not. The function\\'s input\\n                is non-quantized weight and function returns processed weight to be quantized. If None, the weight will\\n                be quantized directly.\\n                Default is None.\\n        act_preprocess_func(function): Function that defines how to preprocess activation before quantization. Using this\\n                can quickly test if user\\'s preprocess method works or not. The function\\'s input\\n                is non-quantized activation and function returns processed activation to be quantized. If None, the activation will\\n                be quantized directly.\\n                Default is None.\\n        optimizer_func(function): Fuction return a optimizer. When \\'is_test\\' is False and user want to use self-defined\\n            quantization function and preprocess function, this function must be set. Default is None.\\n        exe(paddle.static.Executor): If user want to use self-defined quantization function and preprocess function, exe must be set for\\n                initialization. Default is None.\\n        return_program(bool): If user want return value is a Program rather than Compiled Program, This argument should be set True.\\n                Default is False.\\n        draw_graph(bool): whether to draw graph when quantization is initialized. In order to prevent cycle,\\n                the ERNIE model needs to be set to True. Default is False.\\n        return_scale_dict(bool): If user want to return scale dict, model_type and pattern_ops, this argument should be set True.\\n                Default is False.\\n        scale_dict(dict): Use scale dict to initialize scales in program. Default is None.\\n        model_type(str): Model type can be \\'transformer\\' or \\'non-transformer\\'. If model type is transformer, patterns will be analyzed.\\n                Default is None.\\n        pattern_ops(dict): Pattern_ops contain pattern name and corresponding ops. Default is None.\\n    Returns:\\n        paddle.static.CompiledProgram | paddle.static.Program: Program with quantization and dequantization ``operators``\\n    '\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'quant_aware config {config}')\n    skip_tensor_list = []\n    same_scale_tensor_list = []\n    is_test = True if for_test else not config['scale_trainable']\n    if config['quant_post_first'] and for_test:\n        if 'quantizable_op_type' not in calib_config:\n            calib_config['quantizable_op_type'] = config['quantize_op_types']\n        exe = paddle.static.Executor() if executor is None else executor\n        post_training_quantization = PostTrainingQuantizationProgram(exe, program, freeze_model=False, skip_tensor_list=skip_tensor_list, same_scale_tensor_list=same_scale_tensor_list, batch_nums=10, scale_dict=scale_dict, return_graph=True, **calib_config)\n        main_graph = post_training_quantization.quantize()\n        scale_dict = post_training_quantization._scale_dict\n        sub_graphs = list(main_graph.all_sub_graphs())\n    else:\n        main_graph = IrGraph(core.Graph(program.desc), for_test=for_test)\n        sub_graphs = list(main_graph.all_sub_graphs())\n        transform_pass_ops = []\n        quant_dequant_ops = []\n        if 'quant_config' in config and config['quant_config']:\n            transform_pass_ops = config['quant_config'].weight_quant_operation_types\n            quant_dequant_ops = config['quant_config'].activation_quant_operation_types\n        else:\n            for op_type in config['quantize_op_types']:\n                if op_type in TRANSFORM_PASS_OP_TYPES:\n                    transform_pass_ops.append(op_type)\n                elif op_type in QUANT_DEQUANT_PASS_OP_TYPES:\n                    quant_dequant_ops.append(op_type)\n        if len(transform_pass_ops) > 0:\n            transform_func = QuantizationTransformPassV2 if config['onnx_format'] else QuantizationTransformPass\n            transform_pass = transform_func(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], activation_quantize_type=config['activation_quantize_type'], weight_quantize_type=config['weight_quantize_type'], window_size=config['window_size'], moving_rate=config['moving_rate'], quantizable_op_type=transform_pass_ops, skip_pattern=config['not_quant_pattern'], weight_quantize_func=weight_quantize_func, act_quantize_func=act_quantize_func, weight_preprocess_func=weight_preprocess_func, act_preprocess_func=act_preprocess_func, optimizer_func=optimizer_func, executor=executor, is_test=is_test)\n            for sub_graph in sub_graphs:\n                transform_pass.apply(sub_graph)\n        if len(quant_dequant_ops) > 0:\n            qdq_func = AddQuantDequantPassV2 if config['onnx_format'] else AddQuantDequantPass\n            quant_dequant_pass = qdq_func(scope=scope, place=place, moving_rate=config['moving_rate'], quant_bits=config['activation_bits'], skip_pattern=config['not_quant_pattern'], quantizable_op_type=quant_dequant_ops, is_test=is_test)\n            for sub_graph in sub_graphs:\n                quant_dequant_pass.apply(sub_graph)\n    out_scale_training_pass = OutScaleForTrainingPass(scope=scope, place=place, moving_rate=config['moving_rate'], is_test=is_test, scale_dict=scale_dict)\n    for sub_graph in sub_graphs:\n        out_scale_training_pass.apply(sub_graph)\n    if (weight_preprocess_func is not None or act_preprocess_func is not None) and (not for_test) and (not config['onnx_format']):\n        _logger.info('When a preprocess_func is used in quant_aware, Need to save a mapping table to match variable names in the convert phase.')\n        _logger.info(f\"The mapping table is saved as '{VARS_MAPPING_TABLE}'.\")\n        for sub_graph in sub_graphs:\n            save_dict(sub_graph.out_node_mapping_table)\n    if draw_graph:\n        main_graph.draw('./', 'graph.pdf')\n    if for_test or return_program:\n        quant_program = main_graph.to_program()\n    else:\n        quant_program = paddle.static.CompiledProgram(main_graph.graph)\n    if return_scale_dict:\n        return (quant_program, scale_dict, model_type, pattern_ops)\n    else:\n        return quant_program",
            "def quant_aware(program, place, config=None, scope=None, for_test=False, weight_quantize_func=None, act_quantize_func=None, weight_preprocess_func=None, act_preprocess_func=None, optimizer_func=None, executor=None, return_program=False, calib_config={}, draw_graph=False, return_scale_dict=False, scale_dict=None, model_type=None, pattern_ops=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Add quantization  and dequantization operators to \"program\"\\n    for quantization training or testing.\\n    Args:\\n        program(paddle.static.Program): training or testing ``program``.\\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\\n            the executor run on which device.\\n        config(dict, optional): configs for quantization. if None, will use default config.\\n            Default: None.\\n        scope(paddle.static.Scope): Scope records the mapping between variable names and variables,\\n            similar to brackets in programming languages. Usually users can use\\n            `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\\n            When ``None`` will use `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_ .\\n            Default: ``None``.\\n        for_test(bool): If the \\'program\\' parameter is a test program, this parameter should be set to ``True``.\\n            Otherwise, set to ``False``.Default: False\\n        weight_quantize_func(function): Function that defines how to quantize weight. Using this\\n                can quickly test if user\\'s quantization method works or not. In this function, user should\\n                both define quantization function and dequantization function, that is, the function\\'s input\\n                is non-quantized weight and function returns dequantized weight. If None, will use\\n                quantization op defined by \\'weight_quantize_type\\'.\\n                Default is None.\\n        act_quantize_func(function): Function that defines how to quantize activation. Using this\\n                can quickly test if user\\'s quantization method works or not. In this function, user should\\n                both define quantization and dequantization process, that is, the function\\'s input\\n                is non-quantized activation and function returns dequantized activation. If None, will use\\n                quantization op defined by \\'activation_quantize_type\\'.\\n                Default is None.\\n        weight_preprocess_func(function): Function that defines how to preprocess weight before quantization. Using this\\n                can quickly test if user\\'s preprocess method works or not. The function\\'s input\\n                is non-quantized weight and function returns processed weight to be quantized. If None, the weight will\\n                be quantized directly.\\n                Default is None.\\n        act_preprocess_func(function): Function that defines how to preprocess activation before quantization. Using this\\n                can quickly test if user\\'s preprocess method works or not. The function\\'s input\\n                is non-quantized activation and function returns processed activation to be quantized. If None, the activation will\\n                be quantized directly.\\n                Default is None.\\n        optimizer_func(function): Fuction return a optimizer. When \\'is_test\\' is False and user want to use self-defined\\n            quantization function and preprocess function, this function must be set. Default is None.\\n        exe(paddle.static.Executor): If user want to use self-defined quantization function and preprocess function, exe must be set for\\n                initialization. Default is None.\\n        return_program(bool): If user want return value is a Program rather than Compiled Program, This argument should be set True.\\n                Default is False.\\n        draw_graph(bool): whether to draw graph when quantization is initialized. In order to prevent cycle,\\n                the ERNIE model needs to be set to True. Default is False.\\n        return_scale_dict(bool): If user want to return scale dict, model_type and pattern_ops, this argument should be set True.\\n                Default is False.\\n        scale_dict(dict): Use scale dict to initialize scales in program. Default is None.\\n        model_type(str): Model type can be \\'transformer\\' or \\'non-transformer\\'. If model type is transformer, patterns will be analyzed.\\n                Default is None.\\n        pattern_ops(dict): Pattern_ops contain pattern name and corresponding ops. Default is None.\\n    Returns:\\n        paddle.static.CompiledProgram | paddle.static.Program: Program with quantization and dequantization ``operators``\\n    '\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'quant_aware config {config}')\n    skip_tensor_list = []\n    same_scale_tensor_list = []\n    is_test = True if for_test else not config['scale_trainable']\n    if config['quant_post_first'] and for_test:\n        if 'quantizable_op_type' not in calib_config:\n            calib_config['quantizable_op_type'] = config['quantize_op_types']\n        exe = paddle.static.Executor() if executor is None else executor\n        post_training_quantization = PostTrainingQuantizationProgram(exe, program, freeze_model=False, skip_tensor_list=skip_tensor_list, same_scale_tensor_list=same_scale_tensor_list, batch_nums=10, scale_dict=scale_dict, return_graph=True, **calib_config)\n        main_graph = post_training_quantization.quantize()\n        scale_dict = post_training_quantization._scale_dict\n        sub_graphs = list(main_graph.all_sub_graphs())\n    else:\n        main_graph = IrGraph(core.Graph(program.desc), for_test=for_test)\n        sub_graphs = list(main_graph.all_sub_graphs())\n        transform_pass_ops = []\n        quant_dequant_ops = []\n        if 'quant_config' in config and config['quant_config']:\n            transform_pass_ops = config['quant_config'].weight_quant_operation_types\n            quant_dequant_ops = config['quant_config'].activation_quant_operation_types\n        else:\n            for op_type in config['quantize_op_types']:\n                if op_type in TRANSFORM_PASS_OP_TYPES:\n                    transform_pass_ops.append(op_type)\n                elif op_type in QUANT_DEQUANT_PASS_OP_TYPES:\n                    quant_dequant_ops.append(op_type)\n        if len(transform_pass_ops) > 0:\n            transform_func = QuantizationTransformPassV2 if config['onnx_format'] else QuantizationTransformPass\n            transform_pass = transform_func(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], activation_quantize_type=config['activation_quantize_type'], weight_quantize_type=config['weight_quantize_type'], window_size=config['window_size'], moving_rate=config['moving_rate'], quantizable_op_type=transform_pass_ops, skip_pattern=config['not_quant_pattern'], weight_quantize_func=weight_quantize_func, act_quantize_func=act_quantize_func, weight_preprocess_func=weight_preprocess_func, act_preprocess_func=act_preprocess_func, optimizer_func=optimizer_func, executor=executor, is_test=is_test)\n            for sub_graph in sub_graphs:\n                transform_pass.apply(sub_graph)\n        if len(quant_dequant_ops) > 0:\n            qdq_func = AddQuantDequantPassV2 if config['onnx_format'] else AddQuantDequantPass\n            quant_dequant_pass = qdq_func(scope=scope, place=place, moving_rate=config['moving_rate'], quant_bits=config['activation_bits'], skip_pattern=config['not_quant_pattern'], quantizable_op_type=quant_dequant_ops, is_test=is_test)\n            for sub_graph in sub_graphs:\n                quant_dequant_pass.apply(sub_graph)\n    out_scale_training_pass = OutScaleForTrainingPass(scope=scope, place=place, moving_rate=config['moving_rate'], is_test=is_test, scale_dict=scale_dict)\n    for sub_graph in sub_graphs:\n        out_scale_training_pass.apply(sub_graph)\n    if (weight_preprocess_func is not None or act_preprocess_func is not None) and (not for_test) and (not config['onnx_format']):\n        _logger.info('When a preprocess_func is used in quant_aware, Need to save a mapping table to match variable names in the convert phase.')\n        _logger.info(f\"The mapping table is saved as '{VARS_MAPPING_TABLE}'.\")\n        for sub_graph in sub_graphs:\n            save_dict(sub_graph.out_node_mapping_table)\n    if draw_graph:\n        main_graph.draw('./', 'graph.pdf')\n    if for_test or return_program:\n        quant_program = main_graph.to_program()\n    else:\n        quant_program = paddle.static.CompiledProgram(main_graph.graph)\n    if return_scale_dict:\n        return (quant_program, scale_dict, model_type, pattern_ops)\n    else:\n        return quant_program",
            "def quant_aware(program, place, config=None, scope=None, for_test=False, weight_quantize_func=None, act_quantize_func=None, weight_preprocess_func=None, act_preprocess_func=None, optimizer_func=None, executor=None, return_program=False, calib_config={}, draw_graph=False, return_scale_dict=False, scale_dict=None, model_type=None, pattern_ops=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Add quantization  and dequantization operators to \"program\"\\n    for quantization training or testing.\\n    Args:\\n        program(paddle.static.Program): training or testing ``program``.\\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\\n            the executor run on which device.\\n        config(dict, optional): configs for quantization. if None, will use default config.\\n            Default: None.\\n        scope(paddle.static.Scope): Scope records the mapping between variable names and variables,\\n            similar to brackets in programming languages. Usually users can use\\n            `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\\n            When ``None`` will use `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_ .\\n            Default: ``None``.\\n        for_test(bool): If the \\'program\\' parameter is a test program, this parameter should be set to ``True``.\\n            Otherwise, set to ``False``.Default: False\\n        weight_quantize_func(function): Function that defines how to quantize weight. Using this\\n                can quickly test if user\\'s quantization method works or not. In this function, user should\\n                both define quantization function and dequantization function, that is, the function\\'s input\\n                is non-quantized weight and function returns dequantized weight. If None, will use\\n                quantization op defined by \\'weight_quantize_type\\'.\\n                Default is None.\\n        act_quantize_func(function): Function that defines how to quantize activation. Using this\\n                can quickly test if user\\'s quantization method works or not. In this function, user should\\n                both define quantization and dequantization process, that is, the function\\'s input\\n                is non-quantized activation and function returns dequantized activation. If None, will use\\n                quantization op defined by \\'activation_quantize_type\\'.\\n                Default is None.\\n        weight_preprocess_func(function): Function that defines how to preprocess weight before quantization. Using this\\n                can quickly test if user\\'s preprocess method works or not. The function\\'s input\\n                is non-quantized weight and function returns processed weight to be quantized. If None, the weight will\\n                be quantized directly.\\n                Default is None.\\n        act_preprocess_func(function): Function that defines how to preprocess activation before quantization. Using this\\n                can quickly test if user\\'s preprocess method works or not. The function\\'s input\\n                is non-quantized activation and function returns processed activation to be quantized. If None, the activation will\\n                be quantized directly.\\n                Default is None.\\n        optimizer_func(function): Fuction return a optimizer. When \\'is_test\\' is False and user want to use self-defined\\n            quantization function and preprocess function, this function must be set. Default is None.\\n        exe(paddle.static.Executor): If user want to use self-defined quantization function and preprocess function, exe must be set for\\n                initialization. Default is None.\\n        return_program(bool): If user want return value is a Program rather than Compiled Program, This argument should be set True.\\n                Default is False.\\n        draw_graph(bool): whether to draw graph when quantization is initialized. In order to prevent cycle,\\n                the ERNIE model needs to be set to True. Default is False.\\n        return_scale_dict(bool): If user want to return scale dict, model_type and pattern_ops, this argument should be set True.\\n                Default is False.\\n        scale_dict(dict): Use scale dict to initialize scales in program. Default is None.\\n        model_type(str): Model type can be \\'transformer\\' or \\'non-transformer\\'. If model type is transformer, patterns will be analyzed.\\n                Default is None.\\n        pattern_ops(dict): Pattern_ops contain pattern name and corresponding ops. Default is None.\\n    Returns:\\n        paddle.static.CompiledProgram | paddle.static.Program: Program with quantization and dequantization ``operators``\\n    '\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'quant_aware config {config}')\n    skip_tensor_list = []\n    same_scale_tensor_list = []\n    is_test = True if for_test else not config['scale_trainable']\n    if config['quant_post_first'] and for_test:\n        if 'quantizable_op_type' not in calib_config:\n            calib_config['quantizable_op_type'] = config['quantize_op_types']\n        exe = paddle.static.Executor() if executor is None else executor\n        post_training_quantization = PostTrainingQuantizationProgram(exe, program, freeze_model=False, skip_tensor_list=skip_tensor_list, same_scale_tensor_list=same_scale_tensor_list, batch_nums=10, scale_dict=scale_dict, return_graph=True, **calib_config)\n        main_graph = post_training_quantization.quantize()\n        scale_dict = post_training_quantization._scale_dict\n        sub_graphs = list(main_graph.all_sub_graphs())\n    else:\n        main_graph = IrGraph(core.Graph(program.desc), for_test=for_test)\n        sub_graphs = list(main_graph.all_sub_graphs())\n        transform_pass_ops = []\n        quant_dequant_ops = []\n        if 'quant_config' in config and config['quant_config']:\n            transform_pass_ops = config['quant_config'].weight_quant_operation_types\n            quant_dequant_ops = config['quant_config'].activation_quant_operation_types\n        else:\n            for op_type in config['quantize_op_types']:\n                if op_type in TRANSFORM_PASS_OP_TYPES:\n                    transform_pass_ops.append(op_type)\n                elif op_type in QUANT_DEQUANT_PASS_OP_TYPES:\n                    quant_dequant_ops.append(op_type)\n        if len(transform_pass_ops) > 0:\n            transform_func = QuantizationTransformPassV2 if config['onnx_format'] else QuantizationTransformPass\n            transform_pass = transform_func(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], activation_quantize_type=config['activation_quantize_type'], weight_quantize_type=config['weight_quantize_type'], window_size=config['window_size'], moving_rate=config['moving_rate'], quantizable_op_type=transform_pass_ops, skip_pattern=config['not_quant_pattern'], weight_quantize_func=weight_quantize_func, act_quantize_func=act_quantize_func, weight_preprocess_func=weight_preprocess_func, act_preprocess_func=act_preprocess_func, optimizer_func=optimizer_func, executor=executor, is_test=is_test)\n            for sub_graph in sub_graphs:\n                transform_pass.apply(sub_graph)\n        if len(quant_dequant_ops) > 0:\n            qdq_func = AddQuantDequantPassV2 if config['onnx_format'] else AddQuantDequantPass\n            quant_dequant_pass = qdq_func(scope=scope, place=place, moving_rate=config['moving_rate'], quant_bits=config['activation_bits'], skip_pattern=config['not_quant_pattern'], quantizable_op_type=quant_dequant_ops, is_test=is_test)\n            for sub_graph in sub_graphs:\n                quant_dequant_pass.apply(sub_graph)\n    out_scale_training_pass = OutScaleForTrainingPass(scope=scope, place=place, moving_rate=config['moving_rate'], is_test=is_test, scale_dict=scale_dict)\n    for sub_graph in sub_graphs:\n        out_scale_training_pass.apply(sub_graph)\n    if (weight_preprocess_func is not None or act_preprocess_func is not None) and (not for_test) and (not config['onnx_format']):\n        _logger.info('When a preprocess_func is used in quant_aware, Need to save a mapping table to match variable names in the convert phase.')\n        _logger.info(f\"The mapping table is saved as '{VARS_MAPPING_TABLE}'.\")\n        for sub_graph in sub_graphs:\n            save_dict(sub_graph.out_node_mapping_table)\n    if draw_graph:\n        main_graph.draw('./', 'graph.pdf')\n    if for_test or return_program:\n        quant_program = main_graph.to_program()\n    else:\n        quant_program = paddle.static.CompiledProgram(main_graph.graph)\n    if return_scale_dict:\n        return (quant_program, scale_dict, model_type, pattern_ops)\n    else:\n        return quant_program",
            "def quant_aware(program, place, config=None, scope=None, for_test=False, weight_quantize_func=None, act_quantize_func=None, weight_preprocess_func=None, act_preprocess_func=None, optimizer_func=None, executor=None, return_program=False, calib_config={}, draw_graph=False, return_scale_dict=False, scale_dict=None, model_type=None, pattern_ops=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Add quantization  and dequantization operators to \"program\"\\n    for quantization training or testing.\\n    Args:\\n        program(paddle.static.Program): training or testing ``program``.\\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\\n            the executor run on which device.\\n        config(dict, optional): configs for quantization. if None, will use default config.\\n            Default: None.\\n        scope(paddle.static.Scope): Scope records the mapping between variable names and variables,\\n            similar to brackets in programming languages. Usually users can use\\n            `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\\n            When ``None`` will use `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_ .\\n            Default: ``None``.\\n        for_test(bool): If the \\'program\\' parameter is a test program, this parameter should be set to ``True``.\\n            Otherwise, set to ``False``.Default: False\\n        weight_quantize_func(function): Function that defines how to quantize weight. Using this\\n                can quickly test if user\\'s quantization method works or not. In this function, user should\\n                both define quantization function and dequantization function, that is, the function\\'s input\\n                is non-quantized weight and function returns dequantized weight. If None, will use\\n                quantization op defined by \\'weight_quantize_type\\'.\\n                Default is None.\\n        act_quantize_func(function): Function that defines how to quantize activation. Using this\\n                can quickly test if user\\'s quantization method works or not. In this function, user should\\n                both define quantization and dequantization process, that is, the function\\'s input\\n                is non-quantized activation and function returns dequantized activation. If None, will use\\n                quantization op defined by \\'activation_quantize_type\\'.\\n                Default is None.\\n        weight_preprocess_func(function): Function that defines how to preprocess weight before quantization. Using this\\n                can quickly test if user\\'s preprocess method works or not. The function\\'s input\\n                is non-quantized weight and function returns processed weight to be quantized. If None, the weight will\\n                be quantized directly.\\n                Default is None.\\n        act_preprocess_func(function): Function that defines how to preprocess activation before quantization. Using this\\n                can quickly test if user\\'s preprocess method works or not. The function\\'s input\\n                is non-quantized activation and function returns processed activation to be quantized. If None, the activation will\\n                be quantized directly.\\n                Default is None.\\n        optimizer_func(function): Fuction return a optimizer. When \\'is_test\\' is False and user want to use self-defined\\n            quantization function and preprocess function, this function must be set. Default is None.\\n        exe(paddle.static.Executor): If user want to use self-defined quantization function and preprocess function, exe must be set for\\n                initialization. Default is None.\\n        return_program(bool): If user want return value is a Program rather than Compiled Program, This argument should be set True.\\n                Default is False.\\n        draw_graph(bool): whether to draw graph when quantization is initialized. In order to prevent cycle,\\n                the ERNIE model needs to be set to True. Default is False.\\n        return_scale_dict(bool): If user want to return scale dict, model_type and pattern_ops, this argument should be set True.\\n                Default is False.\\n        scale_dict(dict): Use scale dict to initialize scales in program. Default is None.\\n        model_type(str): Model type can be \\'transformer\\' or \\'non-transformer\\'. If model type is transformer, patterns will be analyzed.\\n                Default is None.\\n        pattern_ops(dict): Pattern_ops contain pattern name and corresponding ops. Default is None.\\n    Returns:\\n        paddle.static.CompiledProgram | paddle.static.Program: Program with quantization and dequantization ``operators``\\n    '\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'quant_aware config {config}')\n    skip_tensor_list = []\n    same_scale_tensor_list = []\n    is_test = True if for_test else not config['scale_trainable']\n    if config['quant_post_first'] and for_test:\n        if 'quantizable_op_type' not in calib_config:\n            calib_config['quantizable_op_type'] = config['quantize_op_types']\n        exe = paddle.static.Executor() if executor is None else executor\n        post_training_quantization = PostTrainingQuantizationProgram(exe, program, freeze_model=False, skip_tensor_list=skip_tensor_list, same_scale_tensor_list=same_scale_tensor_list, batch_nums=10, scale_dict=scale_dict, return_graph=True, **calib_config)\n        main_graph = post_training_quantization.quantize()\n        scale_dict = post_training_quantization._scale_dict\n        sub_graphs = list(main_graph.all_sub_graphs())\n    else:\n        main_graph = IrGraph(core.Graph(program.desc), for_test=for_test)\n        sub_graphs = list(main_graph.all_sub_graphs())\n        transform_pass_ops = []\n        quant_dequant_ops = []\n        if 'quant_config' in config and config['quant_config']:\n            transform_pass_ops = config['quant_config'].weight_quant_operation_types\n            quant_dequant_ops = config['quant_config'].activation_quant_operation_types\n        else:\n            for op_type in config['quantize_op_types']:\n                if op_type in TRANSFORM_PASS_OP_TYPES:\n                    transform_pass_ops.append(op_type)\n                elif op_type in QUANT_DEQUANT_PASS_OP_TYPES:\n                    quant_dequant_ops.append(op_type)\n        if len(transform_pass_ops) > 0:\n            transform_func = QuantizationTransformPassV2 if config['onnx_format'] else QuantizationTransformPass\n            transform_pass = transform_func(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], activation_quantize_type=config['activation_quantize_type'], weight_quantize_type=config['weight_quantize_type'], window_size=config['window_size'], moving_rate=config['moving_rate'], quantizable_op_type=transform_pass_ops, skip_pattern=config['not_quant_pattern'], weight_quantize_func=weight_quantize_func, act_quantize_func=act_quantize_func, weight_preprocess_func=weight_preprocess_func, act_preprocess_func=act_preprocess_func, optimizer_func=optimizer_func, executor=executor, is_test=is_test)\n            for sub_graph in sub_graphs:\n                transform_pass.apply(sub_graph)\n        if len(quant_dequant_ops) > 0:\n            qdq_func = AddQuantDequantPassV2 if config['onnx_format'] else AddQuantDequantPass\n            quant_dequant_pass = qdq_func(scope=scope, place=place, moving_rate=config['moving_rate'], quant_bits=config['activation_bits'], skip_pattern=config['not_quant_pattern'], quantizable_op_type=quant_dequant_ops, is_test=is_test)\n            for sub_graph in sub_graphs:\n                quant_dequant_pass.apply(sub_graph)\n    out_scale_training_pass = OutScaleForTrainingPass(scope=scope, place=place, moving_rate=config['moving_rate'], is_test=is_test, scale_dict=scale_dict)\n    for sub_graph in sub_graphs:\n        out_scale_training_pass.apply(sub_graph)\n    if (weight_preprocess_func is not None or act_preprocess_func is not None) and (not for_test) and (not config['onnx_format']):\n        _logger.info('When a preprocess_func is used in quant_aware, Need to save a mapping table to match variable names in the convert phase.')\n        _logger.info(f\"The mapping table is saved as '{VARS_MAPPING_TABLE}'.\")\n        for sub_graph in sub_graphs:\n            save_dict(sub_graph.out_node_mapping_table)\n    if draw_graph:\n        main_graph.draw('./', 'graph.pdf')\n    if for_test or return_program:\n        quant_program = main_graph.to_program()\n    else:\n        quant_program = paddle.static.CompiledProgram(main_graph.graph)\n    if return_scale_dict:\n        return (quant_program, scale_dict, model_type, pattern_ops)\n    else:\n        return quant_program"
        ]
    },
    {
        "func_name": "convert",
        "original": "def convert(program, place, config=None, scope=None, save_int8=False):\n    \"\"\"\n    convert quantized and well-trained ``program`` to final  quantized\n    ``program``that can be used to  save ``inference model``.\n\n    Args:\n        program(paddle.static.Program): quantized and well-trained ``test program``.\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\n                the executor run on which device.\n        config(dict, optional): configs for convert. if set None, will use\n                default config. It must be same with config that used in\n                'quant_aware'. Default is None.\n        scope(paddle.static.Scope, optional):  Scope records the mapping between\n                variable names and variables, similar to brackets in\n                programming languages. Usually users can use\n                `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\n                When ``None`` will use\n                `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_\n                . Default: ``None``.\n        save_int8: Whether to return ``program`` which model parameters'\n                dtype is ``int8``. This parameter can only be used to\n                get model size. Default: ``False``.\n    Returns:\n        Tuple : freezed program which can be used for inference.\n                when ``save_int8`` is False, return ``freezed_program(paddle.static.Program)``.\n                when ``save_int8`` is True, return ``freezed_program(paddle.static.Program)``\n                and ``freezed_program_int8(paddle.static.Program)``\n    \"\"\"\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'convert config {config}')\n    test_graph = IrGraph(core.Graph(program.desc), for_test=True)\n    if config['onnx_format']:\n        quant_weight_pass = QuantWeightPass(scope, place)\n        for sub_graph in test_graph.all_sub_graphs():\n            quant_weight_pass.apply(sub_graph)\n        out_scale_infer_pass = AddQuantDequantForInferencePass(scope=scope, place=place, quant_bits=config['activation_bits'])\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n    else:\n        out_scale_infer_pass = OutScaleForInferencePass(scope=scope)\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n        freeze_pass = QuantizationFreezePass(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], weight_quantize_type=config['weight_quantize_type'])\n        if os.path.exists(VARS_MAPPING_TABLE):\n            test_graph.out_node_mapping_table = load_dict()\n        for sub_graph in test_graph.all_sub_graphs():\n            freeze_pass.apply(sub_graph)\n    freezed_program = test_graph.to_program()\n    global_block = freezed_program.global_block()\n    for _op in global_block.ops:\n        if _op.type == 'while':\n            _block_id = _op.attr('sub_block').id\n            _block = freezed_program.block(_block_id)\n            persistables = []\n            for (_name, _var) in _block.vars.items():\n                if _var.persistable:\n                    global_block._clone_variable(_var)\n                    persistables.append(_name)\n            for _name in persistables:\n                _block._remove_var(_name)\n            persistables.extend(_op.input('X'))\n            _op.desc.set_input('X', persistables)\n    assert not (save_int8 and config['onnx_format']), \"When onnx_format=True, already saved int8 weight,so you can't set save_int8=True.\"\n    if save_int8:\n        convert_int8_pass = ConvertToInt8Pass(scope=scope, place=place)\n        for sub_graph in test_graph.all_sub_graphs():\n            convert_int8_pass.apply(sub_graph)\n        freezed_program_int8 = test_graph.to_program()\n        return (freezed_program, freezed_program_int8)\n    else:\n        return freezed_program",
        "mutated": [
            "def convert(program, place, config=None, scope=None, save_int8=False):\n    if False:\n        i = 10\n    \"\\n    convert quantized and well-trained ``program`` to final  quantized\\n    ``program``that can be used to  save ``inference model``.\\n\\n    Args:\\n        program(paddle.static.Program): quantized and well-trained ``test program``.\\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\\n                the executor run on which device.\\n        config(dict, optional): configs for convert. if set None, will use\\n                default config. It must be same with config that used in\\n                'quant_aware'. Default is None.\\n        scope(paddle.static.Scope, optional):  Scope records the mapping between\\n                variable names and variables, similar to brackets in\\n                programming languages. Usually users can use\\n                `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\\n                When ``None`` will use\\n                `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_\\n                . Default: ``None``.\\n        save_int8: Whether to return ``program`` which model parameters'\\n                dtype is ``int8``. This parameter can only be used to\\n                get model size. Default: ``False``.\\n    Returns:\\n        Tuple : freezed program which can be used for inference.\\n                when ``save_int8`` is False, return ``freezed_program(paddle.static.Program)``.\\n                when ``save_int8`` is True, return ``freezed_program(paddle.static.Program)``\\n                and ``freezed_program_int8(paddle.static.Program)``\\n    \"\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'convert config {config}')\n    test_graph = IrGraph(core.Graph(program.desc), for_test=True)\n    if config['onnx_format']:\n        quant_weight_pass = QuantWeightPass(scope, place)\n        for sub_graph in test_graph.all_sub_graphs():\n            quant_weight_pass.apply(sub_graph)\n        out_scale_infer_pass = AddQuantDequantForInferencePass(scope=scope, place=place, quant_bits=config['activation_bits'])\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n    else:\n        out_scale_infer_pass = OutScaleForInferencePass(scope=scope)\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n        freeze_pass = QuantizationFreezePass(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], weight_quantize_type=config['weight_quantize_type'])\n        if os.path.exists(VARS_MAPPING_TABLE):\n            test_graph.out_node_mapping_table = load_dict()\n        for sub_graph in test_graph.all_sub_graphs():\n            freeze_pass.apply(sub_graph)\n    freezed_program = test_graph.to_program()\n    global_block = freezed_program.global_block()\n    for _op in global_block.ops:\n        if _op.type == 'while':\n            _block_id = _op.attr('sub_block').id\n            _block = freezed_program.block(_block_id)\n            persistables = []\n            for (_name, _var) in _block.vars.items():\n                if _var.persistable:\n                    global_block._clone_variable(_var)\n                    persistables.append(_name)\n            for _name in persistables:\n                _block._remove_var(_name)\n            persistables.extend(_op.input('X'))\n            _op.desc.set_input('X', persistables)\n    assert not (save_int8 and config['onnx_format']), \"When onnx_format=True, already saved int8 weight,so you can't set save_int8=True.\"\n    if save_int8:\n        convert_int8_pass = ConvertToInt8Pass(scope=scope, place=place)\n        for sub_graph in test_graph.all_sub_graphs():\n            convert_int8_pass.apply(sub_graph)\n        freezed_program_int8 = test_graph.to_program()\n        return (freezed_program, freezed_program_int8)\n    else:\n        return freezed_program",
            "def convert(program, place, config=None, scope=None, save_int8=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    convert quantized and well-trained ``program`` to final  quantized\\n    ``program``that can be used to  save ``inference model``.\\n\\n    Args:\\n        program(paddle.static.Program): quantized and well-trained ``test program``.\\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\\n                the executor run on which device.\\n        config(dict, optional): configs for convert. if set None, will use\\n                default config. It must be same with config that used in\\n                'quant_aware'. Default is None.\\n        scope(paddle.static.Scope, optional):  Scope records the mapping between\\n                variable names and variables, similar to brackets in\\n                programming languages. Usually users can use\\n                `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\\n                When ``None`` will use\\n                `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_\\n                . Default: ``None``.\\n        save_int8: Whether to return ``program`` which model parameters'\\n                dtype is ``int8``. This parameter can only be used to\\n                get model size. Default: ``False``.\\n    Returns:\\n        Tuple : freezed program which can be used for inference.\\n                when ``save_int8`` is False, return ``freezed_program(paddle.static.Program)``.\\n                when ``save_int8`` is True, return ``freezed_program(paddle.static.Program)``\\n                and ``freezed_program_int8(paddle.static.Program)``\\n    \"\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'convert config {config}')\n    test_graph = IrGraph(core.Graph(program.desc), for_test=True)\n    if config['onnx_format']:\n        quant_weight_pass = QuantWeightPass(scope, place)\n        for sub_graph in test_graph.all_sub_graphs():\n            quant_weight_pass.apply(sub_graph)\n        out_scale_infer_pass = AddQuantDequantForInferencePass(scope=scope, place=place, quant_bits=config['activation_bits'])\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n    else:\n        out_scale_infer_pass = OutScaleForInferencePass(scope=scope)\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n        freeze_pass = QuantizationFreezePass(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], weight_quantize_type=config['weight_quantize_type'])\n        if os.path.exists(VARS_MAPPING_TABLE):\n            test_graph.out_node_mapping_table = load_dict()\n        for sub_graph in test_graph.all_sub_graphs():\n            freeze_pass.apply(sub_graph)\n    freezed_program = test_graph.to_program()\n    global_block = freezed_program.global_block()\n    for _op in global_block.ops:\n        if _op.type == 'while':\n            _block_id = _op.attr('sub_block').id\n            _block = freezed_program.block(_block_id)\n            persistables = []\n            for (_name, _var) in _block.vars.items():\n                if _var.persistable:\n                    global_block._clone_variable(_var)\n                    persistables.append(_name)\n            for _name in persistables:\n                _block._remove_var(_name)\n            persistables.extend(_op.input('X'))\n            _op.desc.set_input('X', persistables)\n    assert not (save_int8 and config['onnx_format']), \"When onnx_format=True, already saved int8 weight,so you can't set save_int8=True.\"\n    if save_int8:\n        convert_int8_pass = ConvertToInt8Pass(scope=scope, place=place)\n        for sub_graph in test_graph.all_sub_graphs():\n            convert_int8_pass.apply(sub_graph)\n        freezed_program_int8 = test_graph.to_program()\n        return (freezed_program, freezed_program_int8)\n    else:\n        return freezed_program",
            "def convert(program, place, config=None, scope=None, save_int8=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    convert quantized and well-trained ``program`` to final  quantized\\n    ``program``that can be used to  save ``inference model``.\\n\\n    Args:\\n        program(paddle.static.Program): quantized and well-trained ``test program``.\\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\\n                the executor run on which device.\\n        config(dict, optional): configs for convert. if set None, will use\\n                default config. It must be same with config that used in\\n                'quant_aware'. Default is None.\\n        scope(paddle.static.Scope, optional):  Scope records the mapping between\\n                variable names and variables, similar to brackets in\\n                programming languages. Usually users can use\\n                `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\\n                When ``None`` will use\\n                `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_\\n                . Default: ``None``.\\n        save_int8: Whether to return ``program`` which model parameters'\\n                dtype is ``int8``. This parameter can only be used to\\n                get model size. Default: ``False``.\\n    Returns:\\n        Tuple : freezed program which can be used for inference.\\n                when ``save_int8`` is False, return ``freezed_program(paddle.static.Program)``.\\n                when ``save_int8`` is True, return ``freezed_program(paddle.static.Program)``\\n                and ``freezed_program_int8(paddle.static.Program)``\\n    \"\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'convert config {config}')\n    test_graph = IrGraph(core.Graph(program.desc), for_test=True)\n    if config['onnx_format']:\n        quant_weight_pass = QuantWeightPass(scope, place)\n        for sub_graph in test_graph.all_sub_graphs():\n            quant_weight_pass.apply(sub_graph)\n        out_scale_infer_pass = AddQuantDequantForInferencePass(scope=scope, place=place, quant_bits=config['activation_bits'])\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n    else:\n        out_scale_infer_pass = OutScaleForInferencePass(scope=scope)\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n        freeze_pass = QuantizationFreezePass(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], weight_quantize_type=config['weight_quantize_type'])\n        if os.path.exists(VARS_MAPPING_TABLE):\n            test_graph.out_node_mapping_table = load_dict()\n        for sub_graph in test_graph.all_sub_graphs():\n            freeze_pass.apply(sub_graph)\n    freezed_program = test_graph.to_program()\n    global_block = freezed_program.global_block()\n    for _op in global_block.ops:\n        if _op.type == 'while':\n            _block_id = _op.attr('sub_block').id\n            _block = freezed_program.block(_block_id)\n            persistables = []\n            for (_name, _var) in _block.vars.items():\n                if _var.persistable:\n                    global_block._clone_variable(_var)\n                    persistables.append(_name)\n            for _name in persistables:\n                _block._remove_var(_name)\n            persistables.extend(_op.input('X'))\n            _op.desc.set_input('X', persistables)\n    assert not (save_int8 and config['onnx_format']), \"When onnx_format=True, already saved int8 weight,so you can't set save_int8=True.\"\n    if save_int8:\n        convert_int8_pass = ConvertToInt8Pass(scope=scope, place=place)\n        for sub_graph in test_graph.all_sub_graphs():\n            convert_int8_pass.apply(sub_graph)\n        freezed_program_int8 = test_graph.to_program()\n        return (freezed_program, freezed_program_int8)\n    else:\n        return freezed_program",
            "def convert(program, place, config=None, scope=None, save_int8=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    convert quantized and well-trained ``program`` to final  quantized\\n    ``program``that can be used to  save ``inference model``.\\n\\n    Args:\\n        program(paddle.static.Program): quantized and well-trained ``test program``.\\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\\n                the executor run on which device.\\n        config(dict, optional): configs for convert. if set None, will use\\n                default config. It must be same with config that used in\\n                'quant_aware'. Default is None.\\n        scope(paddle.static.Scope, optional):  Scope records the mapping between\\n                variable names and variables, similar to brackets in\\n                programming languages. Usually users can use\\n                `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\\n                When ``None`` will use\\n                `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_\\n                . Default: ``None``.\\n        save_int8: Whether to return ``program`` which model parameters'\\n                dtype is ``int8``. This parameter can only be used to\\n                get model size. Default: ``False``.\\n    Returns:\\n        Tuple : freezed program which can be used for inference.\\n                when ``save_int8`` is False, return ``freezed_program(paddle.static.Program)``.\\n                when ``save_int8`` is True, return ``freezed_program(paddle.static.Program)``\\n                and ``freezed_program_int8(paddle.static.Program)``\\n    \"\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'convert config {config}')\n    test_graph = IrGraph(core.Graph(program.desc), for_test=True)\n    if config['onnx_format']:\n        quant_weight_pass = QuantWeightPass(scope, place)\n        for sub_graph in test_graph.all_sub_graphs():\n            quant_weight_pass.apply(sub_graph)\n        out_scale_infer_pass = AddQuantDequantForInferencePass(scope=scope, place=place, quant_bits=config['activation_bits'])\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n    else:\n        out_scale_infer_pass = OutScaleForInferencePass(scope=scope)\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n        freeze_pass = QuantizationFreezePass(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], weight_quantize_type=config['weight_quantize_type'])\n        if os.path.exists(VARS_MAPPING_TABLE):\n            test_graph.out_node_mapping_table = load_dict()\n        for sub_graph in test_graph.all_sub_graphs():\n            freeze_pass.apply(sub_graph)\n    freezed_program = test_graph.to_program()\n    global_block = freezed_program.global_block()\n    for _op in global_block.ops:\n        if _op.type == 'while':\n            _block_id = _op.attr('sub_block').id\n            _block = freezed_program.block(_block_id)\n            persistables = []\n            for (_name, _var) in _block.vars.items():\n                if _var.persistable:\n                    global_block._clone_variable(_var)\n                    persistables.append(_name)\n            for _name in persistables:\n                _block._remove_var(_name)\n            persistables.extend(_op.input('X'))\n            _op.desc.set_input('X', persistables)\n    assert not (save_int8 and config['onnx_format']), \"When onnx_format=True, already saved int8 weight,so you can't set save_int8=True.\"\n    if save_int8:\n        convert_int8_pass = ConvertToInt8Pass(scope=scope, place=place)\n        for sub_graph in test_graph.all_sub_graphs():\n            convert_int8_pass.apply(sub_graph)\n        freezed_program_int8 = test_graph.to_program()\n        return (freezed_program, freezed_program_int8)\n    else:\n        return freezed_program",
            "def convert(program, place, config=None, scope=None, save_int8=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    convert quantized and well-trained ``program`` to final  quantized\\n    ``program``that can be used to  save ``inference model``.\\n\\n    Args:\\n        program(paddle.static.Program): quantized and well-trained ``test program``.\\n        place(paddle.CPUPlace or paddle.CUDAPlace): This parameter represents\\n                the executor run on which device.\\n        config(dict, optional): configs for convert. if set None, will use\\n                default config. It must be same with config that used in\\n                'quant_aware'. Default is None.\\n        scope(paddle.static.Scope, optional):  Scope records the mapping between\\n                variable names and variables, similar to brackets in\\n                programming languages. Usually users can use\\n                `paddle.static.global_scope <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_.\\n                When ``None`` will use\\n                `paddle.static.global_scope() <https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api_cn/executor_cn/global_scope_cn.html>`_\\n                . Default: ``None``.\\n        save_int8: Whether to return ``program`` which model parameters'\\n                dtype is ``int8``. This parameter can only be used to\\n                get model size. Default: ``False``.\\n    Returns:\\n        Tuple : freezed program which can be used for inference.\\n                when ``save_int8`` is False, return ``freezed_program(paddle.static.Program)``.\\n                when ``save_int8`` is True, return ``freezed_program(paddle.static.Program)``\\n                and ``freezed_program_int8(paddle.static.Program)``\\n    \"\n    scope = paddle.static.global_scope() if not scope else scope\n    if config is None:\n        config = _quant_config_default\n    else:\n        assert isinstance(config, dict), 'config must be dict'\n        config = _parse_configs(config)\n    _logger.info(f'convert config {config}')\n    test_graph = IrGraph(core.Graph(program.desc), for_test=True)\n    if config['onnx_format']:\n        quant_weight_pass = QuantWeightPass(scope, place)\n        for sub_graph in test_graph.all_sub_graphs():\n            quant_weight_pass.apply(sub_graph)\n        out_scale_infer_pass = AddQuantDequantForInferencePass(scope=scope, place=place, quant_bits=config['activation_bits'])\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n    else:\n        out_scale_infer_pass = OutScaleForInferencePass(scope=scope)\n        for sub_graph in test_graph.all_sub_graphs():\n            out_scale_infer_pass.apply(sub_graph)\n        freeze_pass = QuantizationFreezePass(scope=scope, place=place, weight_bits=config['weight_bits'], activation_bits=config['activation_bits'], weight_quantize_type=config['weight_quantize_type'])\n        if os.path.exists(VARS_MAPPING_TABLE):\n            test_graph.out_node_mapping_table = load_dict()\n        for sub_graph in test_graph.all_sub_graphs():\n            freeze_pass.apply(sub_graph)\n    freezed_program = test_graph.to_program()\n    global_block = freezed_program.global_block()\n    for _op in global_block.ops:\n        if _op.type == 'while':\n            _block_id = _op.attr('sub_block').id\n            _block = freezed_program.block(_block_id)\n            persistables = []\n            for (_name, _var) in _block.vars.items():\n                if _var.persistable:\n                    global_block._clone_variable(_var)\n                    persistables.append(_name)\n            for _name in persistables:\n                _block._remove_var(_name)\n            persistables.extend(_op.input('X'))\n            _op.desc.set_input('X', persistables)\n    assert not (save_int8 and config['onnx_format']), \"When onnx_format=True, already saved int8 weight,so you can't set save_int8=True.\"\n    if save_int8:\n        convert_int8_pass = ConvertToInt8Pass(scope=scope, place=place)\n        for sub_graph in test_graph.all_sub_graphs():\n            convert_int8_pass.apply(sub_graph)\n        freezed_program_int8 = test_graph.to_program()\n        return (freezed_program, freezed_program_int8)\n    else:\n        return freezed_program"
        ]
    }
]