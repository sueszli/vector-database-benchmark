[
    {
        "func_name": "__init__",
        "original": "def __init__(self, in_channels, vote_per_seed=1, gt_per_seed=3, num_points=-1, conv_channels=(16, 16), conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), norm_feats=True, with_res_feat=True, vote_xyz_range=None, vote_loss=None):\n    super().__init__()\n    self.in_channels = in_channels\n    self.vote_per_seed = vote_per_seed\n    self.gt_per_seed = gt_per_seed\n    self.num_points = num_points\n    self.norm_feats = norm_feats\n    self.with_res_feat = with_res_feat\n    assert vote_xyz_range is None or is_tuple_of(vote_xyz_range, float)\n    self.vote_xyz_range = vote_xyz_range\n    if vote_loss is not None:\n        self.vote_loss = build_loss(vote_loss)\n    prev_channels = in_channels\n    vote_conv_list = list()\n    for k in range(len(conv_channels)):\n        vote_conv_list.append(ConvModule(prev_channels, conv_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, act_cfg=act_cfg, bias=True, inplace=True))\n        prev_channels = conv_channels[k]\n    self.vote_conv = nn.Sequential(*vote_conv_list)\n    if with_res_feat:\n        out_channel = (3 + in_channels) * self.vote_per_seed\n    else:\n        out_channel = 3 * self.vote_per_seed\n    self.conv_out = nn.Conv1d(prev_channels, out_channel, 1)",
        "mutated": [
            "def __init__(self, in_channels, vote_per_seed=1, gt_per_seed=3, num_points=-1, conv_channels=(16, 16), conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), norm_feats=True, with_res_feat=True, vote_xyz_range=None, vote_loss=None):\n    if False:\n        i = 10\n    super().__init__()\n    self.in_channels = in_channels\n    self.vote_per_seed = vote_per_seed\n    self.gt_per_seed = gt_per_seed\n    self.num_points = num_points\n    self.norm_feats = norm_feats\n    self.with_res_feat = with_res_feat\n    assert vote_xyz_range is None or is_tuple_of(vote_xyz_range, float)\n    self.vote_xyz_range = vote_xyz_range\n    if vote_loss is not None:\n        self.vote_loss = build_loss(vote_loss)\n    prev_channels = in_channels\n    vote_conv_list = list()\n    for k in range(len(conv_channels)):\n        vote_conv_list.append(ConvModule(prev_channels, conv_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, act_cfg=act_cfg, bias=True, inplace=True))\n        prev_channels = conv_channels[k]\n    self.vote_conv = nn.Sequential(*vote_conv_list)\n    if with_res_feat:\n        out_channel = (3 + in_channels) * self.vote_per_seed\n    else:\n        out_channel = 3 * self.vote_per_seed\n    self.conv_out = nn.Conv1d(prev_channels, out_channel, 1)",
            "def __init__(self, in_channels, vote_per_seed=1, gt_per_seed=3, num_points=-1, conv_channels=(16, 16), conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), norm_feats=True, with_res_feat=True, vote_xyz_range=None, vote_loss=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__()\n    self.in_channels = in_channels\n    self.vote_per_seed = vote_per_seed\n    self.gt_per_seed = gt_per_seed\n    self.num_points = num_points\n    self.norm_feats = norm_feats\n    self.with_res_feat = with_res_feat\n    assert vote_xyz_range is None or is_tuple_of(vote_xyz_range, float)\n    self.vote_xyz_range = vote_xyz_range\n    if vote_loss is not None:\n        self.vote_loss = build_loss(vote_loss)\n    prev_channels = in_channels\n    vote_conv_list = list()\n    for k in range(len(conv_channels)):\n        vote_conv_list.append(ConvModule(prev_channels, conv_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, act_cfg=act_cfg, bias=True, inplace=True))\n        prev_channels = conv_channels[k]\n    self.vote_conv = nn.Sequential(*vote_conv_list)\n    if with_res_feat:\n        out_channel = (3 + in_channels) * self.vote_per_seed\n    else:\n        out_channel = 3 * self.vote_per_seed\n    self.conv_out = nn.Conv1d(prev_channels, out_channel, 1)",
            "def __init__(self, in_channels, vote_per_seed=1, gt_per_seed=3, num_points=-1, conv_channels=(16, 16), conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), norm_feats=True, with_res_feat=True, vote_xyz_range=None, vote_loss=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__()\n    self.in_channels = in_channels\n    self.vote_per_seed = vote_per_seed\n    self.gt_per_seed = gt_per_seed\n    self.num_points = num_points\n    self.norm_feats = norm_feats\n    self.with_res_feat = with_res_feat\n    assert vote_xyz_range is None or is_tuple_of(vote_xyz_range, float)\n    self.vote_xyz_range = vote_xyz_range\n    if vote_loss is not None:\n        self.vote_loss = build_loss(vote_loss)\n    prev_channels = in_channels\n    vote_conv_list = list()\n    for k in range(len(conv_channels)):\n        vote_conv_list.append(ConvModule(prev_channels, conv_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, act_cfg=act_cfg, bias=True, inplace=True))\n        prev_channels = conv_channels[k]\n    self.vote_conv = nn.Sequential(*vote_conv_list)\n    if with_res_feat:\n        out_channel = (3 + in_channels) * self.vote_per_seed\n    else:\n        out_channel = 3 * self.vote_per_seed\n    self.conv_out = nn.Conv1d(prev_channels, out_channel, 1)",
            "def __init__(self, in_channels, vote_per_seed=1, gt_per_seed=3, num_points=-1, conv_channels=(16, 16), conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), norm_feats=True, with_res_feat=True, vote_xyz_range=None, vote_loss=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__()\n    self.in_channels = in_channels\n    self.vote_per_seed = vote_per_seed\n    self.gt_per_seed = gt_per_seed\n    self.num_points = num_points\n    self.norm_feats = norm_feats\n    self.with_res_feat = with_res_feat\n    assert vote_xyz_range is None or is_tuple_of(vote_xyz_range, float)\n    self.vote_xyz_range = vote_xyz_range\n    if vote_loss is not None:\n        self.vote_loss = build_loss(vote_loss)\n    prev_channels = in_channels\n    vote_conv_list = list()\n    for k in range(len(conv_channels)):\n        vote_conv_list.append(ConvModule(prev_channels, conv_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, act_cfg=act_cfg, bias=True, inplace=True))\n        prev_channels = conv_channels[k]\n    self.vote_conv = nn.Sequential(*vote_conv_list)\n    if with_res_feat:\n        out_channel = (3 + in_channels) * self.vote_per_seed\n    else:\n        out_channel = 3 * self.vote_per_seed\n    self.conv_out = nn.Conv1d(prev_channels, out_channel, 1)",
            "def __init__(self, in_channels, vote_per_seed=1, gt_per_seed=3, num_points=-1, conv_channels=(16, 16), conv_cfg=dict(type='Conv1d'), norm_cfg=dict(type='BN1d'), act_cfg=dict(type='ReLU'), norm_feats=True, with_res_feat=True, vote_xyz_range=None, vote_loss=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__()\n    self.in_channels = in_channels\n    self.vote_per_seed = vote_per_seed\n    self.gt_per_seed = gt_per_seed\n    self.num_points = num_points\n    self.norm_feats = norm_feats\n    self.with_res_feat = with_res_feat\n    assert vote_xyz_range is None or is_tuple_of(vote_xyz_range, float)\n    self.vote_xyz_range = vote_xyz_range\n    if vote_loss is not None:\n        self.vote_loss = build_loss(vote_loss)\n    prev_channels = in_channels\n    vote_conv_list = list()\n    for k in range(len(conv_channels)):\n        vote_conv_list.append(ConvModule(prev_channels, conv_channels[k], 1, padding=0, conv_cfg=conv_cfg, norm_cfg=norm_cfg, act_cfg=act_cfg, bias=True, inplace=True))\n        prev_channels = conv_channels[k]\n    self.vote_conv = nn.Sequential(*vote_conv_list)\n    if with_res_feat:\n        out_channel = (3 + in_channels) * self.vote_per_seed\n    else:\n        out_channel = 3 * self.vote_per_seed\n    self.conv_out = nn.Conv1d(prev_channels, out_channel, 1)"
        ]
    },
    {
        "func_name": "forward",
        "original": "def forward(self, seed_points, seed_feats):\n    \"\"\"forward.\n\n        Args:\n            seed_points (torch.Tensor): Coordinate of the seed\n                points in shape (B, N, 3).\n            seed_feats (torch.Tensor): Features of the seed points in shape\n                (B, C, N).\n\n        Returns:\n            tuple[torch.Tensor]:\n\n                - vote_points: Voted xyz based on the seed points\n                    with shape (B, M, 3), ``M=num_seed*vote_per_seed``.\n                - vote_features: Voted features based on the seed points with\n                    shape (B, C, M) where ``M=num_seed*vote_per_seed``,\n                    ``C=vote_feature_dim``.\n        \"\"\"\n    if self.num_points != -1:\n        assert self.num_points < seed_points.shape[1], f'Number of vote points ({self.num_points}) should be smaller than seed points size ({seed_points.shape[1]})'\n        seed_points = seed_points[:, :self.num_points]\n        seed_feats = seed_feats[..., :self.num_points]\n    (batch_size, feat_channels, num_seed) = seed_feats.shape\n    num_vote = num_seed * self.vote_per_seed\n    x = self.vote_conv(seed_feats)\n    votes = self.conv_out(x)\n    votes = votes.transpose(2, 1).view(batch_size, num_seed, self.vote_per_seed, -1)\n    offset = votes[:, :, :, 0:3]\n    if self.vote_xyz_range is not None:\n        limited_offset_list = []\n        for axis in range(len(self.vote_xyz_range)):\n            limited_offset_list.append(offset[..., axis].clamp(min=-self.vote_xyz_range[axis], max=self.vote_xyz_range[axis]))\n        limited_offset = torch.stack(limited_offset_list, -1)\n        vote_points = (seed_points.unsqueeze(2) + limited_offset).contiguous()\n    else:\n        vote_points = (seed_points.unsqueeze(2) + offset).contiguous()\n    vote_points = vote_points.view(batch_size, num_vote, 3)\n    offset = offset.reshape(batch_size, num_vote, 3).transpose(2, 1)\n    if self.with_res_feat:\n        res_feats = votes[:, :, :, 3:]\n        vote_feats = (seed_feats.transpose(2, 1).unsqueeze(2) + res_feats).contiguous()\n        vote_feats = vote_feats.view(batch_size, num_vote, feat_channels).transpose(2, 1).contiguous()\n        if self.norm_feats:\n            features_norm = torch.norm(vote_feats, p=2, dim=1)\n            vote_feats = vote_feats.div(features_norm.unsqueeze(1))\n    else:\n        vote_feats = seed_feats\n    return (vote_points, vote_feats, offset)",
        "mutated": [
            "def forward(self, seed_points, seed_feats):\n    if False:\n        i = 10\n    'forward.\\n\\n        Args:\\n            seed_points (torch.Tensor): Coordinate of the seed\\n                points in shape (B, N, 3).\\n            seed_feats (torch.Tensor): Features of the seed points in shape\\n                (B, C, N).\\n\\n        Returns:\\n            tuple[torch.Tensor]:\\n\\n                - vote_points: Voted xyz based on the seed points\\n                    with shape (B, M, 3), ``M=num_seed*vote_per_seed``.\\n                - vote_features: Voted features based on the seed points with\\n                    shape (B, C, M) where ``M=num_seed*vote_per_seed``,\\n                    ``C=vote_feature_dim``.\\n        '\n    if self.num_points != -1:\n        assert self.num_points < seed_points.shape[1], f'Number of vote points ({self.num_points}) should be smaller than seed points size ({seed_points.shape[1]})'\n        seed_points = seed_points[:, :self.num_points]\n        seed_feats = seed_feats[..., :self.num_points]\n    (batch_size, feat_channels, num_seed) = seed_feats.shape\n    num_vote = num_seed * self.vote_per_seed\n    x = self.vote_conv(seed_feats)\n    votes = self.conv_out(x)\n    votes = votes.transpose(2, 1).view(batch_size, num_seed, self.vote_per_seed, -1)\n    offset = votes[:, :, :, 0:3]\n    if self.vote_xyz_range is not None:\n        limited_offset_list = []\n        for axis in range(len(self.vote_xyz_range)):\n            limited_offset_list.append(offset[..., axis].clamp(min=-self.vote_xyz_range[axis], max=self.vote_xyz_range[axis]))\n        limited_offset = torch.stack(limited_offset_list, -1)\n        vote_points = (seed_points.unsqueeze(2) + limited_offset).contiguous()\n    else:\n        vote_points = (seed_points.unsqueeze(2) + offset).contiguous()\n    vote_points = vote_points.view(batch_size, num_vote, 3)\n    offset = offset.reshape(batch_size, num_vote, 3).transpose(2, 1)\n    if self.with_res_feat:\n        res_feats = votes[:, :, :, 3:]\n        vote_feats = (seed_feats.transpose(2, 1).unsqueeze(2) + res_feats).contiguous()\n        vote_feats = vote_feats.view(batch_size, num_vote, feat_channels).transpose(2, 1).contiguous()\n        if self.norm_feats:\n            features_norm = torch.norm(vote_feats, p=2, dim=1)\n            vote_feats = vote_feats.div(features_norm.unsqueeze(1))\n    else:\n        vote_feats = seed_feats\n    return (vote_points, vote_feats, offset)",
            "def forward(self, seed_points, seed_feats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'forward.\\n\\n        Args:\\n            seed_points (torch.Tensor): Coordinate of the seed\\n                points in shape (B, N, 3).\\n            seed_feats (torch.Tensor): Features of the seed points in shape\\n                (B, C, N).\\n\\n        Returns:\\n            tuple[torch.Tensor]:\\n\\n                - vote_points: Voted xyz based on the seed points\\n                    with shape (B, M, 3), ``M=num_seed*vote_per_seed``.\\n                - vote_features: Voted features based on the seed points with\\n                    shape (B, C, M) where ``M=num_seed*vote_per_seed``,\\n                    ``C=vote_feature_dim``.\\n        '\n    if self.num_points != -1:\n        assert self.num_points < seed_points.shape[1], f'Number of vote points ({self.num_points}) should be smaller than seed points size ({seed_points.shape[1]})'\n        seed_points = seed_points[:, :self.num_points]\n        seed_feats = seed_feats[..., :self.num_points]\n    (batch_size, feat_channels, num_seed) = seed_feats.shape\n    num_vote = num_seed * self.vote_per_seed\n    x = self.vote_conv(seed_feats)\n    votes = self.conv_out(x)\n    votes = votes.transpose(2, 1).view(batch_size, num_seed, self.vote_per_seed, -1)\n    offset = votes[:, :, :, 0:3]\n    if self.vote_xyz_range is not None:\n        limited_offset_list = []\n        for axis in range(len(self.vote_xyz_range)):\n            limited_offset_list.append(offset[..., axis].clamp(min=-self.vote_xyz_range[axis], max=self.vote_xyz_range[axis]))\n        limited_offset = torch.stack(limited_offset_list, -1)\n        vote_points = (seed_points.unsqueeze(2) + limited_offset).contiguous()\n    else:\n        vote_points = (seed_points.unsqueeze(2) + offset).contiguous()\n    vote_points = vote_points.view(batch_size, num_vote, 3)\n    offset = offset.reshape(batch_size, num_vote, 3).transpose(2, 1)\n    if self.with_res_feat:\n        res_feats = votes[:, :, :, 3:]\n        vote_feats = (seed_feats.transpose(2, 1).unsqueeze(2) + res_feats).contiguous()\n        vote_feats = vote_feats.view(batch_size, num_vote, feat_channels).transpose(2, 1).contiguous()\n        if self.norm_feats:\n            features_norm = torch.norm(vote_feats, p=2, dim=1)\n            vote_feats = vote_feats.div(features_norm.unsqueeze(1))\n    else:\n        vote_feats = seed_feats\n    return (vote_points, vote_feats, offset)",
            "def forward(self, seed_points, seed_feats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'forward.\\n\\n        Args:\\n            seed_points (torch.Tensor): Coordinate of the seed\\n                points in shape (B, N, 3).\\n            seed_feats (torch.Tensor): Features of the seed points in shape\\n                (B, C, N).\\n\\n        Returns:\\n            tuple[torch.Tensor]:\\n\\n                - vote_points: Voted xyz based on the seed points\\n                    with shape (B, M, 3), ``M=num_seed*vote_per_seed``.\\n                - vote_features: Voted features based on the seed points with\\n                    shape (B, C, M) where ``M=num_seed*vote_per_seed``,\\n                    ``C=vote_feature_dim``.\\n        '\n    if self.num_points != -1:\n        assert self.num_points < seed_points.shape[1], f'Number of vote points ({self.num_points}) should be smaller than seed points size ({seed_points.shape[1]})'\n        seed_points = seed_points[:, :self.num_points]\n        seed_feats = seed_feats[..., :self.num_points]\n    (batch_size, feat_channels, num_seed) = seed_feats.shape\n    num_vote = num_seed * self.vote_per_seed\n    x = self.vote_conv(seed_feats)\n    votes = self.conv_out(x)\n    votes = votes.transpose(2, 1).view(batch_size, num_seed, self.vote_per_seed, -1)\n    offset = votes[:, :, :, 0:3]\n    if self.vote_xyz_range is not None:\n        limited_offset_list = []\n        for axis in range(len(self.vote_xyz_range)):\n            limited_offset_list.append(offset[..., axis].clamp(min=-self.vote_xyz_range[axis], max=self.vote_xyz_range[axis]))\n        limited_offset = torch.stack(limited_offset_list, -1)\n        vote_points = (seed_points.unsqueeze(2) + limited_offset).contiguous()\n    else:\n        vote_points = (seed_points.unsqueeze(2) + offset).contiguous()\n    vote_points = vote_points.view(batch_size, num_vote, 3)\n    offset = offset.reshape(batch_size, num_vote, 3).transpose(2, 1)\n    if self.with_res_feat:\n        res_feats = votes[:, :, :, 3:]\n        vote_feats = (seed_feats.transpose(2, 1).unsqueeze(2) + res_feats).contiguous()\n        vote_feats = vote_feats.view(batch_size, num_vote, feat_channels).transpose(2, 1).contiguous()\n        if self.norm_feats:\n            features_norm = torch.norm(vote_feats, p=2, dim=1)\n            vote_feats = vote_feats.div(features_norm.unsqueeze(1))\n    else:\n        vote_feats = seed_feats\n    return (vote_points, vote_feats, offset)",
            "def forward(self, seed_points, seed_feats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'forward.\\n\\n        Args:\\n            seed_points (torch.Tensor): Coordinate of the seed\\n                points in shape (B, N, 3).\\n            seed_feats (torch.Tensor): Features of the seed points in shape\\n                (B, C, N).\\n\\n        Returns:\\n            tuple[torch.Tensor]:\\n\\n                - vote_points: Voted xyz based on the seed points\\n                    with shape (B, M, 3), ``M=num_seed*vote_per_seed``.\\n                - vote_features: Voted features based on the seed points with\\n                    shape (B, C, M) where ``M=num_seed*vote_per_seed``,\\n                    ``C=vote_feature_dim``.\\n        '\n    if self.num_points != -1:\n        assert self.num_points < seed_points.shape[1], f'Number of vote points ({self.num_points}) should be smaller than seed points size ({seed_points.shape[1]})'\n        seed_points = seed_points[:, :self.num_points]\n        seed_feats = seed_feats[..., :self.num_points]\n    (batch_size, feat_channels, num_seed) = seed_feats.shape\n    num_vote = num_seed * self.vote_per_seed\n    x = self.vote_conv(seed_feats)\n    votes = self.conv_out(x)\n    votes = votes.transpose(2, 1).view(batch_size, num_seed, self.vote_per_seed, -1)\n    offset = votes[:, :, :, 0:3]\n    if self.vote_xyz_range is not None:\n        limited_offset_list = []\n        for axis in range(len(self.vote_xyz_range)):\n            limited_offset_list.append(offset[..., axis].clamp(min=-self.vote_xyz_range[axis], max=self.vote_xyz_range[axis]))\n        limited_offset = torch.stack(limited_offset_list, -1)\n        vote_points = (seed_points.unsqueeze(2) + limited_offset).contiguous()\n    else:\n        vote_points = (seed_points.unsqueeze(2) + offset).contiguous()\n    vote_points = vote_points.view(batch_size, num_vote, 3)\n    offset = offset.reshape(batch_size, num_vote, 3).transpose(2, 1)\n    if self.with_res_feat:\n        res_feats = votes[:, :, :, 3:]\n        vote_feats = (seed_feats.transpose(2, 1).unsqueeze(2) + res_feats).contiguous()\n        vote_feats = vote_feats.view(batch_size, num_vote, feat_channels).transpose(2, 1).contiguous()\n        if self.norm_feats:\n            features_norm = torch.norm(vote_feats, p=2, dim=1)\n            vote_feats = vote_feats.div(features_norm.unsqueeze(1))\n    else:\n        vote_feats = seed_feats\n    return (vote_points, vote_feats, offset)",
            "def forward(self, seed_points, seed_feats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'forward.\\n\\n        Args:\\n            seed_points (torch.Tensor): Coordinate of the seed\\n                points in shape (B, N, 3).\\n            seed_feats (torch.Tensor): Features of the seed points in shape\\n                (B, C, N).\\n\\n        Returns:\\n            tuple[torch.Tensor]:\\n\\n                - vote_points: Voted xyz based on the seed points\\n                    with shape (B, M, 3), ``M=num_seed*vote_per_seed``.\\n                - vote_features: Voted features based on the seed points with\\n                    shape (B, C, M) where ``M=num_seed*vote_per_seed``,\\n                    ``C=vote_feature_dim``.\\n        '\n    if self.num_points != -1:\n        assert self.num_points < seed_points.shape[1], f'Number of vote points ({self.num_points}) should be smaller than seed points size ({seed_points.shape[1]})'\n        seed_points = seed_points[:, :self.num_points]\n        seed_feats = seed_feats[..., :self.num_points]\n    (batch_size, feat_channels, num_seed) = seed_feats.shape\n    num_vote = num_seed * self.vote_per_seed\n    x = self.vote_conv(seed_feats)\n    votes = self.conv_out(x)\n    votes = votes.transpose(2, 1).view(batch_size, num_seed, self.vote_per_seed, -1)\n    offset = votes[:, :, :, 0:3]\n    if self.vote_xyz_range is not None:\n        limited_offset_list = []\n        for axis in range(len(self.vote_xyz_range)):\n            limited_offset_list.append(offset[..., axis].clamp(min=-self.vote_xyz_range[axis], max=self.vote_xyz_range[axis]))\n        limited_offset = torch.stack(limited_offset_list, -1)\n        vote_points = (seed_points.unsqueeze(2) + limited_offset).contiguous()\n    else:\n        vote_points = (seed_points.unsqueeze(2) + offset).contiguous()\n    vote_points = vote_points.view(batch_size, num_vote, 3)\n    offset = offset.reshape(batch_size, num_vote, 3).transpose(2, 1)\n    if self.with_res_feat:\n        res_feats = votes[:, :, :, 3:]\n        vote_feats = (seed_feats.transpose(2, 1).unsqueeze(2) + res_feats).contiguous()\n        vote_feats = vote_feats.view(batch_size, num_vote, feat_channels).transpose(2, 1).contiguous()\n        if self.norm_feats:\n            features_norm = torch.norm(vote_feats, p=2, dim=1)\n            vote_feats = vote_feats.div(features_norm.unsqueeze(1))\n    else:\n        vote_feats = seed_feats\n    return (vote_points, vote_feats, offset)"
        ]
    },
    {
        "func_name": "get_loss",
        "original": "def get_loss(self, seed_points, vote_points, seed_indices, vote_targets_mask, vote_targets):\n    \"\"\"Calculate loss of voting module.\n\n        Args:\n            seed_points (torch.Tensor): Coordinate of the seed points.\n            vote_points (torch.Tensor): Coordinate of the vote points.\n            seed_indices (torch.Tensor): Indices of seed points in raw points.\n            vote_targets_mask (torch.Tensor): Mask of valid vote targets.\n            vote_targets (torch.Tensor): Targets of votes.\n\n        Returns:\n            torch.Tensor: Weighted vote loss.\n        \"\"\"\n    (batch_size, num_seed) = seed_points.shape[:2]\n    seed_gt_votes_mask = torch.gather(vote_targets_mask, 1, seed_indices).float()\n    seed_indices_expand = seed_indices.unsqueeze(-1).repeat(1, 1, 3 * self.gt_per_seed)\n    seed_gt_votes = torch.gather(vote_targets, 1, seed_indices_expand)\n    seed_gt_votes += seed_points.repeat(1, 1, self.gt_per_seed)\n    weight = seed_gt_votes_mask / (torch.sum(seed_gt_votes_mask) + 1e-06)\n    distance = self.vote_loss(vote_points.view(batch_size * num_seed, -1, 3), seed_gt_votes.view(batch_size * num_seed, -1, 3), dst_weight=weight.view(batch_size * num_seed, 1))[1]\n    vote_loss = torch.sum(torch.min(distance, dim=1)[0])\n    return vote_loss",
        "mutated": [
            "def get_loss(self, seed_points, vote_points, seed_indices, vote_targets_mask, vote_targets):\n    if False:\n        i = 10\n    'Calculate loss of voting module.\\n\\n        Args:\\n            seed_points (torch.Tensor): Coordinate of the seed points.\\n            vote_points (torch.Tensor): Coordinate of the vote points.\\n            seed_indices (torch.Tensor): Indices of seed points in raw points.\\n            vote_targets_mask (torch.Tensor): Mask of valid vote targets.\\n            vote_targets (torch.Tensor): Targets of votes.\\n\\n        Returns:\\n            torch.Tensor: Weighted vote loss.\\n        '\n    (batch_size, num_seed) = seed_points.shape[:2]\n    seed_gt_votes_mask = torch.gather(vote_targets_mask, 1, seed_indices).float()\n    seed_indices_expand = seed_indices.unsqueeze(-1).repeat(1, 1, 3 * self.gt_per_seed)\n    seed_gt_votes = torch.gather(vote_targets, 1, seed_indices_expand)\n    seed_gt_votes += seed_points.repeat(1, 1, self.gt_per_seed)\n    weight = seed_gt_votes_mask / (torch.sum(seed_gt_votes_mask) + 1e-06)\n    distance = self.vote_loss(vote_points.view(batch_size * num_seed, -1, 3), seed_gt_votes.view(batch_size * num_seed, -1, 3), dst_weight=weight.view(batch_size * num_seed, 1))[1]\n    vote_loss = torch.sum(torch.min(distance, dim=1)[0])\n    return vote_loss",
            "def get_loss(self, seed_points, vote_points, seed_indices, vote_targets_mask, vote_targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Calculate loss of voting module.\\n\\n        Args:\\n            seed_points (torch.Tensor): Coordinate of the seed points.\\n            vote_points (torch.Tensor): Coordinate of the vote points.\\n            seed_indices (torch.Tensor): Indices of seed points in raw points.\\n            vote_targets_mask (torch.Tensor): Mask of valid vote targets.\\n            vote_targets (torch.Tensor): Targets of votes.\\n\\n        Returns:\\n            torch.Tensor: Weighted vote loss.\\n        '\n    (batch_size, num_seed) = seed_points.shape[:2]\n    seed_gt_votes_mask = torch.gather(vote_targets_mask, 1, seed_indices).float()\n    seed_indices_expand = seed_indices.unsqueeze(-1).repeat(1, 1, 3 * self.gt_per_seed)\n    seed_gt_votes = torch.gather(vote_targets, 1, seed_indices_expand)\n    seed_gt_votes += seed_points.repeat(1, 1, self.gt_per_seed)\n    weight = seed_gt_votes_mask / (torch.sum(seed_gt_votes_mask) + 1e-06)\n    distance = self.vote_loss(vote_points.view(batch_size * num_seed, -1, 3), seed_gt_votes.view(batch_size * num_seed, -1, 3), dst_weight=weight.view(batch_size * num_seed, 1))[1]\n    vote_loss = torch.sum(torch.min(distance, dim=1)[0])\n    return vote_loss",
            "def get_loss(self, seed_points, vote_points, seed_indices, vote_targets_mask, vote_targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Calculate loss of voting module.\\n\\n        Args:\\n            seed_points (torch.Tensor): Coordinate of the seed points.\\n            vote_points (torch.Tensor): Coordinate of the vote points.\\n            seed_indices (torch.Tensor): Indices of seed points in raw points.\\n            vote_targets_mask (torch.Tensor): Mask of valid vote targets.\\n            vote_targets (torch.Tensor): Targets of votes.\\n\\n        Returns:\\n            torch.Tensor: Weighted vote loss.\\n        '\n    (batch_size, num_seed) = seed_points.shape[:2]\n    seed_gt_votes_mask = torch.gather(vote_targets_mask, 1, seed_indices).float()\n    seed_indices_expand = seed_indices.unsqueeze(-1).repeat(1, 1, 3 * self.gt_per_seed)\n    seed_gt_votes = torch.gather(vote_targets, 1, seed_indices_expand)\n    seed_gt_votes += seed_points.repeat(1, 1, self.gt_per_seed)\n    weight = seed_gt_votes_mask / (torch.sum(seed_gt_votes_mask) + 1e-06)\n    distance = self.vote_loss(vote_points.view(batch_size * num_seed, -1, 3), seed_gt_votes.view(batch_size * num_seed, -1, 3), dst_weight=weight.view(batch_size * num_seed, 1))[1]\n    vote_loss = torch.sum(torch.min(distance, dim=1)[0])\n    return vote_loss",
            "def get_loss(self, seed_points, vote_points, seed_indices, vote_targets_mask, vote_targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Calculate loss of voting module.\\n\\n        Args:\\n            seed_points (torch.Tensor): Coordinate of the seed points.\\n            vote_points (torch.Tensor): Coordinate of the vote points.\\n            seed_indices (torch.Tensor): Indices of seed points in raw points.\\n            vote_targets_mask (torch.Tensor): Mask of valid vote targets.\\n            vote_targets (torch.Tensor): Targets of votes.\\n\\n        Returns:\\n            torch.Tensor: Weighted vote loss.\\n        '\n    (batch_size, num_seed) = seed_points.shape[:2]\n    seed_gt_votes_mask = torch.gather(vote_targets_mask, 1, seed_indices).float()\n    seed_indices_expand = seed_indices.unsqueeze(-1).repeat(1, 1, 3 * self.gt_per_seed)\n    seed_gt_votes = torch.gather(vote_targets, 1, seed_indices_expand)\n    seed_gt_votes += seed_points.repeat(1, 1, self.gt_per_seed)\n    weight = seed_gt_votes_mask / (torch.sum(seed_gt_votes_mask) + 1e-06)\n    distance = self.vote_loss(vote_points.view(batch_size * num_seed, -1, 3), seed_gt_votes.view(batch_size * num_seed, -1, 3), dst_weight=weight.view(batch_size * num_seed, 1))[1]\n    vote_loss = torch.sum(torch.min(distance, dim=1)[0])\n    return vote_loss",
            "def get_loss(self, seed_points, vote_points, seed_indices, vote_targets_mask, vote_targets):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Calculate loss of voting module.\\n\\n        Args:\\n            seed_points (torch.Tensor): Coordinate of the seed points.\\n            vote_points (torch.Tensor): Coordinate of the vote points.\\n            seed_indices (torch.Tensor): Indices of seed points in raw points.\\n            vote_targets_mask (torch.Tensor): Mask of valid vote targets.\\n            vote_targets (torch.Tensor): Targets of votes.\\n\\n        Returns:\\n            torch.Tensor: Weighted vote loss.\\n        '\n    (batch_size, num_seed) = seed_points.shape[:2]\n    seed_gt_votes_mask = torch.gather(vote_targets_mask, 1, seed_indices).float()\n    seed_indices_expand = seed_indices.unsqueeze(-1).repeat(1, 1, 3 * self.gt_per_seed)\n    seed_gt_votes = torch.gather(vote_targets, 1, seed_indices_expand)\n    seed_gt_votes += seed_points.repeat(1, 1, self.gt_per_seed)\n    weight = seed_gt_votes_mask / (torch.sum(seed_gt_votes_mask) + 1e-06)\n    distance = self.vote_loss(vote_points.view(batch_size * num_seed, -1, 3), seed_gt_votes.view(batch_size * num_seed, -1, 3), dst_weight=weight.view(batch_size * num_seed, 1))[1]\n    vote_loss = torch.sum(torch.min(distance, dim=1)[0])\n    return vote_loss"
        ]
    }
]