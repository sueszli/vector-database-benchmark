[
    {
        "func_name": "_get_rtol_atol",
        "original": "def _get_rtol_atol(dtype):\n    rtol = 0.001\n    atol = 0\n    if dtype == np.float16:\n        rtol = 0.01\n        atol = 0.001\n    elif dtype == np.float32:\n        atol = 1e-05\n    return (rtol, atol)",
        "mutated": [
            "def _get_rtol_atol(dtype):\n    if False:\n        i = 10\n    rtol = 0.001\n    atol = 0\n    if dtype == np.float16:\n        rtol = 0.01\n        atol = 0.001\n    elif dtype == np.float32:\n        atol = 1e-05\n    return (rtol, atol)",
            "def _get_rtol_atol(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rtol = 0.001\n    atol = 0\n    if dtype == np.float16:\n        rtol = 0.01\n        atol = 0.001\n    elif dtype == np.float32:\n        atol = 1e-05\n    return (rtol, atol)",
            "def _get_rtol_atol(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rtol = 0.001\n    atol = 0\n    if dtype == np.float16:\n        rtol = 0.01\n        atol = 0.001\n    elif dtype == np.float32:\n        atol = 1e-05\n    return (rtol, atol)",
            "def _get_rtol_atol(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rtol = 0.001\n    atol = 0\n    if dtype == np.float16:\n        rtol = 0.01\n        atol = 0.001\n    elif dtype == np.float32:\n        atol = 1e-05\n    return (rtol, atol)",
            "def _get_rtol_atol(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rtol = 0.001\n    atol = 0\n    if dtype == np.float16:\n        rtol = 0.01\n        atol = 0.001\n    elif dtype == np.float32:\n        atol = 1e-05\n    return (rtol, atol)"
        ]
    },
    {
        "func_name": "test_wiener",
        "original": "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_wiener(dtype, ndim):\n    \"\"\"\n    currently only performs pixelwise comparison to\n    precomputed result in 2d case.\n    \"\"\"\n    rng = np.random.RandomState(0)\n    psf = np.ones([5] * ndim, dtype=dtype) / 5 ** ndim\n    if ndim != 2:\n        test_img = rng.randint(0, 100, [50] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    deconvolved = restoration.wiener(data, psf, 0.05)\n    assert deconvolved.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        (rtol, atol) = _get_rtol_atol(dtype)\n        path = fetch('restoration/tests/camera_wiener.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(ndim, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved = restoration.wiener(data, otf, 0.05, reg=laplacian, is_real=False)\n    assert deconvolved.real.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        np.testing.assert_allclose(np.real(deconvolved), np.load(path), rtol=rtol, atol=atol)",
        "mutated": [
            "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_wiener(dtype, ndim):\n    if False:\n        i = 10\n    '\\n    currently only performs pixelwise comparison to\\n    precomputed result in 2d case.\\n    '\n    rng = np.random.RandomState(0)\n    psf = np.ones([5] * ndim, dtype=dtype) / 5 ** ndim\n    if ndim != 2:\n        test_img = rng.randint(0, 100, [50] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    deconvolved = restoration.wiener(data, psf, 0.05)\n    assert deconvolved.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        (rtol, atol) = _get_rtol_atol(dtype)\n        path = fetch('restoration/tests/camera_wiener.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(ndim, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved = restoration.wiener(data, otf, 0.05, reg=laplacian, is_real=False)\n    assert deconvolved.real.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        np.testing.assert_allclose(np.real(deconvolved), np.load(path), rtol=rtol, atol=atol)",
            "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_wiener(dtype, ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    currently only performs pixelwise comparison to\\n    precomputed result in 2d case.\\n    '\n    rng = np.random.RandomState(0)\n    psf = np.ones([5] * ndim, dtype=dtype) / 5 ** ndim\n    if ndim != 2:\n        test_img = rng.randint(0, 100, [50] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    deconvolved = restoration.wiener(data, psf, 0.05)\n    assert deconvolved.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        (rtol, atol) = _get_rtol_atol(dtype)\n        path = fetch('restoration/tests/camera_wiener.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(ndim, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved = restoration.wiener(data, otf, 0.05, reg=laplacian, is_real=False)\n    assert deconvolved.real.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        np.testing.assert_allclose(np.real(deconvolved), np.load(path), rtol=rtol, atol=atol)",
            "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_wiener(dtype, ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    currently only performs pixelwise comparison to\\n    precomputed result in 2d case.\\n    '\n    rng = np.random.RandomState(0)\n    psf = np.ones([5] * ndim, dtype=dtype) / 5 ** ndim\n    if ndim != 2:\n        test_img = rng.randint(0, 100, [50] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    deconvolved = restoration.wiener(data, psf, 0.05)\n    assert deconvolved.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        (rtol, atol) = _get_rtol_atol(dtype)\n        path = fetch('restoration/tests/camera_wiener.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(ndim, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved = restoration.wiener(data, otf, 0.05, reg=laplacian, is_real=False)\n    assert deconvolved.real.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        np.testing.assert_allclose(np.real(deconvolved), np.load(path), rtol=rtol, atol=atol)",
            "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_wiener(dtype, ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    currently only performs pixelwise comparison to\\n    precomputed result in 2d case.\\n    '\n    rng = np.random.RandomState(0)\n    psf = np.ones([5] * ndim, dtype=dtype) / 5 ** ndim\n    if ndim != 2:\n        test_img = rng.randint(0, 100, [50] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    deconvolved = restoration.wiener(data, psf, 0.05)\n    assert deconvolved.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        (rtol, atol) = _get_rtol_atol(dtype)\n        path = fetch('restoration/tests/camera_wiener.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(ndim, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved = restoration.wiener(data, otf, 0.05, reg=laplacian, is_real=False)\n    assert deconvolved.real.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        np.testing.assert_allclose(np.real(deconvolved), np.load(path), rtol=rtol, atol=atol)",
            "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_wiener(dtype, ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    currently only performs pixelwise comparison to\\n    precomputed result in 2d case.\\n    '\n    rng = np.random.RandomState(0)\n    psf = np.ones([5] * ndim, dtype=dtype) / 5 ** ndim\n    if ndim != 2:\n        test_img = rng.randint(0, 100, [50] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    deconvolved = restoration.wiener(data, psf, 0.05)\n    assert deconvolved.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        (rtol, atol) = _get_rtol_atol(dtype)\n        path = fetch('restoration/tests/camera_wiener.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(ndim, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved = restoration.wiener(data, otf, 0.05, reg=laplacian, is_real=False)\n    assert deconvolved.real.dtype == _supported_float_type(dtype)\n    if ndim == 2:\n        np.testing.assert_allclose(np.real(deconvolved), np.load(path), rtol=rtol, atol=atol)"
        ]
    },
    {
        "func_name": "test_unsupervised_wiener",
        "original": "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\ndef test_unsupervised_wiener(dtype):\n    psf = np.ones((5, 5), dtype=dtype) / 25\n    data = convolve2d(test_img, psf, 'same')\n    seed = 16829302\n    rng = np.random.RandomState(seed)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    (deconvolved, _) = restoration.unsupervised_wiener(data, psf, rng=seed)\n    with expected_warnings(['`random_state` is a deprecated argument']):\n        restoration.unsupervised_wiener(data, psf, random_state=seed)\n    float_type = _supported_float_type(dtype)\n    assert deconvolved.dtype == float_type\n    (rtol, atol) = _get_rtol_atol(dtype)\n    path = fetch('restoration/tests/camera_unsup.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved2 = restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'callback': lambda x: None, 'max_num_iter': 200, 'min_num_iter': 30}, rng=seed)[0]\n    assert deconvolved2.real.dtype == float_type\n    path = fetch('restoration/tests/camera_unsup2.npy')\n    np.testing.assert_allclose(np.real(deconvolved2), np.load(path), rtol=rtol, atol=atol)",
        "mutated": [
            "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\ndef test_unsupervised_wiener(dtype):\n    if False:\n        i = 10\n    psf = np.ones((5, 5), dtype=dtype) / 25\n    data = convolve2d(test_img, psf, 'same')\n    seed = 16829302\n    rng = np.random.RandomState(seed)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    (deconvolved, _) = restoration.unsupervised_wiener(data, psf, rng=seed)\n    with expected_warnings(['`random_state` is a deprecated argument']):\n        restoration.unsupervised_wiener(data, psf, random_state=seed)\n    float_type = _supported_float_type(dtype)\n    assert deconvolved.dtype == float_type\n    (rtol, atol) = _get_rtol_atol(dtype)\n    path = fetch('restoration/tests/camera_unsup.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved2 = restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'callback': lambda x: None, 'max_num_iter': 200, 'min_num_iter': 30}, rng=seed)[0]\n    assert deconvolved2.real.dtype == float_type\n    path = fetch('restoration/tests/camera_unsup2.npy')\n    np.testing.assert_allclose(np.real(deconvolved2), np.load(path), rtol=rtol, atol=atol)",
            "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\ndef test_unsupervised_wiener(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    psf = np.ones((5, 5), dtype=dtype) / 25\n    data = convolve2d(test_img, psf, 'same')\n    seed = 16829302\n    rng = np.random.RandomState(seed)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    (deconvolved, _) = restoration.unsupervised_wiener(data, psf, rng=seed)\n    with expected_warnings(['`random_state` is a deprecated argument']):\n        restoration.unsupervised_wiener(data, psf, random_state=seed)\n    float_type = _supported_float_type(dtype)\n    assert deconvolved.dtype == float_type\n    (rtol, atol) = _get_rtol_atol(dtype)\n    path = fetch('restoration/tests/camera_unsup.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved2 = restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'callback': lambda x: None, 'max_num_iter': 200, 'min_num_iter': 30}, rng=seed)[0]\n    assert deconvolved2.real.dtype == float_type\n    path = fetch('restoration/tests/camera_unsup2.npy')\n    np.testing.assert_allclose(np.real(deconvolved2), np.load(path), rtol=rtol, atol=atol)",
            "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\ndef test_unsupervised_wiener(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    psf = np.ones((5, 5), dtype=dtype) / 25\n    data = convolve2d(test_img, psf, 'same')\n    seed = 16829302\n    rng = np.random.RandomState(seed)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    (deconvolved, _) = restoration.unsupervised_wiener(data, psf, rng=seed)\n    with expected_warnings(['`random_state` is a deprecated argument']):\n        restoration.unsupervised_wiener(data, psf, random_state=seed)\n    float_type = _supported_float_type(dtype)\n    assert deconvolved.dtype == float_type\n    (rtol, atol) = _get_rtol_atol(dtype)\n    path = fetch('restoration/tests/camera_unsup.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved2 = restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'callback': lambda x: None, 'max_num_iter': 200, 'min_num_iter': 30}, rng=seed)[0]\n    assert deconvolved2.real.dtype == float_type\n    path = fetch('restoration/tests/camera_unsup2.npy')\n    np.testing.assert_allclose(np.real(deconvolved2), np.load(path), rtol=rtol, atol=atol)",
            "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\ndef test_unsupervised_wiener(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    psf = np.ones((5, 5), dtype=dtype) / 25\n    data = convolve2d(test_img, psf, 'same')\n    seed = 16829302\n    rng = np.random.RandomState(seed)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    (deconvolved, _) = restoration.unsupervised_wiener(data, psf, rng=seed)\n    with expected_warnings(['`random_state` is a deprecated argument']):\n        restoration.unsupervised_wiener(data, psf, random_state=seed)\n    float_type = _supported_float_type(dtype)\n    assert deconvolved.dtype == float_type\n    (rtol, atol) = _get_rtol_atol(dtype)\n    path = fetch('restoration/tests/camera_unsup.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved2 = restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'callback': lambda x: None, 'max_num_iter': 200, 'min_num_iter': 30}, rng=seed)[0]\n    assert deconvolved2.real.dtype == float_type\n    path = fetch('restoration/tests/camera_unsup2.npy')\n    np.testing.assert_allclose(np.real(deconvolved2), np.load(path), rtol=rtol, atol=atol)",
            "@pytest.mark.parametrize('dtype', [np.float16, np.float32, np.float64])\ndef test_unsupervised_wiener(dtype):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    psf = np.ones((5, 5), dtype=dtype) / 25\n    data = convolve2d(test_img, psf, 'same')\n    seed = 16829302\n    rng = np.random.RandomState(seed)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    data = data.astype(dtype, copy=False)\n    (deconvolved, _) = restoration.unsupervised_wiener(data, psf, rng=seed)\n    with expected_warnings(['`random_state` is a deprecated argument']):\n        restoration.unsupervised_wiener(data, psf, random_state=seed)\n    float_type = _supported_float_type(dtype)\n    assert deconvolved.dtype == float_type\n    (rtol, atol) = _get_rtol_atol(dtype)\n    path = fetch('restoration/tests/camera_unsup.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=rtol, atol=atol)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    assert otf.real.dtype == _supported_float_type(dtype)\n    deconvolved2 = restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'callback': lambda x: None, 'max_num_iter': 200, 'min_num_iter': 30}, rng=seed)[0]\n    assert deconvolved2.real.dtype == float_type\n    path = fetch('restoration/tests/camera_unsup2.npy')\n    np.testing.assert_allclose(np.real(deconvolved2), np.load(path), rtol=rtol, atol=atol)"
        ]
    },
    {
        "func_name": "test_unsupervised_wiener_deprecated_user_param",
        "original": "def test_unsupervised_wiener_deprecated_user_param():\n    psf = np.ones((5, 5), dtype=float) / 25\n    data = convolve2d(test_img, psf, 'same')\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'max_num_iter': 300, 'min_num_iter': 30}, rng=5)",
        "mutated": [
            "def test_unsupervised_wiener_deprecated_user_param():\n    if False:\n        i = 10\n    psf = np.ones((5, 5), dtype=float) / 25\n    data = convolve2d(test_img, psf, 'same')\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'max_num_iter': 300, 'min_num_iter': 30}, rng=5)",
            "def test_unsupervised_wiener_deprecated_user_param():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    psf = np.ones((5, 5), dtype=float) / 25\n    data = convolve2d(test_img, psf, 'same')\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'max_num_iter': 300, 'min_num_iter': 30}, rng=5)",
            "def test_unsupervised_wiener_deprecated_user_param():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    psf = np.ones((5, 5), dtype=float) / 25\n    data = convolve2d(test_img, psf, 'same')\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'max_num_iter': 300, 'min_num_iter': 30}, rng=5)",
            "def test_unsupervised_wiener_deprecated_user_param():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    psf = np.ones((5, 5), dtype=float) / 25\n    data = convolve2d(test_img, psf, 'same')\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'max_num_iter': 300, 'min_num_iter': 30}, rng=5)",
            "def test_unsupervised_wiener_deprecated_user_param():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    psf = np.ones((5, 5), dtype=float) / 25\n    data = convolve2d(test_img, psf, 'same')\n    otf = uft.ir2tf(psf, data.shape, is_real=False)\n    (_, laplacian) = uft.laplacian(2, data.shape)\n    restoration.unsupervised_wiener(data, otf, reg=laplacian, is_real=False, user_params={'max_num_iter': 300, 'min_num_iter': 30}, rng=5)"
        ]
    },
    {
        "func_name": "test_image_shape",
        "original": "def test_image_shape():\n    \"\"\"Test that shape of output image in deconvolution is same as input.\n\n    This addresses issue #1172.\n    \"\"\"\n    point = np.zeros((5, 5), float)\n    point[2, 2] = 1.0\n    psf = filters.gaussian(point, sigma=1.0, mode='reflect')\n    image = util.img_as_float(camera()[65:165, 215:315])\n    image_conv = ndi.convolve(image, psf)\n    deconv_sup = restoration.wiener(image_conv, psf, 1)\n    deconv_un = restoration.unsupervised_wiener(image_conv, psf)[0]\n    np.testing.assert_equal(image.shape, deconv_sup.shape)\n    np.testing.assert_equal(image.shape, deconv_un.shape)\n    sup_relative_error = np.abs(deconv_sup - image) / image\n    un_relative_error = np.abs(deconv_un - image) / image\n    np.testing.assert_array_less(np.median(sup_relative_error), 0.1)\n    np.testing.assert_array_less(np.median(un_relative_error), 0.1)",
        "mutated": [
            "def test_image_shape():\n    if False:\n        i = 10\n    'Test that shape of output image in deconvolution is same as input.\\n\\n    This addresses issue #1172.\\n    '\n    point = np.zeros((5, 5), float)\n    point[2, 2] = 1.0\n    psf = filters.gaussian(point, sigma=1.0, mode='reflect')\n    image = util.img_as_float(camera()[65:165, 215:315])\n    image_conv = ndi.convolve(image, psf)\n    deconv_sup = restoration.wiener(image_conv, psf, 1)\n    deconv_un = restoration.unsupervised_wiener(image_conv, psf)[0]\n    np.testing.assert_equal(image.shape, deconv_sup.shape)\n    np.testing.assert_equal(image.shape, deconv_un.shape)\n    sup_relative_error = np.abs(deconv_sup - image) / image\n    un_relative_error = np.abs(deconv_un - image) / image\n    np.testing.assert_array_less(np.median(sup_relative_error), 0.1)\n    np.testing.assert_array_less(np.median(un_relative_error), 0.1)",
            "def test_image_shape():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test that shape of output image in deconvolution is same as input.\\n\\n    This addresses issue #1172.\\n    '\n    point = np.zeros((5, 5), float)\n    point[2, 2] = 1.0\n    psf = filters.gaussian(point, sigma=1.0, mode='reflect')\n    image = util.img_as_float(camera()[65:165, 215:315])\n    image_conv = ndi.convolve(image, psf)\n    deconv_sup = restoration.wiener(image_conv, psf, 1)\n    deconv_un = restoration.unsupervised_wiener(image_conv, psf)[0]\n    np.testing.assert_equal(image.shape, deconv_sup.shape)\n    np.testing.assert_equal(image.shape, deconv_un.shape)\n    sup_relative_error = np.abs(deconv_sup - image) / image\n    un_relative_error = np.abs(deconv_un - image) / image\n    np.testing.assert_array_less(np.median(sup_relative_error), 0.1)\n    np.testing.assert_array_less(np.median(un_relative_error), 0.1)",
            "def test_image_shape():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test that shape of output image in deconvolution is same as input.\\n\\n    This addresses issue #1172.\\n    '\n    point = np.zeros((5, 5), float)\n    point[2, 2] = 1.0\n    psf = filters.gaussian(point, sigma=1.0, mode='reflect')\n    image = util.img_as_float(camera()[65:165, 215:315])\n    image_conv = ndi.convolve(image, psf)\n    deconv_sup = restoration.wiener(image_conv, psf, 1)\n    deconv_un = restoration.unsupervised_wiener(image_conv, psf)[0]\n    np.testing.assert_equal(image.shape, deconv_sup.shape)\n    np.testing.assert_equal(image.shape, deconv_un.shape)\n    sup_relative_error = np.abs(deconv_sup - image) / image\n    un_relative_error = np.abs(deconv_un - image) / image\n    np.testing.assert_array_less(np.median(sup_relative_error), 0.1)\n    np.testing.assert_array_less(np.median(un_relative_error), 0.1)",
            "def test_image_shape():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test that shape of output image in deconvolution is same as input.\\n\\n    This addresses issue #1172.\\n    '\n    point = np.zeros((5, 5), float)\n    point[2, 2] = 1.0\n    psf = filters.gaussian(point, sigma=1.0, mode='reflect')\n    image = util.img_as_float(camera()[65:165, 215:315])\n    image_conv = ndi.convolve(image, psf)\n    deconv_sup = restoration.wiener(image_conv, psf, 1)\n    deconv_un = restoration.unsupervised_wiener(image_conv, psf)[0]\n    np.testing.assert_equal(image.shape, deconv_sup.shape)\n    np.testing.assert_equal(image.shape, deconv_un.shape)\n    sup_relative_error = np.abs(deconv_sup - image) / image\n    un_relative_error = np.abs(deconv_un - image) / image\n    np.testing.assert_array_less(np.median(sup_relative_error), 0.1)\n    np.testing.assert_array_less(np.median(un_relative_error), 0.1)",
            "def test_image_shape():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test that shape of output image in deconvolution is same as input.\\n\\n    This addresses issue #1172.\\n    '\n    point = np.zeros((5, 5), float)\n    point[2, 2] = 1.0\n    psf = filters.gaussian(point, sigma=1.0, mode='reflect')\n    image = util.img_as_float(camera()[65:165, 215:315])\n    image_conv = ndi.convolve(image, psf)\n    deconv_sup = restoration.wiener(image_conv, psf, 1)\n    deconv_un = restoration.unsupervised_wiener(image_conv, psf)[0]\n    np.testing.assert_equal(image.shape, deconv_sup.shape)\n    np.testing.assert_equal(image.shape, deconv_un.shape)\n    sup_relative_error = np.abs(deconv_sup - image) / image\n    un_relative_error = np.abs(deconv_un - image) / image\n    np.testing.assert_array_less(np.median(sup_relative_error), 0.1)\n    np.testing.assert_array_less(np.median(un_relative_error), 0.1)"
        ]
    },
    {
        "func_name": "test_richardson_lucy",
        "original": "@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_richardson_lucy(ndim):\n    psf = np.ones([5] * ndim, dtype=float) / 5 ** ndim\n    if ndim != 2:\n        test_img = np.random.randint(0, 100, [30] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    rng = np.random.RandomState(0)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    deconvolved = restoration.richardson_lucy(data, psf, num_iter=5)\n    if ndim == 2:\n        path = fetch('restoration/tests/camera_rl.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001)",
        "mutated": [
            "@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_richardson_lucy(ndim):\n    if False:\n        i = 10\n    psf = np.ones([5] * ndim, dtype=float) / 5 ** ndim\n    if ndim != 2:\n        test_img = np.random.randint(0, 100, [30] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    rng = np.random.RandomState(0)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    deconvolved = restoration.richardson_lucy(data, psf, num_iter=5)\n    if ndim == 2:\n        path = fetch('restoration/tests/camera_rl.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001)",
            "@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_richardson_lucy(ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    psf = np.ones([5] * ndim, dtype=float) / 5 ** ndim\n    if ndim != 2:\n        test_img = np.random.randint(0, 100, [30] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    rng = np.random.RandomState(0)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    deconvolved = restoration.richardson_lucy(data, psf, num_iter=5)\n    if ndim == 2:\n        path = fetch('restoration/tests/camera_rl.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001)",
            "@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_richardson_lucy(ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    psf = np.ones([5] * ndim, dtype=float) / 5 ** ndim\n    if ndim != 2:\n        test_img = np.random.randint(0, 100, [30] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    rng = np.random.RandomState(0)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    deconvolved = restoration.richardson_lucy(data, psf, num_iter=5)\n    if ndim == 2:\n        path = fetch('restoration/tests/camera_rl.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001)",
            "@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_richardson_lucy(ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    psf = np.ones([5] * ndim, dtype=float) / 5 ** ndim\n    if ndim != 2:\n        test_img = np.random.randint(0, 100, [30] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    rng = np.random.RandomState(0)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    deconvolved = restoration.richardson_lucy(data, psf, num_iter=5)\n    if ndim == 2:\n        path = fetch('restoration/tests/camera_rl.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001)",
            "@pytest.mark.parametrize('ndim', [1, 2, 3])\ndef test_richardson_lucy(ndim):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    psf = np.ones([5] * ndim, dtype=float) / 5 ** ndim\n    if ndim != 2:\n        test_img = np.random.randint(0, 100, [30] * ndim)\n    else:\n        test_img = util.img_as_float(camera())\n    data = convolve(test_img, psf, 'same')\n    rng = np.random.RandomState(0)\n    data += 0.1 * data.std() * rng.standard_normal(data.shape)\n    deconvolved = restoration.richardson_lucy(data, psf, num_iter=5)\n    if ndim == 2:\n        path = fetch('restoration/tests/camera_rl.npy')\n        np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001)"
        ]
    },
    {
        "func_name": "test_richardson_lucy_filtered",
        "original": "@pytest.mark.parametrize('dtype_image', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('dtype_psf', [np.float32, np.float64])\ndef test_richardson_lucy_filtered(dtype_image, dtype_psf):\n    if dtype_image == np.float64:\n        atol = 1e-08\n    else:\n        atol = 1e-05\n    test_img_astro = rgb2gray(astronaut())\n    psf = np.ones((5, 5), dtype=dtype_psf) / 25\n    data = convolve2d(test_img_astro, psf, 'same')\n    data = data.astype(dtype_image, copy=False)\n    deconvolved = restoration.richardson_lucy(data, psf, 5, filter_epsilon=1e-06)\n    assert deconvolved.dtype == _supported_float_type(data.dtype)\n    path = fetch('restoration/tests/astronaut_rl.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001, atol=atol)",
        "mutated": [
            "@pytest.mark.parametrize('dtype_image', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('dtype_psf', [np.float32, np.float64])\ndef test_richardson_lucy_filtered(dtype_image, dtype_psf):\n    if False:\n        i = 10\n    if dtype_image == np.float64:\n        atol = 1e-08\n    else:\n        atol = 1e-05\n    test_img_astro = rgb2gray(astronaut())\n    psf = np.ones((5, 5), dtype=dtype_psf) / 25\n    data = convolve2d(test_img_astro, psf, 'same')\n    data = data.astype(dtype_image, copy=False)\n    deconvolved = restoration.richardson_lucy(data, psf, 5, filter_epsilon=1e-06)\n    assert deconvolved.dtype == _supported_float_type(data.dtype)\n    path = fetch('restoration/tests/astronaut_rl.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001, atol=atol)",
            "@pytest.mark.parametrize('dtype_image', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('dtype_psf', [np.float32, np.float64])\ndef test_richardson_lucy_filtered(dtype_image, dtype_psf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if dtype_image == np.float64:\n        atol = 1e-08\n    else:\n        atol = 1e-05\n    test_img_astro = rgb2gray(astronaut())\n    psf = np.ones((5, 5), dtype=dtype_psf) / 25\n    data = convolve2d(test_img_astro, psf, 'same')\n    data = data.astype(dtype_image, copy=False)\n    deconvolved = restoration.richardson_lucy(data, psf, 5, filter_epsilon=1e-06)\n    assert deconvolved.dtype == _supported_float_type(data.dtype)\n    path = fetch('restoration/tests/astronaut_rl.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001, atol=atol)",
            "@pytest.mark.parametrize('dtype_image', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('dtype_psf', [np.float32, np.float64])\ndef test_richardson_lucy_filtered(dtype_image, dtype_psf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if dtype_image == np.float64:\n        atol = 1e-08\n    else:\n        atol = 1e-05\n    test_img_astro = rgb2gray(astronaut())\n    psf = np.ones((5, 5), dtype=dtype_psf) / 25\n    data = convolve2d(test_img_astro, psf, 'same')\n    data = data.astype(dtype_image, copy=False)\n    deconvolved = restoration.richardson_lucy(data, psf, 5, filter_epsilon=1e-06)\n    assert deconvolved.dtype == _supported_float_type(data.dtype)\n    path = fetch('restoration/tests/astronaut_rl.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001, atol=atol)",
            "@pytest.mark.parametrize('dtype_image', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('dtype_psf', [np.float32, np.float64])\ndef test_richardson_lucy_filtered(dtype_image, dtype_psf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if dtype_image == np.float64:\n        atol = 1e-08\n    else:\n        atol = 1e-05\n    test_img_astro = rgb2gray(astronaut())\n    psf = np.ones((5, 5), dtype=dtype_psf) / 25\n    data = convolve2d(test_img_astro, psf, 'same')\n    data = data.astype(dtype_image, copy=False)\n    deconvolved = restoration.richardson_lucy(data, psf, 5, filter_epsilon=1e-06)\n    assert deconvolved.dtype == _supported_float_type(data.dtype)\n    path = fetch('restoration/tests/astronaut_rl.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001, atol=atol)",
            "@pytest.mark.parametrize('dtype_image', [np.float16, np.float32, np.float64])\n@pytest.mark.parametrize('dtype_psf', [np.float32, np.float64])\ndef test_richardson_lucy_filtered(dtype_image, dtype_psf):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if dtype_image == np.float64:\n        atol = 1e-08\n    else:\n        atol = 1e-05\n    test_img_astro = rgb2gray(astronaut())\n    psf = np.ones((5, 5), dtype=dtype_psf) / 25\n    data = convolve2d(test_img_astro, psf, 'same')\n    data = data.astype(dtype_image, copy=False)\n    deconvolved = restoration.richardson_lucy(data, psf, 5, filter_epsilon=1e-06)\n    assert deconvolved.dtype == _supported_float_type(data.dtype)\n    path = fetch('restoration/tests/astronaut_rl.npy')\n    np.testing.assert_allclose(deconvolved, np.load(path), rtol=0.001, atol=atol)"
        ]
    }
]