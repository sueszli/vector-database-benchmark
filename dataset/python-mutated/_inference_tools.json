[
    {
        "func_name": "_mover_confint",
        "original": "def _mover_confint(stat1, stat2, ci1, ci2, contrast='diff'):\n    \"\"\"\n\n    References\n    ----------\n\n    .. [#] Krishnamoorthy, K., Jie Peng, and Dan Zhang. 2016. \u201cModified Large\n       Sample Confidence Intervals for Poisson Distributions: Ratio, Weighted\n       Average, and Product of Means.\u201d Communications in Statistics - Theory\n       and Methods 45 (1): 83\u201397. https://doi.org/10.1080/03610926.2013.821486.\n\n\n    .. [#] Li, Yanhong, John J. Koval, Allan Donner, and G. Y. Zou. 2010.\n       \u201cInterval Estimation for the Area under the Receiver Operating\n       Characteristic Curve When Data Are Subject to Error.\u201d Statistics in\n       Medicine 29 (24): 2521\u201331. https://doi.org/10.1002/sim.4015.\n\n    .. [#] Zou, G. Y., and A. Donner. 2008. \u201cConstruction of Confidence Limits\n       about Effect Measures: A General Approach.\u201d Statistics in Medicine 27\n       (10): 1693\u20131702. https://doi.org/10.1002/sim.3095.\n    \"\"\"\n    if contrast == 'diff':\n        stat = stat1 - stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[1]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[0]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'sum':\n        stat = stat1 + stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[0]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[1]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'ratio':\n        prod = stat1 * stat2\n        term1 = stat2 ** 2 - (ci2[1] - stat2) ** 2\n        term2 = stat2 ** 2 - (ci2[0] - stat2) ** 2\n        low_ = (prod - np.sqrt(prod ** 2 - term1 * (stat1 ** 2 - (ci1[0] - stat1) ** 2))) / term1\n        upp_ = (prod + np.sqrt(prod ** 2 - term2 * (stat1 ** 2 - (ci1[1] - stat1) ** 2))) / term2\n        (low1, upp1) = ci1\n        (low2, upp2) = ci2\n        term1 = upp2 * (2 * stat2 - upp2)\n        term2 = low2 * (2 * stat2 - low2)\n        low = (prod - np.sqrt(prod ** 2 - term1 * low1 * (2 * stat1 - low1))) / term1\n        upp = (prod + np.sqrt(prod ** 2 - term2 * upp1 * (2 * stat1 - upp1))) / term2\n        assert_allclose((low_, upp_), (low, upp), atol=1e-15, rtol=1e-10)\n        ci = (low, upp)\n    return ci",
        "mutated": [
            "def _mover_confint(stat1, stat2, ci1, ci2, contrast='diff'):\n    if False:\n        i = 10\n    '\\n\\n    References\\n    ----------\\n\\n    .. [#] Krishnamoorthy, K., Jie Peng, and Dan Zhang. 2016. \u201cModified Large\\n       Sample Confidence Intervals for Poisson Distributions: Ratio, Weighted\\n       Average, and Product of Means.\u201d Communications in Statistics - Theory\\n       and Methods 45 (1): 83\u201397. https://doi.org/10.1080/03610926.2013.821486.\\n\\n\\n    .. [#] Li, Yanhong, John J. Koval, Allan Donner, and G. Y. Zou. 2010.\\n       \u201cInterval Estimation for the Area under the Receiver Operating\\n       Characteristic Curve When Data Are Subject to Error.\u201d Statistics in\\n       Medicine 29 (24): 2521\u201331. https://doi.org/10.1002/sim.4015.\\n\\n    .. [#] Zou, G. Y., and A. Donner. 2008. \u201cConstruction of Confidence Limits\\n       about Effect Measures: A General Approach.\u201d Statistics in Medicine 27\\n       (10): 1693\u20131702. https://doi.org/10.1002/sim.3095.\\n    '\n    if contrast == 'diff':\n        stat = stat1 - stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[1]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[0]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'sum':\n        stat = stat1 + stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[0]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[1]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'ratio':\n        prod = stat1 * stat2\n        term1 = stat2 ** 2 - (ci2[1] - stat2) ** 2\n        term2 = stat2 ** 2 - (ci2[0] - stat2) ** 2\n        low_ = (prod - np.sqrt(prod ** 2 - term1 * (stat1 ** 2 - (ci1[0] - stat1) ** 2))) / term1\n        upp_ = (prod + np.sqrt(prod ** 2 - term2 * (stat1 ** 2 - (ci1[1] - stat1) ** 2))) / term2\n        (low1, upp1) = ci1\n        (low2, upp2) = ci2\n        term1 = upp2 * (2 * stat2 - upp2)\n        term2 = low2 * (2 * stat2 - low2)\n        low = (prod - np.sqrt(prod ** 2 - term1 * low1 * (2 * stat1 - low1))) / term1\n        upp = (prod + np.sqrt(prod ** 2 - term2 * upp1 * (2 * stat1 - upp1))) / term2\n        assert_allclose((low_, upp_), (low, upp), atol=1e-15, rtol=1e-10)\n        ci = (low, upp)\n    return ci",
            "def _mover_confint(stat1, stat2, ci1, ci2, contrast='diff'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n    References\\n    ----------\\n\\n    .. [#] Krishnamoorthy, K., Jie Peng, and Dan Zhang. 2016. \u201cModified Large\\n       Sample Confidence Intervals for Poisson Distributions: Ratio, Weighted\\n       Average, and Product of Means.\u201d Communications in Statistics - Theory\\n       and Methods 45 (1): 83\u201397. https://doi.org/10.1080/03610926.2013.821486.\\n\\n\\n    .. [#] Li, Yanhong, John J. Koval, Allan Donner, and G. Y. Zou. 2010.\\n       \u201cInterval Estimation for the Area under the Receiver Operating\\n       Characteristic Curve When Data Are Subject to Error.\u201d Statistics in\\n       Medicine 29 (24): 2521\u201331. https://doi.org/10.1002/sim.4015.\\n\\n    .. [#] Zou, G. Y., and A. Donner. 2008. \u201cConstruction of Confidence Limits\\n       about Effect Measures: A General Approach.\u201d Statistics in Medicine 27\\n       (10): 1693\u20131702. https://doi.org/10.1002/sim.3095.\\n    '\n    if contrast == 'diff':\n        stat = stat1 - stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[1]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[0]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'sum':\n        stat = stat1 + stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[0]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[1]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'ratio':\n        prod = stat1 * stat2\n        term1 = stat2 ** 2 - (ci2[1] - stat2) ** 2\n        term2 = stat2 ** 2 - (ci2[0] - stat2) ** 2\n        low_ = (prod - np.sqrt(prod ** 2 - term1 * (stat1 ** 2 - (ci1[0] - stat1) ** 2))) / term1\n        upp_ = (prod + np.sqrt(prod ** 2 - term2 * (stat1 ** 2 - (ci1[1] - stat1) ** 2))) / term2\n        (low1, upp1) = ci1\n        (low2, upp2) = ci2\n        term1 = upp2 * (2 * stat2 - upp2)\n        term2 = low2 * (2 * stat2 - low2)\n        low = (prod - np.sqrt(prod ** 2 - term1 * low1 * (2 * stat1 - low1))) / term1\n        upp = (prod + np.sqrt(prod ** 2 - term2 * upp1 * (2 * stat1 - upp1))) / term2\n        assert_allclose((low_, upp_), (low, upp), atol=1e-15, rtol=1e-10)\n        ci = (low, upp)\n    return ci",
            "def _mover_confint(stat1, stat2, ci1, ci2, contrast='diff'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n    References\\n    ----------\\n\\n    .. [#] Krishnamoorthy, K., Jie Peng, and Dan Zhang. 2016. \u201cModified Large\\n       Sample Confidence Intervals for Poisson Distributions: Ratio, Weighted\\n       Average, and Product of Means.\u201d Communications in Statistics - Theory\\n       and Methods 45 (1): 83\u201397. https://doi.org/10.1080/03610926.2013.821486.\\n\\n\\n    .. [#] Li, Yanhong, John J. Koval, Allan Donner, and G. Y. Zou. 2010.\\n       \u201cInterval Estimation for the Area under the Receiver Operating\\n       Characteristic Curve When Data Are Subject to Error.\u201d Statistics in\\n       Medicine 29 (24): 2521\u201331. https://doi.org/10.1002/sim.4015.\\n\\n    .. [#] Zou, G. Y., and A. Donner. 2008. \u201cConstruction of Confidence Limits\\n       about Effect Measures: A General Approach.\u201d Statistics in Medicine 27\\n       (10): 1693\u20131702. https://doi.org/10.1002/sim.3095.\\n    '\n    if contrast == 'diff':\n        stat = stat1 - stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[1]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[0]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'sum':\n        stat = stat1 + stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[0]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[1]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'ratio':\n        prod = stat1 * stat2\n        term1 = stat2 ** 2 - (ci2[1] - stat2) ** 2\n        term2 = stat2 ** 2 - (ci2[0] - stat2) ** 2\n        low_ = (prod - np.sqrt(prod ** 2 - term1 * (stat1 ** 2 - (ci1[0] - stat1) ** 2))) / term1\n        upp_ = (prod + np.sqrt(prod ** 2 - term2 * (stat1 ** 2 - (ci1[1] - stat1) ** 2))) / term2\n        (low1, upp1) = ci1\n        (low2, upp2) = ci2\n        term1 = upp2 * (2 * stat2 - upp2)\n        term2 = low2 * (2 * stat2 - low2)\n        low = (prod - np.sqrt(prod ** 2 - term1 * low1 * (2 * stat1 - low1))) / term1\n        upp = (prod + np.sqrt(prod ** 2 - term2 * upp1 * (2 * stat1 - upp1))) / term2\n        assert_allclose((low_, upp_), (low, upp), atol=1e-15, rtol=1e-10)\n        ci = (low, upp)\n    return ci",
            "def _mover_confint(stat1, stat2, ci1, ci2, contrast='diff'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n    References\\n    ----------\\n\\n    .. [#] Krishnamoorthy, K., Jie Peng, and Dan Zhang. 2016. \u201cModified Large\\n       Sample Confidence Intervals for Poisson Distributions: Ratio, Weighted\\n       Average, and Product of Means.\u201d Communications in Statistics - Theory\\n       and Methods 45 (1): 83\u201397. https://doi.org/10.1080/03610926.2013.821486.\\n\\n\\n    .. [#] Li, Yanhong, John J. Koval, Allan Donner, and G. Y. Zou. 2010.\\n       \u201cInterval Estimation for the Area under the Receiver Operating\\n       Characteristic Curve When Data Are Subject to Error.\u201d Statistics in\\n       Medicine 29 (24): 2521\u201331. https://doi.org/10.1002/sim.4015.\\n\\n    .. [#] Zou, G. Y., and A. Donner. 2008. \u201cConstruction of Confidence Limits\\n       about Effect Measures: A General Approach.\u201d Statistics in Medicine 27\\n       (10): 1693\u20131702. https://doi.org/10.1002/sim.3095.\\n    '\n    if contrast == 'diff':\n        stat = stat1 - stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[1]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[0]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'sum':\n        stat = stat1 + stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[0]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[1]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'ratio':\n        prod = stat1 * stat2\n        term1 = stat2 ** 2 - (ci2[1] - stat2) ** 2\n        term2 = stat2 ** 2 - (ci2[0] - stat2) ** 2\n        low_ = (prod - np.sqrt(prod ** 2 - term1 * (stat1 ** 2 - (ci1[0] - stat1) ** 2))) / term1\n        upp_ = (prod + np.sqrt(prod ** 2 - term2 * (stat1 ** 2 - (ci1[1] - stat1) ** 2))) / term2\n        (low1, upp1) = ci1\n        (low2, upp2) = ci2\n        term1 = upp2 * (2 * stat2 - upp2)\n        term2 = low2 * (2 * stat2 - low2)\n        low = (prod - np.sqrt(prod ** 2 - term1 * low1 * (2 * stat1 - low1))) / term1\n        upp = (prod + np.sqrt(prod ** 2 - term2 * upp1 * (2 * stat1 - upp1))) / term2\n        assert_allclose((low_, upp_), (low, upp), atol=1e-15, rtol=1e-10)\n        ci = (low, upp)\n    return ci",
            "def _mover_confint(stat1, stat2, ci1, ci2, contrast='diff'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n    References\\n    ----------\\n\\n    .. [#] Krishnamoorthy, K., Jie Peng, and Dan Zhang. 2016. \u201cModified Large\\n       Sample Confidence Intervals for Poisson Distributions: Ratio, Weighted\\n       Average, and Product of Means.\u201d Communications in Statistics - Theory\\n       and Methods 45 (1): 83\u201397. https://doi.org/10.1080/03610926.2013.821486.\\n\\n\\n    .. [#] Li, Yanhong, John J. Koval, Allan Donner, and G. Y. Zou. 2010.\\n       \u201cInterval Estimation for the Area under the Receiver Operating\\n       Characteristic Curve When Data Are Subject to Error.\u201d Statistics in\\n       Medicine 29 (24): 2521\u201331. https://doi.org/10.1002/sim.4015.\\n\\n    .. [#] Zou, G. Y., and A. Donner. 2008. \u201cConstruction of Confidence Limits\\n       about Effect Measures: A General Approach.\u201d Statistics in Medicine 27\\n       (10): 1693\u20131702. https://doi.org/10.1002/sim.3095.\\n    '\n    if contrast == 'diff':\n        stat = stat1 - stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[1]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[0]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'sum':\n        stat = stat1 + stat2\n        low_half = np.sqrt((stat1 - ci1[0]) ** 2 + (stat2 - ci2[0]) ** 2)\n        upp_half = np.sqrt((stat1 - ci1[1]) ** 2 + (stat2 - ci2[1]) ** 2)\n        ci = (stat - low_half, stat + upp_half)\n    elif contrast == 'ratio':\n        prod = stat1 * stat2\n        term1 = stat2 ** 2 - (ci2[1] - stat2) ** 2\n        term2 = stat2 ** 2 - (ci2[0] - stat2) ** 2\n        low_ = (prod - np.sqrt(prod ** 2 - term1 * (stat1 ** 2 - (ci1[0] - stat1) ** 2))) / term1\n        upp_ = (prod + np.sqrt(prod ** 2 - term2 * (stat1 ** 2 - (ci1[1] - stat1) ** 2))) / term2\n        (low1, upp1) = ci1\n        (low2, upp2) = ci2\n        term1 = upp2 * (2 * stat2 - upp2)\n        term2 = low2 * (2 * stat2 - low2)\n        low = (prod - np.sqrt(prod ** 2 - term1 * low1 * (2 * stat1 - low1))) / term1\n        upp = (prod + np.sqrt(prod ** 2 - term2 * upp1 * (2 * stat1 - upp1))) / term2\n        assert_allclose((low_, upp_), (low, upp), atol=1e-15, rtol=1e-10)\n        ci = (low, upp)\n    return ci"
        ]
    },
    {
        "func_name": "_mover_confint_sum",
        "original": "def _mover_confint_sum(stat, ci):\n    stat_ = stat.sum(0)\n    low_half = np.sqrt(np.sum((stat_ - ci[0]) ** 2))\n    upp_half = np.sqrt(np.sum((stat_ - ci[1]) ** 2))\n    ci = (stat - low_half, stat + upp_half)\n    return ci",
        "mutated": [
            "def _mover_confint_sum(stat, ci):\n    if False:\n        i = 10\n    stat_ = stat.sum(0)\n    low_half = np.sqrt(np.sum((stat_ - ci[0]) ** 2))\n    upp_half = np.sqrt(np.sum((stat_ - ci[1]) ** 2))\n    ci = (stat - low_half, stat + upp_half)\n    return ci",
            "def _mover_confint_sum(stat, ci):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    stat_ = stat.sum(0)\n    low_half = np.sqrt(np.sum((stat_ - ci[0]) ** 2))\n    upp_half = np.sqrt(np.sum((stat_ - ci[1]) ** 2))\n    ci = (stat - low_half, stat + upp_half)\n    return ci",
            "def _mover_confint_sum(stat, ci):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    stat_ = stat.sum(0)\n    low_half = np.sqrt(np.sum((stat_ - ci[0]) ** 2))\n    upp_half = np.sqrt(np.sum((stat_ - ci[1]) ** 2))\n    ci = (stat - low_half, stat + upp_half)\n    return ci",
            "def _mover_confint_sum(stat, ci):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    stat_ = stat.sum(0)\n    low_half = np.sqrt(np.sum((stat_ - ci[0]) ** 2))\n    upp_half = np.sqrt(np.sum((stat_ - ci[1]) ** 2))\n    ci = (stat - low_half, stat + upp_half)\n    return ci",
            "def _mover_confint_sum(stat, ci):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    stat_ = stat.sum(0)\n    low_half = np.sqrt(np.sum((stat_ - ci[0]) ** 2))\n    upp_half = np.sqrt(np.sum((stat_ - ci[1]) ** 2))\n    ci = (stat - low_half, stat + upp_half)\n    return ci"
        ]
    }
]