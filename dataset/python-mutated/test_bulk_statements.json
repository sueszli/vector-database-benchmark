[
    {
        "func_name": "test_no_returning_error",
        "original": "@testing.variation('style', [('default', testing.requires.insert_returning), 'no_executemany', ('no_sort_by', testing.requires.insert_returning), ('all_enabled', testing.requires.insert_returning)])\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('enable_implicit_returning', [True, False])\ndef test_no_returning_error(self, decl_base, testing_engine, style: testing.Variation, sort_by_parameter_order, enable_implicit_returning):\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        if not enable_implicit_returning:\n            __table_args__ = {'implicit_returning': False}\n    engine = testing_engine()\n    if style.default:\n        pass\n    elif style.no_executemany:\n        engine.dialect.use_insertmanyvalues = False\n        engine.dialect.use_insertmanyvalues_wo_returning = False\n        engine.dialect.insert_executemany_returning = False\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.no_sort_by:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.all_enabled:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = True\n    else:\n        style.fail()\n    decl_base.metadata.create_all(engine)\n    s = Session(engine)\n    if style.all_enabled or (style.no_sort_by and (not sort_by_parameter_order)) or style.default:\n        result = s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n        eq_(set(result.all()), {A(data='d3', x=5), A(data='d4', x=6)})\n    else:\n        with expect_raises_message(exc.InvalidRequestError, f\"Can't use explicit RETURNING for bulk INSERT operation.*executemany with RETURNING{(' and sort by parameter order' if sort_by_parameter_order else '')} is not enabled for this dialect\"):\n            s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])",
        "mutated": [
            "@testing.variation('style', [('default', testing.requires.insert_returning), 'no_executemany', ('no_sort_by', testing.requires.insert_returning), ('all_enabled', testing.requires.insert_returning)])\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('enable_implicit_returning', [True, False])\ndef test_no_returning_error(self, decl_base, testing_engine, style: testing.Variation, sort_by_parameter_order, enable_implicit_returning):\n    if False:\n        i = 10\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        if not enable_implicit_returning:\n            __table_args__ = {'implicit_returning': False}\n    engine = testing_engine()\n    if style.default:\n        pass\n    elif style.no_executemany:\n        engine.dialect.use_insertmanyvalues = False\n        engine.dialect.use_insertmanyvalues_wo_returning = False\n        engine.dialect.insert_executemany_returning = False\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.no_sort_by:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.all_enabled:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = True\n    else:\n        style.fail()\n    decl_base.metadata.create_all(engine)\n    s = Session(engine)\n    if style.all_enabled or (style.no_sort_by and (not sort_by_parameter_order)) or style.default:\n        result = s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n        eq_(set(result.all()), {A(data='d3', x=5), A(data='d4', x=6)})\n    else:\n        with expect_raises_message(exc.InvalidRequestError, f\"Can't use explicit RETURNING for bulk INSERT operation.*executemany with RETURNING{(' and sort by parameter order' if sort_by_parameter_order else '')} is not enabled for this dialect\"):\n            s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])",
            "@testing.variation('style', [('default', testing.requires.insert_returning), 'no_executemany', ('no_sort_by', testing.requires.insert_returning), ('all_enabled', testing.requires.insert_returning)])\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('enable_implicit_returning', [True, False])\ndef test_no_returning_error(self, decl_base, testing_engine, style: testing.Variation, sort_by_parameter_order, enable_implicit_returning):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        if not enable_implicit_returning:\n            __table_args__ = {'implicit_returning': False}\n    engine = testing_engine()\n    if style.default:\n        pass\n    elif style.no_executemany:\n        engine.dialect.use_insertmanyvalues = False\n        engine.dialect.use_insertmanyvalues_wo_returning = False\n        engine.dialect.insert_executemany_returning = False\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.no_sort_by:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.all_enabled:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = True\n    else:\n        style.fail()\n    decl_base.metadata.create_all(engine)\n    s = Session(engine)\n    if style.all_enabled or (style.no_sort_by and (not sort_by_parameter_order)) or style.default:\n        result = s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n        eq_(set(result.all()), {A(data='d3', x=5), A(data='d4', x=6)})\n    else:\n        with expect_raises_message(exc.InvalidRequestError, f\"Can't use explicit RETURNING for bulk INSERT operation.*executemany with RETURNING{(' and sort by parameter order' if sort_by_parameter_order else '')} is not enabled for this dialect\"):\n            s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])",
            "@testing.variation('style', [('default', testing.requires.insert_returning), 'no_executemany', ('no_sort_by', testing.requires.insert_returning), ('all_enabled', testing.requires.insert_returning)])\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('enable_implicit_returning', [True, False])\ndef test_no_returning_error(self, decl_base, testing_engine, style: testing.Variation, sort_by_parameter_order, enable_implicit_returning):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        if not enable_implicit_returning:\n            __table_args__ = {'implicit_returning': False}\n    engine = testing_engine()\n    if style.default:\n        pass\n    elif style.no_executemany:\n        engine.dialect.use_insertmanyvalues = False\n        engine.dialect.use_insertmanyvalues_wo_returning = False\n        engine.dialect.insert_executemany_returning = False\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.no_sort_by:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.all_enabled:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = True\n    else:\n        style.fail()\n    decl_base.metadata.create_all(engine)\n    s = Session(engine)\n    if style.all_enabled or (style.no_sort_by and (not sort_by_parameter_order)) or style.default:\n        result = s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n        eq_(set(result.all()), {A(data='d3', x=5), A(data='d4', x=6)})\n    else:\n        with expect_raises_message(exc.InvalidRequestError, f\"Can't use explicit RETURNING for bulk INSERT operation.*executemany with RETURNING{(' and sort by parameter order' if sort_by_parameter_order else '')} is not enabled for this dialect\"):\n            s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])",
            "@testing.variation('style', [('default', testing.requires.insert_returning), 'no_executemany', ('no_sort_by', testing.requires.insert_returning), ('all_enabled', testing.requires.insert_returning)])\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('enable_implicit_returning', [True, False])\ndef test_no_returning_error(self, decl_base, testing_engine, style: testing.Variation, sort_by_parameter_order, enable_implicit_returning):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        if not enable_implicit_returning:\n            __table_args__ = {'implicit_returning': False}\n    engine = testing_engine()\n    if style.default:\n        pass\n    elif style.no_executemany:\n        engine.dialect.use_insertmanyvalues = False\n        engine.dialect.use_insertmanyvalues_wo_returning = False\n        engine.dialect.insert_executemany_returning = False\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.no_sort_by:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.all_enabled:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = True\n    else:\n        style.fail()\n    decl_base.metadata.create_all(engine)\n    s = Session(engine)\n    if style.all_enabled or (style.no_sort_by and (not sort_by_parameter_order)) or style.default:\n        result = s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n        eq_(set(result.all()), {A(data='d3', x=5), A(data='d4', x=6)})\n    else:\n        with expect_raises_message(exc.InvalidRequestError, f\"Can't use explicit RETURNING for bulk INSERT operation.*executemany with RETURNING{(' and sort by parameter order' if sort_by_parameter_order else '')} is not enabled for this dialect\"):\n            s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])",
            "@testing.variation('style', [('default', testing.requires.insert_returning), 'no_executemany', ('no_sort_by', testing.requires.insert_returning), ('all_enabled', testing.requires.insert_returning)])\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('enable_implicit_returning', [True, False])\ndef test_no_returning_error(self, decl_base, testing_engine, style: testing.Variation, sort_by_parameter_order, enable_implicit_returning):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        if not enable_implicit_returning:\n            __table_args__ = {'implicit_returning': False}\n    engine = testing_engine()\n    if style.default:\n        pass\n    elif style.no_executemany:\n        engine.dialect.use_insertmanyvalues = False\n        engine.dialect.use_insertmanyvalues_wo_returning = False\n        engine.dialect.insert_executemany_returning = False\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.no_sort_by:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = False\n    elif style.all_enabled:\n        engine.dialect.use_insertmanyvalues = True\n        engine.dialect.use_insertmanyvalues_wo_returning = True\n        engine.dialect.insert_executemany_returning = True\n        engine.dialect.insert_executemany_returning_sort_by_parameter_order = True\n    else:\n        style.fail()\n    decl_base.metadata.create_all(engine)\n    s = Session(engine)\n    if style.all_enabled or (style.no_sort_by and (not sort_by_parameter_order)) or style.default:\n        result = s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n        eq_(set(result.all()), {A(data='d3', x=5), A(data='d4', x=6)})\n    else:\n        with expect_raises_message(exc.InvalidRequestError, f\"Can't use explicit RETURNING for bulk INSERT operation.*executemany with RETURNING{(' and sort by parameter order' if sort_by_parameter_order else '')} is not enabled for this dialect\"):\n            s.scalars(insert(A).returning(A, sort_by_parameter_order=bool(sort_by_parameter_order)), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])"
        ]
    },
    {
        "func_name": "test_render_nulls",
        "original": "@testing.variation('render_nulls', [True, False])\ndef test_render_nulls(self, decl_base, render_nulls):\n    \"\"\"test #10575\"\"\"\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        stmt = insert(A)\n        if render_nulls:\n            stmt = stmt.execution_options(render_nulls=True)\n        s.execute(stmt, [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}])\n    if render_nulls:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}]), CompiledSQL('INSERT INTO a (data) VALUES (:data)', [{'data': 'd6'}]), CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd7', 'x': 6}]))",
        "mutated": [
            "@testing.variation('render_nulls', [True, False])\ndef test_render_nulls(self, decl_base, render_nulls):\n    if False:\n        i = 10\n    'test #10575'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        stmt = insert(A)\n        if render_nulls:\n            stmt = stmt.execution_options(render_nulls=True)\n        s.execute(stmt, [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}])\n    if render_nulls:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}]), CompiledSQL('INSERT INTO a (data) VALUES (:data)', [{'data': 'd6'}]), CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd7', 'x': 6}]))",
            "@testing.variation('render_nulls', [True, False])\ndef test_render_nulls(self, decl_base, render_nulls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test #10575'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        stmt = insert(A)\n        if render_nulls:\n            stmt = stmt.execution_options(render_nulls=True)\n        s.execute(stmt, [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}])\n    if render_nulls:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}]), CompiledSQL('INSERT INTO a (data) VALUES (:data)', [{'data': 'd6'}]), CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd7', 'x': 6}]))",
            "@testing.variation('render_nulls', [True, False])\ndef test_render_nulls(self, decl_base, render_nulls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test #10575'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        stmt = insert(A)\n        if render_nulls:\n            stmt = stmt.execution_options(render_nulls=True)\n        s.execute(stmt, [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}])\n    if render_nulls:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}]), CompiledSQL('INSERT INTO a (data) VALUES (:data)', [{'data': 'd6'}]), CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd7', 'x': 6}]))",
            "@testing.variation('render_nulls', [True, False])\ndef test_render_nulls(self, decl_base, render_nulls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test #10575'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        stmt = insert(A)\n        if render_nulls:\n            stmt = stmt.execution_options(render_nulls=True)\n        s.execute(stmt, [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}])\n    if render_nulls:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}]), CompiledSQL('INSERT INTO a (data) VALUES (:data)', [{'data': 'd6'}]), CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd7', 'x': 6}]))",
            "@testing.variation('render_nulls', [True, False])\ndef test_render_nulls(self, decl_base, render_nulls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test #10575'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        stmt = insert(A)\n        if render_nulls:\n            stmt = stmt.execution_options(render_nulls=True)\n        s.execute(stmt, [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}])\n    if render_nulls:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}, {'data': 'd6', 'x': None}, {'data': 'd7', 'x': 6}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}, {'data': 'd5', 'x': 6}]), CompiledSQL('INSERT INTO a (data) VALUES (:data)', [{'data': 'd6'}]), CompiledSQL('INSERT INTO a (data, x) VALUES (:data, :x)', [{'data': 'd7', 'x': 6}]))"
        ]
    },
    {
        "func_name": "test_omit_returning_ok",
        "original": "def test_omit_returning_ok(self, decl_base):\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.execute(insert(A), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n    eq_(s.execute(select(A.data, A.x).order_by(A.id)).all(), [('d3', 5), ('d4', 6)])",
        "mutated": [
            "def test_omit_returning_ok(self, decl_base):\n    if False:\n        i = 10\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.execute(insert(A), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n    eq_(s.execute(select(A.data, A.x).order_by(A.id)).all(), [('d3', 5), ('d4', 6)])",
            "def test_omit_returning_ok(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.execute(insert(A), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n    eq_(s.execute(select(A.data, A.x).order_by(A.id)).all(), [('d3', 5), ('d4', 6)])",
            "def test_omit_returning_ok(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.execute(insert(A), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n    eq_(s.execute(select(A.data, A.x).order_by(A.id)).all(), [('d3', 5), ('d4', 6)])",
            "def test_omit_returning_ok(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.execute(insert(A), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n    eq_(s.execute(select(A.data, A.x).order_by(A.id)).all(), [('d3', 5), ('d4', 6)])",
            "def test_omit_returning_ok(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.execute(insert(A), [{'data': 'd3', 'x': 5}, {'data': 'd4', 'x': 6}])\n    eq_(s.execute(select(A.data, A.x).order_by(A.id)).all(), [('d3', 5), ('d4', 6)])"
        ]
    },
    {
        "func_name": "test_insert_returning_cols_dont_give_me_defaults",
        "original": "@testing.requires.insert_returning\ndef test_insert_returning_cols_dont_give_me_defaults(self, decl_base):\n    \"\"\"test #9685\"\"\"\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(User.id)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n    eq_(result.all(), [(1,), (2,), (3,)])\n    asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name) RETURNING users.id', [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))",
        "mutated": [
            "@testing.requires.insert_returning\ndef test_insert_returning_cols_dont_give_me_defaults(self, decl_base):\n    if False:\n        i = 10\n    'test #9685'\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(User.id)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n    eq_(result.all(), [(1,), (2,), (3,)])\n    asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name) RETURNING users.id', [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))",
            "@testing.requires.insert_returning\ndef test_insert_returning_cols_dont_give_me_defaults(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test #9685'\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(User.id)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n    eq_(result.all(), [(1,), (2,), (3,)])\n    asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name) RETURNING users.id', [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))",
            "@testing.requires.insert_returning\ndef test_insert_returning_cols_dont_give_me_defaults(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test #9685'\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(User.id)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n    eq_(result.all(), [(1,), (2,), (3,)])\n    asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name) RETURNING users.id', [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))",
            "@testing.requires.insert_returning\ndef test_insert_returning_cols_dont_give_me_defaults(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test #9685'\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(User.id)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n    eq_(result.all(), [(1,), (2,), (3,)])\n    asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name) RETURNING users.id', [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))",
            "@testing.requires.insert_returning\ndef test_insert_returning_cols_dont_give_me_defaults(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test #9685'\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(User.id)\n    s = fixture_session()\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n    eq_(result.all(), [(1,), (2,), (3,)])\n    asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name) RETURNING users.id', [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))"
        ]
    },
    {
        "func_name": "test_insert_returning_star",
        "original": "@testing.requires.insert_returning\n@testing.requires.returning_star\n@testing.variation('insert_type', ['bulk', ('values', testing.requires.multivalues_inserts), 'single'])\ndef test_insert_returning_star(self, decl_base, insert_type):\n    \"\"\"test #10192\"\"\"\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(literal_column('*'))\n    s = fixture_session()\n    if insert_type.bulk or insert_type.single:\n        with expect_raises_message(exc.CompileError, \"Can't use RETURNING \\\\* with bulk ORM INSERT.\"):\n            if insert_type.bulk:\n                s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n            else:\n                s.execute(insert_stmt, {'name': 'some name 1'})\n        return\n    elif insert_type.values:\n        with self.sql_execution_asserter() as asserter:\n            result = s.execute(insert_stmt.values([{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))\n        eq_(result.all(), [(1, 'some name 1', None, 'thing'), (2, 'some name 2', None, 'thing'), (3, 'some name 3', None, 'thing')])\n        asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name_m0), (:name_m1), (:name_m2) RETURNING *', [{'name_m0': 'some name 1', 'name_m1': 'some name 2', 'name_m2': 'some name 3'}]))\n    else:\n        insert_type.fail()",
        "mutated": [
            "@testing.requires.insert_returning\n@testing.requires.returning_star\n@testing.variation('insert_type', ['bulk', ('values', testing.requires.multivalues_inserts), 'single'])\ndef test_insert_returning_star(self, decl_base, insert_type):\n    if False:\n        i = 10\n    'test #10192'\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(literal_column('*'))\n    s = fixture_session()\n    if insert_type.bulk or insert_type.single:\n        with expect_raises_message(exc.CompileError, \"Can't use RETURNING \\\\* with bulk ORM INSERT.\"):\n            if insert_type.bulk:\n                s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n            else:\n                s.execute(insert_stmt, {'name': 'some name 1'})\n        return\n    elif insert_type.values:\n        with self.sql_execution_asserter() as asserter:\n            result = s.execute(insert_stmt.values([{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))\n        eq_(result.all(), [(1, 'some name 1', None, 'thing'), (2, 'some name 2', None, 'thing'), (3, 'some name 3', None, 'thing')])\n        asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name_m0), (:name_m1), (:name_m2) RETURNING *', [{'name_m0': 'some name 1', 'name_m1': 'some name 2', 'name_m2': 'some name 3'}]))\n    else:\n        insert_type.fail()",
            "@testing.requires.insert_returning\n@testing.requires.returning_star\n@testing.variation('insert_type', ['bulk', ('values', testing.requires.multivalues_inserts), 'single'])\ndef test_insert_returning_star(self, decl_base, insert_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test #10192'\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(literal_column('*'))\n    s = fixture_session()\n    if insert_type.bulk or insert_type.single:\n        with expect_raises_message(exc.CompileError, \"Can't use RETURNING \\\\* with bulk ORM INSERT.\"):\n            if insert_type.bulk:\n                s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n            else:\n                s.execute(insert_stmt, {'name': 'some name 1'})\n        return\n    elif insert_type.values:\n        with self.sql_execution_asserter() as asserter:\n            result = s.execute(insert_stmt.values([{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))\n        eq_(result.all(), [(1, 'some name 1', None, 'thing'), (2, 'some name 2', None, 'thing'), (3, 'some name 3', None, 'thing')])\n        asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name_m0), (:name_m1), (:name_m2) RETURNING *', [{'name_m0': 'some name 1', 'name_m1': 'some name 2', 'name_m2': 'some name 3'}]))\n    else:\n        insert_type.fail()",
            "@testing.requires.insert_returning\n@testing.requires.returning_star\n@testing.variation('insert_type', ['bulk', ('values', testing.requires.multivalues_inserts), 'single'])\ndef test_insert_returning_star(self, decl_base, insert_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test #10192'\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(literal_column('*'))\n    s = fixture_session()\n    if insert_type.bulk or insert_type.single:\n        with expect_raises_message(exc.CompileError, \"Can't use RETURNING \\\\* with bulk ORM INSERT.\"):\n            if insert_type.bulk:\n                s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n            else:\n                s.execute(insert_stmt, {'name': 'some name 1'})\n        return\n    elif insert_type.values:\n        with self.sql_execution_asserter() as asserter:\n            result = s.execute(insert_stmt.values([{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))\n        eq_(result.all(), [(1, 'some name 1', None, 'thing'), (2, 'some name 2', None, 'thing'), (3, 'some name 3', None, 'thing')])\n        asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name_m0), (:name_m1), (:name_m2) RETURNING *', [{'name_m0': 'some name 1', 'name_m1': 'some name 2', 'name_m2': 'some name 3'}]))\n    else:\n        insert_type.fail()",
            "@testing.requires.insert_returning\n@testing.requires.returning_star\n@testing.variation('insert_type', ['bulk', ('values', testing.requires.multivalues_inserts), 'single'])\ndef test_insert_returning_star(self, decl_base, insert_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test #10192'\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(literal_column('*'))\n    s = fixture_session()\n    if insert_type.bulk or insert_type.single:\n        with expect_raises_message(exc.CompileError, \"Can't use RETURNING \\\\* with bulk ORM INSERT.\"):\n            if insert_type.bulk:\n                s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n            else:\n                s.execute(insert_stmt, {'name': 'some name 1'})\n        return\n    elif insert_type.values:\n        with self.sql_execution_asserter() as asserter:\n            result = s.execute(insert_stmt.values([{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))\n        eq_(result.all(), [(1, 'some name 1', None, 'thing'), (2, 'some name 2', None, 'thing'), (3, 'some name 3', None, 'thing')])\n        asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name_m0), (:name_m1), (:name_m2) RETURNING *', [{'name_m0': 'some name 1', 'name_m1': 'some name 2', 'name_m2': 'some name 3'}]))\n    else:\n        insert_type.fail()",
            "@testing.requires.insert_returning\n@testing.requires.returning_star\n@testing.variation('insert_type', ['bulk', ('values', testing.requires.multivalues_inserts), 'single'])\ndef test_insert_returning_star(self, decl_base, insert_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test #10192'\n\n    class User(decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        name: Mapped[str] = mapped_column()\n        other_thing: Mapped[Optional[str]]\n        server_thing: Mapped[str] = mapped_column(server_default='thing')\n    decl_base.metadata.create_all(testing.db)\n    insert_stmt = insert(User).returning(literal_column('*'))\n    s = fixture_session()\n    if insert_type.bulk or insert_type.single:\n        with expect_raises_message(exc.CompileError, \"Can't use RETURNING \\\\* with bulk ORM INSERT.\"):\n            if insert_type.bulk:\n                s.execute(insert_stmt, [{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}])\n            else:\n                s.execute(insert_stmt, {'name': 'some name 1'})\n        return\n    elif insert_type.values:\n        with self.sql_execution_asserter() as asserter:\n            result = s.execute(insert_stmt.values([{'name': 'some name 1'}, {'name': 'some name 2'}, {'name': 'some name 3'}]))\n        eq_(result.all(), [(1, 'some name 1', None, 'thing'), (2, 'some name 2', None, 'thing'), (3, 'some name 3', None, 'thing')])\n        asserter.assert_(CompiledSQL('INSERT INTO users (name) VALUES (:name_m0), (:name_m1), (:name_m2) RETURNING *', [{'name_m0': 'some name 1', 'name_m1': 'some name 2', 'name_m2': 'some name 3'}]))\n    else:\n        insert_type.fail()"
        ]
    },
    {
        "func_name": "test_insert_from_select_col_property",
        "original": "@testing.requires.insert_returning\n@testing.skip_if('oracle', \"oracle doesn't like the no-FROM SELECT inside of an INSERT\")\ndef test_insert_from_select_col_property(self, decl_base):\n    \"\"\"test #9273\"\"\"\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(primary_key=True)\n        name: Mapped[str] = mapped_column()\n        age: Mapped[int] = mapped_column()\n        is_adult: Mapped[bool] = column_property(age >= 18)\n    decl_base.metadata.create_all(testing.db)\n    stmt = select(literal(1).label('id'), literal('John').label('name'), literal(30).label('age'))\n    insert_stmt = insert(User).from_select(['id', 'name', 'age'], stmt).returning(User)\n    s = fixture_session()\n    result = s.scalars(insert_stmt)\n    eq_(result.all(), [User(id=1, name='John', age=30)])",
        "mutated": [
            "@testing.requires.insert_returning\n@testing.skip_if('oracle', \"oracle doesn't like the no-FROM SELECT inside of an INSERT\")\ndef test_insert_from_select_col_property(self, decl_base):\n    if False:\n        i = 10\n    'test #9273'\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(primary_key=True)\n        name: Mapped[str] = mapped_column()\n        age: Mapped[int] = mapped_column()\n        is_adult: Mapped[bool] = column_property(age >= 18)\n    decl_base.metadata.create_all(testing.db)\n    stmt = select(literal(1).label('id'), literal('John').label('name'), literal(30).label('age'))\n    insert_stmt = insert(User).from_select(['id', 'name', 'age'], stmt).returning(User)\n    s = fixture_session()\n    result = s.scalars(insert_stmt)\n    eq_(result.all(), [User(id=1, name='John', age=30)])",
            "@testing.requires.insert_returning\n@testing.skip_if('oracle', \"oracle doesn't like the no-FROM SELECT inside of an INSERT\")\ndef test_insert_from_select_col_property(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test #9273'\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(primary_key=True)\n        name: Mapped[str] = mapped_column()\n        age: Mapped[int] = mapped_column()\n        is_adult: Mapped[bool] = column_property(age >= 18)\n    decl_base.metadata.create_all(testing.db)\n    stmt = select(literal(1).label('id'), literal('John').label('name'), literal(30).label('age'))\n    insert_stmt = insert(User).from_select(['id', 'name', 'age'], stmt).returning(User)\n    s = fixture_session()\n    result = s.scalars(insert_stmt)\n    eq_(result.all(), [User(id=1, name='John', age=30)])",
            "@testing.requires.insert_returning\n@testing.skip_if('oracle', \"oracle doesn't like the no-FROM SELECT inside of an INSERT\")\ndef test_insert_from_select_col_property(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test #9273'\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(primary_key=True)\n        name: Mapped[str] = mapped_column()\n        age: Mapped[int] = mapped_column()\n        is_adult: Mapped[bool] = column_property(age >= 18)\n    decl_base.metadata.create_all(testing.db)\n    stmt = select(literal(1).label('id'), literal('John').label('name'), literal(30).label('age'))\n    insert_stmt = insert(User).from_select(['id', 'name', 'age'], stmt).returning(User)\n    s = fixture_session()\n    result = s.scalars(insert_stmt)\n    eq_(result.all(), [User(id=1, name='John', age=30)])",
            "@testing.requires.insert_returning\n@testing.skip_if('oracle', \"oracle doesn't like the no-FROM SELECT inside of an INSERT\")\ndef test_insert_from_select_col_property(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test #9273'\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(primary_key=True)\n        name: Mapped[str] = mapped_column()\n        age: Mapped[int] = mapped_column()\n        is_adult: Mapped[bool] = column_property(age >= 18)\n    decl_base.metadata.create_all(testing.db)\n    stmt = select(literal(1).label('id'), literal('John').label('name'), literal(30).label('age'))\n    insert_stmt = insert(User).from_select(['id', 'name', 'age'], stmt).returning(User)\n    s = fixture_session()\n    result = s.scalars(insert_stmt)\n    eq_(result.all(), [User(id=1, name='John', age=30)])",
            "@testing.requires.insert_returning\n@testing.skip_if('oracle', \"oracle doesn't like the no-FROM SELECT inside of an INSERT\")\ndef test_insert_from_select_col_property(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test #9273'\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[int] = mapped_column(primary_key=True)\n        name: Mapped[str] = mapped_column()\n        age: Mapped[int] = mapped_column()\n        is_adult: Mapped[bool] = column_property(age >= 18)\n    decl_base.metadata.create_all(testing.db)\n    stmt = select(literal(1).label('id'), literal('John').label('name'), literal(30).label('age'))\n    insert_stmt = insert(User).from_select(['id', 'name', 'age'], stmt).returning(User)\n    s = fixture_session()\n    result = s.scalars(insert_stmt)\n    eq_(result.all(), [User(id=1, name='John', age=30)])"
        ]
    },
    {
        "func_name": "test_alt_bindparam_names",
        "original": "@testing.variation('use_returning', [(True, testing.requires.insert_returning), False])\n@testing.variation('use_multiparams', [True, False])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'raw', 'bulk', 'orm', argnames='dml_strategy')\ndef test_alt_bindparam_names(self, use_returning, decl_base, use_multiparams, dml_strategy, bindparam_in_expression):\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    if bindparam_in_expression:\n        stmt = insert(A).values(y=literal(3) * (bindparam('q') + 15))\n    else:\n        stmt = insert(A).values(y=bindparam('q'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if use_returning:\n        stmt = stmt.returning(A.x, A.y)\n    if use_multiparams:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        result = s.execute(stmt, [{'q': 5, 'x': 10}, {'q': 8, 'x': 11}, {'q': 12, 'x': 12}])\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'q': 5, 'x': 10})\n    if use_returning:\n        if use_multiparams:\n            eq_(result.all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])\n        else:\n            eq_(result.first(), (10, expected_qs[0]))",
        "mutated": [
            "@testing.variation('use_returning', [(True, testing.requires.insert_returning), False])\n@testing.variation('use_multiparams', [True, False])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'raw', 'bulk', 'orm', argnames='dml_strategy')\ndef test_alt_bindparam_names(self, use_returning, decl_base, use_multiparams, dml_strategy, bindparam_in_expression):\n    if False:\n        i = 10\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    if bindparam_in_expression:\n        stmt = insert(A).values(y=literal(3) * (bindparam('q') + 15))\n    else:\n        stmt = insert(A).values(y=bindparam('q'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if use_returning:\n        stmt = stmt.returning(A.x, A.y)\n    if use_multiparams:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        result = s.execute(stmt, [{'q': 5, 'x': 10}, {'q': 8, 'x': 11}, {'q': 12, 'x': 12}])\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'q': 5, 'x': 10})\n    if use_returning:\n        if use_multiparams:\n            eq_(result.all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])\n        else:\n            eq_(result.first(), (10, expected_qs[0]))",
            "@testing.variation('use_returning', [(True, testing.requires.insert_returning), False])\n@testing.variation('use_multiparams', [True, False])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'raw', 'bulk', 'orm', argnames='dml_strategy')\ndef test_alt_bindparam_names(self, use_returning, decl_base, use_multiparams, dml_strategy, bindparam_in_expression):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    if bindparam_in_expression:\n        stmt = insert(A).values(y=literal(3) * (bindparam('q') + 15))\n    else:\n        stmt = insert(A).values(y=bindparam('q'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if use_returning:\n        stmt = stmt.returning(A.x, A.y)\n    if use_multiparams:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        result = s.execute(stmt, [{'q': 5, 'x': 10}, {'q': 8, 'x': 11}, {'q': 12, 'x': 12}])\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'q': 5, 'x': 10})\n    if use_returning:\n        if use_multiparams:\n            eq_(result.all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])\n        else:\n            eq_(result.first(), (10, expected_qs[0]))",
            "@testing.variation('use_returning', [(True, testing.requires.insert_returning), False])\n@testing.variation('use_multiparams', [True, False])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'raw', 'bulk', 'orm', argnames='dml_strategy')\ndef test_alt_bindparam_names(self, use_returning, decl_base, use_multiparams, dml_strategy, bindparam_in_expression):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    if bindparam_in_expression:\n        stmt = insert(A).values(y=literal(3) * (bindparam('q') + 15))\n    else:\n        stmt = insert(A).values(y=bindparam('q'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if use_returning:\n        stmt = stmt.returning(A.x, A.y)\n    if use_multiparams:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        result = s.execute(stmt, [{'q': 5, 'x': 10}, {'q': 8, 'x': 11}, {'q': 12, 'x': 12}])\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'q': 5, 'x': 10})\n    if use_returning:\n        if use_multiparams:\n            eq_(result.all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])\n        else:\n            eq_(result.first(), (10, expected_qs[0]))",
            "@testing.variation('use_returning', [(True, testing.requires.insert_returning), False])\n@testing.variation('use_multiparams', [True, False])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'raw', 'bulk', 'orm', argnames='dml_strategy')\ndef test_alt_bindparam_names(self, use_returning, decl_base, use_multiparams, dml_strategy, bindparam_in_expression):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    if bindparam_in_expression:\n        stmt = insert(A).values(y=literal(3) * (bindparam('q') + 15))\n    else:\n        stmt = insert(A).values(y=bindparam('q'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if use_returning:\n        stmt = stmt.returning(A.x, A.y)\n    if use_multiparams:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        result = s.execute(stmt, [{'q': 5, 'x': 10}, {'q': 8, 'x': 11}, {'q': 12, 'x': 12}])\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'q': 5, 'x': 10})\n    if use_returning:\n        if use_multiparams:\n            eq_(result.all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])\n        else:\n            eq_(result.first(), (10, expected_qs[0]))",
            "@testing.variation('use_returning', [(True, testing.requires.insert_returning), False])\n@testing.variation('use_multiparams', [True, False])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'raw', 'bulk', 'orm', argnames='dml_strategy')\ndef test_alt_bindparam_names(self, use_returning, decl_base, use_multiparams, dml_strategy, bindparam_in_expression):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    if bindparam_in_expression:\n        stmt = insert(A).values(y=literal(3) * (bindparam('q') + 15))\n    else:\n        stmt = insert(A).values(y=bindparam('q'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if use_returning:\n        stmt = stmt.returning(A.x, A.y)\n    if use_multiparams:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        result = s.execute(stmt, [{'q': 5, 'x': 10}, {'q': 8, 'x': 11}, {'q': 12, 'x': 12}])\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'q': 5, 'x': 10})\n    if use_returning:\n        if use_multiparams:\n            eq_(result.all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])\n        else:\n            eq_(result.first(), (10, expected_qs[0]))"
        ]
    },
    {
        "func_name": "test_upsert_populate_existing",
        "original": "@testing.variation('populate_existing', [True, False])\n@testing.requires.provisioned_upsert\n@testing.requires.update_returning\ndef test_upsert_populate_existing(self, decl_base, populate_existing):\n    \"\"\"test #9742\"\"\"\n\n    class Employee(ComparableEntity, decl_base):\n        __tablename__ = 'employee'\n        uuid: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        user_name: Mapped[str] = mapped_column(nullable=False)\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    uuid1 = uuid.uuid4()\n    uuid2 = uuid.uuid4()\n    e1 = Employee(uuid=uuid1, user_name='e1 old name')\n    e2 = Employee(uuid=uuid2, user_name='e2 old name')\n    s.add_all([e1, e2])\n    s.flush()\n    stmt = provision.upsert(config, Employee, (Employee,), set_lambda=lambda inserted: {'user_name': inserted.user_name}).values([dict(uuid=uuid1, user_name='e1 new name'), dict(uuid=uuid2, user_name='e2 new name')])\n    if populate_existing:\n        rows = s.scalars(stmt, execution_options={'populate_existing': True})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 new name'), Employee(uuid=uuid2, user_name='e2 new name')})\n        eq_(e1.user_name, 'e1 new name')\n        eq_(e2.user_name, 'e2 new name')\n    else:\n        rows = s.scalars(stmt)\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 old name'), Employee(uuid=uuid2, user_name='e2 old name')})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n    s.commit()\n    s.expire_all()\n    eq_(e1.user_name, 'e1 new name')\n    eq_(e2.user_name, 'e2 new name')",
        "mutated": [
            "@testing.variation('populate_existing', [True, False])\n@testing.requires.provisioned_upsert\n@testing.requires.update_returning\ndef test_upsert_populate_existing(self, decl_base, populate_existing):\n    if False:\n        i = 10\n    'test #9742'\n\n    class Employee(ComparableEntity, decl_base):\n        __tablename__ = 'employee'\n        uuid: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        user_name: Mapped[str] = mapped_column(nullable=False)\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    uuid1 = uuid.uuid4()\n    uuid2 = uuid.uuid4()\n    e1 = Employee(uuid=uuid1, user_name='e1 old name')\n    e2 = Employee(uuid=uuid2, user_name='e2 old name')\n    s.add_all([e1, e2])\n    s.flush()\n    stmt = provision.upsert(config, Employee, (Employee,), set_lambda=lambda inserted: {'user_name': inserted.user_name}).values([dict(uuid=uuid1, user_name='e1 new name'), dict(uuid=uuid2, user_name='e2 new name')])\n    if populate_existing:\n        rows = s.scalars(stmt, execution_options={'populate_existing': True})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 new name'), Employee(uuid=uuid2, user_name='e2 new name')})\n        eq_(e1.user_name, 'e1 new name')\n        eq_(e2.user_name, 'e2 new name')\n    else:\n        rows = s.scalars(stmt)\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 old name'), Employee(uuid=uuid2, user_name='e2 old name')})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n    s.commit()\n    s.expire_all()\n    eq_(e1.user_name, 'e1 new name')\n    eq_(e2.user_name, 'e2 new name')",
            "@testing.variation('populate_existing', [True, False])\n@testing.requires.provisioned_upsert\n@testing.requires.update_returning\ndef test_upsert_populate_existing(self, decl_base, populate_existing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test #9742'\n\n    class Employee(ComparableEntity, decl_base):\n        __tablename__ = 'employee'\n        uuid: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        user_name: Mapped[str] = mapped_column(nullable=False)\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    uuid1 = uuid.uuid4()\n    uuid2 = uuid.uuid4()\n    e1 = Employee(uuid=uuid1, user_name='e1 old name')\n    e2 = Employee(uuid=uuid2, user_name='e2 old name')\n    s.add_all([e1, e2])\n    s.flush()\n    stmt = provision.upsert(config, Employee, (Employee,), set_lambda=lambda inserted: {'user_name': inserted.user_name}).values([dict(uuid=uuid1, user_name='e1 new name'), dict(uuid=uuid2, user_name='e2 new name')])\n    if populate_existing:\n        rows = s.scalars(stmt, execution_options={'populate_existing': True})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 new name'), Employee(uuid=uuid2, user_name='e2 new name')})\n        eq_(e1.user_name, 'e1 new name')\n        eq_(e2.user_name, 'e2 new name')\n    else:\n        rows = s.scalars(stmt)\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 old name'), Employee(uuid=uuid2, user_name='e2 old name')})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n    s.commit()\n    s.expire_all()\n    eq_(e1.user_name, 'e1 new name')\n    eq_(e2.user_name, 'e2 new name')",
            "@testing.variation('populate_existing', [True, False])\n@testing.requires.provisioned_upsert\n@testing.requires.update_returning\ndef test_upsert_populate_existing(self, decl_base, populate_existing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test #9742'\n\n    class Employee(ComparableEntity, decl_base):\n        __tablename__ = 'employee'\n        uuid: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        user_name: Mapped[str] = mapped_column(nullable=False)\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    uuid1 = uuid.uuid4()\n    uuid2 = uuid.uuid4()\n    e1 = Employee(uuid=uuid1, user_name='e1 old name')\n    e2 = Employee(uuid=uuid2, user_name='e2 old name')\n    s.add_all([e1, e2])\n    s.flush()\n    stmt = provision.upsert(config, Employee, (Employee,), set_lambda=lambda inserted: {'user_name': inserted.user_name}).values([dict(uuid=uuid1, user_name='e1 new name'), dict(uuid=uuid2, user_name='e2 new name')])\n    if populate_existing:\n        rows = s.scalars(stmt, execution_options={'populate_existing': True})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 new name'), Employee(uuid=uuid2, user_name='e2 new name')})\n        eq_(e1.user_name, 'e1 new name')\n        eq_(e2.user_name, 'e2 new name')\n    else:\n        rows = s.scalars(stmt)\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 old name'), Employee(uuid=uuid2, user_name='e2 old name')})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n    s.commit()\n    s.expire_all()\n    eq_(e1.user_name, 'e1 new name')\n    eq_(e2.user_name, 'e2 new name')",
            "@testing.variation('populate_existing', [True, False])\n@testing.requires.provisioned_upsert\n@testing.requires.update_returning\ndef test_upsert_populate_existing(self, decl_base, populate_existing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test #9742'\n\n    class Employee(ComparableEntity, decl_base):\n        __tablename__ = 'employee'\n        uuid: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        user_name: Mapped[str] = mapped_column(nullable=False)\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    uuid1 = uuid.uuid4()\n    uuid2 = uuid.uuid4()\n    e1 = Employee(uuid=uuid1, user_name='e1 old name')\n    e2 = Employee(uuid=uuid2, user_name='e2 old name')\n    s.add_all([e1, e2])\n    s.flush()\n    stmt = provision.upsert(config, Employee, (Employee,), set_lambda=lambda inserted: {'user_name': inserted.user_name}).values([dict(uuid=uuid1, user_name='e1 new name'), dict(uuid=uuid2, user_name='e2 new name')])\n    if populate_existing:\n        rows = s.scalars(stmt, execution_options={'populate_existing': True})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 new name'), Employee(uuid=uuid2, user_name='e2 new name')})\n        eq_(e1.user_name, 'e1 new name')\n        eq_(e2.user_name, 'e2 new name')\n    else:\n        rows = s.scalars(stmt)\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 old name'), Employee(uuid=uuid2, user_name='e2 old name')})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n    s.commit()\n    s.expire_all()\n    eq_(e1.user_name, 'e1 new name')\n    eq_(e2.user_name, 'e2 new name')",
            "@testing.variation('populate_existing', [True, False])\n@testing.requires.provisioned_upsert\n@testing.requires.update_returning\ndef test_upsert_populate_existing(self, decl_base, populate_existing):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test #9742'\n\n    class Employee(ComparableEntity, decl_base):\n        __tablename__ = 'employee'\n        uuid: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        user_name: Mapped[str] = mapped_column(nullable=False)\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    uuid1 = uuid.uuid4()\n    uuid2 = uuid.uuid4()\n    e1 = Employee(uuid=uuid1, user_name='e1 old name')\n    e2 = Employee(uuid=uuid2, user_name='e2 old name')\n    s.add_all([e1, e2])\n    s.flush()\n    stmt = provision.upsert(config, Employee, (Employee,), set_lambda=lambda inserted: {'user_name': inserted.user_name}).values([dict(uuid=uuid1, user_name='e1 new name'), dict(uuid=uuid2, user_name='e2 new name')])\n    if populate_existing:\n        rows = s.scalars(stmt, execution_options={'populate_existing': True})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 new name'), Employee(uuid=uuid2, user_name='e2 new name')})\n        eq_(e1.user_name, 'e1 new name')\n        eq_(e2.user_name, 'e2 new name')\n    else:\n        rows = s.scalars(stmt)\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n        eq_(set(rows), {Employee(uuid=uuid1, user_name='e1 old name'), Employee(uuid=uuid2, user_name='e2 old name')})\n        eq_(e1.user_name, 'e1 old name')\n        eq_(e2.user_name, 'e2 old name')\n    s.commit()\n    s.expire_all()\n    eq_(e1.user_name, 'e1 new name')\n    eq_(e2.user_name, 'e2 new name')"
        ]
    },
    {
        "func_name": "test_alt_bindparam_names",
        "original": "@testing.variation('returning_executemany', [('returning', testing.requires.update_returning), 'executemany', 'plain'])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'orm', argnames='dml_strategy')\n@testing.combinations('evaluate', 'fetch', None, argnames='synchronize_strategy')\ndef test_alt_bindparam_names(self, decl_base, returning_executemany, dml_strategy, bindparam_in_expression, synchronize_strategy):\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    if bindparam_in_expression:\n        stmt = update(A).values(y=literal(3) * (bindparam('q') + 15)).where(A.id == bindparam('b_id'))\n    else:\n        stmt = update(A).values(y=bindparam('q')).where(A.id == bindparam('b_id'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if returning_executemany.returning:\n        stmt = stmt.returning(A.x, A.y)\n    if synchronize_strategy in (None, 'evaluate', 'fetch'):\n        stmt = stmt.execution_options(synchronize_session=synchronize_strategy)\n    if returning_executemany.executemany:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        if dml_strategy != 'orm':\n            params = [{'id': 1, 'b_id': 1, 'q': 5, 'x': 10}, {'id': 2, 'b_id': 2, 'q': 8, 'x': 11}, {'id': 3, 'b_id': 3, 'q': 12, 'x': 12}]\n        else:\n            params = [{'b_id': 1, 'q': 5, 'x': 10}, {'b_id': 2, 'q': 8, 'x': 11}, {'b_id': 3, 'q': 12, 'x': 12}]\n        _expect_raises = None\n        if synchronize_strategy == 'fetch':\n            if dml_strategy != 'orm':\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"The 'fetch' synchronization strategy is not available for 'bulk' ORM updates \\\\(i.e. multiple parameter sets\\\\)\")\n            elif not testing.db.dialect.update_executemany_returning:\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"For synchronize_session='fetch', can't use multiple parameter sets in ORM mode, which this backend does not support with RETURNING\")\n        elif synchronize_strategy == 'evaluate' and dml_strategy != 'orm':\n            _expect_raises = expect_raises_message(exc.InvalidRequestError, 'bulk synchronize of persistent objects not supported')\n        if _expect_raises:\n            with _expect_raises:\n                result = s.execute(stmt, params)\n            return\n        result = s.execute(stmt, params)\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'b_id': 1, 'q': 5, 'x': 10})\n    if returning_executemany.returning:\n        eq_(result.first(), (10, expected_qs[0]))\n    elif returning_executemany.executemany:\n        eq_(s.execute(select(A.x, A.y).order_by(A.id)).all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])",
        "mutated": [
            "@testing.variation('returning_executemany', [('returning', testing.requires.update_returning), 'executemany', 'plain'])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'orm', argnames='dml_strategy')\n@testing.combinations('evaluate', 'fetch', None, argnames='synchronize_strategy')\ndef test_alt_bindparam_names(self, decl_base, returning_executemany, dml_strategy, bindparam_in_expression, synchronize_strategy):\n    if False:\n        i = 10\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    if bindparam_in_expression:\n        stmt = update(A).values(y=literal(3) * (bindparam('q') + 15)).where(A.id == bindparam('b_id'))\n    else:\n        stmt = update(A).values(y=bindparam('q')).where(A.id == bindparam('b_id'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if returning_executemany.returning:\n        stmt = stmt.returning(A.x, A.y)\n    if synchronize_strategy in (None, 'evaluate', 'fetch'):\n        stmt = stmt.execution_options(synchronize_session=synchronize_strategy)\n    if returning_executemany.executemany:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        if dml_strategy != 'orm':\n            params = [{'id': 1, 'b_id': 1, 'q': 5, 'x': 10}, {'id': 2, 'b_id': 2, 'q': 8, 'x': 11}, {'id': 3, 'b_id': 3, 'q': 12, 'x': 12}]\n        else:\n            params = [{'b_id': 1, 'q': 5, 'x': 10}, {'b_id': 2, 'q': 8, 'x': 11}, {'b_id': 3, 'q': 12, 'x': 12}]\n        _expect_raises = None\n        if synchronize_strategy == 'fetch':\n            if dml_strategy != 'orm':\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"The 'fetch' synchronization strategy is not available for 'bulk' ORM updates \\\\(i.e. multiple parameter sets\\\\)\")\n            elif not testing.db.dialect.update_executemany_returning:\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"For synchronize_session='fetch', can't use multiple parameter sets in ORM mode, which this backend does not support with RETURNING\")\n        elif synchronize_strategy == 'evaluate' and dml_strategy != 'orm':\n            _expect_raises = expect_raises_message(exc.InvalidRequestError, 'bulk synchronize of persistent objects not supported')\n        if _expect_raises:\n            with _expect_raises:\n                result = s.execute(stmt, params)\n            return\n        result = s.execute(stmt, params)\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'b_id': 1, 'q': 5, 'x': 10})\n    if returning_executemany.returning:\n        eq_(result.first(), (10, expected_qs[0]))\n    elif returning_executemany.executemany:\n        eq_(s.execute(select(A.x, A.y).order_by(A.id)).all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])",
            "@testing.variation('returning_executemany', [('returning', testing.requires.update_returning), 'executemany', 'plain'])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'orm', argnames='dml_strategy')\n@testing.combinations('evaluate', 'fetch', None, argnames='synchronize_strategy')\ndef test_alt_bindparam_names(self, decl_base, returning_executemany, dml_strategy, bindparam_in_expression, synchronize_strategy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    if bindparam_in_expression:\n        stmt = update(A).values(y=literal(3) * (bindparam('q') + 15)).where(A.id == bindparam('b_id'))\n    else:\n        stmt = update(A).values(y=bindparam('q')).where(A.id == bindparam('b_id'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if returning_executemany.returning:\n        stmt = stmt.returning(A.x, A.y)\n    if synchronize_strategy in (None, 'evaluate', 'fetch'):\n        stmt = stmt.execution_options(synchronize_session=synchronize_strategy)\n    if returning_executemany.executemany:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        if dml_strategy != 'orm':\n            params = [{'id': 1, 'b_id': 1, 'q': 5, 'x': 10}, {'id': 2, 'b_id': 2, 'q': 8, 'x': 11}, {'id': 3, 'b_id': 3, 'q': 12, 'x': 12}]\n        else:\n            params = [{'b_id': 1, 'q': 5, 'x': 10}, {'b_id': 2, 'q': 8, 'x': 11}, {'b_id': 3, 'q': 12, 'x': 12}]\n        _expect_raises = None\n        if synchronize_strategy == 'fetch':\n            if dml_strategy != 'orm':\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"The 'fetch' synchronization strategy is not available for 'bulk' ORM updates \\\\(i.e. multiple parameter sets\\\\)\")\n            elif not testing.db.dialect.update_executemany_returning:\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"For synchronize_session='fetch', can't use multiple parameter sets in ORM mode, which this backend does not support with RETURNING\")\n        elif synchronize_strategy == 'evaluate' and dml_strategy != 'orm':\n            _expect_raises = expect_raises_message(exc.InvalidRequestError, 'bulk synchronize of persistent objects not supported')\n        if _expect_raises:\n            with _expect_raises:\n                result = s.execute(stmt, params)\n            return\n        result = s.execute(stmt, params)\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'b_id': 1, 'q': 5, 'x': 10})\n    if returning_executemany.returning:\n        eq_(result.first(), (10, expected_qs[0]))\n    elif returning_executemany.executemany:\n        eq_(s.execute(select(A.x, A.y).order_by(A.id)).all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])",
            "@testing.variation('returning_executemany', [('returning', testing.requires.update_returning), 'executemany', 'plain'])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'orm', argnames='dml_strategy')\n@testing.combinations('evaluate', 'fetch', None, argnames='synchronize_strategy')\ndef test_alt_bindparam_names(self, decl_base, returning_executemany, dml_strategy, bindparam_in_expression, synchronize_strategy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    if bindparam_in_expression:\n        stmt = update(A).values(y=literal(3) * (bindparam('q') + 15)).where(A.id == bindparam('b_id'))\n    else:\n        stmt = update(A).values(y=bindparam('q')).where(A.id == bindparam('b_id'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if returning_executemany.returning:\n        stmt = stmt.returning(A.x, A.y)\n    if synchronize_strategy in (None, 'evaluate', 'fetch'):\n        stmt = stmt.execution_options(synchronize_session=synchronize_strategy)\n    if returning_executemany.executemany:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        if dml_strategy != 'orm':\n            params = [{'id': 1, 'b_id': 1, 'q': 5, 'x': 10}, {'id': 2, 'b_id': 2, 'q': 8, 'x': 11}, {'id': 3, 'b_id': 3, 'q': 12, 'x': 12}]\n        else:\n            params = [{'b_id': 1, 'q': 5, 'x': 10}, {'b_id': 2, 'q': 8, 'x': 11}, {'b_id': 3, 'q': 12, 'x': 12}]\n        _expect_raises = None\n        if synchronize_strategy == 'fetch':\n            if dml_strategy != 'orm':\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"The 'fetch' synchronization strategy is not available for 'bulk' ORM updates \\\\(i.e. multiple parameter sets\\\\)\")\n            elif not testing.db.dialect.update_executemany_returning:\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"For synchronize_session='fetch', can't use multiple parameter sets in ORM mode, which this backend does not support with RETURNING\")\n        elif synchronize_strategy == 'evaluate' and dml_strategy != 'orm':\n            _expect_raises = expect_raises_message(exc.InvalidRequestError, 'bulk synchronize of persistent objects not supported')\n        if _expect_raises:\n            with _expect_raises:\n                result = s.execute(stmt, params)\n            return\n        result = s.execute(stmt, params)\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'b_id': 1, 'q': 5, 'x': 10})\n    if returning_executemany.returning:\n        eq_(result.first(), (10, expected_qs[0]))\n    elif returning_executemany.executemany:\n        eq_(s.execute(select(A.x, A.y).order_by(A.id)).all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])",
            "@testing.variation('returning_executemany', [('returning', testing.requires.update_returning), 'executemany', 'plain'])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'orm', argnames='dml_strategy')\n@testing.combinations('evaluate', 'fetch', None, argnames='synchronize_strategy')\ndef test_alt_bindparam_names(self, decl_base, returning_executemany, dml_strategy, bindparam_in_expression, synchronize_strategy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    if bindparam_in_expression:\n        stmt = update(A).values(y=literal(3) * (bindparam('q') + 15)).where(A.id == bindparam('b_id'))\n    else:\n        stmt = update(A).values(y=bindparam('q')).where(A.id == bindparam('b_id'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if returning_executemany.returning:\n        stmt = stmt.returning(A.x, A.y)\n    if synchronize_strategy in (None, 'evaluate', 'fetch'):\n        stmt = stmt.execution_options(synchronize_session=synchronize_strategy)\n    if returning_executemany.executemany:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        if dml_strategy != 'orm':\n            params = [{'id': 1, 'b_id': 1, 'q': 5, 'x': 10}, {'id': 2, 'b_id': 2, 'q': 8, 'x': 11}, {'id': 3, 'b_id': 3, 'q': 12, 'x': 12}]\n        else:\n            params = [{'b_id': 1, 'q': 5, 'x': 10}, {'b_id': 2, 'q': 8, 'x': 11}, {'b_id': 3, 'q': 12, 'x': 12}]\n        _expect_raises = None\n        if synchronize_strategy == 'fetch':\n            if dml_strategy != 'orm':\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"The 'fetch' synchronization strategy is not available for 'bulk' ORM updates \\\\(i.e. multiple parameter sets\\\\)\")\n            elif not testing.db.dialect.update_executemany_returning:\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"For synchronize_session='fetch', can't use multiple parameter sets in ORM mode, which this backend does not support with RETURNING\")\n        elif synchronize_strategy == 'evaluate' and dml_strategy != 'orm':\n            _expect_raises = expect_raises_message(exc.InvalidRequestError, 'bulk synchronize of persistent objects not supported')\n        if _expect_raises:\n            with _expect_raises:\n                result = s.execute(stmt, params)\n            return\n        result = s.execute(stmt, params)\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'b_id': 1, 'q': 5, 'x': 10})\n    if returning_executemany.returning:\n        eq_(result.first(), (10, expected_qs[0]))\n    elif returning_executemany.executemany:\n        eq_(s.execute(select(A.x, A.y).order_by(A.id)).all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])",
            "@testing.variation('returning_executemany', [('returning', testing.requires.update_returning), 'executemany', 'plain'])\n@testing.variation('bindparam_in_expression', [True, False])\n@testing.combinations('auto', 'orm', argnames='dml_strategy')\n@testing.combinations('evaluate', 'fetch', None, argnames='synchronize_strategy')\ndef test_alt_bindparam_names(self, decl_base, returning_executemany, dml_strategy, bindparam_in_expression, synchronize_strategy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    if bindparam_in_expression:\n        stmt = update(A).values(y=literal(3) * (bindparam('q') + 15)).where(A.id == bindparam('b_id'))\n    else:\n        stmt = update(A).values(y=bindparam('q')).where(A.id == bindparam('b_id'))\n    if dml_strategy != 'auto':\n        stmt = stmt.execution_options(dml_strategy=dml_strategy)\n    if returning_executemany.returning:\n        stmt = stmt.returning(A.x, A.y)\n    if synchronize_strategy in (None, 'evaluate', 'fetch'):\n        stmt = stmt.execution_options(synchronize_session=synchronize_strategy)\n    if returning_executemany.executemany:\n        if bindparam_in_expression:\n            expected_qs = [60, 69, 81]\n        else:\n            expected_qs = [5, 8, 12]\n        if dml_strategy != 'orm':\n            params = [{'id': 1, 'b_id': 1, 'q': 5, 'x': 10}, {'id': 2, 'b_id': 2, 'q': 8, 'x': 11}, {'id': 3, 'b_id': 3, 'q': 12, 'x': 12}]\n        else:\n            params = [{'b_id': 1, 'q': 5, 'x': 10}, {'b_id': 2, 'q': 8, 'x': 11}, {'b_id': 3, 'q': 12, 'x': 12}]\n        _expect_raises = None\n        if synchronize_strategy == 'fetch':\n            if dml_strategy != 'orm':\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"The 'fetch' synchronization strategy is not available for 'bulk' ORM updates \\\\(i.e. multiple parameter sets\\\\)\")\n            elif not testing.db.dialect.update_executemany_returning:\n                _expect_raises = expect_raises_message(exc.InvalidRequestError, \"For synchronize_session='fetch', can't use multiple parameter sets in ORM mode, which this backend does not support with RETURNING\")\n        elif synchronize_strategy == 'evaluate' and dml_strategy != 'orm':\n            _expect_raises = expect_raises_message(exc.InvalidRequestError, 'bulk synchronize of persistent objects not supported')\n        if _expect_raises:\n            with _expect_raises:\n                result = s.execute(stmt, params)\n            return\n        result = s.execute(stmt, params)\n    else:\n        if bindparam_in_expression:\n            expected_qs = [60]\n        else:\n            expected_qs = [5]\n        result = s.execute(stmt, {'b_id': 1, 'q': 5, 'x': 10})\n    if returning_executemany.returning:\n        eq_(result.first(), (10, expected_qs[0]))\n    elif returning_executemany.executemany:\n        eq_(s.execute(select(A.x, A.y).order_by(A.id)).all(), [(10, expected_qs[0]), (11, expected_qs[1]), (12, expected_qs[2])])"
        ]
    },
    {
        "func_name": "test_bulk_update_no_pk",
        "original": "@testing.variation('add_where', [True, False])\n@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\ndef test_bulk_update_no_pk(self, decl_base, add_where, multi_row):\n    \"\"\"test #9917\"\"\"\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A)\n    if add_where:\n        stmt = stmt.where(A.x > 1)\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied for column\\\\(s\\\\) a.id; per-row ORM Bulk UPDATE by Primary Key requires that records contain primary key values'):\n            s.execute(stmt, data)\n    else:\n        with self.sql_execution_asserter() as asserter:\n            s.execute(stmt, data)\n        if add_where:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y WHERE a.x > :x_1', [{'x': 5, 'y': 9, 'x_1': 1}]))\n        else:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y', [{'x': 5, 'y': 9}]))",
        "mutated": [
            "@testing.variation('add_where', [True, False])\n@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\ndef test_bulk_update_no_pk(self, decl_base, add_where, multi_row):\n    if False:\n        i = 10\n    'test #9917'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A)\n    if add_where:\n        stmt = stmt.where(A.x > 1)\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied for column\\\\(s\\\\) a.id; per-row ORM Bulk UPDATE by Primary Key requires that records contain primary key values'):\n            s.execute(stmt, data)\n    else:\n        with self.sql_execution_asserter() as asserter:\n            s.execute(stmt, data)\n        if add_where:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y WHERE a.x > :x_1', [{'x': 5, 'y': 9, 'x_1': 1}]))\n        else:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y', [{'x': 5, 'y': 9}]))",
            "@testing.variation('add_where', [True, False])\n@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\ndef test_bulk_update_no_pk(self, decl_base, add_where, multi_row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test #9917'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A)\n    if add_where:\n        stmt = stmt.where(A.x > 1)\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied for column\\\\(s\\\\) a.id; per-row ORM Bulk UPDATE by Primary Key requires that records contain primary key values'):\n            s.execute(stmt, data)\n    else:\n        with self.sql_execution_asserter() as asserter:\n            s.execute(stmt, data)\n        if add_where:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y WHERE a.x > :x_1', [{'x': 5, 'y': 9, 'x_1': 1}]))\n        else:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y', [{'x': 5, 'y': 9}]))",
            "@testing.variation('add_where', [True, False])\n@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\ndef test_bulk_update_no_pk(self, decl_base, add_where, multi_row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test #9917'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A)\n    if add_where:\n        stmt = stmt.where(A.x > 1)\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied for column\\\\(s\\\\) a.id; per-row ORM Bulk UPDATE by Primary Key requires that records contain primary key values'):\n            s.execute(stmt, data)\n    else:\n        with self.sql_execution_asserter() as asserter:\n            s.execute(stmt, data)\n        if add_where:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y WHERE a.x > :x_1', [{'x': 5, 'y': 9, 'x_1': 1}]))\n        else:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y', [{'x': 5, 'y': 9}]))",
            "@testing.variation('add_where', [True, False])\n@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\ndef test_bulk_update_no_pk(self, decl_base, add_where, multi_row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test #9917'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A)\n    if add_where:\n        stmt = stmt.where(A.x > 1)\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied for column\\\\(s\\\\) a.id; per-row ORM Bulk UPDATE by Primary Key requires that records contain primary key values'):\n            s.execute(stmt, data)\n    else:\n        with self.sql_execution_asserter() as asserter:\n            s.execute(stmt, data)\n        if add_where:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y WHERE a.x > :x_1', [{'x': 5, 'y': 9, 'x_1': 1}]))\n        else:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y', [{'x': 5, 'y': 9}]))",
            "@testing.variation('add_where', [True, False])\n@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\ndef test_bulk_update_no_pk(self, decl_base, add_where, multi_row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test #9917'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A)\n    if add_where:\n        stmt = stmt.where(A.x > 1)\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied for column\\\\(s\\\\) a.id; per-row ORM Bulk UPDATE by Primary Key requires that records contain primary key values'):\n            s.execute(stmt, data)\n    else:\n        with self.sql_execution_asserter() as asserter:\n            s.execute(stmt, data)\n        if add_where:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y WHERE a.x > :x_1', [{'x': 5, 'y': 9, 'x_1': 1}]))\n        else:\n            asserter.assert_(CompiledSQL('UPDATE a SET x=:x, y=:y', [{'x': 5, 'y': 9}]))"
        ]
    },
    {
        "func_name": "test_bulk_update_returning_star",
        "original": "@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\n@testing.requires.update_returning\n@testing.requires.returning_star\ndef test_bulk_update_returning_star(self, decl_base, multi_row):\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).returning(literal_column('*'))\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied'):\n            s.execute(stmt, data)\n            return\n    else:\n        result = s.execute(stmt, data)\n        eq_(result.all(), [(1, 5, 9), (2, 5, 9), (3, 5, 9)])",
        "mutated": [
            "@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\n@testing.requires.update_returning\n@testing.requires.returning_star\ndef test_bulk_update_returning_star(self, decl_base, multi_row):\n    if False:\n        i = 10\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).returning(literal_column('*'))\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied'):\n            s.execute(stmt, data)\n            return\n    else:\n        result = s.execute(stmt, data)\n        eq_(result.all(), [(1, 5, 9), (2, 5, 9), (3, 5, 9)])",
            "@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\n@testing.requires.update_returning\n@testing.requires.returning_star\ndef test_bulk_update_returning_star(self, decl_base, multi_row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).returning(literal_column('*'))\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied'):\n            s.execute(stmt, data)\n            return\n    else:\n        result = s.execute(stmt, data)\n        eq_(result.all(), [(1, 5, 9), (2, 5, 9), (3, 5, 9)])",
            "@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\n@testing.requires.update_returning\n@testing.requires.returning_star\ndef test_bulk_update_returning_star(self, decl_base, multi_row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).returning(literal_column('*'))\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied'):\n            s.execute(stmt, data)\n            return\n    else:\n        result = s.execute(stmt, data)\n        eq_(result.all(), [(1, 5, 9), (2, 5, 9), (3, 5, 9)])",
            "@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\n@testing.requires.update_returning\n@testing.requires.returning_star\ndef test_bulk_update_returning_star(self, decl_base, multi_row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).returning(literal_column('*'))\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied'):\n            s.execute(stmt, data)\n            return\n    else:\n        result = s.execute(stmt, data)\n        eq_(result.all(), [(1, 5, 9), (2, 5, 9), (3, 5, 9)])",
            "@testing.variation('multi_row', ['multirow', 'singlerow', 'listwsingle'])\n@testing.requires.update_returning\n@testing.requires.returning_star\ndef test_bulk_update_returning_star(self, decl_base, multi_row):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).returning(literal_column('*'))\n    if multi_row.multirow:\n        data = [{'x': 3, 'y': 8}, {'x': 5, 'y': 9}, {'x': 12, 'y': 15}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.listwsingle:\n        data = [{'x': 5, 'y': 9}]\n        stmt = stmt.execution_options(synchronize_session=None)\n    elif multi_row.singlerow:\n        data = {'x': 5, 'y': 9}\n    else:\n        multi_row.fail()\n    if multi_row.multirow or multi_row.listwsingle:\n        with expect_raises_message(exc.InvalidRequestError, 'No primary key value supplied'):\n            s.execute(stmt, data)\n            return\n    else:\n        result = s.execute(stmt, data)\n        eq_(result.all(), [(1, 5, 9), (2, 5, 9), (3, 5, 9)])"
        ]
    },
    {
        "func_name": "test_bulk_update_w_where_one",
        "original": "def test_bulk_update_w_where_one(self, decl_base):\n    \"\"\"test use case in #9595\"\"\"\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).where(A.x > 1).execution_options(synchronize_session=None)\n    s.execute(stmt, [{'id': 1, 'x': 3, 'y': 8}, {'id': 2, 'x': 5, 'y': 9}, {'id': 3, 'x': 12, 'y': 15}])\n    eq_(s.execute(select(A.id, A.x, A.y).order_by(A.id)).all(), [(1, 1, 1), (2, 5, 9), (3, 12, 15)])",
        "mutated": [
            "def test_bulk_update_w_where_one(self, decl_base):\n    if False:\n        i = 10\n    'test use case in #9595'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).where(A.x > 1).execution_options(synchronize_session=None)\n    s.execute(stmt, [{'id': 1, 'x': 3, 'y': 8}, {'id': 2, 'x': 5, 'y': 9}, {'id': 3, 'x': 12, 'y': 15}])\n    eq_(s.execute(select(A.id, A.x, A.y).order_by(A.id)).all(), [(1, 1, 1), (2, 5, 9), (3, 12, 15)])",
            "def test_bulk_update_w_where_one(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test use case in #9595'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).where(A.x > 1).execution_options(synchronize_session=None)\n    s.execute(stmt, [{'id': 1, 'x': 3, 'y': 8}, {'id': 2, 'x': 5, 'y': 9}, {'id': 3, 'x': 12, 'y': 15}])\n    eq_(s.execute(select(A.id, A.x, A.y).order_by(A.id)).all(), [(1, 1, 1), (2, 5, 9), (3, 12, 15)])",
            "def test_bulk_update_w_where_one(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test use case in #9595'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).where(A.x > 1).execution_options(synchronize_session=None)\n    s.execute(stmt, [{'id': 1, 'x': 3, 'y': 8}, {'id': 2, 'x': 5, 'y': 9}, {'id': 3, 'x': 12, 'y': 15}])\n    eq_(s.execute(select(A.id, A.x, A.y).order_by(A.id)).all(), [(1, 1, 1), (2, 5, 9), (3, 12, 15)])",
            "def test_bulk_update_w_where_one(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test use case in #9595'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).where(A.x > 1).execution_options(synchronize_session=None)\n    s.execute(stmt, [{'id': 1, 'x': 3, 'y': 8}, {'id': 2, 'x': 5, 'y': 9}, {'id': 3, 'x': 12, 'y': 15}])\n    eq_(s.execute(select(A.id, A.x, A.y).order_by(A.id)).all(), [(1, 1, 1), (2, 5, 9), (3, 12, 15)])",
            "def test_bulk_update_w_where_one(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test use case in #9595'\n\n    class A(decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        x: Mapped[int]\n        y: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    s = fixture_session()\n    s.add_all([A(id=1, x=1, y=1), A(id=2, x=2, y=2), A(id=3, x=3, y=3)])\n    s.commit()\n    stmt = update(A).where(A.x > 1).execution_options(synchronize_session=None)\n    s.execute(stmt, [{'id': 1, 'x': 3, 'y': 8}, {'id': 2, 'x': 5, 'y': 9}, {'id': 3, 'x': 12, 'y': 15}])\n    eq_(s.execute(select(A.id, A.x, A.y).order_by(A.id)).all(), [(1, 1, 1), (2, 5, 9), (3, 12, 15)])"
        ]
    },
    {
        "func_name": "test_bulk_update_w_where_two",
        "original": "def test_bulk_update_w_where_two(self, decl_base):\n\n    class User(decl_base):\n        __tablename__ = 'user'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        name: Mapped[str]\n        age: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    sess = fixture_session()\n    sess.execute(insert(User), [dict(id=1, name='john', age=25), dict(id=2, name='jack', age=47), dict(id=3, name='jill', age=29), dict(id=4, name='jane', age=37)])\n    sess.execute(update(User).where(User.age > bindparam('gtage')).values(age=bindparam('dest_age')).execution_options(synchronize_session=None), [{'id': 1, 'gtage': 28, 'dest_age': 40}, {'id': 2, 'gtage': 20, 'dest_age': 45}])\n    eq_(sess.execute(select(User.id, User.name, User.age).order_by(User.id)).all(), [(1, 'john', 25), (2, 'jack', 45), (3, 'jill', 29), (4, 'jane', 37)])",
        "mutated": [
            "def test_bulk_update_w_where_two(self, decl_base):\n    if False:\n        i = 10\n\n    class User(decl_base):\n        __tablename__ = 'user'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        name: Mapped[str]\n        age: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    sess = fixture_session()\n    sess.execute(insert(User), [dict(id=1, name='john', age=25), dict(id=2, name='jack', age=47), dict(id=3, name='jill', age=29), dict(id=4, name='jane', age=37)])\n    sess.execute(update(User).where(User.age > bindparam('gtage')).values(age=bindparam('dest_age')).execution_options(synchronize_session=None), [{'id': 1, 'gtage': 28, 'dest_age': 40}, {'id': 2, 'gtage': 20, 'dest_age': 45}])\n    eq_(sess.execute(select(User.id, User.name, User.age).order_by(User.id)).all(), [(1, 'john', 25), (2, 'jack', 45), (3, 'jill', 29), (4, 'jane', 37)])",
            "def test_bulk_update_w_where_two(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    class User(decl_base):\n        __tablename__ = 'user'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        name: Mapped[str]\n        age: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    sess = fixture_session()\n    sess.execute(insert(User), [dict(id=1, name='john', age=25), dict(id=2, name='jack', age=47), dict(id=3, name='jill', age=29), dict(id=4, name='jane', age=37)])\n    sess.execute(update(User).where(User.age > bindparam('gtage')).values(age=bindparam('dest_age')).execution_options(synchronize_session=None), [{'id': 1, 'gtage': 28, 'dest_age': 40}, {'id': 2, 'gtage': 20, 'dest_age': 45}])\n    eq_(sess.execute(select(User.id, User.name, User.age).order_by(User.id)).all(), [(1, 'john', 25), (2, 'jack', 45), (3, 'jill', 29), (4, 'jane', 37)])",
            "def test_bulk_update_w_where_two(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    class User(decl_base):\n        __tablename__ = 'user'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        name: Mapped[str]\n        age: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    sess = fixture_session()\n    sess.execute(insert(User), [dict(id=1, name='john', age=25), dict(id=2, name='jack', age=47), dict(id=3, name='jill', age=29), dict(id=4, name='jane', age=37)])\n    sess.execute(update(User).where(User.age > bindparam('gtage')).values(age=bindparam('dest_age')).execution_options(synchronize_session=None), [{'id': 1, 'gtage': 28, 'dest_age': 40}, {'id': 2, 'gtage': 20, 'dest_age': 45}])\n    eq_(sess.execute(select(User.id, User.name, User.age).order_by(User.id)).all(), [(1, 'john', 25), (2, 'jack', 45), (3, 'jill', 29), (4, 'jane', 37)])",
            "def test_bulk_update_w_where_two(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    class User(decl_base):\n        __tablename__ = 'user'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        name: Mapped[str]\n        age: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    sess = fixture_session()\n    sess.execute(insert(User), [dict(id=1, name='john', age=25), dict(id=2, name='jack', age=47), dict(id=3, name='jill', age=29), dict(id=4, name='jane', age=37)])\n    sess.execute(update(User).where(User.age > bindparam('gtage')).values(age=bindparam('dest_age')).execution_options(synchronize_session=None), [{'id': 1, 'gtage': 28, 'dest_age': 40}, {'id': 2, 'gtage': 20, 'dest_age': 45}])\n    eq_(sess.execute(select(User.id, User.name, User.age).order_by(User.id)).all(), [(1, 'john', 25), (2, 'jack', 45), (3, 'jill', 29), (4, 'jane', 37)])",
            "def test_bulk_update_w_where_two(self, decl_base):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    class User(decl_base):\n        __tablename__ = 'user'\n        id: Mapped[int] = mapped_column(primary_key=True, autoincrement=False)\n        name: Mapped[str]\n        age: Mapped[int]\n    decl_base.metadata.create_all(testing.db)\n    sess = fixture_session()\n    sess.execute(insert(User), [dict(id=1, name='john', age=25), dict(id=2, name='jack', age=47), dict(id=3, name='jill', age=29), dict(id=4, name='jane', age=37)])\n    sess.execute(update(User).where(User.age > bindparam('gtage')).values(age=bindparam('dest_age')).execution_options(synchronize_session=None), [{'id': 1, 'gtage': 28, 'dest_age': 40}, {'id': 2, 'gtage': 20, 'dest_age': 45}])\n    eq_(sess.execute(select(User.id, User.name, User.age).order_by(User.id)).all(), [(1, 'john', 25), (2, 'jack', 45), (3, 'jill', 29), (4, 'jane', 37)])"
        ]
    },
    {
        "func_name": "assert_for_downgrade",
        "original": "def assert_for_downgrade(self, *, sort_by_parameter_order):\n    if not sort_by_parameter_order or not self.randomize_returning or (not testing.against(['postgresql', 'mssql', 'mariadb'])):\n        return contextlib.nullcontext()\n    else:\n        return expect_warnings('Batches were downgraded')",
        "mutated": [
            "def assert_for_downgrade(self, *, sort_by_parameter_order):\n    if False:\n        i = 10\n    if not sort_by_parameter_order or not self.randomize_returning or (not testing.against(['postgresql', 'mssql', 'mariadb'])):\n        return contextlib.nullcontext()\n    else:\n        return expect_warnings('Batches were downgraded')",
            "def assert_for_downgrade(self, *, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not sort_by_parameter_order or not self.randomize_returning or (not testing.against(['postgresql', 'mssql', 'mariadb'])):\n        return contextlib.nullcontext()\n    else:\n        return expect_warnings('Batches were downgraded')",
            "def assert_for_downgrade(self, *, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not sort_by_parameter_order or not self.randomize_returning or (not testing.against(['postgresql', 'mssql', 'mariadb'])):\n        return contextlib.nullcontext()\n    else:\n        return expect_warnings('Batches were downgraded')",
            "def assert_for_downgrade(self, *, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not sort_by_parameter_order or not self.randomize_returning or (not testing.against(['postgresql', 'mssql', 'mariadb'])):\n        return contextlib.nullcontext()\n    else:\n        return expect_warnings('Batches were downgraded')",
            "def assert_for_downgrade(self, *, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not sort_by_parameter_order or not self.randomize_returning or (not testing.against(['postgresql', 'mssql', 'mariadb'])):\n        return contextlib.nullcontext()\n    else:\n        return expect_warnings('Batches were downgraded')"
        ]
    },
    {
        "func_name": "eng_connect",
        "original": "@event.listens_for(new_eng, 'engine_connect')\ndef eng_connect(connection):\n    fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))",
        "mutated": [
            "@event.listens_for(new_eng, 'engine_connect')\ndef eng_connect(connection):\n    if False:\n        i = 10\n    fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))",
            "@event.listens_for(new_eng, 'engine_connect')\ndef eng_connect(connection):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))",
            "@event.listens_for(new_eng, 'engine_connect')\ndef eng_connect(connection):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))",
            "@event.listens_for(new_eng, 'engine_connect')\ndef eng_connect(connection):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))",
            "@event.listens_for(new_eng, 'engine_connect')\ndef eng_connect(connection):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))"
        ]
    },
    {
        "func_name": "setup_bind",
        "original": "@classmethod\ndef setup_bind(cls):\n    if cls.randomize_returning:\n        new_eng = config.db.execution_options()\n\n        @event.listens_for(new_eng, 'engine_connect')\n        def eng_connect(connection):\n            fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))\n        return new_eng\n    else:\n        return config.db",
        "mutated": [
            "@classmethod\ndef setup_bind(cls):\n    if False:\n        i = 10\n    if cls.randomize_returning:\n        new_eng = config.db.execution_options()\n\n        @event.listens_for(new_eng, 'engine_connect')\n        def eng_connect(connection):\n            fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))\n        return new_eng\n    else:\n        return config.db",
            "@classmethod\ndef setup_bind(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if cls.randomize_returning:\n        new_eng = config.db.execution_options()\n\n        @event.listens_for(new_eng, 'engine_connect')\n        def eng_connect(connection):\n            fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))\n        return new_eng\n    else:\n        return config.db",
            "@classmethod\ndef setup_bind(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if cls.randomize_returning:\n        new_eng = config.db.execution_options()\n\n        @event.listens_for(new_eng, 'engine_connect')\n        def eng_connect(connection):\n            fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))\n        return new_eng\n    else:\n        return config.db",
            "@classmethod\ndef setup_bind(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if cls.randomize_returning:\n        new_eng = config.db.execution_options()\n\n        @event.listens_for(new_eng, 'engine_connect')\n        def eng_connect(connection):\n            fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))\n        return new_eng\n    else:\n        return config.db",
            "@classmethod\ndef setup_bind(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if cls.randomize_returning:\n        new_eng = config.db.execution_options()\n\n        @event.listens_for(new_eng, 'engine_connect')\n        def eng_connect(connection):\n            fixtures.insertmanyvalues_fixture(connection, randomize_rows=True, warn_on_downgraded=testing.against(['postgresql', 'mssql', 'mariadb']))\n        return new_eng\n    else:\n        return config.db"
        ]
    },
    {
        "func_name": "test_insert_col_key_also_works_currently",
        "original": "def test_insert_col_key_also_works_currently(self):\n    \"\"\"using the column key, not mapped attr key.\n\n        right now this passes through to the INSERT.  when doing this with\n        an UPDATE, it tends to fail because the synchronize session\n        strategies can't match \"xcol\" back.  however w/ INSERT we aren't\n        doing that, so there's no place this gets checked.   UPDATE also\n        succeeds if synchronize_session is turned off.\n\n        \"\"\"\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    s.execute(insert(A).values(type='a', data='d', xcol=10))\n    eq_(s.scalars(select(A.x)).all(), [10])",
        "mutated": [
            "def test_insert_col_key_also_works_currently(self):\n    if False:\n        i = 10\n    'using the column key, not mapped attr key.\\n\\n        right now this passes through to the INSERT.  when doing this with\\n        an UPDATE, it tends to fail because the synchronize session\\n        strategies can\\'t match \"xcol\" back.  however w/ INSERT we aren\\'t\\n        doing that, so there\\'s no place this gets checked.   UPDATE also\\n        succeeds if synchronize_session is turned off.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    s.execute(insert(A).values(type='a', data='d', xcol=10))\n    eq_(s.scalars(select(A.x)).all(), [10])",
            "def test_insert_col_key_also_works_currently(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'using the column key, not mapped attr key.\\n\\n        right now this passes through to the INSERT.  when doing this with\\n        an UPDATE, it tends to fail because the synchronize session\\n        strategies can\\'t match \"xcol\" back.  however w/ INSERT we aren\\'t\\n        doing that, so there\\'s no place this gets checked.   UPDATE also\\n        succeeds if synchronize_session is turned off.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    s.execute(insert(A).values(type='a', data='d', xcol=10))\n    eq_(s.scalars(select(A.x)).all(), [10])",
            "def test_insert_col_key_also_works_currently(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'using the column key, not mapped attr key.\\n\\n        right now this passes through to the INSERT.  when doing this with\\n        an UPDATE, it tends to fail because the synchronize session\\n        strategies can\\'t match \"xcol\" back.  however w/ INSERT we aren\\'t\\n        doing that, so there\\'s no place this gets checked.   UPDATE also\\n        succeeds if synchronize_session is turned off.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    s.execute(insert(A).values(type='a', data='d', xcol=10))\n    eq_(s.scalars(select(A.x)).all(), [10])",
            "def test_insert_col_key_also_works_currently(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'using the column key, not mapped attr key.\\n\\n        right now this passes through to the INSERT.  when doing this with\\n        an UPDATE, it tends to fail because the synchronize session\\n        strategies can\\'t match \"xcol\" back.  however w/ INSERT we aren\\'t\\n        doing that, so there\\'s no place this gets checked.   UPDATE also\\n        succeeds if synchronize_session is turned off.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    s.execute(insert(A).values(type='a', data='d', xcol=10))\n    eq_(s.scalars(select(A.x)).all(), [10])",
            "def test_insert_col_key_also_works_currently(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'using the column key, not mapped attr key.\\n\\n        right now this passes through to the INSERT.  when doing this with\\n        an UPDATE, it tends to fail because the synchronize session\\n        strategies can\\'t match \"xcol\" back.  however w/ INSERT we aren\\'t\\n        doing that, so there\\'s no place this gets checked.   UPDATE also\\n        succeeds if synchronize_session is turned off.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    s.execute(insert(A).values(type='a', data='d', xcol=10))\n    eq_(s.scalars(select(A.x)).all(), [10])"
        ]
    },
    {
        "func_name": "test_autoflush",
        "original": "@testing.combinations('default', 'session_disable', 'opt_disable')\ndef test_autoflush(self, autoflush_option):\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    a1 = A(data='x1')\n    s.add(a1)\n    if autoflush_option == 'default':\n        s.execute(insert(A).values(type='a', data='x2'))\n        assert inspect(a1).persistent\n        eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x1', 'x2'])\n    elif autoflush_option == 'session_disable':\n        with s.no_autoflush:\n            s.execute(insert(A).values(type='a', data='x2'))\n            assert inspect(a1).pending\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    elif autoflush_option == 'opt_disable':\n        s.execute(insert(A).values(type='a', data='x2'), execution_options={'autoflush': False})\n        assert inspect(a1).pending\n        with s.no_autoflush:\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    else:\n        assert False",
        "mutated": [
            "@testing.combinations('default', 'session_disable', 'opt_disable')\ndef test_autoflush(self, autoflush_option):\n    if False:\n        i = 10\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    a1 = A(data='x1')\n    s.add(a1)\n    if autoflush_option == 'default':\n        s.execute(insert(A).values(type='a', data='x2'))\n        assert inspect(a1).persistent\n        eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x1', 'x2'])\n    elif autoflush_option == 'session_disable':\n        with s.no_autoflush:\n            s.execute(insert(A).values(type='a', data='x2'))\n            assert inspect(a1).pending\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    elif autoflush_option == 'opt_disable':\n        s.execute(insert(A).values(type='a', data='x2'), execution_options={'autoflush': False})\n        assert inspect(a1).pending\n        with s.no_autoflush:\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    else:\n        assert False",
            "@testing.combinations('default', 'session_disable', 'opt_disable')\ndef test_autoflush(self, autoflush_option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    a1 = A(data='x1')\n    s.add(a1)\n    if autoflush_option == 'default':\n        s.execute(insert(A).values(type='a', data='x2'))\n        assert inspect(a1).persistent\n        eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x1', 'x2'])\n    elif autoflush_option == 'session_disable':\n        with s.no_autoflush:\n            s.execute(insert(A).values(type='a', data='x2'))\n            assert inspect(a1).pending\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    elif autoflush_option == 'opt_disable':\n        s.execute(insert(A).values(type='a', data='x2'), execution_options={'autoflush': False})\n        assert inspect(a1).pending\n        with s.no_autoflush:\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    else:\n        assert False",
            "@testing.combinations('default', 'session_disable', 'opt_disable')\ndef test_autoflush(self, autoflush_option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    a1 = A(data='x1')\n    s.add(a1)\n    if autoflush_option == 'default':\n        s.execute(insert(A).values(type='a', data='x2'))\n        assert inspect(a1).persistent\n        eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x1', 'x2'])\n    elif autoflush_option == 'session_disable':\n        with s.no_autoflush:\n            s.execute(insert(A).values(type='a', data='x2'))\n            assert inspect(a1).pending\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    elif autoflush_option == 'opt_disable':\n        s.execute(insert(A).values(type='a', data='x2'), execution_options={'autoflush': False})\n        assert inspect(a1).pending\n        with s.no_autoflush:\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    else:\n        assert False",
            "@testing.combinations('default', 'session_disable', 'opt_disable')\ndef test_autoflush(self, autoflush_option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    a1 = A(data='x1')\n    s.add(a1)\n    if autoflush_option == 'default':\n        s.execute(insert(A).values(type='a', data='x2'))\n        assert inspect(a1).persistent\n        eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x1', 'x2'])\n    elif autoflush_option == 'session_disable':\n        with s.no_autoflush:\n            s.execute(insert(A).values(type='a', data='x2'))\n            assert inspect(a1).pending\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    elif autoflush_option == 'opt_disable':\n        s.execute(insert(A).values(type='a', data='x2'), execution_options={'autoflush': False})\n        assert inspect(a1).pending\n        with s.no_autoflush:\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    else:\n        assert False",
            "@testing.combinations('default', 'session_disable', 'opt_disable')\ndef test_autoflush(self, autoflush_option):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    a1 = A(data='x1')\n    s.add(a1)\n    if autoflush_option == 'default':\n        s.execute(insert(A).values(type='a', data='x2'))\n        assert inspect(a1).persistent\n        eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x1', 'x2'])\n    elif autoflush_option == 'session_disable':\n        with s.no_autoflush:\n            s.execute(insert(A).values(type='a', data='x2'))\n            assert inspect(a1).pending\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    elif autoflush_option == 'opt_disable':\n        s.execute(insert(A).values(type='a', data='x2'), execution_options={'autoflush': False})\n        assert inspect(a1).pending\n        with s.no_autoflush:\n            eq_(s.scalars(select(A.data).order_by(A.id)).all(), ['x2'])\n    else:\n        assert False"
        ]
    },
    {
        "func_name": "test_heterogeneous_keys",
        "original": "@testing.variation('use_returning', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_heterogeneous_keys(self, use_returning, sort_by_parameter_order):\n    (A, B) = self.classes('A', 'B')\n    values = [{'data': 'd3', 'x': 5, 'type': 'a'}, {'data': 'd4', 'x': 6, 'type': 'a'}, {'data': 'd5', 'type': 'a'}, {'data': 'd6', 'x': 8, 'y': 9, 'type': 'a'}, {'data': 'd7', 'x': 12, 'y': 12, 'type': 'a'}, {'data': 'd8', 'x': 7, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A)\n    if use_returning:\n        stmt = stmt.returning(A, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(stmt, values)\n    if use_returning:\n        if self.use_sentinel and sort_by_parameter_order:\n            _sentinel_col = ', _sentinel'\n            _sentinel_returning = ', a._sentinel'\n            _sentinel_param = ', :_sentinel'\n        else:\n            _sentinel_col = _sentinel_param = _sentinel_returning = ''\n        asserter.assert_(CompiledSQL(f'INSERT INTO a (type, data, xcol{_sentinel_col}) VALUES (:type, :data, :xcol{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd5'}]), CompiledSQL(f'INSERT INTO a (type, data, xcol, y{_sentinel_col}) VALUES (:type, :data, :xcol, :y{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data)', [{'type': 'a', 'data': 'd5'}]), CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y)', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    if use_returning:\n        with self.assert_statement_count(testing.db, 0):\n            eq_(set(result.scalars().all()), {A(data='d3', id=mock.ANY, type='a', x=5, y=None), A(data='d4', id=mock.ANY, type='a', x=6, y=None), A(data='d5', id=mock.ANY, type='a', x=None, y=None), A(data='d6', id=mock.ANY, type='a', x=8, y=9), A(data='d7', id=mock.ANY, type='a', x=12, y=12), A(data='d8', id=mock.ANY, type='a', x=7, y=None)})",
        "mutated": [
            "@testing.variation('use_returning', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_heterogeneous_keys(self, use_returning, sort_by_parameter_order):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    values = [{'data': 'd3', 'x': 5, 'type': 'a'}, {'data': 'd4', 'x': 6, 'type': 'a'}, {'data': 'd5', 'type': 'a'}, {'data': 'd6', 'x': 8, 'y': 9, 'type': 'a'}, {'data': 'd7', 'x': 12, 'y': 12, 'type': 'a'}, {'data': 'd8', 'x': 7, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A)\n    if use_returning:\n        stmt = stmt.returning(A, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(stmt, values)\n    if use_returning:\n        if self.use_sentinel and sort_by_parameter_order:\n            _sentinel_col = ', _sentinel'\n            _sentinel_returning = ', a._sentinel'\n            _sentinel_param = ', :_sentinel'\n        else:\n            _sentinel_col = _sentinel_param = _sentinel_returning = ''\n        asserter.assert_(CompiledSQL(f'INSERT INTO a (type, data, xcol{_sentinel_col}) VALUES (:type, :data, :xcol{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd5'}]), CompiledSQL(f'INSERT INTO a (type, data, xcol, y{_sentinel_col}) VALUES (:type, :data, :xcol, :y{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data)', [{'type': 'a', 'data': 'd5'}]), CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y)', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    if use_returning:\n        with self.assert_statement_count(testing.db, 0):\n            eq_(set(result.scalars().all()), {A(data='d3', id=mock.ANY, type='a', x=5, y=None), A(data='d4', id=mock.ANY, type='a', x=6, y=None), A(data='d5', id=mock.ANY, type='a', x=None, y=None), A(data='d6', id=mock.ANY, type='a', x=8, y=9), A(data='d7', id=mock.ANY, type='a', x=12, y=12), A(data='d8', id=mock.ANY, type='a', x=7, y=None)})",
            "@testing.variation('use_returning', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_heterogeneous_keys(self, use_returning, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    values = [{'data': 'd3', 'x': 5, 'type': 'a'}, {'data': 'd4', 'x': 6, 'type': 'a'}, {'data': 'd5', 'type': 'a'}, {'data': 'd6', 'x': 8, 'y': 9, 'type': 'a'}, {'data': 'd7', 'x': 12, 'y': 12, 'type': 'a'}, {'data': 'd8', 'x': 7, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A)\n    if use_returning:\n        stmt = stmt.returning(A, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(stmt, values)\n    if use_returning:\n        if self.use_sentinel and sort_by_parameter_order:\n            _sentinel_col = ', _sentinel'\n            _sentinel_returning = ', a._sentinel'\n            _sentinel_param = ', :_sentinel'\n        else:\n            _sentinel_col = _sentinel_param = _sentinel_returning = ''\n        asserter.assert_(CompiledSQL(f'INSERT INTO a (type, data, xcol{_sentinel_col}) VALUES (:type, :data, :xcol{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd5'}]), CompiledSQL(f'INSERT INTO a (type, data, xcol, y{_sentinel_col}) VALUES (:type, :data, :xcol, :y{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data)', [{'type': 'a', 'data': 'd5'}]), CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y)', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    if use_returning:\n        with self.assert_statement_count(testing.db, 0):\n            eq_(set(result.scalars().all()), {A(data='d3', id=mock.ANY, type='a', x=5, y=None), A(data='d4', id=mock.ANY, type='a', x=6, y=None), A(data='d5', id=mock.ANY, type='a', x=None, y=None), A(data='d6', id=mock.ANY, type='a', x=8, y=9), A(data='d7', id=mock.ANY, type='a', x=12, y=12), A(data='d8', id=mock.ANY, type='a', x=7, y=None)})",
            "@testing.variation('use_returning', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_heterogeneous_keys(self, use_returning, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    values = [{'data': 'd3', 'x': 5, 'type': 'a'}, {'data': 'd4', 'x': 6, 'type': 'a'}, {'data': 'd5', 'type': 'a'}, {'data': 'd6', 'x': 8, 'y': 9, 'type': 'a'}, {'data': 'd7', 'x': 12, 'y': 12, 'type': 'a'}, {'data': 'd8', 'x': 7, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A)\n    if use_returning:\n        stmt = stmt.returning(A, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(stmt, values)\n    if use_returning:\n        if self.use_sentinel and sort_by_parameter_order:\n            _sentinel_col = ', _sentinel'\n            _sentinel_returning = ', a._sentinel'\n            _sentinel_param = ', :_sentinel'\n        else:\n            _sentinel_col = _sentinel_param = _sentinel_returning = ''\n        asserter.assert_(CompiledSQL(f'INSERT INTO a (type, data, xcol{_sentinel_col}) VALUES (:type, :data, :xcol{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd5'}]), CompiledSQL(f'INSERT INTO a (type, data, xcol, y{_sentinel_col}) VALUES (:type, :data, :xcol, :y{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data)', [{'type': 'a', 'data': 'd5'}]), CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y)', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    if use_returning:\n        with self.assert_statement_count(testing.db, 0):\n            eq_(set(result.scalars().all()), {A(data='d3', id=mock.ANY, type='a', x=5, y=None), A(data='d4', id=mock.ANY, type='a', x=6, y=None), A(data='d5', id=mock.ANY, type='a', x=None, y=None), A(data='d6', id=mock.ANY, type='a', x=8, y=9), A(data='d7', id=mock.ANY, type='a', x=12, y=12), A(data='d8', id=mock.ANY, type='a', x=7, y=None)})",
            "@testing.variation('use_returning', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_heterogeneous_keys(self, use_returning, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    values = [{'data': 'd3', 'x': 5, 'type': 'a'}, {'data': 'd4', 'x': 6, 'type': 'a'}, {'data': 'd5', 'type': 'a'}, {'data': 'd6', 'x': 8, 'y': 9, 'type': 'a'}, {'data': 'd7', 'x': 12, 'y': 12, 'type': 'a'}, {'data': 'd8', 'x': 7, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A)\n    if use_returning:\n        stmt = stmt.returning(A, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(stmt, values)\n    if use_returning:\n        if self.use_sentinel and sort_by_parameter_order:\n            _sentinel_col = ', _sentinel'\n            _sentinel_returning = ', a._sentinel'\n            _sentinel_param = ', :_sentinel'\n        else:\n            _sentinel_col = _sentinel_param = _sentinel_returning = ''\n        asserter.assert_(CompiledSQL(f'INSERT INTO a (type, data, xcol{_sentinel_col}) VALUES (:type, :data, :xcol{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd5'}]), CompiledSQL(f'INSERT INTO a (type, data, xcol, y{_sentinel_col}) VALUES (:type, :data, :xcol, :y{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data)', [{'type': 'a', 'data': 'd5'}]), CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y)', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    if use_returning:\n        with self.assert_statement_count(testing.db, 0):\n            eq_(set(result.scalars().all()), {A(data='d3', id=mock.ANY, type='a', x=5, y=None), A(data='d4', id=mock.ANY, type='a', x=6, y=None), A(data='d5', id=mock.ANY, type='a', x=None, y=None), A(data='d6', id=mock.ANY, type='a', x=8, y=9), A(data='d7', id=mock.ANY, type='a', x=12, y=12), A(data='d8', id=mock.ANY, type='a', x=7, y=None)})",
            "@testing.variation('use_returning', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_heterogeneous_keys(self, use_returning, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    values = [{'data': 'd3', 'x': 5, 'type': 'a'}, {'data': 'd4', 'x': 6, 'type': 'a'}, {'data': 'd5', 'type': 'a'}, {'data': 'd6', 'x': 8, 'y': 9, 'type': 'a'}, {'data': 'd7', 'x': 12, 'y': 12, 'type': 'a'}, {'data': 'd8', 'x': 7, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A)\n    if use_returning:\n        stmt = stmt.returning(A, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(stmt, values)\n    if use_returning:\n        if self.use_sentinel and sort_by_parameter_order:\n            _sentinel_col = ', _sentinel'\n            _sentinel_returning = ', a._sentinel'\n            _sentinel_param = ', :_sentinel'\n        else:\n            _sentinel_col = _sentinel_param = _sentinel_returning = ''\n        asserter.assert_(CompiledSQL(f'INSERT INTO a (type, data, xcol{_sentinel_col}) VALUES (:type, :data, :xcol{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd5'}]), CompiledSQL(f'INSERT INTO a (type, data, xcol, y{_sentinel_col}) VALUES (:type, :data, :xcol, :y{_sentinel_param}) RETURNING a.id, a.type, a.data, a.xcol, a.y{_sentinel_returning}', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol) RETURNING a.id, a.type, a.data, a.xcol, a.y', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    else:\n        asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd3', 'xcol': 5}, {'type': 'a', 'data': 'd4', 'xcol': 6}]), CompiledSQL('INSERT INTO a (type, data) VALUES (:type, :data)', [{'type': 'a', 'data': 'd5'}]), CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y)', [{'type': 'a', 'data': 'd6', 'xcol': 8, 'y': 9}, {'type': 'a', 'data': 'd7', 'xcol': 12, 'y': 12}]), CompiledSQL('INSERT INTO a (type, data, xcol) VALUES (:type, :data, :xcol)', [{'type': 'a', 'data': 'd8', 'xcol': 7}]))\n    if use_returning:\n        with self.assert_statement_count(testing.db, 0):\n            eq_(set(result.scalars().all()), {A(data='d3', id=mock.ANY, type='a', x=5, y=None), A(data='d4', id=mock.ANY, type='a', x=6, y=None), A(data='d5', id=mock.ANY, type='a', x=None, y=None), A(data='d6', id=mock.ANY, type='a', x=8, y=9), A(data='d7', id=mock.ANY, type='a', x=12, y=12), A(data='d8', id=mock.ANY, type='a', x=7, y=None)})"
        ]
    },
    {
        "func_name": "test_single_values_returning_fn",
        "original": "@testing.combinations('strings', 'cols', 'strings_w_exprs', 'cols_w_exprs', argnames='paramstyle')\n@testing.variation('single_element', [True, (False, testing.requires.multivalues_inserts)])\ndef test_single_values_returning_fn(self, paramstyle, single_element):\n    \"\"\"test using insert().values().\n\n        these INSERT statements go straight in as a single execute without any\n        insertmanyreturning or bulk_insert_mappings thing going on.  the\n        advantage here is that SQL expressions can be used in the values also.\n        Disadvantage is none of the automation for inheritance mappers.\n\n        \"\"\"\n    (A, B) = self.classes('A', 'B')\n    if paramstyle == 'strings':\n        values = [{'data': 'd3', 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': 10, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols':\n        values = [{A.data: 'd3', A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: 10, A.y: 8, A.type: 'a'}]\n    elif paramstyle == 'strings_w_exprs':\n        values = [{'data': func.lower('D3'), 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': literal_column('5') + 5, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols_w_exprs':\n        values = [{A.data: func.lower('D3'), A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: literal_column('5') + 5, A.y: 8, A.type: 'a'}]\n    else:\n        assert False\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        if paramstyle.startswith('strings'):\n            stmt = insert(A).values(**values[0]).returning(A, func.upper(A.data, type_=String))\n        else:\n            stmt = insert(A).values(values[0]).returning(A, func.upper(A.data, type_=String))\n    else:\n        stmt = insert(A).values(values).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt)\n        expected: List[Any] = [(A(data='d3', x=5, y=9), 'D3')]\n        if not single_element:\n            expected.append((A(data='d4', x=10, y=8), 'D4'))\n        eq_(result.all(), expected)",
        "mutated": [
            "@testing.combinations('strings', 'cols', 'strings_w_exprs', 'cols_w_exprs', argnames='paramstyle')\n@testing.variation('single_element', [True, (False, testing.requires.multivalues_inserts)])\ndef test_single_values_returning_fn(self, paramstyle, single_element):\n    if False:\n        i = 10\n    'test using insert().values().\\n\\n        these INSERT statements go straight in as a single execute without any\\n        insertmanyreturning or bulk_insert_mappings thing going on.  the\\n        advantage here is that SQL expressions can be used in the values also.\\n        Disadvantage is none of the automation for inheritance mappers.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    if paramstyle == 'strings':\n        values = [{'data': 'd3', 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': 10, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols':\n        values = [{A.data: 'd3', A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: 10, A.y: 8, A.type: 'a'}]\n    elif paramstyle == 'strings_w_exprs':\n        values = [{'data': func.lower('D3'), 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': literal_column('5') + 5, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols_w_exprs':\n        values = [{A.data: func.lower('D3'), A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: literal_column('5') + 5, A.y: 8, A.type: 'a'}]\n    else:\n        assert False\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        if paramstyle.startswith('strings'):\n            stmt = insert(A).values(**values[0]).returning(A, func.upper(A.data, type_=String))\n        else:\n            stmt = insert(A).values(values[0]).returning(A, func.upper(A.data, type_=String))\n    else:\n        stmt = insert(A).values(values).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt)\n        expected: List[Any] = [(A(data='d3', x=5, y=9), 'D3')]\n        if not single_element:\n            expected.append((A(data='d4', x=10, y=8), 'D4'))\n        eq_(result.all(), expected)",
            "@testing.combinations('strings', 'cols', 'strings_w_exprs', 'cols_w_exprs', argnames='paramstyle')\n@testing.variation('single_element', [True, (False, testing.requires.multivalues_inserts)])\ndef test_single_values_returning_fn(self, paramstyle, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test using insert().values().\\n\\n        these INSERT statements go straight in as a single execute without any\\n        insertmanyreturning or bulk_insert_mappings thing going on.  the\\n        advantage here is that SQL expressions can be used in the values also.\\n        Disadvantage is none of the automation for inheritance mappers.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    if paramstyle == 'strings':\n        values = [{'data': 'd3', 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': 10, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols':\n        values = [{A.data: 'd3', A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: 10, A.y: 8, A.type: 'a'}]\n    elif paramstyle == 'strings_w_exprs':\n        values = [{'data': func.lower('D3'), 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': literal_column('5') + 5, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols_w_exprs':\n        values = [{A.data: func.lower('D3'), A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: literal_column('5') + 5, A.y: 8, A.type: 'a'}]\n    else:\n        assert False\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        if paramstyle.startswith('strings'):\n            stmt = insert(A).values(**values[0]).returning(A, func.upper(A.data, type_=String))\n        else:\n            stmt = insert(A).values(values[0]).returning(A, func.upper(A.data, type_=String))\n    else:\n        stmt = insert(A).values(values).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt)\n        expected: List[Any] = [(A(data='d3', x=5, y=9), 'D3')]\n        if not single_element:\n            expected.append((A(data='d4', x=10, y=8), 'D4'))\n        eq_(result.all(), expected)",
            "@testing.combinations('strings', 'cols', 'strings_w_exprs', 'cols_w_exprs', argnames='paramstyle')\n@testing.variation('single_element', [True, (False, testing.requires.multivalues_inserts)])\ndef test_single_values_returning_fn(self, paramstyle, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test using insert().values().\\n\\n        these INSERT statements go straight in as a single execute without any\\n        insertmanyreturning or bulk_insert_mappings thing going on.  the\\n        advantage here is that SQL expressions can be used in the values also.\\n        Disadvantage is none of the automation for inheritance mappers.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    if paramstyle == 'strings':\n        values = [{'data': 'd3', 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': 10, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols':\n        values = [{A.data: 'd3', A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: 10, A.y: 8, A.type: 'a'}]\n    elif paramstyle == 'strings_w_exprs':\n        values = [{'data': func.lower('D3'), 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': literal_column('5') + 5, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols_w_exprs':\n        values = [{A.data: func.lower('D3'), A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: literal_column('5') + 5, A.y: 8, A.type: 'a'}]\n    else:\n        assert False\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        if paramstyle.startswith('strings'):\n            stmt = insert(A).values(**values[0]).returning(A, func.upper(A.data, type_=String))\n        else:\n            stmt = insert(A).values(values[0]).returning(A, func.upper(A.data, type_=String))\n    else:\n        stmt = insert(A).values(values).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt)\n        expected: List[Any] = [(A(data='d3', x=5, y=9), 'D3')]\n        if not single_element:\n            expected.append((A(data='d4', x=10, y=8), 'D4'))\n        eq_(result.all(), expected)",
            "@testing.combinations('strings', 'cols', 'strings_w_exprs', 'cols_w_exprs', argnames='paramstyle')\n@testing.variation('single_element', [True, (False, testing.requires.multivalues_inserts)])\ndef test_single_values_returning_fn(self, paramstyle, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test using insert().values().\\n\\n        these INSERT statements go straight in as a single execute without any\\n        insertmanyreturning or bulk_insert_mappings thing going on.  the\\n        advantage here is that SQL expressions can be used in the values also.\\n        Disadvantage is none of the automation for inheritance mappers.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    if paramstyle == 'strings':\n        values = [{'data': 'd3', 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': 10, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols':\n        values = [{A.data: 'd3', A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: 10, A.y: 8, A.type: 'a'}]\n    elif paramstyle == 'strings_w_exprs':\n        values = [{'data': func.lower('D3'), 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': literal_column('5') + 5, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols_w_exprs':\n        values = [{A.data: func.lower('D3'), A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: literal_column('5') + 5, A.y: 8, A.type: 'a'}]\n    else:\n        assert False\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        if paramstyle.startswith('strings'):\n            stmt = insert(A).values(**values[0]).returning(A, func.upper(A.data, type_=String))\n        else:\n            stmt = insert(A).values(values[0]).returning(A, func.upper(A.data, type_=String))\n    else:\n        stmt = insert(A).values(values).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt)\n        expected: List[Any] = [(A(data='d3', x=5, y=9), 'D3')]\n        if not single_element:\n            expected.append((A(data='d4', x=10, y=8), 'D4'))\n        eq_(result.all(), expected)",
            "@testing.combinations('strings', 'cols', 'strings_w_exprs', 'cols_w_exprs', argnames='paramstyle')\n@testing.variation('single_element', [True, (False, testing.requires.multivalues_inserts)])\ndef test_single_values_returning_fn(self, paramstyle, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test using insert().values().\\n\\n        these INSERT statements go straight in as a single execute without any\\n        insertmanyreturning or bulk_insert_mappings thing going on.  the\\n        advantage here is that SQL expressions can be used in the values also.\\n        Disadvantage is none of the automation for inheritance mappers.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    if paramstyle == 'strings':\n        values = [{'data': 'd3', 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': 10, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols':\n        values = [{A.data: 'd3', A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: 10, A.y: 8, A.type: 'a'}]\n    elif paramstyle == 'strings_w_exprs':\n        values = [{'data': func.lower('D3'), 'x': 5, 'y': 9, 'type': 'a'}, {'data': 'd4', 'x': literal_column('5') + 5, 'y': 8, 'type': 'a'}]\n    elif paramstyle == 'cols_w_exprs':\n        values = [{A.data: func.lower('D3'), A.x: 5, A.y: 9, A.type: 'a'}, {A.data: 'd4', A.x: literal_column('5') + 5, A.y: 8, A.type: 'a'}]\n    else:\n        assert False\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        if paramstyle.startswith('strings'):\n            stmt = insert(A).values(**values[0]).returning(A, func.upper(A.data, type_=String))\n        else:\n            stmt = insert(A).values(values[0]).returning(A, func.upper(A.data, type_=String))\n    else:\n        stmt = insert(A).values(values).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt)\n        expected: List[Any] = [(A(data='d3', x=5, y=9), 'D3')]\n        if not single_element:\n            expected.append((A(data='d4', x=10, y=8), 'D4'))\n        eq_(result.all(), expected)"
        ]
    },
    {
        "func_name": "test_bulk_w_sql_expressions",
        "original": "def test_bulk_w_sql_expressions(self):\n    (A, B) = self.classes('A', 'B')\n    data = [{'x': 5, 'y': 9, 'type': 'a'}, {'x': 10, 'y': 8, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A).values(data=func.lower('DD')).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(A(data='dd', x=5, y=9), 'DD'), (A(data='dd', x=10, y=8), 'DD')}\n        eq_(set(result.all()), expected)",
        "mutated": [
            "def test_bulk_w_sql_expressions(self):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    data = [{'x': 5, 'y': 9, 'type': 'a'}, {'x': 10, 'y': 8, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A).values(data=func.lower('DD')).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(A(data='dd', x=5, y=9), 'DD'), (A(data='dd', x=10, y=8), 'DD')}\n        eq_(set(result.all()), expected)",
            "def test_bulk_w_sql_expressions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    data = [{'x': 5, 'y': 9, 'type': 'a'}, {'x': 10, 'y': 8, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A).values(data=func.lower('DD')).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(A(data='dd', x=5, y=9), 'DD'), (A(data='dd', x=10, y=8), 'DD')}\n        eq_(set(result.all()), expected)",
            "def test_bulk_w_sql_expressions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    data = [{'x': 5, 'y': 9, 'type': 'a'}, {'x': 10, 'y': 8, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A).values(data=func.lower('DD')).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(A(data='dd', x=5, y=9), 'DD'), (A(data='dd', x=10, y=8), 'DD')}\n        eq_(set(result.all()), expected)",
            "def test_bulk_w_sql_expressions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    data = [{'x': 5, 'y': 9, 'type': 'a'}, {'x': 10, 'y': 8, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A).values(data=func.lower('DD')).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(A(data='dd', x=5, y=9), 'DD'), (A(data='dd', x=10, y=8), 'DD')}\n        eq_(set(result.all()), expected)",
            "def test_bulk_w_sql_expressions(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    data = [{'x': 5, 'y': 9, 'type': 'a'}, {'x': 10, 'y': 8, 'type': 'a'}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(A).values(data=func.lower('DD')).returning(A, func.upper(A.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(A(data='dd', x=5, y=9), 'DD'), (A(data='dd', x=10, y=8), 'DD')}\n        eq_(set(result.all()), expected)"
        ]
    },
    {
        "func_name": "test_bulk_w_sql_expressions_subclass",
        "original": "def test_bulk_w_sql_expressions_subclass(self):\n    (A, B) = self.classes('A', 'B')\n    data = [{'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(B).values(data=func.lower('DD')).returning(B, func.upper(B.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(B(bd='bd1', data='dd', q=4, type='b', x=1, y=2, z=3), 'DD'), (B(bd='bd2', data='dd', q=8, type='b', x=5, y=6, z=7), 'DD')}\n        eq_(set(result), expected)",
        "mutated": [
            "def test_bulk_w_sql_expressions_subclass(self):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    data = [{'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(B).values(data=func.lower('DD')).returning(B, func.upper(B.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(B(bd='bd1', data='dd', q=4, type='b', x=1, y=2, z=3), 'DD'), (B(bd='bd2', data='dd', q=8, type='b', x=5, y=6, z=7), 'DD')}\n        eq_(set(result), expected)",
            "def test_bulk_w_sql_expressions_subclass(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    data = [{'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(B).values(data=func.lower('DD')).returning(B, func.upper(B.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(B(bd='bd1', data='dd', q=4, type='b', x=1, y=2, z=3), 'DD'), (B(bd='bd2', data='dd', q=8, type='b', x=5, y=6, z=7), 'DD')}\n        eq_(set(result), expected)",
            "def test_bulk_w_sql_expressions_subclass(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    data = [{'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(B).values(data=func.lower('DD')).returning(B, func.upper(B.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(B(bd='bd1', data='dd', q=4, type='b', x=1, y=2, z=3), 'DD'), (B(bd='bd2', data='dd', q=8, type='b', x=5, y=6, z=7), 'DD')}\n        eq_(set(result), expected)",
            "def test_bulk_w_sql_expressions_subclass(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    data = [{'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(B).values(data=func.lower('DD')).returning(B, func.upper(B.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(B(bd='bd1', data='dd', q=4, type='b', x=1, y=2, z=3), 'DD'), (B(bd='bd2', data='dd', q=8, type='b', x=5, y=6, z=7), 'DD')}\n        eq_(set(result), expected)",
            "def test_bulk_w_sql_expressions_subclass(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    data = [{'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    s = fixture_session(bind=self.bind)\n    stmt = insert(B).values(data=func.lower('DD')).returning(B, func.upper(B.data, type_=String))\n    for i in range(3):\n        result = s.execute(stmt, data)\n        expected: Set[Any] = {(B(bd='bd1', data='dd', q=4, type='b', x=1, y=2, z=3), 'DD'), (B(bd='bd2', data='dd', q=8, type='b', x=5, y=6, z=7), 'DD')}\n        eq_(set(result), expected)"
        ]
    },
    {
        "func_name": "test_bulk_upd_w_sql_expressions_no_ordered_values",
        "original": "@testing.combinations(True, False, argnames='use_ordered')\ndef test_bulk_upd_w_sql_expressions_no_ordered_values(self, use_ordered):\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    stmt = update(B).ordered_values(('data', func.lower('DD_UPDATE')), ('z', literal_column('3 + 12')))\n    with expect_raises_message(exc.InvalidRequestError, 'bulk ORM UPDATE does not support ordered_values\\\\(\\\\) for custom UPDATE'):\n        s.execute(stmt, [{'id': 5, 'bd': 'bd1_updated'}, {'id': 6, 'bd': 'bd2_updated'}])",
        "mutated": [
            "@testing.combinations(True, False, argnames='use_ordered')\ndef test_bulk_upd_w_sql_expressions_no_ordered_values(self, use_ordered):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    stmt = update(B).ordered_values(('data', func.lower('DD_UPDATE')), ('z', literal_column('3 + 12')))\n    with expect_raises_message(exc.InvalidRequestError, 'bulk ORM UPDATE does not support ordered_values\\\\(\\\\) for custom UPDATE'):\n        s.execute(stmt, [{'id': 5, 'bd': 'bd1_updated'}, {'id': 6, 'bd': 'bd2_updated'}])",
            "@testing.combinations(True, False, argnames='use_ordered')\ndef test_bulk_upd_w_sql_expressions_no_ordered_values(self, use_ordered):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    stmt = update(B).ordered_values(('data', func.lower('DD_UPDATE')), ('z', literal_column('3 + 12')))\n    with expect_raises_message(exc.InvalidRequestError, 'bulk ORM UPDATE does not support ordered_values\\\\(\\\\) for custom UPDATE'):\n        s.execute(stmt, [{'id': 5, 'bd': 'bd1_updated'}, {'id': 6, 'bd': 'bd2_updated'}])",
            "@testing.combinations(True, False, argnames='use_ordered')\ndef test_bulk_upd_w_sql_expressions_no_ordered_values(self, use_ordered):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    stmt = update(B).ordered_values(('data', func.lower('DD_UPDATE')), ('z', literal_column('3 + 12')))\n    with expect_raises_message(exc.InvalidRequestError, 'bulk ORM UPDATE does not support ordered_values\\\\(\\\\) for custom UPDATE'):\n        s.execute(stmt, [{'id': 5, 'bd': 'bd1_updated'}, {'id': 6, 'bd': 'bd2_updated'}])",
            "@testing.combinations(True, False, argnames='use_ordered')\ndef test_bulk_upd_w_sql_expressions_no_ordered_values(self, use_ordered):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    stmt = update(B).ordered_values(('data', func.lower('DD_UPDATE')), ('z', literal_column('3 + 12')))\n    with expect_raises_message(exc.InvalidRequestError, 'bulk ORM UPDATE does not support ordered_values\\\\(\\\\) for custom UPDATE'):\n        s.execute(stmt, [{'id': 5, 'bd': 'bd1_updated'}, {'id': 6, 'bd': 'bd2_updated'}])",
            "@testing.combinations(True, False, argnames='use_ordered')\ndef test_bulk_upd_w_sql_expressions_no_ordered_values(self, use_ordered):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    stmt = update(B).ordered_values(('data', func.lower('DD_UPDATE')), ('z', literal_column('3 + 12')))\n    with expect_raises_message(exc.InvalidRequestError, 'bulk ORM UPDATE does not support ordered_values\\\\(\\\\) for custom UPDATE'):\n        s.execute(stmt, [{'id': 5, 'bd': 'bd1_updated'}, {'id': 6, 'bd': 'bd2_updated'}])"
        ]
    },
    {
        "func_name": "test_bulk_upd_w_sql_expressions_subclass",
        "original": "def test_bulk_upd_w_sql_expressions_subclass(self):\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data)}\n    stmt = update(B).values(data=func.lower('DD_UPDATE'), z=literal_column('3 + 12'))\n    result = s.execute(stmt, [{'id': ids['d3'], 'bd': 'bd1_updated'}, {'id': ids['d4'], 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='dd_update', id=ids['d3'], q=4, type='b', x=1, y=2, z=15), B(bd='bd2_updated', data='dd_update', id=ids['d4'], q=8, type='b', x=5, y=6, z=15)})",
        "mutated": [
            "def test_bulk_upd_w_sql_expressions_subclass(self):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data)}\n    stmt = update(B).values(data=func.lower('DD_UPDATE'), z=literal_column('3 + 12'))\n    result = s.execute(stmt, [{'id': ids['d3'], 'bd': 'bd1_updated'}, {'id': ids['d4'], 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='dd_update', id=ids['d3'], q=4, type='b', x=1, y=2, z=15), B(bd='bd2_updated', data='dd_update', id=ids['d4'], q=8, type='b', x=5, y=6, z=15)})",
            "def test_bulk_upd_w_sql_expressions_subclass(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data)}\n    stmt = update(B).values(data=func.lower('DD_UPDATE'), z=literal_column('3 + 12'))\n    result = s.execute(stmt, [{'id': ids['d3'], 'bd': 'bd1_updated'}, {'id': ids['d4'], 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='dd_update', id=ids['d3'], q=4, type='b', x=1, y=2, z=15), B(bd='bd2_updated', data='dd_update', id=ids['d4'], q=8, type='b', x=5, y=6, z=15)})",
            "def test_bulk_upd_w_sql_expressions_subclass(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data)}\n    stmt = update(B).values(data=func.lower('DD_UPDATE'), z=literal_column('3 + 12'))\n    result = s.execute(stmt, [{'id': ids['d3'], 'bd': 'bd1_updated'}, {'id': ids['d4'], 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='dd_update', id=ids['d3'], q=4, type='b', x=1, y=2, z=15), B(bd='bd2_updated', data='dd_update', id=ids['d4'], q=8, type='b', x=5, y=6, z=15)})",
            "def test_bulk_upd_w_sql_expressions_subclass(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data)}\n    stmt = update(B).values(data=func.lower('DD_UPDATE'), z=literal_column('3 + 12'))\n    result = s.execute(stmt, [{'id': ids['d3'], 'bd': 'bd1_updated'}, {'id': ids['d4'], 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='dd_update', id=ids['d3'], q=4, type='b', x=1, y=2, z=15), B(bd='bd2_updated', data='dd_update', id=ids['d4'], q=8, type='b', x=5, y=6, z=15)})",
            "def test_bulk_upd_w_sql_expressions_subclass(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data)}\n    stmt = update(B).values(data=func.lower('DD_UPDATE'), z=literal_column('3 + 12'))\n    result = s.execute(stmt, [{'id': ids['d3'], 'bd': 'bd1_updated'}, {'id': ids['d4'], 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='dd_update', id=ids['d3'], q=4, type='b', x=1, y=2, z=15), B(bd='bd2_updated', data='dd_update', id=ids['d4'], q=8, type='b', x=5, y=6, z=15)})"
        ]
    },
    {
        "func_name": "test_single_returning_fn",
        "original": "def test_single_returning_fn(self):\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    for i in range(3):\n        result = s.execute(insert(A).returning(A, func.upper(A.data, type_=String)), [{'data': 'd3'}, {'data': 'd4'}])\n        eq_(set(result), {(A(data='d3'), 'D3'), (A(data='d4'), 'D4')})",
        "mutated": [
            "def test_single_returning_fn(self):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    for i in range(3):\n        result = s.execute(insert(A).returning(A, func.upper(A.data, type_=String)), [{'data': 'd3'}, {'data': 'd4'}])\n        eq_(set(result), {(A(data='d3'), 'D3'), (A(data='d4'), 'D4')})",
            "def test_single_returning_fn(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    for i in range(3):\n        result = s.execute(insert(A).returning(A, func.upper(A.data, type_=String)), [{'data': 'd3'}, {'data': 'd4'}])\n        eq_(set(result), {(A(data='d3'), 'D3'), (A(data='d4'), 'D4')})",
            "def test_single_returning_fn(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    for i in range(3):\n        result = s.execute(insert(A).returning(A, func.upper(A.data, type_=String)), [{'data': 'd3'}, {'data': 'd4'}])\n        eq_(set(result), {(A(data='d3'), 'D3'), (A(data='d4'), 'D4')})",
            "def test_single_returning_fn(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    for i in range(3):\n        result = s.execute(insert(A).returning(A, func.upper(A.data, type_=String)), [{'data': 'd3'}, {'data': 'd4'}])\n        eq_(set(result), {(A(data='d3'), 'D3'), (A(data='d4'), 'D4')})",
            "def test_single_returning_fn(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    for i in range(3):\n        result = s.execute(insert(A).returning(A, func.upper(A.data, type_=String)), [{'data': 'd3'}, {'data': 'd4'}])\n        eq_(set(result), {(A(data='d3'), 'D3'), (A(data='d4'), 'D4')})"
        ]
    },
    {
        "func_name": "test_subclass_no_returning",
        "original": "@testing.variation('single_element', [True, False])\ndef test_subclass_no_returning(self, single_element):\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B), data)\n    assert result._soft_closed",
        "mutated": [
            "@testing.variation('single_element', [True, False])\ndef test_subclass_no_returning(self, single_element):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B), data)\n    assert result._soft_closed",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_no_returning(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B), data)\n    assert result._soft_closed",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_no_returning(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B), data)\n    assert result._soft_closed",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_no_returning(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B), data)\n    assert result._soft_closed",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_no_returning(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B), data)\n    assert result._soft_closed"
        ]
    },
    {
        "func_name": "test_subclass_load_only",
        "original": "@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('single_element', [True, False])\ndef test_subclass_load_only(self, single_element, sort_by_parameter_order):\n    \"\"\"test that load_only() prevents additional attributes from being\n        populated.\n\n        \"\"\"\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    for i in range(3):\n        result = s.execute(insert(B).returning(B, sort_by_parameter_order=bool(sort_by_parameter_order)).options(load_only(B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        for obj in objects:\n            assert 'data' in obj.__dict__\n            assert 'q' in obj.__dict__\n            assert 'z' not in obj.__dict__\n            assert 'x' not in obj.__dict__\n        expected = [B(data='d3', bd='bd1', x=1, y=2, z=3, q=4)]\n        if not single_element:\n            expected.append(B(data='d4', bd='bd2', x=5, y=6, z=7, q=8))\n        if sort_by_parameter_order:\n            coll = list\n        else:\n            coll = set\n        eq_(coll(objects), coll(expected))",
        "mutated": [
            "@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('single_element', [True, False])\ndef test_subclass_load_only(self, single_element, sort_by_parameter_order):\n    if False:\n        i = 10\n    'test that load_only() prevents additional attributes from being\\n        populated.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    for i in range(3):\n        result = s.execute(insert(B).returning(B, sort_by_parameter_order=bool(sort_by_parameter_order)).options(load_only(B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        for obj in objects:\n            assert 'data' in obj.__dict__\n            assert 'q' in obj.__dict__\n            assert 'z' not in obj.__dict__\n            assert 'x' not in obj.__dict__\n        expected = [B(data='d3', bd='bd1', x=1, y=2, z=3, q=4)]\n        if not single_element:\n            expected.append(B(data='d4', bd='bd2', x=5, y=6, z=7, q=8))\n        if sort_by_parameter_order:\n            coll = list\n        else:\n            coll = set\n        eq_(coll(objects), coll(expected))",
            "@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('single_element', [True, False])\ndef test_subclass_load_only(self, single_element, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test that load_only() prevents additional attributes from being\\n        populated.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    for i in range(3):\n        result = s.execute(insert(B).returning(B, sort_by_parameter_order=bool(sort_by_parameter_order)).options(load_only(B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        for obj in objects:\n            assert 'data' in obj.__dict__\n            assert 'q' in obj.__dict__\n            assert 'z' not in obj.__dict__\n            assert 'x' not in obj.__dict__\n        expected = [B(data='d3', bd='bd1', x=1, y=2, z=3, q=4)]\n        if not single_element:\n            expected.append(B(data='d4', bd='bd2', x=5, y=6, z=7, q=8))\n        if sort_by_parameter_order:\n            coll = list\n        else:\n            coll = set\n        eq_(coll(objects), coll(expected))",
            "@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('single_element', [True, False])\ndef test_subclass_load_only(self, single_element, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test that load_only() prevents additional attributes from being\\n        populated.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    for i in range(3):\n        result = s.execute(insert(B).returning(B, sort_by_parameter_order=bool(sort_by_parameter_order)).options(load_only(B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        for obj in objects:\n            assert 'data' in obj.__dict__\n            assert 'q' in obj.__dict__\n            assert 'z' not in obj.__dict__\n            assert 'x' not in obj.__dict__\n        expected = [B(data='d3', bd='bd1', x=1, y=2, z=3, q=4)]\n        if not single_element:\n            expected.append(B(data='d4', bd='bd2', x=5, y=6, z=7, q=8))\n        if sort_by_parameter_order:\n            coll = list\n        else:\n            coll = set\n        eq_(coll(objects), coll(expected))",
            "@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('single_element', [True, False])\ndef test_subclass_load_only(self, single_element, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test that load_only() prevents additional attributes from being\\n        populated.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    for i in range(3):\n        result = s.execute(insert(B).returning(B, sort_by_parameter_order=bool(sort_by_parameter_order)).options(load_only(B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        for obj in objects:\n            assert 'data' in obj.__dict__\n            assert 'q' in obj.__dict__\n            assert 'z' not in obj.__dict__\n            assert 'x' not in obj.__dict__\n        expected = [B(data='d3', bd='bd1', x=1, y=2, z=3, q=4)]\n        if not single_element:\n            expected.append(B(data='d4', bd='bd2', x=5, y=6, z=7, q=8))\n        if sort_by_parameter_order:\n            coll = list\n        else:\n            coll = set\n        eq_(coll(objects), coll(expected))",
            "@testing.variation('sort_by_parameter_order', [True, False])\n@testing.variation('single_element', [True, False])\ndef test_subclass_load_only(self, single_element, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test that load_only() prevents additional attributes from being\\n        populated.\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    for i in range(3):\n        result = s.execute(insert(B).returning(B, sort_by_parameter_order=bool(sort_by_parameter_order)).options(load_only(B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        for obj in objects:\n            assert 'data' in obj.__dict__\n            assert 'q' in obj.__dict__\n            assert 'z' not in obj.__dict__\n            assert 'x' not in obj.__dict__\n        expected = [B(data='d3', bd='bd1', x=1, y=2, z=3, q=4)]\n        if not single_element:\n            expected.append(B(data='d4', bd='bd2', x=5, y=6, z=7, q=8))\n        if sort_by_parameter_order:\n            coll = list\n        else:\n            coll = set\n        eq_(coll(objects), coll(expected))"
        ]
    },
    {
        "func_name": "test_subclass_load_only_doesnt_fetch_cols",
        "original": "@testing.variation('single_element', [True, False])\ndef test_subclass_load_only_doesnt_fetch_cols(self, single_element):\n    \"\"\"test that when using load_only(), the actual INSERT statement\n        does not include the deferred columns\n\n        \"\"\"\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    if single_element:\n        data = data[0]\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert(B).returning(B).options(load_only(B.id, B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        if single_element:\n            id0 = objects[0].id\n            id1 = None\n        else:\n            (id0, id1) = (objects[0].id, objects[1].id)\n    if inspect(B).single or inspect(B).concrete:\n        expected_params = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            expected_params[1:] = []\n        if inspect(B).single:\n            asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING a.id, a.type, a.data, a.y, a.q', expected_params))\n        else:\n            asserter.assert_(CompiledSQL('INSERT INTO b (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING b.id, b.type, b.data, b.y, b.q', expected_params))\n    else:\n        a_data = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6}]\n        b_data = [{'id': id0, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'id': id1, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            a_data[1:] = []\n            b_data[1:] = []\n        asserter.assert_(Conditional(self.use_sentinel and (not single_element), [CompiledSQL('INSERT INTO a (type, data, xcol, y, _sentinel) VALUES (:type, :data, :xcol, :y, :_sentinel) RETURNING a.id, a.type, a.data, a.y, a._sentinel', a_data), CompiledSQL('INSERT INTO b (id, bd, zcol, q, _sentinel) VALUES (:id, :bd, :zcol, :q, :_sentinel) RETURNING b.id, b.q, b._sentinel', b_data)], [CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y) RETURNING a.id, a.type, a.data, a.y', a_data), Conditional(single_element, [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q', b_data)], [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q, b.id AS id__1', b_data)])]))",
        "mutated": [
            "@testing.variation('single_element', [True, False])\ndef test_subclass_load_only_doesnt_fetch_cols(self, single_element):\n    if False:\n        i = 10\n    'test that when using load_only(), the actual INSERT statement\\n        does not include the deferred columns\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    if single_element:\n        data = data[0]\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert(B).returning(B).options(load_only(B.id, B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        if single_element:\n            id0 = objects[0].id\n            id1 = None\n        else:\n            (id0, id1) = (objects[0].id, objects[1].id)\n    if inspect(B).single or inspect(B).concrete:\n        expected_params = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            expected_params[1:] = []\n        if inspect(B).single:\n            asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING a.id, a.type, a.data, a.y, a.q', expected_params))\n        else:\n            asserter.assert_(CompiledSQL('INSERT INTO b (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING b.id, b.type, b.data, b.y, b.q', expected_params))\n    else:\n        a_data = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6}]\n        b_data = [{'id': id0, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'id': id1, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            a_data[1:] = []\n            b_data[1:] = []\n        asserter.assert_(Conditional(self.use_sentinel and (not single_element), [CompiledSQL('INSERT INTO a (type, data, xcol, y, _sentinel) VALUES (:type, :data, :xcol, :y, :_sentinel) RETURNING a.id, a.type, a.data, a.y, a._sentinel', a_data), CompiledSQL('INSERT INTO b (id, bd, zcol, q, _sentinel) VALUES (:id, :bd, :zcol, :q, :_sentinel) RETURNING b.id, b.q, b._sentinel', b_data)], [CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y) RETURNING a.id, a.type, a.data, a.y', a_data), Conditional(single_element, [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q', b_data)], [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q, b.id AS id__1', b_data)])]))",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_load_only_doesnt_fetch_cols(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test that when using load_only(), the actual INSERT statement\\n        does not include the deferred columns\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    if single_element:\n        data = data[0]\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert(B).returning(B).options(load_only(B.id, B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        if single_element:\n            id0 = objects[0].id\n            id1 = None\n        else:\n            (id0, id1) = (objects[0].id, objects[1].id)\n    if inspect(B).single or inspect(B).concrete:\n        expected_params = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            expected_params[1:] = []\n        if inspect(B).single:\n            asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING a.id, a.type, a.data, a.y, a.q', expected_params))\n        else:\n            asserter.assert_(CompiledSQL('INSERT INTO b (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING b.id, b.type, b.data, b.y, b.q', expected_params))\n    else:\n        a_data = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6}]\n        b_data = [{'id': id0, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'id': id1, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            a_data[1:] = []\n            b_data[1:] = []\n        asserter.assert_(Conditional(self.use_sentinel and (not single_element), [CompiledSQL('INSERT INTO a (type, data, xcol, y, _sentinel) VALUES (:type, :data, :xcol, :y, :_sentinel) RETURNING a.id, a.type, a.data, a.y, a._sentinel', a_data), CompiledSQL('INSERT INTO b (id, bd, zcol, q, _sentinel) VALUES (:id, :bd, :zcol, :q, :_sentinel) RETURNING b.id, b.q, b._sentinel', b_data)], [CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y) RETURNING a.id, a.type, a.data, a.y', a_data), Conditional(single_element, [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q', b_data)], [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q, b.id AS id__1', b_data)])]))",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_load_only_doesnt_fetch_cols(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test that when using load_only(), the actual INSERT statement\\n        does not include the deferred columns\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    if single_element:\n        data = data[0]\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert(B).returning(B).options(load_only(B.id, B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        if single_element:\n            id0 = objects[0].id\n            id1 = None\n        else:\n            (id0, id1) = (objects[0].id, objects[1].id)\n    if inspect(B).single or inspect(B).concrete:\n        expected_params = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            expected_params[1:] = []\n        if inspect(B).single:\n            asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING a.id, a.type, a.data, a.y, a.q', expected_params))\n        else:\n            asserter.assert_(CompiledSQL('INSERT INTO b (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING b.id, b.type, b.data, b.y, b.q', expected_params))\n    else:\n        a_data = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6}]\n        b_data = [{'id': id0, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'id': id1, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            a_data[1:] = []\n            b_data[1:] = []\n        asserter.assert_(Conditional(self.use_sentinel and (not single_element), [CompiledSQL('INSERT INTO a (type, data, xcol, y, _sentinel) VALUES (:type, :data, :xcol, :y, :_sentinel) RETURNING a.id, a.type, a.data, a.y, a._sentinel', a_data), CompiledSQL('INSERT INTO b (id, bd, zcol, q, _sentinel) VALUES (:id, :bd, :zcol, :q, :_sentinel) RETURNING b.id, b.q, b._sentinel', b_data)], [CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y) RETURNING a.id, a.type, a.data, a.y', a_data), Conditional(single_element, [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q', b_data)], [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q, b.id AS id__1', b_data)])]))",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_load_only_doesnt_fetch_cols(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test that when using load_only(), the actual INSERT statement\\n        does not include the deferred columns\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    if single_element:\n        data = data[0]\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert(B).returning(B).options(load_only(B.id, B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        if single_element:\n            id0 = objects[0].id\n            id1 = None\n        else:\n            (id0, id1) = (objects[0].id, objects[1].id)\n    if inspect(B).single or inspect(B).concrete:\n        expected_params = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            expected_params[1:] = []\n        if inspect(B).single:\n            asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING a.id, a.type, a.data, a.y, a.q', expected_params))\n        else:\n            asserter.assert_(CompiledSQL('INSERT INTO b (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING b.id, b.type, b.data, b.y, b.q', expected_params))\n    else:\n        a_data = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6}]\n        b_data = [{'id': id0, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'id': id1, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            a_data[1:] = []\n            b_data[1:] = []\n        asserter.assert_(Conditional(self.use_sentinel and (not single_element), [CompiledSQL('INSERT INTO a (type, data, xcol, y, _sentinel) VALUES (:type, :data, :xcol, :y, :_sentinel) RETURNING a.id, a.type, a.data, a.y, a._sentinel', a_data), CompiledSQL('INSERT INTO b (id, bd, zcol, q, _sentinel) VALUES (:id, :bd, :zcol, :q, :_sentinel) RETURNING b.id, b.q, b._sentinel', b_data)], [CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y) RETURNING a.id, a.type, a.data, a.y', a_data), Conditional(single_element, [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q', b_data)], [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q, b.id AS id__1', b_data)])]))",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_load_only_doesnt_fetch_cols(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test that when using load_only(), the actual INSERT statement\\n        does not include the deferred columns\\n\\n        '\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    if single_element:\n        data = data[0]\n    with self.sql_execution_asserter() as asserter:\n        result = s.execute(insert(B).returning(B).options(load_only(B.id, B.data, B.y, B.q)), data)\n        objects = result.scalars().all()\n        if single_element:\n            id0 = objects[0].id\n            id1 = None\n        else:\n            (id0, id1) = (objects[0].id, objects[1].id)\n    if inspect(B).single or inspect(B).concrete:\n        expected_params = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            expected_params[1:] = []\n        if inspect(B).single:\n            asserter.assert_(CompiledSQL('INSERT INTO a (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING a.id, a.type, a.data, a.y, a.q', expected_params))\n        else:\n            asserter.assert_(CompiledSQL('INSERT INTO b (type, data, xcol, y, bd, zcol, q) VALUES (:type, :data, :xcol, :y, :bd, :zcol, :q) RETURNING b.id, b.type, b.data, b.y, b.q', expected_params))\n    else:\n        a_data = [{'type': 'b', 'data': 'd3', 'xcol': 1, 'y': 2}, {'type': 'b', 'data': 'd4', 'xcol': 5, 'y': 6}]\n        b_data = [{'id': id0, 'bd': 'bd1', 'zcol': 3, 'q': 4}, {'id': id1, 'bd': 'bd2', 'zcol': 7, 'q': 8}]\n        if single_element:\n            a_data[1:] = []\n            b_data[1:] = []\n        asserter.assert_(Conditional(self.use_sentinel and (not single_element), [CompiledSQL('INSERT INTO a (type, data, xcol, y, _sentinel) VALUES (:type, :data, :xcol, :y, :_sentinel) RETURNING a.id, a.type, a.data, a.y, a._sentinel', a_data), CompiledSQL('INSERT INTO b (id, bd, zcol, q, _sentinel) VALUES (:id, :bd, :zcol, :q, :_sentinel) RETURNING b.id, b.q, b._sentinel', b_data)], [CompiledSQL('INSERT INTO a (type, data, xcol, y) VALUES (:type, :data, :xcol, :y) RETURNING a.id, a.type, a.data, a.y', a_data), Conditional(single_element, [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q', b_data)], [CompiledSQL('INSERT INTO b (id, bd, zcol, q) VALUES (:id, :bd, :zcol, :q) RETURNING b.id, b.q, b.id AS id__1', b_data)])]))"
        ]
    },
    {
        "func_name": "test_subclass_returning_bind_expr",
        "original": "@testing.variation('single_element', [True, False])\ndef test_subclass_returning_bind_expr(self, single_element):\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B).returning(B.data, B.y, B.q + 5), data)\n    if single_element:\n        eq_(result.all(), [('d3', 2, 9)])\n    else:\n        eq_(set(result), {('d3', 2, 9), ('d4', 6, 13)})",
        "mutated": [
            "@testing.variation('single_element', [True, False])\ndef test_subclass_returning_bind_expr(self, single_element):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B).returning(B.data, B.y, B.q + 5), data)\n    if single_element:\n        eq_(result.all(), [('d3', 2, 9)])\n    else:\n        eq_(set(result), {('d3', 2, 9), ('d4', 6, 13)})",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_returning_bind_expr(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B).returning(B.data, B.y, B.q + 5), data)\n    if single_element:\n        eq_(result.all(), [('d3', 2, 9)])\n    else:\n        eq_(set(result), {('d3', 2, 9), ('d4', 6, 13)})",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_returning_bind_expr(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B).returning(B.data, B.y, B.q + 5), data)\n    if single_element:\n        eq_(result.all(), [('d3', 2, 9)])\n    else:\n        eq_(set(result), {('d3', 2, 9), ('d4', 6, 13)})",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_returning_bind_expr(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B).returning(B.data, B.y, B.q + 5), data)\n    if single_element:\n        eq_(result.all(), [('d3', 2, 9)])\n    else:\n        eq_(set(result), {('d3', 2, 9), ('d4', 6, 13)})",
            "@testing.variation('single_element', [True, False])\ndef test_subclass_returning_bind_expr(self, single_element):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    result = s.execute(insert(B).returning(B.data, B.y, B.q + 5), data)\n    if single_element:\n        eq_(result.all(), [('d3', 2, 9)])\n    else:\n        eq_(set(result), {('d3', 2, 9), ('d4', 6, 13)})"
        ]
    },
    {
        "func_name": "test_subclass_bulk_update",
        "original": "def test_subclass_bulk_update(self):\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data).all()}\n    result = s.execute(update(B), [{'id': ids['d3'], 'data': 'd3_updated', 'bd': 'bd1_updated'}, {'id': ids['d4'], 'data': 'd4_updated', 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='d3_updated', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd2_updated', data='d4_updated', id=ids['d4'], q=8, type='b', x=5, y=6, z=7)})",
        "mutated": [
            "def test_subclass_bulk_update(self):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data).all()}\n    result = s.execute(update(B), [{'id': ids['d3'], 'data': 'd3_updated', 'bd': 'bd1_updated'}, {'id': ids['d4'], 'data': 'd4_updated', 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='d3_updated', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd2_updated', data='d4_updated', id=ids['d4'], q=8, type='b', x=5, y=6, z=7)})",
            "def test_subclass_bulk_update(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data).all()}\n    result = s.execute(update(B), [{'id': ids['d3'], 'data': 'd3_updated', 'bd': 'bd1_updated'}, {'id': ids['d4'], 'data': 'd4_updated', 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='d3_updated', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd2_updated', data='d4_updated', id=ids['d4'], q=8, type='b', x=5, y=6, z=7)})",
            "def test_subclass_bulk_update(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data).all()}\n    result = s.execute(update(B), [{'id': ids['d3'], 'data': 'd3_updated', 'bd': 'bd1_updated'}, {'id': ids['d4'], 'data': 'd4_updated', 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='d3_updated', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd2_updated', data='d4_updated', id=ids['d4'], q=8, type='b', x=5, y=6, z=7)})",
            "def test_subclass_bulk_update(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data).all()}\n    result = s.execute(update(B), [{'id': ids['d3'], 'data': 'd3_updated', 'bd': 'bd1_updated'}, {'id': ids['d4'], 'data': 'd4_updated', 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='d3_updated', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd2_updated', data='d4_updated', id=ids['d4'], q=8, type='b', x=5, y=6, z=7)})",
            "def test_subclass_bulk_update(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data), data).all()}\n    result = s.execute(update(B), [{'id': ids['d3'], 'data': 'd3_updated', 'bd': 'bd1_updated'}, {'id': ids['d4'], 'data': 'd4_updated', 'bd': 'bd2_updated'}])\n    assert result is not None\n    eq_(set(s.scalars(select(B))), {B(bd='bd1_updated', data='d3_updated', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd2_updated', data='d4_updated', id=ids['d4'], q=8, type='b', x=5, y=6, z=7)})"
        ]
    },
    {
        "func_name": "test_subclass_return_just_subclass_ids",
        "original": "@testing.variation('single_element', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_subclass_return_just_subclass_ids(self, single_element, sort_by_parameter_order):\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=bool(sort_by_parameter_order)), data)\n    actual_ids = s.execute(select(B.id, B.data).order_by(B.id))\n    if sort_by_parameter_order:\n        coll = list\n    else:\n        coll = set\n    eq_(coll(ids), coll(actual_ids))",
        "mutated": [
            "@testing.variation('single_element', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_subclass_return_just_subclass_ids(self, single_element, sort_by_parameter_order):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=bool(sort_by_parameter_order)), data)\n    actual_ids = s.execute(select(B.id, B.data).order_by(B.id))\n    if sort_by_parameter_order:\n        coll = list\n    else:\n        coll = set\n    eq_(coll(ids), coll(actual_ids))",
            "@testing.variation('single_element', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_subclass_return_just_subclass_ids(self, single_element, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=bool(sort_by_parameter_order)), data)\n    actual_ids = s.execute(select(B.id, B.data).order_by(B.id))\n    if sort_by_parameter_order:\n        coll = list\n    else:\n        coll = set\n    eq_(coll(ids), coll(actual_ids))",
            "@testing.variation('single_element', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_subclass_return_just_subclass_ids(self, single_element, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=bool(sort_by_parameter_order)), data)\n    actual_ids = s.execute(select(B.id, B.data).order_by(B.id))\n    if sort_by_parameter_order:\n        coll = list\n    else:\n        coll = set\n    eq_(coll(ids), coll(actual_ids))",
            "@testing.variation('single_element', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_subclass_return_just_subclass_ids(self, single_element, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=bool(sort_by_parameter_order)), data)\n    actual_ids = s.execute(select(B.id, B.data).order_by(B.id))\n    if sort_by_parameter_order:\n        coll = list\n    else:\n        coll = set\n    eq_(coll(ids), coll(actual_ids))",
            "@testing.variation('single_element', [True, False])\n@testing.variation('sort_by_parameter_order', [True, False])\ndef test_subclass_return_just_subclass_ids(self, single_element, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    if single_element:\n        data = {'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}\n    else:\n        data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=bool(sort_by_parameter_order)), data)\n    actual_ids = s.execute(select(B.id, B.data).order_by(B.id))\n    if sort_by_parameter_order:\n        coll = list\n    else:\n        coll = set\n    eq_(coll(ids), coll(actual_ids))"
        ]
    },
    {
        "func_name": "test_base_class_upsert",
        "original": "@testing.variation('insert_strategy', ['orm', 'bulk', 'bulk_ordered', 'bulk_w_embedded_bindparam'])\n@testing.requires.provisioned_upsert\ndef test_base_class_upsert(self, insert_strategy):\n    \"\"\"upsert is really tricky.   if you dont have any data updated,\n        then you dont get the rows back and things dont work so well.\n\n        so we need to be careful how much we document this because this is\n        still a thorny use case.\n\n        \"\"\"\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'x': 1, 'y': 2, 'q': 4}, {'data': 'd4', 'x': 5, 'y': 6, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(A).returning(A.id, A.data), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'a', 'data': 'd3', 'x': 1, 'y': 2}, {'id': 32, 'type': 'a', 'data': 'd32', 'x': 19, 'y': 5}, {'id': ids['d4'], 'type': 'a', 'data': 'd4', 'x': 5, 'y': 6}, {'id': 28, 'type': 'a', 'data': 'd28', 'x': 9, 'y': 15}]\n    stmt = provision.upsert(config, A, (A,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted'}, sort_by_parameter_order=insert_strategy.bulk_ordered)\n    if insert_strategy.orm:\n        result = s.scalars(stmt.values(upsert_data))\n    elif insert_strategy.bulk or insert_strategy.bulk_ordered:\n        with self.assert_for_downgrade(sort_by_parameter_order=insert_strategy.bulk_ordered):\n            result = s.scalars(stmt, upsert_data)\n    elif insert_strategy.bulk_w_embedded_bindparam:\n        stmt = stmt.values(y=select(bindparam('qq1', type_=Integer)).scalar_subquery())\n        for d in upsert_data:\n            d['qq1'] = d.pop('y')\n        result = s.scalars(stmt, upsert_data)\n    else:\n        insert_strategy.fail()\n    eq_(set(result.all()), {A(data='d3 upserted', id=ids['d3'], type='a', x=1, y=2), A(data='d32', id=32, type='a', x=19, y=5), A(data='d4 upserted', id=ids['d4'], type='a', x=5, y=6), A(data='d28', id=28, type='a', x=9, y=15)})",
        "mutated": [
            "@testing.variation('insert_strategy', ['orm', 'bulk', 'bulk_ordered', 'bulk_w_embedded_bindparam'])\n@testing.requires.provisioned_upsert\ndef test_base_class_upsert(self, insert_strategy):\n    if False:\n        i = 10\n    'upsert is really tricky.   if you dont have any data updated,\\n        then you dont get the rows back and things dont work so well.\\n\\n        so we need to be careful how much we document this because this is\\n        still a thorny use case.\\n\\n        '\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'x': 1, 'y': 2, 'q': 4}, {'data': 'd4', 'x': 5, 'y': 6, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(A).returning(A.id, A.data), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'a', 'data': 'd3', 'x': 1, 'y': 2}, {'id': 32, 'type': 'a', 'data': 'd32', 'x': 19, 'y': 5}, {'id': ids['d4'], 'type': 'a', 'data': 'd4', 'x': 5, 'y': 6}, {'id': 28, 'type': 'a', 'data': 'd28', 'x': 9, 'y': 15}]\n    stmt = provision.upsert(config, A, (A,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted'}, sort_by_parameter_order=insert_strategy.bulk_ordered)\n    if insert_strategy.orm:\n        result = s.scalars(stmt.values(upsert_data))\n    elif insert_strategy.bulk or insert_strategy.bulk_ordered:\n        with self.assert_for_downgrade(sort_by_parameter_order=insert_strategy.bulk_ordered):\n            result = s.scalars(stmt, upsert_data)\n    elif insert_strategy.bulk_w_embedded_bindparam:\n        stmt = stmt.values(y=select(bindparam('qq1', type_=Integer)).scalar_subquery())\n        for d in upsert_data:\n            d['qq1'] = d.pop('y')\n        result = s.scalars(stmt, upsert_data)\n    else:\n        insert_strategy.fail()\n    eq_(set(result.all()), {A(data='d3 upserted', id=ids['d3'], type='a', x=1, y=2), A(data='d32', id=32, type='a', x=19, y=5), A(data='d4 upserted', id=ids['d4'], type='a', x=5, y=6), A(data='d28', id=28, type='a', x=9, y=15)})",
            "@testing.variation('insert_strategy', ['orm', 'bulk', 'bulk_ordered', 'bulk_w_embedded_bindparam'])\n@testing.requires.provisioned_upsert\ndef test_base_class_upsert(self, insert_strategy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'upsert is really tricky.   if you dont have any data updated,\\n        then you dont get the rows back and things dont work so well.\\n\\n        so we need to be careful how much we document this because this is\\n        still a thorny use case.\\n\\n        '\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'x': 1, 'y': 2, 'q': 4}, {'data': 'd4', 'x': 5, 'y': 6, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(A).returning(A.id, A.data), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'a', 'data': 'd3', 'x': 1, 'y': 2}, {'id': 32, 'type': 'a', 'data': 'd32', 'x': 19, 'y': 5}, {'id': ids['d4'], 'type': 'a', 'data': 'd4', 'x': 5, 'y': 6}, {'id': 28, 'type': 'a', 'data': 'd28', 'x': 9, 'y': 15}]\n    stmt = provision.upsert(config, A, (A,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted'}, sort_by_parameter_order=insert_strategy.bulk_ordered)\n    if insert_strategy.orm:\n        result = s.scalars(stmt.values(upsert_data))\n    elif insert_strategy.bulk or insert_strategy.bulk_ordered:\n        with self.assert_for_downgrade(sort_by_parameter_order=insert_strategy.bulk_ordered):\n            result = s.scalars(stmt, upsert_data)\n    elif insert_strategy.bulk_w_embedded_bindparam:\n        stmt = stmt.values(y=select(bindparam('qq1', type_=Integer)).scalar_subquery())\n        for d in upsert_data:\n            d['qq1'] = d.pop('y')\n        result = s.scalars(stmt, upsert_data)\n    else:\n        insert_strategy.fail()\n    eq_(set(result.all()), {A(data='d3 upserted', id=ids['d3'], type='a', x=1, y=2), A(data='d32', id=32, type='a', x=19, y=5), A(data='d4 upserted', id=ids['d4'], type='a', x=5, y=6), A(data='d28', id=28, type='a', x=9, y=15)})",
            "@testing.variation('insert_strategy', ['orm', 'bulk', 'bulk_ordered', 'bulk_w_embedded_bindparam'])\n@testing.requires.provisioned_upsert\ndef test_base_class_upsert(self, insert_strategy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'upsert is really tricky.   if you dont have any data updated,\\n        then you dont get the rows back and things dont work so well.\\n\\n        so we need to be careful how much we document this because this is\\n        still a thorny use case.\\n\\n        '\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'x': 1, 'y': 2, 'q': 4}, {'data': 'd4', 'x': 5, 'y': 6, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(A).returning(A.id, A.data), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'a', 'data': 'd3', 'x': 1, 'y': 2}, {'id': 32, 'type': 'a', 'data': 'd32', 'x': 19, 'y': 5}, {'id': ids['d4'], 'type': 'a', 'data': 'd4', 'x': 5, 'y': 6}, {'id': 28, 'type': 'a', 'data': 'd28', 'x': 9, 'y': 15}]\n    stmt = provision.upsert(config, A, (A,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted'}, sort_by_parameter_order=insert_strategy.bulk_ordered)\n    if insert_strategy.orm:\n        result = s.scalars(stmt.values(upsert_data))\n    elif insert_strategy.bulk or insert_strategy.bulk_ordered:\n        with self.assert_for_downgrade(sort_by_parameter_order=insert_strategy.bulk_ordered):\n            result = s.scalars(stmt, upsert_data)\n    elif insert_strategy.bulk_w_embedded_bindparam:\n        stmt = stmt.values(y=select(bindparam('qq1', type_=Integer)).scalar_subquery())\n        for d in upsert_data:\n            d['qq1'] = d.pop('y')\n        result = s.scalars(stmt, upsert_data)\n    else:\n        insert_strategy.fail()\n    eq_(set(result.all()), {A(data='d3 upserted', id=ids['d3'], type='a', x=1, y=2), A(data='d32', id=32, type='a', x=19, y=5), A(data='d4 upserted', id=ids['d4'], type='a', x=5, y=6), A(data='d28', id=28, type='a', x=9, y=15)})",
            "@testing.variation('insert_strategy', ['orm', 'bulk', 'bulk_ordered', 'bulk_w_embedded_bindparam'])\n@testing.requires.provisioned_upsert\ndef test_base_class_upsert(self, insert_strategy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'upsert is really tricky.   if you dont have any data updated,\\n        then you dont get the rows back and things dont work so well.\\n\\n        so we need to be careful how much we document this because this is\\n        still a thorny use case.\\n\\n        '\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'x': 1, 'y': 2, 'q': 4}, {'data': 'd4', 'x': 5, 'y': 6, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(A).returning(A.id, A.data), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'a', 'data': 'd3', 'x': 1, 'y': 2}, {'id': 32, 'type': 'a', 'data': 'd32', 'x': 19, 'y': 5}, {'id': ids['d4'], 'type': 'a', 'data': 'd4', 'x': 5, 'y': 6}, {'id': 28, 'type': 'a', 'data': 'd28', 'x': 9, 'y': 15}]\n    stmt = provision.upsert(config, A, (A,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted'}, sort_by_parameter_order=insert_strategy.bulk_ordered)\n    if insert_strategy.orm:\n        result = s.scalars(stmt.values(upsert_data))\n    elif insert_strategy.bulk or insert_strategy.bulk_ordered:\n        with self.assert_for_downgrade(sort_by_parameter_order=insert_strategy.bulk_ordered):\n            result = s.scalars(stmt, upsert_data)\n    elif insert_strategy.bulk_w_embedded_bindparam:\n        stmt = stmt.values(y=select(bindparam('qq1', type_=Integer)).scalar_subquery())\n        for d in upsert_data:\n            d['qq1'] = d.pop('y')\n        result = s.scalars(stmt, upsert_data)\n    else:\n        insert_strategy.fail()\n    eq_(set(result.all()), {A(data='d3 upserted', id=ids['d3'], type='a', x=1, y=2), A(data='d32', id=32, type='a', x=19, y=5), A(data='d4 upserted', id=ids['d4'], type='a', x=5, y=6), A(data='d28', id=28, type='a', x=9, y=15)})",
            "@testing.variation('insert_strategy', ['orm', 'bulk', 'bulk_ordered', 'bulk_w_embedded_bindparam'])\n@testing.requires.provisioned_upsert\ndef test_base_class_upsert(self, insert_strategy):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'upsert is really tricky.   if you dont have any data updated,\\n        then you dont get the rows back and things dont work so well.\\n\\n        so we need to be careful how much we document this because this is\\n        still a thorny use case.\\n\\n        '\n    A = self.classes.A\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'x': 1, 'y': 2, 'q': 4}, {'data': 'd4', 'x': 5, 'y': 6, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(A).returning(A.id, A.data), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'a', 'data': 'd3', 'x': 1, 'y': 2}, {'id': 32, 'type': 'a', 'data': 'd32', 'x': 19, 'y': 5}, {'id': ids['d4'], 'type': 'a', 'data': 'd4', 'x': 5, 'y': 6}, {'id': 28, 'type': 'a', 'data': 'd28', 'x': 9, 'y': 15}]\n    stmt = provision.upsert(config, A, (A,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted'}, sort_by_parameter_order=insert_strategy.bulk_ordered)\n    if insert_strategy.orm:\n        result = s.scalars(stmt.values(upsert_data))\n    elif insert_strategy.bulk or insert_strategy.bulk_ordered:\n        with self.assert_for_downgrade(sort_by_parameter_order=insert_strategy.bulk_ordered):\n            result = s.scalars(stmt, upsert_data)\n    elif insert_strategy.bulk_w_embedded_bindparam:\n        stmt = stmt.values(y=select(bindparam('qq1', type_=Integer)).scalar_subquery())\n        for d in upsert_data:\n            d['qq1'] = d.pop('y')\n        result = s.scalars(stmt, upsert_data)\n    else:\n        insert_strategy.fail()\n    eq_(set(result.all()), {A(data='d3 upserted', id=ids['d3'], type='a', x=1, y=2), A(data='d32', id=32, type='a', x=19, y=5), A(data='d4 upserted', id=ids['d4'], type='a', x=5, y=6), A(data='d28', id=28, type='a', x=9, y=15)})"
        ]
    },
    {
        "func_name": "test_subclass_upsert",
        "original": "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, sort_by_parameter_order):\n    \"\"\"note this is overridden in the joined version to expect failure\"\"\"\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    idd3 = 1\n    idd4 = 2\n    id32 = 32\n    id28 = 28\n    initial_data = [{'id': idd3, 'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'id': idd4, 'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=True), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'b', 'data': 'd3', 'bd': 'bd1_upserted', 'x': 1, 'y': 2, 'z': 33, 'q': 44}, {'id': id32, 'type': 'b', 'data': 'd32', 'bd': 'bd 32', 'x': 19, 'y': 5, 'z': 20, 'q': 21}, {'id': ids['d4'], 'type': 'b', 'bd': 'bd2_upserted', 'data': 'd4', 'x': 5, 'y': 6, 'z': 77, 'q': 88}, {'id': id28, 'type': 'b', 'data': 'd28', 'bd': 'bd 28', 'x': 9, 'y': 15, 'z': 10, 'q': 11}]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted', 'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.assert_for_downgrade(sort_by_parameter_order=bool(sort_by_parameter_order)):\n        result = s.scalars(stmt, upsert_data)\n    eq_(set(result), {B(bd='bd1_upserted upserted', data='d3 upserted', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd 32', data='d32', id=32, q=21, type='b', x=19, y=5, z=20), B(bd='bd2_upserted upserted', data='d4 upserted', id=ids['d4'], q=8, type='b', x=5, y=6, z=7), B(bd='bd 28', data='d28', id=28, q=11, type='b', x=9, y=15, z=10)})",
        "mutated": [
            "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, sort_by_parameter_order):\n    if False:\n        i = 10\n    'note this is overridden in the joined version to expect failure'\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    idd3 = 1\n    idd4 = 2\n    id32 = 32\n    id28 = 28\n    initial_data = [{'id': idd3, 'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'id': idd4, 'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=True), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'b', 'data': 'd3', 'bd': 'bd1_upserted', 'x': 1, 'y': 2, 'z': 33, 'q': 44}, {'id': id32, 'type': 'b', 'data': 'd32', 'bd': 'bd 32', 'x': 19, 'y': 5, 'z': 20, 'q': 21}, {'id': ids['d4'], 'type': 'b', 'bd': 'bd2_upserted', 'data': 'd4', 'x': 5, 'y': 6, 'z': 77, 'q': 88}, {'id': id28, 'type': 'b', 'data': 'd28', 'bd': 'bd 28', 'x': 9, 'y': 15, 'z': 10, 'q': 11}]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted', 'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.assert_for_downgrade(sort_by_parameter_order=bool(sort_by_parameter_order)):\n        result = s.scalars(stmt, upsert_data)\n    eq_(set(result), {B(bd='bd1_upserted upserted', data='d3 upserted', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd 32', data='d32', id=32, q=21, type='b', x=19, y=5, z=20), B(bd='bd2_upserted upserted', data='d4 upserted', id=ids['d4'], q=8, type='b', x=5, y=6, z=7), B(bd='bd 28', data='d28', id=28, q=11, type='b', x=9, y=15, z=10)})",
            "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'note this is overridden in the joined version to expect failure'\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    idd3 = 1\n    idd4 = 2\n    id32 = 32\n    id28 = 28\n    initial_data = [{'id': idd3, 'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'id': idd4, 'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=True), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'b', 'data': 'd3', 'bd': 'bd1_upserted', 'x': 1, 'y': 2, 'z': 33, 'q': 44}, {'id': id32, 'type': 'b', 'data': 'd32', 'bd': 'bd 32', 'x': 19, 'y': 5, 'z': 20, 'q': 21}, {'id': ids['d4'], 'type': 'b', 'bd': 'bd2_upserted', 'data': 'd4', 'x': 5, 'y': 6, 'z': 77, 'q': 88}, {'id': id28, 'type': 'b', 'data': 'd28', 'bd': 'bd 28', 'x': 9, 'y': 15, 'z': 10, 'q': 11}]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted', 'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.assert_for_downgrade(sort_by_parameter_order=bool(sort_by_parameter_order)):\n        result = s.scalars(stmt, upsert_data)\n    eq_(set(result), {B(bd='bd1_upserted upserted', data='d3 upserted', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd 32', data='d32', id=32, q=21, type='b', x=19, y=5, z=20), B(bd='bd2_upserted upserted', data='d4 upserted', id=ids['d4'], q=8, type='b', x=5, y=6, z=7), B(bd='bd 28', data='d28', id=28, q=11, type='b', x=9, y=15, z=10)})",
            "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'note this is overridden in the joined version to expect failure'\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    idd3 = 1\n    idd4 = 2\n    id32 = 32\n    id28 = 28\n    initial_data = [{'id': idd3, 'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'id': idd4, 'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=True), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'b', 'data': 'd3', 'bd': 'bd1_upserted', 'x': 1, 'y': 2, 'z': 33, 'q': 44}, {'id': id32, 'type': 'b', 'data': 'd32', 'bd': 'bd 32', 'x': 19, 'y': 5, 'z': 20, 'q': 21}, {'id': ids['d4'], 'type': 'b', 'bd': 'bd2_upserted', 'data': 'd4', 'x': 5, 'y': 6, 'z': 77, 'q': 88}, {'id': id28, 'type': 'b', 'data': 'd28', 'bd': 'bd 28', 'x': 9, 'y': 15, 'z': 10, 'q': 11}]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted', 'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.assert_for_downgrade(sort_by_parameter_order=bool(sort_by_parameter_order)):\n        result = s.scalars(stmt, upsert_data)\n    eq_(set(result), {B(bd='bd1_upserted upserted', data='d3 upserted', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd 32', data='d32', id=32, q=21, type='b', x=19, y=5, z=20), B(bd='bd2_upserted upserted', data='d4 upserted', id=ids['d4'], q=8, type='b', x=5, y=6, z=7), B(bd='bd 28', data='d28', id=28, q=11, type='b', x=9, y=15, z=10)})",
            "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'note this is overridden in the joined version to expect failure'\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    idd3 = 1\n    idd4 = 2\n    id32 = 32\n    id28 = 28\n    initial_data = [{'id': idd3, 'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'id': idd4, 'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=True), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'b', 'data': 'd3', 'bd': 'bd1_upserted', 'x': 1, 'y': 2, 'z': 33, 'q': 44}, {'id': id32, 'type': 'b', 'data': 'd32', 'bd': 'bd 32', 'x': 19, 'y': 5, 'z': 20, 'q': 21}, {'id': ids['d4'], 'type': 'b', 'bd': 'bd2_upserted', 'data': 'd4', 'x': 5, 'y': 6, 'z': 77, 'q': 88}, {'id': id28, 'type': 'b', 'data': 'd28', 'bd': 'bd 28', 'x': 9, 'y': 15, 'z': 10, 'q': 11}]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted', 'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.assert_for_downgrade(sort_by_parameter_order=bool(sort_by_parameter_order)):\n        result = s.scalars(stmt, upsert_data)\n    eq_(set(result), {B(bd='bd1_upserted upserted', data='d3 upserted', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd 32', data='d32', id=32, q=21, type='b', x=19, y=5, z=20), B(bd='bd2_upserted upserted', data='d4 upserted', id=ids['d4'], q=8, type='b', x=5, y=6, z=7), B(bd='bd 28', data='d28', id=28, q=11, type='b', x=9, y=15, z=10)})",
            "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'note this is overridden in the joined version to expect failure'\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    idd3 = 1\n    idd4 = 2\n    id32 = 32\n    id28 = 28\n    initial_data = [{'id': idd3, 'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'id': idd4, 'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = {row.data: row.id for row in s.execute(insert(B).returning(B.id, B.data, sort_by_parameter_order=True), initial_data)}\n    upsert_data = [{'id': ids['d3'], 'type': 'b', 'data': 'd3', 'bd': 'bd1_upserted', 'x': 1, 'y': 2, 'z': 33, 'q': 44}, {'id': id32, 'type': 'b', 'data': 'd32', 'bd': 'bd 32', 'x': 19, 'y': 5, 'z': 20, 'q': 21}, {'id': ids['d4'], 'type': 'b', 'bd': 'bd2_upserted', 'data': 'd4', 'x': 5, 'y': 6, 'z': 77, 'q': 88}, {'id': id28, 'type': 'b', 'data': 'd28', 'bd': 'bd 28', 'x': 9, 'y': 15, 'z': 10, 'q': 11}]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'data': inserted.data + ' upserted', 'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with self.assert_for_downgrade(sort_by_parameter_order=bool(sort_by_parameter_order)):\n        result = s.scalars(stmt, upsert_data)\n    eq_(set(result), {B(bd='bd1_upserted upserted', data='d3 upserted', id=ids['d3'], q=4, type='b', x=1, y=2, z=3), B(bd='bd 32', data='d32', id=32, q=21, type='b', x=19, y=5, z=20), B(bd='bd2_upserted upserted', data='d4 upserted', id=ids['d4'], q=8, type='b', x=5, y=6, z=7), B(bd='bd 28', data='d28', id=28, q=11, type='b', x=9, y=15, z=10)})"
        ]
    },
    {
        "func_name": "setup_classes",
        "original": "@classmethod\ndef setup_classes(cls):\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(ForeignKey('a.id'), primary_key=True)\n        bd: Mapped[str]\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'b'}",
        "mutated": [
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(ForeignKey('a.id'), primary_key=True)\n        bd: Mapped[str]\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'b'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(ForeignKey('a.id'), primary_key=True)\n        bd: Mapped[str]\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'b'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(ForeignKey('a.id'), primary_key=True)\n        bd: Mapped[str]\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'b'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(ForeignKey('a.id'), primary_key=True)\n        bd: Mapped[str]\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'b'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(ForeignKey('a.id'), primary_key=True)\n        bd: Mapped[str]\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        if cls.use_sentinel:\n            _sentinel: Mapped[int] = orm_insert_sentinel()\n        __mapper_args__ = {'polymorphic_identity': 'b'}"
        ]
    },
    {
        "func_name": "test_subclass_upsert",
        "original": "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.combinations(True, False, argnames='single_param')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, single_param, sort_by_parameter_order):\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.scalars(insert(B).returning(B.id, sort_by_parameter_order=True), initial_data).all()\n    upsert_data = [{'id': ids[0], 'type': 'b'}, {'id': 32, 'type': 'b'}]\n    if single_param:\n        upsert_data = upsert_data[0]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with expect_raises_message(exc.InvalidRequestError, \"bulk INSERT with a 'post values' clause \\\\(typically upsert\\\\) not supported for multi-table mapper\"):\n        s.scalars(stmt, upsert_data)",
        "mutated": [
            "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.combinations(True, False, argnames='single_param')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, single_param, sort_by_parameter_order):\n    if False:\n        i = 10\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.scalars(insert(B).returning(B.id, sort_by_parameter_order=True), initial_data).all()\n    upsert_data = [{'id': ids[0], 'type': 'b'}, {'id': 32, 'type': 'b'}]\n    if single_param:\n        upsert_data = upsert_data[0]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with expect_raises_message(exc.InvalidRequestError, \"bulk INSERT with a 'post values' clause \\\\(typically upsert\\\\) not supported for multi-table mapper\"):\n        s.scalars(stmt, upsert_data)",
            "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.combinations(True, False, argnames='single_param')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, single_param, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.scalars(insert(B).returning(B.id, sort_by_parameter_order=True), initial_data).all()\n    upsert_data = [{'id': ids[0], 'type': 'b'}, {'id': 32, 'type': 'b'}]\n    if single_param:\n        upsert_data = upsert_data[0]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with expect_raises_message(exc.InvalidRequestError, \"bulk INSERT with a 'post values' clause \\\\(typically upsert\\\\) not supported for multi-table mapper\"):\n        s.scalars(stmt, upsert_data)",
            "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.combinations(True, False, argnames='single_param')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, single_param, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.scalars(insert(B).returning(B.id, sort_by_parameter_order=True), initial_data).all()\n    upsert_data = [{'id': ids[0], 'type': 'b'}, {'id': 32, 'type': 'b'}]\n    if single_param:\n        upsert_data = upsert_data[0]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with expect_raises_message(exc.InvalidRequestError, \"bulk INSERT with a 'post values' clause \\\\(typically upsert\\\\) not supported for multi-table mapper\"):\n        s.scalars(stmt, upsert_data)",
            "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.combinations(True, False, argnames='single_param')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, single_param, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.scalars(insert(B).returning(B.id, sort_by_parameter_order=True), initial_data).all()\n    upsert_data = [{'id': ids[0], 'type': 'b'}, {'id': 32, 'type': 'b'}]\n    if single_param:\n        upsert_data = upsert_data[0]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with expect_raises_message(exc.InvalidRequestError, \"bulk INSERT with a 'post values' clause \\\\(typically upsert\\\\) not supported for multi-table mapper\"):\n        s.scalars(stmt, upsert_data)",
            "@testing.combinations('orm', 'bulk', argnames='insert_strategy')\n@testing.combinations(True, False, argnames='single_param')\n@testing.variation('sort_by_parameter_order', [True, False])\n@testing.requires.provisioned_upsert\ndef test_subclass_upsert(self, insert_strategy, single_param, sort_by_parameter_order):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (A, B) = self.classes('A', 'B')\n    s = fixture_session(bind=self.bind)\n    initial_data = [{'data': 'd3', 'bd': 'bd1', 'x': 1, 'y': 2, 'z': 3, 'q': 4}, {'data': 'd4', 'bd': 'bd2', 'x': 5, 'y': 6, 'z': 7, 'q': 8}]\n    ids = s.scalars(insert(B).returning(B.id, sort_by_parameter_order=True), initial_data).all()\n    upsert_data = [{'id': ids[0], 'type': 'b'}, {'id': 32, 'type': 'b'}]\n    if single_param:\n        upsert_data = upsert_data[0]\n    stmt = provision.upsert(config, B, (B,), set_lambda=lambda inserted: {'bd': inserted.bd + ' upserted'}, sort_by_parameter_order=bool(sort_by_parameter_order))\n    with expect_raises_message(exc.InvalidRequestError, \"bulk INSERT with a 'post values' clause \\\\(typically upsert\\\\) not supported for multi-table mapper\"):\n        s.scalars(stmt, upsert_data)"
        ]
    },
    {
        "func_name": "setup_classes",
        "original": "@classmethod\ndef setup_classes(cls):\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b'}",
        "mutated": [
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b'}"
        ]
    },
    {
        "func_name": "setup_classes",
        "original": "@classmethod\ndef setup_classes(cls):\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b', 'concrete': True, 'polymorphic_on': 'type'}",
        "mutated": [
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b', 'concrete': True, 'polymorphic_on': 'type'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b', 'concrete': True, 'polymorphic_on': 'type'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b', 'concrete': True, 'polymorphic_on': 'type'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b', 'concrete': True, 'polymorphic_on': 'type'}",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    decl_base = cls.DeclarativeBasic\n\n    class A(ComparableEntity, decl_base):\n        __tablename__ = 'a'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'a', 'polymorphic_on': 'type'}\n\n    class B(A):\n        __tablename__ = 'b'\n        id: Mapped[int] = mapped_column(Identity(), primary_key=True)\n        type: Mapped[str]\n        data: Mapped[str]\n        x: Mapped[Optional[int]] = mapped_column('xcol')\n        y: Mapped[Optional[int]]\n        bd: Mapped[str] = mapped_column(nullable=True)\n        z: Mapped[Optional[int]] = mapped_column('zcol')\n        q: Mapped[Optional[int]]\n        __mapper_args__ = {'polymorphic_identity': 'b', 'concrete': True, 'polymorphic_on': 'type'}"
        ]
    },
    {
        "func_name": "setup_classes",
        "original": "@classmethod\ndef setup_classes(cls):\n    decl_base = cls.DeclarativeBasic\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        username: Mapped[str]",
        "mutated": [
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n    decl_base = cls.DeclarativeBasic\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        username: Mapped[str]",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    decl_base = cls.DeclarativeBasic\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        username: Mapped[str]",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    decl_base = cls.DeclarativeBasic\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        username: Mapped[str]",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    decl_base = cls.DeclarativeBasic\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        username: Mapped[str]",
            "@classmethod\ndef setup_classes(cls):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    decl_base = cls.DeclarativeBasic\n\n    class User(ComparableEntity, decl_base):\n        __tablename__ = 'users'\n        id: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n        username: Mapped[str]"
        ]
    },
    {
        "func_name": "test_select_from_insert_cte",
        "original": "@testing.combinations(('cte_aliased', True), ('cte', False), argnames='wrap_cte_in_aliased', id_='ia')\n@testing.combinations(('use_union', True), ('no_union', False), argnames='use_a_union', id_='ia')\n@testing.combinations('from_statement', 'aliased', 'direct', argnames='fetch_entity_type')\ndef test_select_from_insert_cte(self, wrap_cte_in_aliased, use_a_union, fetch_entity_type):\n    \"\"\"test the use case from #8544; SELECT that selects from a\n        CTE INSERT...RETURNING.\n\n        \"\"\"\n    User = self.classes.User\n    id_ = uuid.uuid4()\n    cte = insert(User).values(id=id_, username='some user').returning(User).cte()\n    if wrap_cte_in_aliased:\n        cte = aliased(User, cte)\n    if use_a_union:\n        stmt = select(User).where(User.id == id_).union(select(cte))\n    else:\n        stmt = select(cte)\n    if fetch_entity_type == 'from_statement':\n        outer_stmt = select(User).from_statement(stmt)\n        expect_entity = True\n    elif fetch_entity_type == 'aliased':\n        outer_stmt = select(aliased(User, stmt.subquery()))\n        expect_entity = True\n    elif fetch_entity_type == 'direct':\n        outer_stmt = stmt\n        expect_entity = not use_a_union and wrap_cte_in_aliased\n    else:\n        assert False\n    sess = fixture_session(bind=self.bind)\n    with self.sql_execution_asserter() as asserter:\n        if not expect_entity:\n            row = sess.execute(outer_stmt).one()\n            eq_(row, (id_, 'some user'))\n        else:\n            new_user = sess.scalars(outer_stmt).one()\n            eq_(new_user, User(id=id_, username='some user'))\n    cte_sql = '(INSERT INTO users (id, username) VALUES (:param_1, :param_2) RETURNING users.id, users.username)'\n    if fetch_entity_type == 'aliased' and (not use_a_union):\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    elif not use_a_union:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM anon_1'\n    elif fetch_entity_type == 'aliased':\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT users.id AS id, users.username AS username FROM users WHERE users.id = :id_1 UNION SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    else:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT users.id, users.username FROM users WHERE users.id = :id_1 UNION SELECT anon_1.id, anon_1.username FROM anon_1'\n    asserter.assert_(CompiledSQL(expected, [{'param_1': id_, 'param_2': 'some user'}]))",
        "mutated": [
            "@testing.combinations(('cte_aliased', True), ('cte', False), argnames='wrap_cte_in_aliased', id_='ia')\n@testing.combinations(('use_union', True), ('no_union', False), argnames='use_a_union', id_='ia')\n@testing.combinations('from_statement', 'aliased', 'direct', argnames='fetch_entity_type')\ndef test_select_from_insert_cte(self, wrap_cte_in_aliased, use_a_union, fetch_entity_type):\n    if False:\n        i = 10\n    'test the use case from #8544; SELECT that selects from a\\n        CTE INSERT...RETURNING.\\n\\n        '\n    User = self.classes.User\n    id_ = uuid.uuid4()\n    cte = insert(User).values(id=id_, username='some user').returning(User).cte()\n    if wrap_cte_in_aliased:\n        cte = aliased(User, cte)\n    if use_a_union:\n        stmt = select(User).where(User.id == id_).union(select(cte))\n    else:\n        stmt = select(cte)\n    if fetch_entity_type == 'from_statement':\n        outer_stmt = select(User).from_statement(stmt)\n        expect_entity = True\n    elif fetch_entity_type == 'aliased':\n        outer_stmt = select(aliased(User, stmt.subquery()))\n        expect_entity = True\n    elif fetch_entity_type == 'direct':\n        outer_stmt = stmt\n        expect_entity = not use_a_union and wrap_cte_in_aliased\n    else:\n        assert False\n    sess = fixture_session(bind=self.bind)\n    with self.sql_execution_asserter() as asserter:\n        if not expect_entity:\n            row = sess.execute(outer_stmt).one()\n            eq_(row, (id_, 'some user'))\n        else:\n            new_user = sess.scalars(outer_stmt).one()\n            eq_(new_user, User(id=id_, username='some user'))\n    cte_sql = '(INSERT INTO users (id, username) VALUES (:param_1, :param_2) RETURNING users.id, users.username)'\n    if fetch_entity_type == 'aliased' and (not use_a_union):\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    elif not use_a_union:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM anon_1'\n    elif fetch_entity_type == 'aliased':\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT users.id AS id, users.username AS username FROM users WHERE users.id = :id_1 UNION SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    else:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT users.id, users.username FROM users WHERE users.id = :id_1 UNION SELECT anon_1.id, anon_1.username FROM anon_1'\n    asserter.assert_(CompiledSQL(expected, [{'param_1': id_, 'param_2': 'some user'}]))",
            "@testing.combinations(('cte_aliased', True), ('cte', False), argnames='wrap_cte_in_aliased', id_='ia')\n@testing.combinations(('use_union', True), ('no_union', False), argnames='use_a_union', id_='ia')\n@testing.combinations('from_statement', 'aliased', 'direct', argnames='fetch_entity_type')\ndef test_select_from_insert_cte(self, wrap_cte_in_aliased, use_a_union, fetch_entity_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'test the use case from #8544; SELECT that selects from a\\n        CTE INSERT...RETURNING.\\n\\n        '\n    User = self.classes.User\n    id_ = uuid.uuid4()\n    cte = insert(User).values(id=id_, username='some user').returning(User).cte()\n    if wrap_cte_in_aliased:\n        cte = aliased(User, cte)\n    if use_a_union:\n        stmt = select(User).where(User.id == id_).union(select(cte))\n    else:\n        stmt = select(cte)\n    if fetch_entity_type == 'from_statement':\n        outer_stmt = select(User).from_statement(stmt)\n        expect_entity = True\n    elif fetch_entity_type == 'aliased':\n        outer_stmt = select(aliased(User, stmt.subquery()))\n        expect_entity = True\n    elif fetch_entity_type == 'direct':\n        outer_stmt = stmt\n        expect_entity = not use_a_union and wrap_cte_in_aliased\n    else:\n        assert False\n    sess = fixture_session(bind=self.bind)\n    with self.sql_execution_asserter() as asserter:\n        if not expect_entity:\n            row = sess.execute(outer_stmt).one()\n            eq_(row, (id_, 'some user'))\n        else:\n            new_user = sess.scalars(outer_stmt).one()\n            eq_(new_user, User(id=id_, username='some user'))\n    cte_sql = '(INSERT INTO users (id, username) VALUES (:param_1, :param_2) RETURNING users.id, users.username)'\n    if fetch_entity_type == 'aliased' and (not use_a_union):\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    elif not use_a_union:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM anon_1'\n    elif fetch_entity_type == 'aliased':\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT users.id AS id, users.username AS username FROM users WHERE users.id = :id_1 UNION SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    else:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT users.id, users.username FROM users WHERE users.id = :id_1 UNION SELECT anon_1.id, anon_1.username FROM anon_1'\n    asserter.assert_(CompiledSQL(expected, [{'param_1': id_, 'param_2': 'some user'}]))",
            "@testing.combinations(('cte_aliased', True), ('cte', False), argnames='wrap_cte_in_aliased', id_='ia')\n@testing.combinations(('use_union', True), ('no_union', False), argnames='use_a_union', id_='ia')\n@testing.combinations('from_statement', 'aliased', 'direct', argnames='fetch_entity_type')\ndef test_select_from_insert_cte(self, wrap_cte_in_aliased, use_a_union, fetch_entity_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'test the use case from #8544; SELECT that selects from a\\n        CTE INSERT...RETURNING.\\n\\n        '\n    User = self.classes.User\n    id_ = uuid.uuid4()\n    cte = insert(User).values(id=id_, username='some user').returning(User).cte()\n    if wrap_cte_in_aliased:\n        cte = aliased(User, cte)\n    if use_a_union:\n        stmt = select(User).where(User.id == id_).union(select(cte))\n    else:\n        stmt = select(cte)\n    if fetch_entity_type == 'from_statement':\n        outer_stmt = select(User).from_statement(stmt)\n        expect_entity = True\n    elif fetch_entity_type == 'aliased':\n        outer_stmt = select(aliased(User, stmt.subquery()))\n        expect_entity = True\n    elif fetch_entity_type == 'direct':\n        outer_stmt = stmt\n        expect_entity = not use_a_union and wrap_cte_in_aliased\n    else:\n        assert False\n    sess = fixture_session(bind=self.bind)\n    with self.sql_execution_asserter() as asserter:\n        if not expect_entity:\n            row = sess.execute(outer_stmt).one()\n            eq_(row, (id_, 'some user'))\n        else:\n            new_user = sess.scalars(outer_stmt).one()\n            eq_(new_user, User(id=id_, username='some user'))\n    cte_sql = '(INSERT INTO users (id, username) VALUES (:param_1, :param_2) RETURNING users.id, users.username)'\n    if fetch_entity_type == 'aliased' and (not use_a_union):\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    elif not use_a_union:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM anon_1'\n    elif fetch_entity_type == 'aliased':\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT users.id AS id, users.username AS username FROM users WHERE users.id = :id_1 UNION SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    else:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT users.id, users.username FROM users WHERE users.id = :id_1 UNION SELECT anon_1.id, anon_1.username FROM anon_1'\n    asserter.assert_(CompiledSQL(expected, [{'param_1': id_, 'param_2': 'some user'}]))",
            "@testing.combinations(('cte_aliased', True), ('cte', False), argnames='wrap_cte_in_aliased', id_='ia')\n@testing.combinations(('use_union', True), ('no_union', False), argnames='use_a_union', id_='ia')\n@testing.combinations('from_statement', 'aliased', 'direct', argnames='fetch_entity_type')\ndef test_select_from_insert_cte(self, wrap_cte_in_aliased, use_a_union, fetch_entity_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'test the use case from #8544; SELECT that selects from a\\n        CTE INSERT...RETURNING.\\n\\n        '\n    User = self.classes.User\n    id_ = uuid.uuid4()\n    cte = insert(User).values(id=id_, username='some user').returning(User).cte()\n    if wrap_cte_in_aliased:\n        cte = aliased(User, cte)\n    if use_a_union:\n        stmt = select(User).where(User.id == id_).union(select(cte))\n    else:\n        stmt = select(cte)\n    if fetch_entity_type == 'from_statement':\n        outer_stmt = select(User).from_statement(stmt)\n        expect_entity = True\n    elif fetch_entity_type == 'aliased':\n        outer_stmt = select(aliased(User, stmt.subquery()))\n        expect_entity = True\n    elif fetch_entity_type == 'direct':\n        outer_stmt = stmt\n        expect_entity = not use_a_union and wrap_cte_in_aliased\n    else:\n        assert False\n    sess = fixture_session(bind=self.bind)\n    with self.sql_execution_asserter() as asserter:\n        if not expect_entity:\n            row = sess.execute(outer_stmt).one()\n            eq_(row, (id_, 'some user'))\n        else:\n            new_user = sess.scalars(outer_stmt).one()\n            eq_(new_user, User(id=id_, username='some user'))\n    cte_sql = '(INSERT INTO users (id, username) VALUES (:param_1, :param_2) RETURNING users.id, users.username)'\n    if fetch_entity_type == 'aliased' and (not use_a_union):\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    elif not use_a_union:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM anon_1'\n    elif fetch_entity_type == 'aliased':\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT users.id AS id, users.username AS username FROM users WHERE users.id = :id_1 UNION SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    else:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT users.id, users.username FROM users WHERE users.id = :id_1 UNION SELECT anon_1.id, anon_1.username FROM anon_1'\n    asserter.assert_(CompiledSQL(expected, [{'param_1': id_, 'param_2': 'some user'}]))",
            "@testing.combinations(('cte_aliased', True), ('cte', False), argnames='wrap_cte_in_aliased', id_='ia')\n@testing.combinations(('use_union', True), ('no_union', False), argnames='use_a_union', id_='ia')\n@testing.combinations('from_statement', 'aliased', 'direct', argnames='fetch_entity_type')\ndef test_select_from_insert_cte(self, wrap_cte_in_aliased, use_a_union, fetch_entity_type):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'test the use case from #8544; SELECT that selects from a\\n        CTE INSERT...RETURNING.\\n\\n        '\n    User = self.classes.User\n    id_ = uuid.uuid4()\n    cte = insert(User).values(id=id_, username='some user').returning(User).cte()\n    if wrap_cte_in_aliased:\n        cte = aliased(User, cte)\n    if use_a_union:\n        stmt = select(User).where(User.id == id_).union(select(cte))\n    else:\n        stmt = select(cte)\n    if fetch_entity_type == 'from_statement':\n        outer_stmt = select(User).from_statement(stmt)\n        expect_entity = True\n    elif fetch_entity_type == 'aliased':\n        outer_stmt = select(aliased(User, stmt.subquery()))\n        expect_entity = True\n    elif fetch_entity_type == 'direct':\n        outer_stmt = stmt\n        expect_entity = not use_a_union and wrap_cte_in_aliased\n    else:\n        assert False\n    sess = fixture_session(bind=self.bind)\n    with self.sql_execution_asserter() as asserter:\n        if not expect_entity:\n            row = sess.execute(outer_stmt).one()\n            eq_(row, (id_, 'some user'))\n        else:\n            new_user = sess.scalars(outer_stmt).one()\n            eq_(new_user, User(id=id_, username='some user'))\n    cte_sql = '(INSERT INTO users (id, username) VALUES (:param_1, :param_2) RETURNING users.id, users.username)'\n    if fetch_entity_type == 'aliased' and (not use_a_union):\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    elif not use_a_union:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM anon_1'\n    elif fetch_entity_type == 'aliased':\n        expected = f'WITH anon_2 AS {cte_sql} SELECT anon_1.id, anon_1.username FROM (SELECT users.id AS id, users.username AS username FROM users WHERE users.id = :id_1 UNION SELECT anon_2.id AS id, anon_2.username AS username FROM anon_2) AS anon_1'\n    else:\n        expected = f'WITH anon_1 AS {cte_sql} SELECT users.id, users.username FROM users WHERE users.id = :id_1 UNION SELECT anon_1.id, anon_1.username FROM anon_1'\n    asserter.assert_(CompiledSQL(expected, [{'param_1': id_, 'param_2': 'some user'}]))"
        ]
    }
]