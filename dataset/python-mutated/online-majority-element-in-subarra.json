[
    {
        "func_name": "__init__",
        "original": "def __init__(self, arr):\n    \"\"\"\n        :type arr: List[int]\n        \"\"\"\n    (Q, ERROR_RATE) = (10000, 0.001)\n    self.__K = int(Q / ERROR_RATE).bit_length()\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)",
        "mutated": [
            "def __init__(self, arr):\n    if False:\n        i = 10\n    '\\n        :type arr: List[int]\\n        '\n    (Q, ERROR_RATE) = (10000, 0.001)\n    self.__K = int(Q / ERROR_RATE).bit_length()\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type arr: List[int]\\n        '\n    (Q, ERROR_RATE) = (10000, 0.001)\n    self.__K = int(Q / ERROR_RATE).bit_length()\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type arr: List[int]\\n        '\n    (Q, ERROR_RATE) = (10000, 0.001)\n    self.__K = int(Q / ERROR_RATE).bit_length()\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type arr: List[int]\\n        '\n    (Q, ERROR_RATE) = (10000, 0.001)\n    self.__K = int(Q / ERROR_RATE).bit_length()\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type arr: List[int]\\n        '\n    (Q, ERROR_RATE) = (10000, 0.001)\n    self.__K = int(Q / ERROR_RATE).bit_length()\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)"
        ]
    },
    {
        "func_name": "count",
        "original": "def count(inv_idx, m, left, right):\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
        "mutated": [
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)"
        ]
    },
    {
        "func_name": "query",
        "original": "def query(self, left, right, threshold):\n    \"\"\"\n        :type left: int\n        :type right: int\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    for _ in xrange(self.__K):\n        m = self.__arr[random.randint(left, right)]\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    return -1",
        "mutated": [
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    for _ in xrange(self.__K):\n        m = self.__arr[random.randint(left, right)]\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    for _ in xrange(self.__K):\n        m = self.__arr[random.randint(left, right)]\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    for _ in xrange(self.__K):\n        m = self.__arr[random.randint(left, right)]\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    for _ in xrange(self.__K):\n        m = self.__arr[random.randint(left, right)]\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    for _ in xrange(self.__K):\n        m = self.__arr[random.randint(left, right)]\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    return -1"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, arr):\n    \"\"\"\n        :type arr: List[int]\n        \"\"\"\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bound = int(round(len(arr) ** 0.5))\n    self.__majorities = [i for (i, group) in self.__inv_idx.iteritems() if len(group) >= self.__bound]",
        "mutated": [
            "def __init__(self, arr):\n    if False:\n        i = 10\n    '\\n        :type arr: List[int]\\n        '\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bound = int(round(len(arr) ** 0.5))\n    self.__majorities = [i for (i, group) in self.__inv_idx.iteritems() if len(group) >= self.__bound]",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type arr: List[int]\\n        '\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bound = int(round(len(arr) ** 0.5))\n    self.__majorities = [i for (i, group) in self.__inv_idx.iteritems() if len(group) >= self.__bound]",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type arr: List[int]\\n        '\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bound = int(round(len(arr) ** 0.5))\n    self.__majorities = [i for (i, group) in self.__inv_idx.iteritems() if len(group) >= self.__bound]",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type arr: List[int]\\n        '\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bound = int(round(len(arr) ** 0.5))\n    self.__majorities = [i for (i, group) in self.__inv_idx.iteritems() if len(group) >= self.__bound]",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type arr: List[int]\\n        '\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bound = int(round(len(arr) ** 0.5))\n    self.__majorities = [i for (i, group) in self.__inv_idx.iteritems() if len(group) >= self.__bound]"
        ]
    },
    {
        "func_name": "count",
        "original": "def count(inv_idx, m, left, right):\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
        "mutated": [
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)"
        ]
    },
    {
        "func_name": "boyer_moore_majority_vote",
        "original": "def boyer_moore_majority_vote(nums, left, right):\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m",
        "mutated": [
            "def boyer_moore_majority_vote(nums, left, right):\n    if False:\n        i = 10\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m",
            "def boyer_moore_majority_vote(nums, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m",
            "def boyer_moore_majority_vote(nums, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m",
            "def boyer_moore_majority_vote(nums, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m",
            "def boyer_moore_majority_vote(nums, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m"
        ]
    },
    {
        "func_name": "query",
        "original": "def query(self, left, right, threshold):\n    \"\"\"\n        :type left: int\n        :type right: int\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n\n    def boyer_moore_majority_vote(nums, left, right):\n        (m, cnt) = (nums[left], 1)\n        for i in xrange(left + 1, right + 1):\n            if m == nums[i]:\n                cnt += 1\n            else:\n                cnt -= 1\n                if cnt == 0:\n                    m = nums[i]\n                    cnt = 1\n        return m\n    if right - left + 1 < self.__bound:\n        m = boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    else:\n        for m in self.__majorities:\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m\n    return -1",
        "mutated": [
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n\n    def boyer_moore_majority_vote(nums, left, right):\n        (m, cnt) = (nums[left], 1)\n        for i in xrange(left + 1, right + 1):\n            if m == nums[i]:\n                cnt += 1\n            else:\n                cnt -= 1\n                if cnt == 0:\n                    m = nums[i]\n                    cnt = 1\n        return m\n    if right - left + 1 < self.__bound:\n        m = boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    else:\n        for m in self.__majorities:\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n\n    def boyer_moore_majority_vote(nums, left, right):\n        (m, cnt) = (nums[left], 1)\n        for i in xrange(left + 1, right + 1):\n            if m == nums[i]:\n                cnt += 1\n            else:\n                cnt -= 1\n                if cnt == 0:\n                    m = nums[i]\n                    cnt = 1\n        return m\n    if right - left + 1 < self.__bound:\n        m = boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    else:\n        for m in self.__majorities:\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n\n    def boyer_moore_majority_vote(nums, left, right):\n        (m, cnt) = (nums[left], 1)\n        for i in xrange(left + 1, right + 1):\n            if m == nums[i]:\n                cnt += 1\n            else:\n                cnt -= 1\n                if cnt == 0:\n                    m = nums[i]\n                    cnt = 1\n        return m\n    if right - left + 1 < self.__bound:\n        m = boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    else:\n        for m in self.__majorities:\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n\n    def boyer_moore_majority_vote(nums, left, right):\n        (m, cnt) = (nums[left], 1)\n        for i in xrange(left + 1, right + 1):\n            if m == nums[i]:\n                cnt += 1\n            else:\n                cnt -= 1\n                if cnt == 0:\n                    m = nums[i]\n                    cnt = 1\n        return m\n    if right - left + 1 < self.__bound:\n        m = boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    else:\n        for m in self.__majorities:\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n\n    def boyer_moore_majority_vote(nums, left, right):\n        (m, cnt) = (nums[left], 1)\n        for i in xrange(left + 1, right + 1):\n            if m == nums[i]:\n                cnt += 1\n            else:\n                cnt -= 1\n                if cnt == 0:\n                    m = nums[i]\n                    cnt = 1\n        return m\n    if right - left + 1 < self.__bound:\n        m = boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n    else:\n        for m in self.__majorities:\n            if count(self.__inv_idx, m, left, right) >= threshold:\n                return m\n    return -1"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, nums, count):\n    \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n    N = len(nums)\n    self.__original_length = N\n    self.__tree_length = 2 ** (N.bit_length() + (N & N - 1 != 0)) - 1\n    self.__tree = [-1 for _ in range(self.__tree_length)]\n    self.__count = count\n    self.__constructTree(nums, 0, self.__original_length - 1, 0)",
        "mutated": [
            "def __init__(self, nums, count):\n    if False:\n        i = 10\n    '\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        '\n    N = len(nums)\n    self.__original_length = N\n    self.__tree_length = 2 ** (N.bit_length() + (N & N - 1 != 0)) - 1\n    self.__tree = [-1 for _ in range(self.__tree_length)]\n    self.__count = count\n    self.__constructTree(nums, 0, self.__original_length - 1, 0)",
            "def __init__(self, nums, count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        '\n    N = len(nums)\n    self.__original_length = N\n    self.__tree_length = 2 ** (N.bit_length() + (N & N - 1 != 0)) - 1\n    self.__tree = [-1 for _ in range(self.__tree_length)]\n    self.__count = count\n    self.__constructTree(nums, 0, self.__original_length - 1, 0)",
            "def __init__(self, nums, count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        '\n    N = len(nums)\n    self.__original_length = N\n    self.__tree_length = 2 ** (N.bit_length() + (N & N - 1 != 0)) - 1\n    self.__tree = [-1 for _ in range(self.__tree_length)]\n    self.__count = count\n    self.__constructTree(nums, 0, self.__original_length - 1, 0)",
            "def __init__(self, nums, count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        '\n    N = len(nums)\n    self.__original_length = N\n    self.__tree_length = 2 ** (N.bit_length() + (N & N - 1 != 0)) - 1\n    self.__tree = [-1 for _ in range(self.__tree_length)]\n    self.__count = count\n    self.__constructTree(nums, 0, self.__original_length - 1, 0)",
            "def __init__(self, nums, count):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        '\n    N = len(nums)\n    self.__original_length = N\n    self.__tree_length = 2 ** (N.bit_length() + (N & N - 1 != 0)) - 1\n    self.__tree = [-1 for _ in range(self.__tree_length)]\n    self.__count = count\n    self.__constructTree(nums, 0, self.__original_length - 1, 0)"
        ]
    },
    {
        "func_name": "query",
        "original": "def query(self, i, j):\n    return self.__queryRange(i, j, 0, self.__original_length - 1, 0)",
        "mutated": [
            "def query(self, i, j):\n    if False:\n        i = 10\n    return self.__queryRange(i, j, 0, self.__original_length - 1, 0)",
            "def query(self, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return self.__queryRange(i, j, 0, self.__original_length - 1, 0)",
            "def query(self, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return self.__queryRange(i, j, 0, self.__original_length - 1, 0)",
            "def query(self, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return self.__queryRange(i, j, 0, self.__original_length - 1, 0)",
            "def query(self, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return self.__queryRange(i, j, 0, self.__original_length - 1, 0)"
        ]
    },
    {
        "func_name": "__constructTree",
        "original": "def __constructTree(self, nums, left, right, idx):\n    if left > right:\n        return\n    if left == right:\n        self.__tree[idx] = nums[left]\n        return\n    mid = left + (right - left) // 2\n    self.__constructTree(nums, left, mid, idx * 2 + 1)\n    self.__constructTree(nums, mid + 1, right, idx * 2 + 2)\n    if self.__tree[idx * 2 + 1] != -1 and self.__count(self.__tree[idx * 2 + 1], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 1]\n    elif self.__tree[idx * 2 + 2] != -1 and self.__count(self.__tree[idx * 2 + 2], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 2]",
        "mutated": [
            "def __constructTree(self, nums, left, right, idx):\n    if False:\n        i = 10\n    if left > right:\n        return\n    if left == right:\n        self.__tree[idx] = nums[left]\n        return\n    mid = left + (right - left) // 2\n    self.__constructTree(nums, left, mid, idx * 2 + 1)\n    self.__constructTree(nums, mid + 1, right, idx * 2 + 2)\n    if self.__tree[idx * 2 + 1] != -1 and self.__count(self.__tree[idx * 2 + 1], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 1]\n    elif self.__tree[idx * 2 + 2] != -1 and self.__count(self.__tree[idx * 2 + 2], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 2]",
            "def __constructTree(self, nums, left, right, idx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if left > right:\n        return\n    if left == right:\n        self.__tree[idx] = nums[left]\n        return\n    mid = left + (right - left) // 2\n    self.__constructTree(nums, left, mid, idx * 2 + 1)\n    self.__constructTree(nums, mid + 1, right, idx * 2 + 2)\n    if self.__tree[idx * 2 + 1] != -1 and self.__count(self.__tree[idx * 2 + 1], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 1]\n    elif self.__tree[idx * 2 + 2] != -1 and self.__count(self.__tree[idx * 2 + 2], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 2]",
            "def __constructTree(self, nums, left, right, idx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if left > right:\n        return\n    if left == right:\n        self.__tree[idx] = nums[left]\n        return\n    mid = left + (right - left) // 2\n    self.__constructTree(nums, left, mid, idx * 2 + 1)\n    self.__constructTree(nums, mid + 1, right, idx * 2 + 2)\n    if self.__tree[idx * 2 + 1] != -1 and self.__count(self.__tree[idx * 2 + 1], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 1]\n    elif self.__tree[idx * 2 + 2] != -1 and self.__count(self.__tree[idx * 2 + 2], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 2]",
            "def __constructTree(self, nums, left, right, idx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if left > right:\n        return\n    if left == right:\n        self.__tree[idx] = nums[left]\n        return\n    mid = left + (right - left) // 2\n    self.__constructTree(nums, left, mid, idx * 2 + 1)\n    self.__constructTree(nums, mid + 1, right, idx * 2 + 2)\n    if self.__tree[idx * 2 + 1] != -1 and self.__count(self.__tree[idx * 2 + 1], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 1]\n    elif self.__tree[idx * 2 + 2] != -1 and self.__count(self.__tree[idx * 2 + 2], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 2]",
            "def __constructTree(self, nums, left, right, idx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if left > right:\n        return\n    if left == right:\n        self.__tree[idx] = nums[left]\n        return\n    mid = left + (right - left) // 2\n    self.__constructTree(nums, left, mid, idx * 2 + 1)\n    self.__constructTree(nums, mid + 1, right, idx * 2 + 2)\n    if self.__tree[idx * 2 + 1] != -1 and self.__count(self.__tree[idx * 2 + 1], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 1]\n    elif self.__tree[idx * 2 + 2] != -1 and self.__count(self.__tree[idx * 2 + 2], left, right) * 2 > right - left + 1:\n        self.__tree[idx] = self.__tree[idx * 2 + 2]"
        ]
    },
    {
        "func_name": "__queryRange",
        "original": "def __queryRange(self, range_left, range_right, left, right, idx):\n    if left > right:\n        return (-1, -1)\n    if right < range_left or left > range_right:\n        return (-1, -1)\n    if range_left <= left and right <= range_right:\n        if self.__tree[idx] != -1:\n            c = self.__count(self.__tree[idx], range_left, range_right)\n            if c * 2 > range_right - range_left + 1:\n                return (self.__tree[idx], c)\n    else:\n        mid = left + (right - left) // 2\n        result = self.__queryRange(range_left, range_right, left, mid, idx * 2 + 1)\n        if result[0] != -1:\n            return result\n        result = self.__queryRange(range_left, range_right, mid + 1, right, idx * 2 + 2)\n        if result[0] != -1:\n            return result\n    return (-1, -1)",
        "mutated": [
            "def __queryRange(self, range_left, range_right, left, right, idx):\n    if False:\n        i = 10\n    if left > right:\n        return (-1, -1)\n    if right < range_left or left > range_right:\n        return (-1, -1)\n    if range_left <= left and right <= range_right:\n        if self.__tree[idx] != -1:\n            c = self.__count(self.__tree[idx], range_left, range_right)\n            if c * 2 > range_right - range_left + 1:\n                return (self.__tree[idx], c)\n    else:\n        mid = left + (right - left) // 2\n        result = self.__queryRange(range_left, range_right, left, mid, idx * 2 + 1)\n        if result[0] != -1:\n            return result\n        result = self.__queryRange(range_left, range_right, mid + 1, right, idx * 2 + 2)\n        if result[0] != -1:\n            return result\n    return (-1, -1)",
            "def __queryRange(self, range_left, range_right, left, right, idx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if left > right:\n        return (-1, -1)\n    if right < range_left or left > range_right:\n        return (-1, -1)\n    if range_left <= left and right <= range_right:\n        if self.__tree[idx] != -1:\n            c = self.__count(self.__tree[idx], range_left, range_right)\n            if c * 2 > range_right - range_left + 1:\n                return (self.__tree[idx], c)\n    else:\n        mid = left + (right - left) // 2\n        result = self.__queryRange(range_left, range_right, left, mid, idx * 2 + 1)\n        if result[0] != -1:\n            return result\n        result = self.__queryRange(range_left, range_right, mid + 1, right, idx * 2 + 2)\n        if result[0] != -1:\n            return result\n    return (-1, -1)",
            "def __queryRange(self, range_left, range_right, left, right, idx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if left > right:\n        return (-1, -1)\n    if right < range_left or left > range_right:\n        return (-1, -1)\n    if range_left <= left and right <= range_right:\n        if self.__tree[idx] != -1:\n            c = self.__count(self.__tree[idx], range_left, range_right)\n            if c * 2 > range_right - range_left + 1:\n                return (self.__tree[idx], c)\n    else:\n        mid = left + (right - left) // 2\n        result = self.__queryRange(range_left, range_right, left, mid, idx * 2 + 1)\n        if result[0] != -1:\n            return result\n        result = self.__queryRange(range_left, range_right, mid + 1, right, idx * 2 + 2)\n        if result[0] != -1:\n            return result\n    return (-1, -1)",
            "def __queryRange(self, range_left, range_right, left, right, idx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if left > right:\n        return (-1, -1)\n    if right < range_left or left > range_right:\n        return (-1, -1)\n    if range_left <= left and right <= range_right:\n        if self.__tree[idx] != -1:\n            c = self.__count(self.__tree[idx], range_left, range_right)\n            if c * 2 > range_right - range_left + 1:\n                return (self.__tree[idx], c)\n    else:\n        mid = left + (right - left) // 2\n        result = self.__queryRange(range_left, range_right, left, mid, idx * 2 + 1)\n        if result[0] != -1:\n            return result\n        result = self.__queryRange(range_left, range_right, mid + 1, right, idx * 2 + 2)\n        if result[0] != -1:\n            return result\n    return (-1, -1)",
            "def __queryRange(self, range_left, range_right, left, right, idx):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if left > right:\n        return (-1, -1)\n    if right < range_left or left > range_right:\n        return (-1, -1)\n    if range_left <= left and right <= range_right:\n        if self.__tree[idx] != -1:\n            c = self.__count(self.__tree[idx], range_left, range_right)\n            if c * 2 > range_right - range_left + 1:\n                return (self.__tree[idx], c)\n    else:\n        mid = left + (right - left) // 2\n        result = self.__queryRange(range_left, range_right, left, mid, idx * 2 + 1)\n        if result[0] != -1:\n            return result\n        result = self.__queryRange(range_left, range_right, mid + 1, right, idx * 2 + 2)\n        if result[0] != -1:\n            return result\n    return (-1, -1)"
        ]
    },
    {
        "func_name": "count",
        "original": "def count(inv_idx, m, left, right):\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
        "mutated": [
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, arr):\n    \"\"\"\n        :type arr: List[int]\n        \"\"\"\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__segment_tree = SegmentTreeRecu(arr, functools.partial(count, self.__inv_idx))",
        "mutated": [
            "def __init__(self, arr):\n    if False:\n        i = 10\n    '\\n        :type arr: List[int]\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__segment_tree = SegmentTreeRecu(arr, functools.partial(count, self.__inv_idx))",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type arr: List[int]\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__segment_tree = SegmentTreeRecu(arr, functools.partial(count, self.__inv_idx))",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type arr: List[int]\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__segment_tree = SegmentTreeRecu(arr, functools.partial(count, self.__inv_idx))",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type arr: List[int]\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__segment_tree = SegmentTreeRecu(arr, functools.partial(count, self.__inv_idx))",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type arr: List[int]\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__segment_tree = SegmentTreeRecu(arr, functools.partial(count, self.__inv_idx))"
        ]
    },
    {
        "func_name": "query",
        "original": "def query(self, left, right, threshold):\n    \"\"\"\n        :type left: int\n        :type right: int\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n    result = self.__segment_tree.query(left, right)\n    if result[1] >= threshold:\n        return result[0]\n    return -1",
        "mutated": [
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n    result = self.__segment_tree.query(left, right)\n    if result[1] >= threshold:\n        return result[0]\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n    result = self.__segment_tree.query(left, right)\n    if result[1] >= threshold:\n        return result[0]\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n    result = self.__segment_tree.query(left, right)\n    if result[1] >= threshold:\n        return result[0]\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n    result = self.__segment_tree.query(left, right)\n    if result[1] >= threshold:\n        return result[0]\n    return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n    result = self.__segment_tree.query(left, right)\n    if result[1] >= threshold:\n        return result[0]\n    return -1"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, arr):\n    \"\"\"\n        :type arr: List[int]\n        \"\"\"\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bucket_size = int(round(len(arr) ** 0.5))\n    self.__bucket_majorities = []\n    for left in xrange(0, len(self.__arr), self.__bucket_size):\n        right = min(left + self.__bucket_size - 1, len(self.__arr) - 1)\n        self.__bucket_majorities.append(self.__boyer_moore_majority_vote(self.__arr, left, right))",
        "mutated": [
            "def __init__(self, arr):\n    if False:\n        i = 10\n    '\\n        :type arr: List[int]\\n        '\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bucket_size = int(round(len(arr) ** 0.5))\n    self.__bucket_majorities = []\n    for left in xrange(0, len(self.__arr), self.__bucket_size):\n        right = min(left + self.__bucket_size - 1, len(self.__arr) - 1)\n        self.__bucket_majorities.append(self.__boyer_moore_majority_vote(self.__arr, left, right))",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type arr: List[int]\\n        '\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bucket_size = int(round(len(arr) ** 0.5))\n    self.__bucket_majorities = []\n    for left in xrange(0, len(self.__arr), self.__bucket_size):\n        right = min(left + self.__bucket_size - 1, len(self.__arr) - 1)\n        self.__bucket_majorities.append(self.__boyer_moore_majority_vote(self.__arr, left, right))",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type arr: List[int]\\n        '\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bucket_size = int(round(len(arr) ** 0.5))\n    self.__bucket_majorities = []\n    for left in xrange(0, len(self.__arr), self.__bucket_size):\n        right = min(left + self.__bucket_size - 1, len(self.__arr) - 1)\n        self.__bucket_majorities.append(self.__boyer_moore_majority_vote(self.__arr, left, right))",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type arr: List[int]\\n        '\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bucket_size = int(round(len(arr) ** 0.5))\n    self.__bucket_majorities = []\n    for left in xrange(0, len(self.__arr), self.__bucket_size):\n        right = min(left + self.__bucket_size - 1, len(self.__arr) - 1)\n        self.__bucket_majorities.append(self.__boyer_moore_majority_vote(self.__arr, left, right))",
            "def __init__(self, arr):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type arr: List[int]\\n        '\n    self.__arr = arr\n    self.__inv_idx = collections.defaultdict(list)\n    for (i, x) in enumerate(self.__arr):\n        self.__inv_idx[x].append(i)\n    self.__bucket_size = int(round(len(arr) ** 0.5))\n    self.__bucket_majorities = []\n    for left in xrange(0, len(self.__arr), self.__bucket_size):\n        right = min(left + self.__bucket_size - 1, len(self.__arr) - 1)\n        self.__bucket_majorities.append(self.__boyer_moore_majority_vote(self.__arr, left, right))"
        ]
    },
    {
        "func_name": "count",
        "original": "def count(inv_idx, m, left, right):\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
        "mutated": [
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)",
            "def count(inv_idx, m, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)"
        ]
    },
    {
        "func_name": "query",
        "original": "def query(self, left, right, threshold):\n    \"\"\"\n        :type left: int\n        :type right: int\n        :type threshold: int\n        :rtype: int\n        \"\"\"\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    (l, r) = (left // self.__bucket_size, right // self.__bucket_size)\n    if l == r:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        return -1\n    else:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, (l + 1) * self.__bucket_size - 1)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        m = self.__boyer_moore_majority_vote(self.__arr, r * self.__bucket_size, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        for i in xrange(l + 1, r):\n            if count(self.__inv_idx, self.__bucket_majorities[i], left, right) >= threshold:\n                return self.__bucket_majorities[i]\n        return -1",
        "mutated": [
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    (l, r) = (left // self.__bucket_size, right // self.__bucket_size)\n    if l == r:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        return -1\n    else:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, (l + 1) * self.__bucket_size - 1)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        m = self.__boyer_moore_majority_vote(self.__arr, r * self.__bucket_size, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        for i in xrange(l + 1, r):\n            if count(self.__inv_idx, self.__bucket_majorities[i], left, right) >= threshold:\n                return self.__bucket_majorities[i]\n        return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    (l, r) = (left // self.__bucket_size, right // self.__bucket_size)\n    if l == r:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        return -1\n    else:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, (l + 1) * self.__bucket_size - 1)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        m = self.__boyer_moore_majority_vote(self.__arr, r * self.__bucket_size, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        for i in xrange(l + 1, r):\n            if count(self.__inv_idx, self.__bucket_majorities[i], left, right) >= threshold:\n                return self.__bucket_majorities[i]\n        return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    (l, r) = (left // self.__bucket_size, right // self.__bucket_size)\n    if l == r:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        return -1\n    else:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, (l + 1) * self.__bucket_size - 1)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        m = self.__boyer_moore_majority_vote(self.__arr, r * self.__bucket_size, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        for i in xrange(l + 1, r):\n            if count(self.__inv_idx, self.__bucket_majorities[i], left, right) >= threshold:\n                return self.__bucket_majorities[i]\n        return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    (l, r) = (left // self.__bucket_size, right // self.__bucket_size)\n    if l == r:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        return -1\n    else:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, (l + 1) * self.__bucket_size - 1)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        m = self.__boyer_moore_majority_vote(self.__arr, r * self.__bucket_size, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        for i in xrange(l + 1, r):\n            if count(self.__inv_idx, self.__bucket_majorities[i], left, right) >= threshold:\n                return self.__bucket_majorities[i]\n        return -1",
            "def query(self, left, right, threshold):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        :type left: int\\n        :type right: int\\n        :type threshold: int\\n        :rtype: int\\n        '\n\n    def count(inv_idx, m, left, right):\n        return bisect.bisect_right(inv_idx[m], right) - bisect.bisect_left(inv_idx[m], left)\n    (l, r) = (left // self.__bucket_size, right // self.__bucket_size)\n    if l == r:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        return -1\n    else:\n        m = self.__boyer_moore_majority_vote(self.__arr, left, (l + 1) * self.__bucket_size - 1)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        m = self.__boyer_moore_majority_vote(self.__arr, r * self.__bucket_size, right)\n        if count(self.__inv_idx, m, left, right) >= threshold:\n            return m\n        for i in xrange(l + 1, r):\n            if count(self.__inv_idx, self.__bucket_majorities[i], left, right) >= threshold:\n                return self.__bucket_majorities[i]\n        return -1"
        ]
    },
    {
        "func_name": "__boyer_moore_majority_vote",
        "original": "def __boyer_moore_majority_vote(self, nums, left, right):\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m",
        "mutated": [
            "def __boyer_moore_majority_vote(self, nums, left, right):\n    if False:\n        i = 10\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m",
            "def __boyer_moore_majority_vote(self, nums, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m",
            "def __boyer_moore_majority_vote(self, nums, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m",
            "def __boyer_moore_majority_vote(self, nums, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m",
            "def __boyer_moore_majority_vote(self, nums, left, right):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (m, cnt) = (nums[left], 1)\n    for i in xrange(left + 1, right + 1):\n        if m == nums[i]:\n            cnt += 1\n        else:\n            cnt -= 1\n            if cnt == 0:\n                m = nums[i]\n                cnt = 1\n    return m"
        ]
    }
]