[
    {
        "func_name": "zgrap_parser_http",
        "original": "def zgrap_parser_http(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    \"\"\"This function handles data from `{\"data\": {\"http\": [...]}}`\n    records. `data` should be the content, i.e. the `[...]`. It should\n    consist of simple dictionary, that may contain a `\"response\"` key\n    and/or a `\"redirect_response_chain\"` key.\n\n    The output is a port dict (i.e., the content of the \"ports\" key of an\n    `nmap` of `view` record in IVRE), that may be empty.\n\n    \"\"\"\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if 'response' not in data:\n        utils.LOGGER.warning('Missing \"response\" field in zgrab HTTP result')\n        return {}\n    resp = data['response']\n    needed_fields = set(['request', 'status_code', 'status_line'])\n    missing_fields = needed_fields.difference(resp)\n    if missing_fields:\n        utils.LOGGER.warning('Missing field%s %s in zgrab HTTP result', 's' if len(missing_fields) > 1 else '', ', '.join((repr(fld) for fld in missing_fields)))\n        return {}\n    req = resp['request']\n    url = req.get('url')\n    res: NmapPort = {'service_name': 'http', 'service_method': 'probed', 'state_state': 'open', 'state_reason': 'response', 'protocol': 'tcp'}\n    tls = None\n    try:\n        tls = req['tls_handshake']\n    except KeyError:\n        try:\n            tls = req['tls_log']['handshake_log']\n        except KeyError:\n            pass\n    if tls is not None:\n        res['service_tunnel'] = 'ssl'\n        try:\n            cert = tls['server_certificates']['certificate']['raw']\n        except KeyError:\n            pass\n        else:\n            (output, info_cert) = create_ssl_cert(cert.encode(), b64encoded=True)\n            if info_cert:\n                res.setdefault('scripts', []).append({'id': 'ssl-cert', 'output': output, 'ssl-cert': info_cert})\n                for cert in info_cert:\n                    add_cert_hostnames(cert, hostrec.setdefault('hostnames', []))\n    if url:\n        try:\n            (_, guessed_port) = utils.url2hostport('%(scheme)s://%(host)s' % url)\n        except ValueError:\n            utils.LOGGER.warning('Cannot guess port from url %r', url)\n            guessed_port = 80\n        else:\n            if port is not None and port != guessed_port:\n                utils.LOGGER.warning('Port %d found from the URL %s differs from the provided port value %d', guessed_port, url.get('path'), port)\n                port = guessed_port\n        if port is None:\n            port = guessed_port\n        if url.get('path', '').endswith('/.git/index'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body', '').startswith('DIRC'):\n                return {}\n            repository = '%s:%d%s' % (hostrec['addr'], port, url['path'][:-5])\n            res['port'] = port\n            res.setdefault('scripts', []).append({'id': 'http-git', 'output': '\\n  %s\\n    Git repository found!\\n' % repository, 'http-git': [{'repository': repository, 'files-found': ['.git/index']}]})\n            return res\n        if url.get('path', '').endswith('/owa/auth/logon.aspx'):\n            if resp.get('status_code') != 200:\n                return {}\n            version_set = set((m.group(1) for m in _EXPR_OWA_VERSION.finditer(resp.get('body', ''))))\n            if not version_set:\n                return {}\n            version_list = sorted(version_set, key=lambda v: [int(x) for x in v.split('.')])\n            res['port'] = port\n            path = url['path'][:-15]\n            if version_list:\n                parsed_version = EXCHANGE_BUILDS.get(version_list[0], 'unknown build number')\n                if len(version_list) > 1:\n                    version_list = ['%s (%s)' % (vers, EXCHANGE_BUILDS.get(vers, 'unknown build number')) for vers in version_list]\n                    output = 'OWA: path %s, version %s (multiple versions found!)' % (path, ' / '.join(version_list))\n                else:\n                    output = 'OWA: path %s, version %s (%s)' % (path, version_list[0], parsed_version)\n                res.setdefault('scripts', []).append({'id': 'http-app', 'output': output, 'http-app': [{'path': path, 'application': 'OWA', 'version': version_list[0], 'parsed_version': parsed_version}]})\n            return res\n        if url.get('path', '').endswith('/centreon/'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            path = url['path']\n            match = _EXPR_TITLE.search(body)\n            if match is None:\n                return {}\n            if match.groups()[0] != 'Centreon - IT & Network Monitoring':\n                return {}\n            match = _EXPR_CENTREON_VERSION.search(body)\n            version: Optional[str]\n            if match is None:\n                version = None\n            else:\n                version = match.group(1) or match.group(2)\n            res.setdefault('scripts', []).append({'id': 'http-app', 'output': 'Centreon: path %s%s' % (path, '' if version is None else ', version %s' % version), 'http-app': [{'path': path, 'application': 'Centreon', **({} if version is None else {'version': version})}]})\n            return res\n        if url.get('path', '').endswith('/.well-known/security.txt'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('headers'):\n                return {}\n            if not any((ctype.split(';', 1)[0].lower() == 'text/plain' for ctype in resp['headers'].get('content_type', []))):\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            parsed: Dict[str, List[str]] = {}\n            for line in body.splitlines():\n                line = line.strip().split('#', 1)[0]\n                if not line:\n                    continue\n                if ':' not in line:\n                    utils.LOGGER.warning('Invalid line in security.txt file [%r]', line)\n                    continue\n                (key, value) = line.split(':', 1)\n                parsed.setdefault(key.strip().lower(), []).append(value.strip())\n            res.setdefault('scripts', []).append({'id': 'http-securitytxt', 'output': body, 'http-securitytxt': {key: ' / '.join(value) for (key, value) in parsed.items()}})\n            return res\n        if url.get('path', '') != '/':\n            utils.LOGGER.warning('URL path not supported yet: %s', url.get('path'))\n            return {}\n    elif port is None:\n        if req.get('tls_handshake') or req.get('tls_log'):\n            port = 443\n        else:\n            port = 80\n    res['port'] = port\n    banner = None\n    if resp.get('headers'):\n        headers = resp['headers']\n        if headers.get('www_authenticate'):\n            auths = headers.get('www_authenticate')\n            for auth in auths:\n                if ntlm._is_ntlm_message(auth):\n                    try:\n                        infos = ntlm.ntlm_extract_info(utils.decode_b64(auth.split(None, 1)[1].encode()))\n                    except (UnicodeDecodeError, TypeError, ValueError, binascii.Error):\n                        continue\n                    if not infos:\n                        continue\n                    keyvals = zip(ntlm_values, [infos.get(k) for k in ntlm_values])\n                    output = '\\n'.join(('{}: {}'.format(k, v) for (k, v) in keyvals if v))\n                    res.setdefault('scripts', []).append({'id': 'ntlm-info', 'output': output, 'ntlm-info': dict(infos, protocol='http')})\n                    if 'DNS_Computer_Name' in infos:\n                        add_hostname(infos['DNS_Computer_Name'], 'ntlm', hostrec.setdefault('hostnames', []))\n        if any((val.lower().startswith('ntlm') for val in req.get('headers', {}).get('authorization', []))):\n            return res\n        http_hdrs: List[HttpHeader] = []\n        output_list: List[str] = []\n        has_raw_value = False\n        if resp.get('headers_raw'):\n            try:\n                banner = utils.decode_b64(resp.get('headers_raw').encode())\n            except Exception:\n                utils.LOGGER.warning('Cannot decode raw headers, using parsed result')\n            else:\n                output_list = [utils.nmap_encode_data(line) for line in re.split(b'\\r?\\n', banner)]\n                banner_split = banner.split(b'\\n')\n                http_hdrs = [{'name': '_status', 'value': utils.nmap_encode_data(banner_split[0].strip())}]\n                http_hdrs.extend(({'name': utils.nmap_encode_data(hdrname).lower(), 'value': utils.nmap_encode_data(hdrval)} for (hdrname, hdrval) in (m.groups() for m in (utils.RAW_HTTP_HEADER.search(part.strip()) for part in banner_split) if m)))\n                has_raw_value = True\n        if not has_raw_value:\n            banner = utils.nmap_decode_data(resp['protocol']['name']) + b' ' + utils.nmap_decode_data(resp['status_line']) + b'\\r\\n'\n            line = '%s %s' % (resp['protocol']['name'], resp['status_line'])\n            http_hdrs = [{'name': '_status', 'value': line}]\n            output_list = [line]\n            for unk in headers.pop('unknown', []):\n                headers[unk['key']] = unk['value']\n            for (hdr, values) in headers.items():\n                hdr = hdr.replace('_', '-')\n                for val in values:\n                    http_hdrs.append({'name': hdr, 'value': val})\n                    output_list.append('%s: %s' % (hdr, val))\n            if headers.get('server'):\n                banner += b'Server: ' + utils.nmap_decode_data(headers['server'][0]) + b'\\r\\n\\r\\n'\n        if http_hdrs:\n            method = req.get('method')\n            if method:\n                output_list.append('')\n                output_list.append('(Request type: %s)' % method)\n            script: NmapScript = {'id': 'http-headers', 'output': '\\n'.join(output_list), 'http-headers': http_hdrs}\n            if has_raw_value and banner is not None:\n                script['masscan'] = {'raw': utils.encode_b64(banner).decode()}\n            res.setdefault('scripts', []).append(script)\n            handle_http_headers(hostrec, res, http_hdrs, path=url.get('path'))\n    info: NmapServiceMatch = {} if banner is None else utils.match_nmap_svc_fp(banner, proto='tcp', probe='GetRequest')\n    if info:\n        add_cpe_values(hostrec, 'ports.port:%s' % port, info.pop('cpe', []))\n        res.update(cast(NmapPort, info))\n        add_service_hostname(info, hostrec.setdefault('hostnames', []))\n    if resp.get('body'):\n        body = resp['body']\n        res.setdefault('scripts', []).append({'id': 'http-content', 'output': utils.nmap_encode_data(body.encode())})\n        handle_http_content(hostrec, res, body.encode())\n    return res",
        "mutated": [
            "def zgrap_parser_http(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    if False:\n        i = 10\n    'This function handles data from `{\"data\": {\"http\": [...]}}`\\n    records. `data` should be the content, i.e. the `[...]`. It should\\n    consist of simple dictionary, that may contain a `\"response\"` key\\n    and/or a `\"redirect_response_chain\"` key.\\n\\n    The output is a port dict (i.e., the content of the \"ports\" key of an\\n    `nmap` of `view` record in IVRE), that may be empty.\\n\\n    '\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if 'response' not in data:\n        utils.LOGGER.warning('Missing \"response\" field in zgrab HTTP result')\n        return {}\n    resp = data['response']\n    needed_fields = set(['request', 'status_code', 'status_line'])\n    missing_fields = needed_fields.difference(resp)\n    if missing_fields:\n        utils.LOGGER.warning('Missing field%s %s in zgrab HTTP result', 's' if len(missing_fields) > 1 else '', ', '.join((repr(fld) for fld in missing_fields)))\n        return {}\n    req = resp['request']\n    url = req.get('url')\n    res: NmapPort = {'service_name': 'http', 'service_method': 'probed', 'state_state': 'open', 'state_reason': 'response', 'protocol': 'tcp'}\n    tls = None\n    try:\n        tls = req['tls_handshake']\n    except KeyError:\n        try:\n            tls = req['tls_log']['handshake_log']\n        except KeyError:\n            pass\n    if tls is not None:\n        res['service_tunnel'] = 'ssl'\n        try:\n            cert = tls['server_certificates']['certificate']['raw']\n        except KeyError:\n            pass\n        else:\n            (output, info_cert) = create_ssl_cert(cert.encode(), b64encoded=True)\n            if info_cert:\n                res.setdefault('scripts', []).append({'id': 'ssl-cert', 'output': output, 'ssl-cert': info_cert})\n                for cert in info_cert:\n                    add_cert_hostnames(cert, hostrec.setdefault('hostnames', []))\n    if url:\n        try:\n            (_, guessed_port) = utils.url2hostport('%(scheme)s://%(host)s' % url)\n        except ValueError:\n            utils.LOGGER.warning('Cannot guess port from url %r', url)\n            guessed_port = 80\n        else:\n            if port is not None and port != guessed_port:\n                utils.LOGGER.warning('Port %d found from the URL %s differs from the provided port value %d', guessed_port, url.get('path'), port)\n                port = guessed_port\n        if port is None:\n            port = guessed_port\n        if url.get('path', '').endswith('/.git/index'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body', '').startswith('DIRC'):\n                return {}\n            repository = '%s:%d%s' % (hostrec['addr'], port, url['path'][:-5])\n            res['port'] = port\n            res.setdefault('scripts', []).append({'id': 'http-git', 'output': '\\n  %s\\n    Git repository found!\\n' % repository, 'http-git': [{'repository': repository, 'files-found': ['.git/index']}]})\n            return res\n        if url.get('path', '').endswith('/owa/auth/logon.aspx'):\n            if resp.get('status_code') != 200:\n                return {}\n            version_set = set((m.group(1) for m in _EXPR_OWA_VERSION.finditer(resp.get('body', ''))))\n            if not version_set:\n                return {}\n            version_list = sorted(version_set, key=lambda v: [int(x) for x in v.split('.')])\n            res['port'] = port\n            path = url['path'][:-15]\n            if version_list:\n                parsed_version = EXCHANGE_BUILDS.get(version_list[0], 'unknown build number')\n                if len(version_list) > 1:\n                    version_list = ['%s (%s)' % (vers, EXCHANGE_BUILDS.get(vers, 'unknown build number')) for vers in version_list]\n                    output = 'OWA: path %s, version %s (multiple versions found!)' % (path, ' / '.join(version_list))\n                else:\n                    output = 'OWA: path %s, version %s (%s)' % (path, version_list[0], parsed_version)\n                res.setdefault('scripts', []).append({'id': 'http-app', 'output': output, 'http-app': [{'path': path, 'application': 'OWA', 'version': version_list[0], 'parsed_version': parsed_version}]})\n            return res\n        if url.get('path', '').endswith('/centreon/'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            path = url['path']\n            match = _EXPR_TITLE.search(body)\n            if match is None:\n                return {}\n            if match.groups()[0] != 'Centreon - IT & Network Monitoring':\n                return {}\n            match = _EXPR_CENTREON_VERSION.search(body)\n            version: Optional[str]\n            if match is None:\n                version = None\n            else:\n                version = match.group(1) or match.group(2)\n            res.setdefault('scripts', []).append({'id': 'http-app', 'output': 'Centreon: path %s%s' % (path, '' if version is None else ', version %s' % version), 'http-app': [{'path': path, 'application': 'Centreon', **({} if version is None else {'version': version})}]})\n            return res\n        if url.get('path', '').endswith('/.well-known/security.txt'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('headers'):\n                return {}\n            if not any((ctype.split(';', 1)[0].lower() == 'text/plain' for ctype in resp['headers'].get('content_type', []))):\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            parsed: Dict[str, List[str]] = {}\n            for line in body.splitlines():\n                line = line.strip().split('#', 1)[0]\n                if not line:\n                    continue\n                if ':' not in line:\n                    utils.LOGGER.warning('Invalid line in security.txt file [%r]', line)\n                    continue\n                (key, value) = line.split(':', 1)\n                parsed.setdefault(key.strip().lower(), []).append(value.strip())\n            res.setdefault('scripts', []).append({'id': 'http-securitytxt', 'output': body, 'http-securitytxt': {key: ' / '.join(value) for (key, value) in parsed.items()}})\n            return res\n        if url.get('path', '') != '/':\n            utils.LOGGER.warning('URL path not supported yet: %s', url.get('path'))\n            return {}\n    elif port is None:\n        if req.get('tls_handshake') or req.get('tls_log'):\n            port = 443\n        else:\n            port = 80\n    res['port'] = port\n    banner = None\n    if resp.get('headers'):\n        headers = resp['headers']\n        if headers.get('www_authenticate'):\n            auths = headers.get('www_authenticate')\n            for auth in auths:\n                if ntlm._is_ntlm_message(auth):\n                    try:\n                        infos = ntlm.ntlm_extract_info(utils.decode_b64(auth.split(None, 1)[1].encode()))\n                    except (UnicodeDecodeError, TypeError, ValueError, binascii.Error):\n                        continue\n                    if not infos:\n                        continue\n                    keyvals = zip(ntlm_values, [infos.get(k) for k in ntlm_values])\n                    output = '\\n'.join(('{}: {}'.format(k, v) for (k, v) in keyvals if v))\n                    res.setdefault('scripts', []).append({'id': 'ntlm-info', 'output': output, 'ntlm-info': dict(infos, protocol='http')})\n                    if 'DNS_Computer_Name' in infos:\n                        add_hostname(infos['DNS_Computer_Name'], 'ntlm', hostrec.setdefault('hostnames', []))\n        if any((val.lower().startswith('ntlm') for val in req.get('headers', {}).get('authorization', []))):\n            return res\n        http_hdrs: List[HttpHeader] = []\n        output_list: List[str] = []\n        has_raw_value = False\n        if resp.get('headers_raw'):\n            try:\n                banner = utils.decode_b64(resp.get('headers_raw').encode())\n            except Exception:\n                utils.LOGGER.warning('Cannot decode raw headers, using parsed result')\n            else:\n                output_list = [utils.nmap_encode_data(line) for line in re.split(b'\\r?\\n', banner)]\n                banner_split = banner.split(b'\\n')\n                http_hdrs = [{'name': '_status', 'value': utils.nmap_encode_data(banner_split[0].strip())}]\n                http_hdrs.extend(({'name': utils.nmap_encode_data(hdrname).lower(), 'value': utils.nmap_encode_data(hdrval)} for (hdrname, hdrval) in (m.groups() for m in (utils.RAW_HTTP_HEADER.search(part.strip()) for part in banner_split) if m)))\n                has_raw_value = True\n        if not has_raw_value:\n            banner = utils.nmap_decode_data(resp['protocol']['name']) + b' ' + utils.nmap_decode_data(resp['status_line']) + b'\\r\\n'\n            line = '%s %s' % (resp['protocol']['name'], resp['status_line'])\n            http_hdrs = [{'name': '_status', 'value': line}]\n            output_list = [line]\n            for unk in headers.pop('unknown', []):\n                headers[unk['key']] = unk['value']\n            for (hdr, values) in headers.items():\n                hdr = hdr.replace('_', '-')\n                for val in values:\n                    http_hdrs.append({'name': hdr, 'value': val})\n                    output_list.append('%s: %s' % (hdr, val))\n            if headers.get('server'):\n                banner += b'Server: ' + utils.nmap_decode_data(headers['server'][0]) + b'\\r\\n\\r\\n'\n        if http_hdrs:\n            method = req.get('method')\n            if method:\n                output_list.append('')\n                output_list.append('(Request type: %s)' % method)\n            script: NmapScript = {'id': 'http-headers', 'output': '\\n'.join(output_list), 'http-headers': http_hdrs}\n            if has_raw_value and banner is not None:\n                script['masscan'] = {'raw': utils.encode_b64(banner).decode()}\n            res.setdefault('scripts', []).append(script)\n            handle_http_headers(hostrec, res, http_hdrs, path=url.get('path'))\n    info: NmapServiceMatch = {} if banner is None else utils.match_nmap_svc_fp(banner, proto='tcp', probe='GetRequest')\n    if info:\n        add_cpe_values(hostrec, 'ports.port:%s' % port, info.pop('cpe', []))\n        res.update(cast(NmapPort, info))\n        add_service_hostname(info, hostrec.setdefault('hostnames', []))\n    if resp.get('body'):\n        body = resp['body']\n        res.setdefault('scripts', []).append({'id': 'http-content', 'output': utils.nmap_encode_data(body.encode())})\n        handle_http_content(hostrec, res, body.encode())\n    return res",
            "def zgrap_parser_http(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'This function handles data from `{\"data\": {\"http\": [...]}}`\\n    records. `data` should be the content, i.e. the `[...]`. It should\\n    consist of simple dictionary, that may contain a `\"response\"` key\\n    and/or a `\"redirect_response_chain\"` key.\\n\\n    The output is a port dict (i.e., the content of the \"ports\" key of an\\n    `nmap` of `view` record in IVRE), that may be empty.\\n\\n    '\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if 'response' not in data:\n        utils.LOGGER.warning('Missing \"response\" field in zgrab HTTP result')\n        return {}\n    resp = data['response']\n    needed_fields = set(['request', 'status_code', 'status_line'])\n    missing_fields = needed_fields.difference(resp)\n    if missing_fields:\n        utils.LOGGER.warning('Missing field%s %s in zgrab HTTP result', 's' if len(missing_fields) > 1 else '', ', '.join((repr(fld) for fld in missing_fields)))\n        return {}\n    req = resp['request']\n    url = req.get('url')\n    res: NmapPort = {'service_name': 'http', 'service_method': 'probed', 'state_state': 'open', 'state_reason': 'response', 'protocol': 'tcp'}\n    tls = None\n    try:\n        tls = req['tls_handshake']\n    except KeyError:\n        try:\n            tls = req['tls_log']['handshake_log']\n        except KeyError:\n            pass\n    if tls is not None:\n        res['service_tunnel'] = 'ssl'\n        try:\n            cert = tls['server_certificates']['certificate']['raw']\n        except KeyError:\n            pass\n        else:\n            (output, info_cert) = create_ssl_cert(cert.encode(), b64encoded=True)\n            if info_cert:\n                res.setdefault('scripts', []).append({'id': 'ssl-cert', 'output': output, 'ssl-cert': info_cert})\n                for cert in info_cert:\n                    add_cert_hostnames(cert, hostrec.setdefault('hostnames', []))\n    if url:\n        try:\n            (_, guessed_port) = utils.url2hostport('%(scheme)s://%(host)s' % url)\n        except ValueError:\n            utils.LOGGER.warning('Cannot guess port from url %r', url)\n            guessed_port = 80\n        else:\n            if port is not None and port != guessed_port:\n                utils.LOGGER.warning('Port %d found from the URL %s differs from the provided port value %d', guessed_port, url.get('path'), port)\n                port = guessed_port\n        if port is None:\n            port = guessed_port\n        if url.get('path', '').endswith('/.git/index'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body', '').startswith('DIRC'):\n                return {}\n            repository = '%s:%d%s' % (hostrec['addr'], port, url['path'][:-5])\n            res['port'] = port\n            res.setdefault('scripts', []).append({'id': 'http-git', 'output': '\\n  %s\\n    Git repository found!\\n' % repository, 'http-git': [{'repository': repository, 'files-found': ['.git/index']}]})\n            return res\n        if url.get('path', '').endswith('/owa/auth/logon.aspx'):\n            if resp.get('status_code') != 200:\n                return {}\n            version_set = set((m.group(1) for m in _EXPR_OWA_VERSION.finditer(resp.get('body', ''))))\n            if not version_set:\n                return {}\n            version_list = sorted(version_set, key=lambda v: [int(x) for x in v.split('.')])\n            res['port'] = port\n            path = url['path'][:-15]\n            if version_list:\n                parsed_version = EXCHANGE_BUILDS.get(version_list[0], 'unknown build number')\n                if len(version_list) > 1:\n                    version_list = ['%s (%s)' % (vers, EXCHANGE_BUILDS.get(vers, 'unknown build number')) for vers in version_list]\n                    output = 'OWA: path %s, version %s (multiple versions found!)' % (path, ' / '.join(version_list))\n                else:\n                    output = 'OWA: path %s, version %s (%s)' % (path, version_list[0], parsed_version)\n                res.setdefault('scripts', []).append({'id': 'http-app', 'output': output, 'http-app': [{'path': path, 'application': 'OWA', 'version': version_list[0], 'parsed_version': parsed_version}]})\n            return res\n        if url.get('path', '').endswith('/centreon/'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            path = url['path']\n            match = _EXPR_TITLE.search(body)\n            if match is None:\n                return {}\n            if match.groups()[0] != 'Centreon - IT & Network Monitoring':\n                return {}\n            match = _EXPR_CENTREON_VERSION.search(body)\n            version: Optional[str]\n            if match is None:\n                version = None\n            else:\n                version = match.group(1) or match.group(2)\n            res.setdefault('scripts', []).append({'id': 'http-app', 'output': 'Centreon: path %s%s' % (path, '' if version is None else ', version %s' % version), 'http-app': [{'path': path, 'application': 'Centreon', **({} if version is None else {'version': version})}]})\n            return res\n        if url.get('path', '').endswith('/.well-known/security.txt'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('headers'):\n                return {}\n            if not any((ctype.split(';', 1)[0].lower() == 'text/plain' for ctype in resp['headers'].get('content_type', []))):\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            parsed: Dict[str, List[str]] = {}\n            for line in body.splitlines():\n                line = line.strip().split('#', 1)[0]\n                if not line:\n                    continue\n                if ':' not in line:\n                    utils.LOGGER.warning('Invalid line in security.txt file [%r]', line)\n                    continue\n                (key, value) = line.split(':', 1)\n                parsed.setdefault(key.strip().lower(), []).append(value.strip())\n            res.setdefault('scripts', []).append({'id': 'http-securitytxt', 'output': body, 'http-securitytxt': {key: ' / '.join(value) for (key, value) in parsed.items()}})\n            return res\n        if url.get('path', '') != '/':\n            utils.LOGGER.warning('URL path not supported yet: %s', url.get('path'))\n            return {}\n    elif port is None:\n        if req.get('tls_handshake') or req.get('tls_log'):\n            port = 443\n        else:\n            port = 80\n    res['port'] = port\n    banner = None\n    if resp.get('headers'):\n        headers = resp['headers']\n        if headers.get('www_authenticate'):\n            auths = headers.get('www_authenticate')\n            for auth in auths:\n                if ntlm._is_ntlm_message(auth):\n                    try:\n                        infos = ntlm.ntlm_extract_info(utils.decode_b64(auth.split(None, 1)[1].encode()))\n                    except (UnicodeDecodeError, TypeError, ValueError, binascii.Error):\n                        continue\n                    if not infos:\n                        continue\n                    keyvals = zip(ntlm_values, [infos.get(k) for k in ntlm_values])\n                    output = '\\n'.join(('{}: {}'.format(k, v) for (k, v) in keyvals if v))\n                    res.setdefault('scripts', []).append({'id': 'ntlm-info', 'output': output, 'ntlm-info': dict(infos, protocol='http')})\n                    if 'DNS_Computer_Name' in infos:\n                        add_hostname(infos['DNS_Computer_Name'], 'ntlm', hostrec.setdefault('hostnames', []))\n        if any((val.lower().startswith('ntlm') for val in req.get('headers', {}).get('authorization', []))):\n            return res\n        http_hdrs: List[HttpHeader] = []\n        output_list: List[str] = []\n        has_raw_value = False\n        if resp.get('headers_raw'):\n            try:\n                banner = utils.decode_b64(resp.get('headers_raw').encode())\n            except Exception:\n                utils.LOGGER.warning('Cannot decode raw headers, using parsed result')\n            else:\n                output_list = [utils.nmap_encode_data(line) for line in re.split(b'\\r?\\n', banner)]\n                banner_split = banner.split(b'\\n')\n                http_hdrs = [{'name': '_status', 'value': utils.nmap_encode_data(banner_split[0].strip())}]\n                http_hdrs.extend(({'name': utils.nmap_encode_data(hdrname).lower(), 'value': utils.nmap_encode_data(hdrval)} for (hdrname, hdrval) in (m.groups() for m in (utils.RAW_HTTP_HEADER.search(part.strip()) for part in banner_split) if m)))\n                has_raw_value = True\n        if not has_raw_value:\n            banner = utils.nmap_decode_data(resp['protocol']['name']) + b' ' + utils.nmap_decode_data(resp['status_line']) + b'\\r\\n'\n            line = '%s %s' % (resp['protocol']['name'], resp['status_line'])\n            http_hdrs = [{'name': '_status', 'value': line}]\n            output_list = [line]\n            for unk in headers.pop('unknown', []):\n                headers[unk['key']] = unk['value']\n            for (hdr, values) in headers.items():\n                hdr = hdr.replace('_', '-')\n                for val in values:\n                    http_hdrs.append({'name': hdr, 'value': val})\n                    output_list.append('%s: %s' % (hdr, val))\n            if headers.get('server'):\n                banner += b'Server: ' + utils.nmap_decode_data(headers['server'][0]) + b'\\r\\n\\r\\n'\n        if http_hdrs:\n            method = req.get('method')\n            if method:\n                output_list.append('')\n                output_list.append('(Request type: %s)' % method)\n            script: NmapScript = {'id': 'http-headers', 'output': '\\n'.join(output_list), 'http-headers': http_hdrs}\n            if has_raw_value and banner is not None:\n                script['masscan'] = {'raw': utils.encode_b64(banner).decode()}\n            res.setdefault('scripts', []).append(script)\n            handle_http_headers(hostrec, res, http_hdrs, path=url.get('path'))\n    info: NmapServiceMatch = {} if banner is None else utils.match_nmap_svc_fp(banner, proto='tcp', probe='GetRequest')\n    if info:\n        add_cpe_values(hostrec, 'ports.port:%s' % port, info.pop('cpe', []))\n        res.update(cast(NmapPort, info))\n        add_service_hostname(info, hostrec.setdefault('hostnames', []))\n    if resp.get('body'):\n        body = resp['body']\n        res.setdefault('scripts', []).append({'id': 'http-content', 'output': utils.nmap_encode_data(body.encode())})\n        handle_http_content(hostrec, res, body.encode())\n    return res",
            "def zgrap_parser_http(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'This function handles data from `{\"data\": {\"http\": [...]}}`\\n    records. `data` should be the content, i.e. the `[...]`. It should\\n    consist of simple dictionary, that may contain a `\"response\"` key\\n    and/or a `\"redirect_response_chain\"` key.\\n\\n    The output is a port dict (i.e., the content of the \"ports\" key of an\\n    `nmap` of `view` record in IVRE), that may be empty.\\n\\n    '\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if 'response' not in data:\n        utils.LOGGER.warning('Missing \"response\" field in zgrab HTTP result')\n        return {}\n    resp = data['response']\n    needed_fields = set(['request', 'status_code', 'status_line'])\n    missing_fields = needed_fields.difference(resp)\n    if missing_fields:\n        utils.LOGGER.warning('Missing field%s %s in zgrab HTTP result', 's' if len(missing_fields) > 1 else '', ', '.join((repr(fld) for fld in missing_fields)))\n        return {}\n    req = resp['request']\n    url = req.get('url')\n    res: NmapPort = {'service_name': 'http', 'service_method': 'probed', 'state_state': 'open', 'state_reason': 'response', 'protocol': 'tcp'}\n    tls = None\n    try:\n        tls = req['tls_handshake']\n    except KeyError:\n        try:\n            tls = req['tls_log']['handshake_log']\n        except KeyError:\n            pass\n    if tls is not None:\n        res['service_tunnel'] = 'ssl'\n        try:\n            cert = tls['server_certificates']['certificate']['raw']\n        except KeyError:\n            pass\n        else:\n            (output, info_cert) = create_ssl_cert(cert.encode(), b64encoded=True)\n            if info_cert:\n                res.setdefault('scripts', []).append({'id': 'ssl-cert', 'output': output, 'ssl-cert': info_cert})\n                for cert in info_cert:\n                    add_cert_hostnames(cert, hostrec.setdefault('hostnames', []))\n    if url:\n        try:\n            (_, guessed_port) = utils.url2hostport('%(scheme)s://%(host)s' % url)\n        except ValueError:\n            utils.LOGGER.warning('Cannot guess port from url %r', url)\n            guessed_port = 80\n        else:\n            if port is not None and port != guessed_port:\n                utils.LOGGER.warning('Port %d found from the URL %s differs from the provided port value %d', guessed_port, url.get('path'), port)\n                port = guessed_port\n        if port is None:\n            port = guessed_port\n        if url.get('path', '').endswith('/.git/index'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body', '').startswith('DIRC'):\n                return {}\n            repository = '%s:%d%s' % (hostrec['addr'], port, url['path'][:-5])\n            res['port'] = port\n            res.setdefault('scripts', []).append({'id': 'http-git', 'output': '\\n  %s\\n    Git repository found!\\n' % repository, 'http-git': [{'repository': repository, 'files-found': ['.git/index']}]})\n            return res\n        if url.get('path', '').endswith('/owa/auth/logon.aspx'):\n            if resp.get('status_code') != 200:\n                return {}\n            version_set = set((m.group(1) for m in _EXPR_OWA_VERSION.finditer(resp.get('body', ''))))\n            if not version_set:\n                return {}\n            version_list = sorted(version_set, key=lambda v: [int(x) for x in v.split('.')])\n            res['port'] = port\n            path = url['path'][:-15]\n            if version_list:\n                parsed_version = EXCHANGE_BUILDS.get(version_list[0], 'unknown build number')\n                if len(version_list) > 1:\n                    version_list = ['%s (%s)' % (vers, EXCHANGE_BUILDS.get(vers, 'unknown build number')) for vers in version_list]\n                    output = 'OWA: path %s, version %s (multiple versions found!)' % (path, ' / '.join(version_list))\n                else:\n                    output = 'OWA: path %s, version %s (%s)' % (path, version_list[0], parsed_version)\n                res.setdefault('scripts', []).append({'id': 'http-app', 'output': output, 'http-app': [{'path': path, 'application': 'OWA', 'version': version_list[0], 'parsed_version': parsed_version}]})\n            return res\n        if url.get('path', '').endswith('/centreon/'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            path = url['path']\n            match = _EXPR_TITLE.search(body)\n            if match is None:\n                return {}\n            if match.groups()[0] != 'Centreon - IT & Network Monitoring':\n                return {}\n            match = _EXPR_CENTREON_VERSION.search(body)\n            version: Optional[str]\n            if match is None:\n                version = None\n            else:\n                version = match.group(1) or match.group(2)\n            res.setdefault('scripts', []).append({'id': 'http-app', 'output': 'Centreon: path %s%s' % (path, '' if version is None else ', version %s' % version), 'http-app': [{'path': path, 'application': 'Centreon', **({} if version is None else {'version': version})}]})\n            return res\n        if url.get('path', '').endswith('/.well-known/security.txt'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('headers'):\n                return {}\n            if not any((ctype.split(';', 1)[0].lower() == 'text/plain' for ctype in resp['headers'].get('content_type', []))):\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            parsed: Dict[str, List[str]] = {}\n            for line in body.splitlines():\n                line = line.strip().split('#', 1)[0]\n                if not line:\n                    continue\n                if ':' not in line:\n                    utils.LOGGER.warning('Invalid line in security.txt file [%r]', line)\n                    continue\n                (key, value) = line.split(':', 1)\n                parsed.setdefault(key.strip().lower(), []).append(value.strip())\n            res.setdefault('scripts', []).append({'id': 'http-securitytxt', 'output': body, 'http-securitytxt': {key: ' / '.join(value) for (key, value) in parsed.items()}})\n            return res\n        if url.get('path', '') != '/':\n            utils.LOGGER.warning('URL path not supported yet: %s', url.get('path'))\n            return {}\n    elif port is None:\n        if req.get('tls_handshake') or req.get('tls_log'):\n            port = 443\n        else:\n            port = 80\n    res['port'] = port\n    banner = None\n    if resp.get('headers'):\n        headers = resp['headers']\n        if headers.get('www_authenticate'):\n            auths = headers.get('www_authenticate')\n            for auth in auths:\n                if ntlm._is_ntlm_message(auth):\n                    try:\n                        infos = ntlm.ntlm_extract_info(utils.decode_b64(auth.split(None, 1)[1].encode()))\n                    except (UnicodeDecodeError, TypeError, ValueError, binascii.Error):\n                        continue\n                    if not infos:\n                        continue\n                    keyvals = zip(ntlm_values, [infos.get(k) for k in ntlm_values])\n                    output = '\\n'.join(('{}: {}'.format(k, v) for (k, v) in keyvals if v))\n                    res.setdefault('scripts', []).append({'id': 'ntlm-info', 'output': output, 'ntlm-info': dict(infos, protocol='http')})\n                    if 'DNS_Computer_Name' in infos:\n                        add_hostname(infos['DNS_Computer_Name'], 'ntlm', hostrec.setdefault('hostnames', []))\n        if any((val.lower().startswith('ntlm') for val in req.get('headers', {}).get('authorization', []))):\n            return res\n        http_hdrs: List[HttpHeader] = []\n        output_list: List[str] = []\n        has_raw_value = False\n        if resp.get('headers_raw'):\n            try:\n                banner = utils.decode_b64(resp.get('headers_raw').encode())\n            except Exception:\n                utils.LOGGER.warning('Cannot decode raw headers, using parsed result')\n            else:\n                output_list = [utils.nmap_encode_data(line) for line in re.split(b'\\r?\\n', banner)]\n                banner_split = banner.split(b'\\n')\n                http_hdrs = [{'name': '_status', 'value': utils.nmap_encode_data(banner_split[0].strip())}]\n                http_hdrs.extend(({'name': utils.nmap_encode_data(hdrname).lower(), 'value': utils.nmap_encode_data(hdrval)} for (hdrname, hdrval) in (m.groups() for m in (utils.RAW_HTTP_HEADER.search(part.strip()) for part in banner_split) if m)))\n                has_raw_value = True\n        if not has_raw_value:\n            banner = utils.nmap_decode_data(resp['protocol']['name']) + b' ' + utils.nmap_decode_data(resp['status_line']) + b'\\r\\n'\n            line = '%s %s' % (resp['protocol']['name'], resp['status_line'])\n            http_hdrs = [{'name': '_status', 'value': line}]\n            output_list = [line]\n            for unk in headers.pop('unknown', []):\n                headers[unk['key']] = unk['value']\n            for (hdr, values) in headers.items():\n                hdr = hdr.replace('_', '-')\n                for val in values:\n                    http_hdrs.append({'name': hdr, 'value': val})\n                    output_list.append('%s: %s' % (hdr, val))\n            if headers.get('server'):\n                banner += b'Server: ' + utils.nmap_decode_data(headers['server'][0]) + b'\\r\\n\\r\\n'\n        if http_hdrs:\n            method = req.get('method')\n            if method:\n                output_list.append('')\n                output_list.append('(Request type: %s)' % method)\n            script: NmapScript = {'id': 'http-headers', 'output': '\\n'.join(output_list), 'http-headers': http_hdrs}\n            if has_raw_value and banner is not None:\n                script['masscan'] = {'raw': utils.encode_b64(banner).decode()}\n            res.setdefault('scripts', []).append(script)\n            handle_http_headers(hostrec, res, http_hdrs, path=url.get('path'))\n    info: NmapServiceMatch = {} if banner is None else utils.match_nmap_svc_fp(banner, proto='tcp', probe='GetRequest')\n    if info:\n        add_cpe_values(hostrec, 'ports.port:%s' % port, info.pop('cpe', []))\n        res.update(cast(NmapPort, info))\n        add_service_hostname(info, hostrec.setdefault('hostnames', []))\n    if resp.get('body'):\n        body = resp['body']\n        res.setdefault('scripts', []).append({'id': 'http-content', 'output': utils.nmap_encode_data(body.encode())})\n        handle_http_content(hostrec, res, body.encode())\n    return res",
            "def zgrap_parser_http(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'This function handles data from `{\"data\": {\"http\": [...]}}`\\n    records. `data` should be the content, i.e. the `[...]`. It should\\n    consist of simple dictionary, that may contain a `\"response\"` key\\n    and/or a `\"redirect_response_chain\"` key.\\n\\n    The output is a port dict (i.e., the content of the \"ports\" key of an\\n    `nmap` of `view` record in IVRE), that may be empty.\\n\\n    '\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if 'response' not in data:\n        utils.LOGGER.warning('Missing \"response\" field in zgrab HTTP result')\n        return {}\n    resp = data['response']\n    needed_fields = set(['request', 'status_code', 'status_line'])\n    missing_fields = needed_fields.difference(resp)\n    if missing_fields:\n        utils.LOGGER.warning('Missing field%s %s in zgrab HTTP result', 's' if len(missing_fields) > 1 else '', ', '.join((repr(fld) for fld in missing_fields)))\n        return {}\n    req = resp['request']\n    url = req.get('url')\n    res: NmapPort = {'service_name': 'http', 'service_method': 'probed', 'state_state': 'open', 'state_reason': 'response', 'protocol': 'tcp'}\n    tls = None\n    try:\n        tls = req['tls_handshake']\n    except KeyError:\n        try:\n            tls = req['tls_log']['handshake_log']\n        except KeyError:\n            pass\n    if tls is not None:\n        res['service_tunnel'] = 'ssl'\n        try:\n            cert = tls['server_certificates']['certificate']['raw']\n        except KeyError:\n            pass\n        else:\n            (output, info_cert) = create_ssl_cert(cert.encode(), b64encoded=True)\n            if info_cert:\n                res.setdefault('scripts', []).append({'id': 'ssl-cert', 'output': output, 'ssl-cert': info_cert})\n                for cert in info_cert:\n                    add_cert_hostnames(cert, hostrec.setdefault('hostnames', []))\n    if url:\n        try:\n            (_, guessed_port) = utils.url2hostport('%(scheme)s://%(host)s' % url)\n        except ValueError:\n            utils.LOGGER.warning('Cannot guess port from url %r', url)\n            guessed_port = 80\n        else:\n            if port is not None and port != guessed_port:\n                utils.LOGGER.warning('Port %d found from the URL %s differs from the provided port value %d', guessed_port, url.get('path'), port)\n                port = guessed_port\n        if port is None:\n            port = guessed_port\n        if url.get('path', '').endswith('/.git/index'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body', '').startswith('DIRC'):\n                return {}\n            repository = '%s:%d%s' % (hostrec['addr'], port, url['path'][:-5])\n            res['port'] = port\n            res.setdefault('scripts', []).append({'id': 'http-git', 'output': '\\n  %s\\n    Git repository found!\\n' % repository, 'http-git': [{'repository': repository, 'files-found': ['.git/index']}]})\n            return res\n        if url.get('path', '').endswith('/owa/auth/logon.aspx'):\n            if resp.get('status_code') != 200:\n                return {}\n            version_set = set((m.group(1) for m in _EXPR_OWA_VERSION.finditer(resp.get('body', ''))))\n            if not version_set:\n                return {}\n            version_list = sorted(version_set, key=lambda v: [int(x) for x in v.split('.')])\n            res['port'] = port\n            path = url['path'][:-15]\n            if version_list:\n                parsed_version = EXCHANGE_BUILDS.get(version_list[0], 'unknown build number')\n                if len(version_list) > 1:\n                    version_list = ['%s (%s)' % (vers, EXCHANGE_BUILDS.get(vers, 'unknown build number')) for vers in version_list]\n                    output = 'OWA: path %s, version %s (multiple versions found!)' % (path, ' / '.join(version_list))\n                else:\n                    output = 'OWA: path %s, version %s (%s)' % (path, version_list[0], parsed_version)\n                res.setdefault('scripts', []).append({'id': 'http-app', 'output': output, 'http-app': [{'path': path, 'application': 'OWA', 'version': version_list[0], 'parsed_version': parsed_version}]})\n            return res\n        if url.get('path', '').endswith('/centreon/'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            path = url['path']\n            match = _EXPR_TITLE.search(body)\n            if match is None:\n                return {}\n            if match.groups()[0] != 'Centreon - IT & Network Monitoring':\n                return {}\n            match = _EXPR_CENTREON_VERSION.search(body)\n            version: Optional[str]\n            if match is None:\n                version = None\n            else:\n                version = match.group(1) or match.group(2)\n            res.setdefault('scripts', []).append({'id': 'http-app', 'output': 'Centreon: path %s%s' % (path, '' if version is None else ', version %s' % version), 'http-app': [{'path': path, 'application': 'Centreon', **({} if version is None else {'version': version})}]})\n            return res\n        if url.get('path', '').endswith('/.well-known/security.txt'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('headers'):\n                return {}\n            if not any((ctype.split(';', 1)[0].lower() == 'text/plain' for ctype in resp['headers'].get('content_type', []))):\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            parsed: Dict[str, List[str]] = {}\n            for line in body.splitlines():\n                line = line.strip().split('#', 1)[0]\n                if not line:\n                    continue\n                if ':' not in line:\n                    utils.LOGGER.warning('Invalid line in security.txt file [%r]', line)\n                    continue\n                (key, value) = line.split(':', 1)\n                parsed.setdefault(key.strip().lower(), []).append(value.strip())\n            res.setdefault('scripts', []).append({'id': 'http-securitytxt', 'output': body, 'http-securitytxt': {key: ' / '.join(value) for (key, value) in parsed.items()}})\n            return res\n        if url.get('path', '') != '/':\n            utils.LOGGER.warning('URL path not supported yet: %s', url.get('path'))\n            return {}\n    elif port is None:\n        if req.get('tls_handshake') or req.get('tls_log'):\n            port = 443\n        else:\n            port = 80\n    res['port'] = port\n    banner = None\n    if resp.get('headers'):\n        headers = resp['headers']\n        if headers.get('www_authenticate'):\n            auths = headers.get('www_authenticate')\n            for auth in auths:\n                if ntlm._is_ntlm_message(auth):\n                    try:\n                        infos = ntlm.ntlm_extract_info(utils.decode_b64(auth.split(None, 1)[1].encode()))\n                    except (UnicodeDecodeError, TypeError, ValueError, binascii.Error):\n                        continue\n                    if not infos:\n                        continue\n                    keyvals = zip(ntlm_values, [infos.get(k) for k in ntlm_values])\n                    output = '\\n'.join(('{}: {}'.format(k, v) for (k, v) in keyvals if v))\n                    res.setdefault('scripts', []).append({'id': 'ntlm-info', 'output': output, 'ntlm-info': dict(infos, protocol='http')})\n                    if 'DNS_Computer_Name' in infos:\n                        add_hostname(infos['DNS_Computer_Name'], 'ntlm', hostrec.setdefault('hostnames', []))\n        if any((val.lower().startswith('ntlm') for val in req.get('headers', {}).get('authorization', []))):\n            return res\n        http_hdrs: List[HttpHeader] = []\n        output_list: List[str] = []\n        has_raw_value = False\n        if resp.get('headers_raw'):\n            try:\n                banner = utils.decode_b64(resp.get('headers_raw').encode())\n            except Exception:\n                utils.LOGGER.warning('Cannot decode raw headers, using parsed result')\n            else:\n                output_list = [utils.nmap_encode_data(line) for line in re.split(b'\\r?\\n', banner)]\n                banner_split = banner.split(b'\\n')\n                http_hdrs = [{'name': '_status', 'value': utils.nmap_encode_data(banner_split[0].strip())}]\n                http_hdrs.extend(({'name': utils.nmap_encode_data(hdrname).lower(), 'value': utils.nmap_encode_data(hdrval)} for (hdrname, hdrval) in (m.groups() for m in (utils.RAW_HTTP_HEADER.search(part.strip()) for part in banner_split) if m)))\n                has_raw_value = True\n        if not has_raw_value:\n            banner = utils.nmap_decode_data(resp['protocol']['name']) + b' ' + utils.nmap_decode_data(resp['status_line']) + b'\\r\\n'\n            line = '%s %s' % (resp['protocol']['name'], resp['status_line'])\n            http_hdrs = [{'name': '_status', 'value': line}]\n            output_list = [line]\n            for unk in headers.pop('unknown', []):\n                headers[unk['key']] = unk['value']\n            for (hdr, values) in headers.items():\n                hdr = hdr.replace('_', '-')\n                for val in values:\n                    http_hdrs.append({'name': hdr, 'value': val})\n                    output_list.append('%s: %s' % (hdr, val))\n            if headers.get('server'):\n                banner += b'Server: ' + utils.nmap_decode_data(headers['server'][0]) + b'\\r\\n\\r\\n'\n        if http_hdrs:\n            method = req.get('method')\n            if method:\n                output_list.append('')\n                output_list.append('(Request type: %s)' % method)\n            script: NmapScript = {'id': 'http-headers', 'output': '\\n'.join(output_list), 'http-headers': http_hdrs}\n            if has_raw_value and banner is not None:\n                script['masscan'] = {'raw': utils.encode_b64(banner).decode()}\n            res.setdefault('scripts', []).append(script)\n            handle_http_headers(hostrec, res, http_hdrs, path=url.get('path'))\n    info: NmapServiceMatch = {} if banner is None else utils.match_nmap_svc_fp(banner, proto='tcp', probe='GetRequest')\n    if info:\n        add_cpe_values(hostrec, 'ports.port:%s' % port, info.pop('cpe', []))\n        res.update(cast(NmapPort, info))\n        add_service_hostname(info, hostrec.setdefault('hostnames', []))\n    if resp.get('body'):\n        body = resp['body']\n        res.setdefault('scripts', []).append({'id': 'http-content', 'output': utils.nmap_encode_data(body.encode())})\n        handle_http_content(hostrec, res, body.encode())\n    return res",
            "def zgrap_parser_http(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'This function handles data from `{\"data\": {\"http\": [...]}}`\\n    records. `data` should be the content, i.e. the `[...]`. It should\\n    consist of simple dictionary, that may contain a `\"response\"` key\\n    and/or a `\"redirect_response_chain\"` key.\\n\\n    The output is a port dict (i.e., the content of the \"ports\" key of an\\n    `nmap` of `view` record in IVRE), that may be empty.\\n\\n    '\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if 'response' not in data:\n        utils.LOGGER.warning('Missing \"response\" field in zgrab HTTP result')\n        return {}\n    resp = data['response']\n    needed_fields = set(['request', 'status_code', 'status_line'])\n    missing_fields = needed_fields.difference(resp)\n    if missing_fields:\n        utils.LOGGER.warning('Missing field%s %s in zgrab HTTP result', 's' if len(missing_fields) > 1 else '', ', '.join((repr(fld) for fld in missing_fields)))\n        return {}\n    req = resp['request']\n    url = req.get('url')\n    res: NmapPort = {'service_name': 'http', 'service_method': 'probed', 'state_state': 'open', 'state_reason': 'response', 'protocol': 'tcp'}\n    tls = None\n    try:\n        tls = req['tls_handshake']\n    except KeyError:\n        try:\n            tls = req['tls_log']['handshake_log']\n        except KeyError:\n            pass\n    if tls is not None:\n        res['service_tunnel'] = 'ssl'\n        try:\n            cert = tls['server_certificates']['certificate']['raw']\n        except KeyError:\n            pass\n        else:\n            (output, info_cert) = create_ssl_cert(cert.encode(), b64encoded=True)\n            if info_cert:\n                res.setdefault('scripts', []).append({'id': 'ssl-cert', 'output': output, 'ssl-cert': info_cert})\n                for cert in info_cert:\n                    add_cert_hostnames(cert, hostrec.setdefault('hostnames', []))\n    if url:\n        try:\n            (_, guessed_port) = utils.url2hostport('%(scheme)s://%(host)s' % url)\n        except ValueError:\n            utils.LOGGER.warning('Cannot guess port from url %r', url)\n            guessed_port = 80\n        else:\n            if port is not None and port != guessed_port:\n                utils.LOGGER.warning('Port %d found from the URL %s differs from the provided port value %d', guessed_port, url.get('path'), port)\n                port = guessed_port\n        if port is None:\n            port = guessed_port\n        if url.get('path', '').endswith('/.git/index'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body', '').startswith('DIRC'):\n                return {}\n            repository = '%s:%d%s' % (hostrec['addr'], port, url['path'][:-5])\n            res['port'] = port\n            res.setdefault('scripts', []).append({'id': 'http-git', 'output': '\\n  %s\\n    Git repository found!\\n' % repository, 'http-git': [{'repository': repository, 'files-found': ['.git/index']}]})\n            return res\n        if url.get('path', '').endswith('/owa/auth/logon.aspx'):\n            if resp.get('status_code') != 200:\n                return {}\n            version_set = set((m.group(1) for m in _EXPR_OWA_VERSION.finditer(resp.get('body', ''))))\n            if not version_set:\n                return {}\n            version_list = sorted(version_set, key=lambda v: [int(x) for x in v.split('.')])\n            res['port'] = port\n            path = url['path'][:-15]\n            if version_list:\n                parsed_version = EXCHANGE_BUILDS.get(version_list[0], 'unknown build number')\n                if len(version_list) > 1:\n                    version_list = ['%s (%s)' % (vers, EXCHANGE_BUILDS.get(vers, 'unknown build number')) for vers in version_list]\n                    output = 'OWA: path %s, version %s (multiple versions found!)' % (path, ' / '.join(version_list))\n                else:\n                    output = 'OWA: path %s, version %s (%s)' % (path, version_list[0], parsed_version)\n                res.setdefault('scripts', []).append({'id': 'http-app', 'output': output, 'http-app': [{'path': path, 'application': 'OWA', 'version': version_list[0], 'parsed_version': parsed_version}]})\n            return res\n        if url.get('path', '').endswith('/centreon/'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            path = url['path']\n            match = _EXPR_TITLE.search(body)\n            if match is None:\n                return {}\n            if match.groups()[0] != 'Centreon - IT & Network Monitoring':\n                return {}\n            match = _EXPR_CENTREON_VERSION.search(body)\n            version: Optional[str]\n            if match is None:\n                version = None\n            else:\n                version = match.group(1) or match.group(2)\n            res.setdefault('scripts', []).append({'id': 'http-app', 'output': 'Centreon: path %s%s' % (path, '' if version is None else ', version %s' % version), 'http-app': [{'path': path, 'application': 'Centreon', **({} if version is None else {'version': version})}]})\n            return res\n        if url.get('path', '').endswith('/.well-known/security.txt'):\n            if resp.get('status_code') != 200:\n                return {}\n            if not resp.get('headers'):\n                return {}\n            if not any((ctype.split(';', 1)[0].lower() == 'text/plain' for ctype in resp['headers'].get('content_type', []))):\n                return {}\n            if not resp.get('body'):\n                return {}\n            body = resp['body']\n            res['port'] = port\n            parsed: Dict[str, List[str]] = {}\n            for line in body.splitlines():\n                line = line.strip().split('#', 1)[0]\n                if not line:\n                    continue\n                if ':' not in line:\n                    utils.LOGGER.warning('Invalid line in security.txt file [%r]', line)\n                    continue\n                (key, value) = line.split(':', 1)\n                parsed.setdefault(key.strip().lower(), []).append(value.strip())\n            res.setdefault('scripts', []).append({'id': 'http-securitytxt', 'output': body, 'http-securitytxt': {key: ' / '.join(value) for (key, value) in parsed.items()}})\n            return res\n        if url.get('path', '') != '/':\n            utils.LOGGER.warning('URL path not supported yet: %s', url.get('path'))\n            return {}\n    elif port is None:\n        if req.get('tls_handshake') or req.get('tls_log'):\n            port = 443\n        else:\n            port = 80\n    res['port'] = port\n    banner = None\n    if resp.get('headers'):\n        headers = resp['headers']\n        if headers.get('www_authenticate'):\n            auths = headers.get('www_authenticate')\n            for auth in auths:\n                if ntlm._is_ntlm_message(auth):\n                    try:\n                        infos = ntlm.ntlm_extract_info(utils.decode_b64(auth.split(None, 1)[1].encode()))\n                    except (UnicodeDecodeError, TypeError, ValueError, binascii.Error):\n                        continue\n                    if not infos:\n                        continue\n                    keyvals = zip(ntlm_values, [infos.get(k) for k in ntlm_values])\n                    output = '\\n'.join(('{}: {}'.format(k, v) for (k, v) in keyvals if v))\n                    res.setdefault('scripts', []).append({'id': 'ntlm-info', 'output': output, 'ntlm-info': dict(infos, protocol='http')})\n                    if 'DNS_Computer_Name' in infos:\n                        add_hostname(infos['DNS_Computer_Name'], 'ntlm', hostrec.setdefault('hostnames', []))\n        if any((val.lower().startswith('ntlm') for val in req.get('headers', {}).get('authorization', []))):\n            return res\n        http_hdrs: List[HttpHeader] = []\n        output_list: List[str] = []\n        has_raw_value = False\n        if resp.get('headers_raw'):\n            try:\n                banner = utils.decode_b64(resp.get('headers_raw').encode())\n            except Exception:\n                utils.LOGGER.warning('Cannot decode raw headers, using parsed result')\n            else:\n                output_list = [utils.nmap_encode_data(line) for line in re.split(b'\\r?\\n', banner)]\n                banner_split = banner.split(b'\\n')\n                http_hdrs = [{'name': '_status', 'value': utils.nmap_encode_data(banner_split[0].strip())}]\n                http_hdrs.extend(({'name': utils.nmap_encode_data(hdrname).lower(), 'value': utils.nmap_encode_data(hdrval)} for (hdrname, hdrval) in (m.groups() for m in (utils.RAW_HTTP_HEADER.search(part.strip()) for part in banner_split) if m)))\n                has_raw_value = True\n        if not has_raw_value:\n            banner = utils.nmap_decode_data(resp['protocol']['name']) + b' ' + utils.nmap_decode_data(resp['status_line']) + b'\\r\\n'\n            line = '%s %s' % (resp['protocol']['name'], resp['status_line'])\n            http_hdrs = [{'name': '_status', 'value': line}]\n            output_list = [line]\n            for unk in headers.pop('unknown', []):\n                headers[unk['key']] = unk['value']\n            for (hdr, values) in headers.items():\n                hdr = hdr.replace('_', '-')\n                for val in values:\n                    http_hdrs.append({'name': hdr, 'value': val})\n                    output_list.append('%s: %s' % (hdr, val))\n            if headers.get('server'):\n                banner += b'Server: ' + utils.nmap_decode_data(headers['server'][0]) + b'\\r\\n\\r\\n'\n        if http_hdrs:\n            method = req.get('method')\n            if method:\n                output_list.append('')\n                output_list.append('(Request type: %s)' % method)\n            script: NmapScript = {'id': 'http-headers', 'output': '\\n'.join(output_list), 'http-headers': http_hdrs}\n            if has_raw_value and banner is not None:\n                script['masscan'] = {'raw': utils.encode_b64(banner).decode()}\n            res.setdefault('scripts', []).append(script)\n            handle_http_headers(hostrec, res, http_hdrs, path=url.get('path'))\n    info: NmapServiceMatch = {} if banner is None else utils.match_nmap_svc_fp(banner, proto='tcp', probe='GetRequest')\n    if info:\n        add_cpe_values(hostrec, 'ports.port:%s' % port, info.pop('cpe', []))\n        res.update(cast(NmapPort, info))\n        add_service_hostname(info, hostrec.setdefault('hostnames', []))\n    if resp.get('body'):\n        body = resp['body']\n        res.setdefault('scripts', []).append({'id': 'http-content', 'output': utils.nmap_encode_data(body.encode())})\n        handle_http_content(hostrec, res, body.encode())\n    return res"
        ]
    },
    {
        "func_name": "zgrap_parser_jarm",
        "original": "def zgrap_parser_jarm(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    \"\"\"This function handles data from `{\"data\": {\"jarm\": [...]}}`\n    records. `data` should be the content, i.e. the `[...]`. It should\n    consist of simple dictionary, that must contain a `\"status\"` key and a\n    `\"fingerprint\"` key (that may be in a `\"result\"` sub-document).\n\n    The output is a port dict (i.e., the content of the \"ports\" key of an\n    `nmap` of `view` record in IVRE), that may be empty.\n\n    \"\"\"\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if data.get('status') != 'success':\n        return {}\n    if 'fingerprint' not in data:\n        utils.LOGGER.warning('Missing \"fingerprint\" field in zgrab JARM result')\n        return {}\n    if data['fingerprint'] == '00000000000000000000000000000000000000000000000000000000000000':\n        utils.LOGGER.warning('Null \"fingerprint\" in zgrab JARM result')\n        return {}\n    if port is None:\n        port = 443\n        utils.LOGGER.warning('No port provided; using default %d. Use --zgrab-port to change it.', port)\n    return {'state_state': 'open', 'state_reason': 'response', 'port': port, 'protocol': 'tcp', 'service_tunnel': 'ssl', 'scripts': [{'id': 'ssl-jarm', 'output': data['fingerprint'], 'ssl-jarm': data['fingerprint']}]}",
        "mutated": [
            "def zgrap_parser_jarm(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    if False:\n        i = 10\n    'This function handles data from `{\"data\": {\"jarm\": [...]}}`\\n    records. `data` should be the content, i.e. the `[...]`. It should\\n    consist of simple dictionary, that must contain a `\"status\"` key and a\\n    `\"fingerprint\"` key (that may be in a `\"result\"` sub-document).\\n\\n    The output is a port dict (i.e., the content of the \"ports\" key of an\\n    `nmap` of `view` record in IVRE), that may be empty.\\n\\n    '\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if data.get('status') != 'success':\n        return {}\n    if 'fingerprint' not in data:\n        utils.LOGGER.warning('Missing \"fingerprint\" field in zgrab JARM result')\n        return {}\n    if data['fingerprint'] == '00000000000000000000000000000000000000000000000000000000000000':\n        utils.LOGGER.warning('Null \"fingerprint\" in zgrab JARM result')\n        return {}\n    if port is None:\n        port = 443\n        utils.LOGGER.warning('No port provided; using default %d. Use --zgrab-port to change it.', port)\n    return {'state_state': 'open', 'state_reason': 'response', 'port': port, 'protocol': 'tcp', 'service_tunnel': 'ssl', 'scripts': [{'id': 'ssl-jarm', 'output': data['fingerprint'], 'ssl-jarm': data['fingerprint']}]}",
            "def zgrap_parser_jarm(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'This function handles data from `{\"data\": {\"jarm\": [...]}}`\\n    records. `data` should be the content, i.e. the `[...]`. It should\\n    consist of simple dictionary, that must contain a `\"status\"` key and a\\n    `\"fingerprint\"` key (that may be in a `\"result\"` sub-document).\\n\\n    The output is a port dict (i.e., the content of the \"ports\" key of an\\n    `nmap` of `view` record in IVRE), that may be empty.\\n\\n    '\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if data.get('status') != 'success':\n        return {}\n    if 'fingerprint' not in data:\n        utils.LOGGER.warning('Missing \"fingerprint\" field in zgrab JARM result')\n        return {}\n    if data['fingerprint'] == '00000000000000000000000000000000000000000000000000000000000000':\n        utils.LOGGER.warning('Null \"fingerprint\" in zgrab JARM result')\n        return {}\n    if port is None:\n        port = 443\n        utils.LOGGER.warning('No port provided; using default %d. Use --zgrab-port to change it.', port)\n    return {'state_state': 'open', 'state_reason': 'response', 'port': port, 'protocol': 'tcp', 'service_tunnel': 'ssl', 'scripts': [{'id': 'ssl-jarm', 'output': data['fingerprint'], 'ssl-jarm': data['fingerprint']}]}",
            "def zgrap_parser_jarm(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'This function handles data from `{\"data\": {\"jarm\": [...]}}`\\n    records. `data` should be the content, i.e. the `[...]`. It should\\n    consist of simple dictionary, that must contain a `\"status\"` key and a\\n    `\"fingerprint\"` key (that may be in a `\"result\"` sub-document).\\n\\n    The output is a port dict (i.e., the content of the \"ports\" key of an\\n    `nmap` of `view` record in IVRE), that may be empty.\\n\\n    '\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if data.get('status') != 'success':\n        return {}\n    if 'fingerprint' not in data:\n        utils.LOGGER.warning('Missing \"fingerprint\" field in zgrab JARM result')\n        return {}\n    if data['fingerprint'] == '00000000000000000000000000000000000000000000000000000000000000':\n        utils.LOGGER.warning('Null \"fingerprint\" in zgrab JARM result')\n        return {}\n    if port is None:\n        port = 443\n        utils.LOGGER.warning('No port provided; using default %d. Use --zgrab-port to change it.', port)\n    return {'state_state': 'open', 'state_reason': 'response', 'port': port, 'protocol': 'tcp', 'service_tunnel': 'ssl', 'scripts': [{'id': 'ssl-jarm', 'output': data['fingerprint'], 'ssl-jarm': data['fingerprint']}]}",
            "def zgrap_parser_jarm(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'This function handles data from `{\"data\": {\"jarm\": [...]}}`\\n    records. `data` should be the content, i.e. the `[...]`. It should\\n    consist of simple dictionary, that must contain a `\"status\"` key and a\\n    `\"fingerprint\"` key (that may be in a `\"result\"` sub-document).\\n\\n    The output is a port dict (i.e., the content of the \"ports\" key of an\\n    `nmap` of `view` record in IVRE), that may be empty.\\n\\n    '\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if data.get('status') != 'success':\n        return {}\n    if 'fingerprint' not in data:\n        utils.LOGGER.warning('Missing \"fingerprint\" field in zgrab JARM result')\n        return {}\n    if data['fingerprint'] == '00000000000000000000000000000000000000000000000000000000000000':\n        utils.LOGGER.warning('Null \"fingerprint\" in zgrab JARM result')\n        return {}\n    if port is None:\n        port = 443\n        utils.LOGGER.warning('No port provided; using default %d. Use --zgrab-port to change it.', port)\n    return {'state_state': 'open', 'state_reason': 'response', 'port': port, 'protocol': 'tcp', 'service_tunnel': 'ssl', 'scripts': [{'id': 'ssl-jarm', 'output': data['fingerprint'], 'ssl-jarm': data['fingerprint']}]}",
            "def zgrap_parser_jarm(data: Dict[str, Any], hostrec: NmapHost, port: Optional[int]=None) -> NmapPort:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'This function handles data from `{\"data\": {\"jarm\": [...]}}`\\n    records. `data` should be the content, i.e. the `[...]`. It should\\n    consist of simple dictionary, that must contain a `\"status\"` key and a\\n    `\"fingerprint\"` key (that may be in a `\"result\"` sub-document).\\n\\n    The output is a port dict (i.e., the content of the \"ports\" key of an\\n    `nmap` of `view` record in IVRE), that may be empty.\\n\\n    '\n    if not data:\n        return {}\n    if 'result' in data:\n        data.update(data.pop('result'))\n    if data.get('status') != 'success':\n        return {}\n    if 'fingerprint' not in data:\n        utils.LOGGER.warning('Missing \"fingerprint\" field in zgrab JARM result')\n        return {}\n    if data['fingerprint'] == '00000000000000000000000000000000000000000000000000000000000000':\n        utils.LOGGER.warning('Null \"fingerprint\" in zgrab JARM result')\n        return {}\n    if port is None:\n        port = 443\n        utils.LOGGER.warning('No port provided; using default %d. Use --zgrab-port to change it.', port)\n    return {'state_state': 'open', 'state_reason': 'response', 'port': port, 'protocol': 'tcp', 'service_tunnel': 'ssl', 'scripts': [{'id': 'ssl-jarm', 'output': data['fingerprint'], 'ssl-jarm': data['fingerprint']}]}"
        ]
    }
]