[
    {
        "func_name": "add_single_bd",
        "original": "def add_single_bd(x: np.ndarray, distance: int=2, pixel_value: int=1) -> np.ndarray:\n    \"\"\"\n    Augments a matrix by setting value some `distance` away from the bottom-right edge to 1. Works for a single image\n    or a batch of images.\n\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\n    :param distance: Distance from bottom-right walls.\n    :param pixel_value: Value used to replace the entries of the image matrix.\n    :return: Backdoored image.\n    \"\"\"\n    x = np.copy(x)\n    shape = x.shape\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    return x",
        "mutated": [
            "def add_single_bd(x: np.ndarray, distance: int=2, pixel_value: int=1) -> np.ndarray:\n    if False:\n        i = 10\n    '\\n    Augments a matrix by setting value some `distance` away from the bottom-right edge to 1. Works for a single image\\n    or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\\n    :param distance: Distance from bottom-right walls.\\n    :param pixel_value: Value used to replace the entries of the image matrix.\\n    :return: Backdoored image.\\n    '\n    x = np.copy(x)\n    shape = x.shape\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    return x",
            "def add_single_bd(x: np.ndarray, distance: int=2, pixel_value: int=1) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Augments a matrix by setting value some `distance` away from the bottom-right edge to 1. Works for a single image\\n    or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\\n    :param distance: Distance from bottom-right walls.\\n    :param pixel_value: Value used to replace the entries of the image matrix.\\n    :return: Backdoored image.\\n    '\n    x = np.copy(x)\n    shape = x.shape\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    return x",
            "def add_single_bd(x: np.ndarray, distance: int=2, pixel_value: int=1) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Augments a matrix by setting value some `distance` away from the bottom-right edge to 1. Works for a single image\\n    or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\\n    :param distance: Distance from bottom-right walls.\\n    :param pixel_value: Value used to replace the entries of the image matrix.\\n    :return: Backdoored image.\\n    '\n    x = np.copy(x)\n    shape = x.shape\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    return x",
            "def add_single_bd(x: np.ndarray, distance: int=2, pixel_value: int=1) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Augments a matrix by setting value some `distance` away from the bottom-right edge to 1. Works for a single image\\n    or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\\n    :param distance: Distance from bottom-right walls.\\n    :param pixel_value: Value used to replace the entries of the image matrix.\\n    :return: Backdoored image.\\n    '\n    x = np.copy(x)\n    shape = x.shape\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    return x",
            "def add_single_bd(x: np.ndarray, distance: int=2, pixel_value: int=1) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Augments a matrix by setting value some `distance` away from the bottom-right edge to 1. Works for a single image\\n    or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\\n    :param distance: Distance from bottom-right walls.\\n    :param pixel_value: Value used to replace the entries of the image matrix.\\n    :return: Backdoored image.\\n    '\n    x = np.copy(x)\n    shape = x.shape\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    return x"
        ]
    },
    {
        "func_name": "add_pattern_bd",
        "original": "def add_pattern_bd(x: np.ndarray, distance: int=2, pixel_value: int=1, channels_first: bool=False) -> np.ndarray:\n    \"\"\"\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\n    edge to 1. Works for single images or a batch of images.\n\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\n    :param distance: Distance from bottom-right walls.\n    :param pixel_value: Value used to replace the entries of the image matrix.\n    :param channels_first: If the data is provided in channels first format we transpose to NWHC or HC depending on\n                           input shape\n    :return: Backdoored image.\n    \"\"\"\n    x = np.copy(x)\n    original_dtype = x.dtype\n    shape = x.shape\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 2, 3, 1))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n        x[:, height - distance - 1, width - distance - 1, :] = pixel_value\n        x[:, height - distance, width - distance - 2, :] = pixel_value\n        x[:, height - distance - 2, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n        x[:, height - distance - 1, width - distance - 1] = pixel_value\n        x[:, height - distance, width - distance - 2] = pixel_value\n        x[:, height - distance - 2, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n        x[height - distance - 1, width - distance - 1] = pixel_value\n        x[height - distance, width - distance - 2] = pixel_value\n        x[height - distance - 2, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 3, 1, 2))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    return x.astype(original_dtype)",
        "mutated": [
            "def add_pattern_bd(x: np.ndarray, distance: int=2, pixel_value: int=1, channels_first: bool=False) -> np.ndarray:\n    if False:\n        i = 10\n    '\\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\\n    edge to 1. Works for single images or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\\n    :param distance: Distance from bottom-right walls.\\n    :param pixel_value: Value used to replace the entries of the image matrix.\\n    :param channels_first: If the data is provided in channels first format we transpose to NWHC or HC depending on\\n                           input shape\\n    :return: Backdoored image.\\n    '\n    x = np.copy(x)\n    original_dtype = x.dtype\n    shape = x.shape\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 2, 3, 1))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n        x[:, height - distance - 1, width - distance - 1, :] = pixel_value\n        x[:, height - distance, width - distance - 2, :] = pixel_value\n        x[:, height - distance - 2, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n        x[:, height - distance - 1, width - distance - 1] = pixel_value\n        x[:, height - distance, width - distance - 2] = pixel_value\n        x[:, height - distance - 2, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n        x[height - distance - 1, width - distance - 1] = pixel_value\n        x[height - distance, width - distance - 2] = pixel_value\n        x[height - distance - 2, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 3, 1, 2))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    return x.astype(original_dtype)",
            "def add_pattern_bd(x: np.ndarray, distance: int=2, pixel_value: int=1, channels_first: bool=False) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\\n    edge to 1. Works for single images or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\\n    :param distance: Distance from bottom-right walls.\\n    :param pixel_value: Value used to replace the entries of the image matrix.\\n    :param channels_first: If the data is provided in channels first format we transpose to NWHC or HC depending on\\n                           input shape\\n    :return: Backdoored image.\\n    '\n    x = np.copy(x)\n    original_dtype = x.dtype\n    shape = x.shape\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 2, 3, 1))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n        x[:, height - distance - 1, width - distance - 1, :] = pixel_value\n        x[:, height - distance, width - distance - 2, :] = pixel_value\n        x[:, height - distance - 2, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n        x[:, height - distance - 1, width - distance - 1] = pixel_value\n        x[:, height - distance, width - distance - 2] = pixel_value\n        x[:, height - distance - 2, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n        x[height - distance - 1, width - distance - 1] = pixel_value\n        x[height - distance, width - distance - 2] = pixel_value\n        x[height - distance - 2, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 3, 1, 2))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    return x.astype(original_dtype)",
            "def add_pattern_bd(x: np.ndarray, distance: int=2, pixel_value: int=1, channels_first: bool=False) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\\n    edge to 1. Works for single images or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\\n    :param distance: Distance from bottom-right walls.\\n    :param pixel_value: Value used to replace the entries of the image matrix.\\n    :param channels_first: If the data is provided in channels first format we transpose to NWHC or HC depending on\\n                           input shape\\n    :return: Backdoored image.\\n    '\n    x = np.copy(x)\n    original_dtype = x.dtype\n    shape = x.shape\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 2, 3, 1))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n        x[:, height - distance - 1, width - distance - 1, :] = pixel_value\n        x[:, height - distance, width - distance - 2, :] = pixel_value\n        x[:, height - distance - 2, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n        x[:, height - distance - 1, width - distance - 1] = pixel_value\n        x[:, height - distance, width - distance - 2] = pixel_value\n        x[:, height - distance - 2, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n        x[height - distance - 1, width - distance - 1] = pixel_value\n        x[height - distance, width - distance - 2] = pixel_value\n        x[height - distance - 2, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 3, 1, 2))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    return x.astype(original_dtype)",
            "def add_pattern_bd(x: np.ndarray, distance: int=2, pixel_value: int=1, channels_first: bool=False) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\\n    edge to 1. Works for single images or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\\n    :param distance: Distance from bottom-right walls.\\n    :param pixel_value: Value used to replace the entries of the image matrix.\\n    :param channels_first: If the data is provided in channels first format we transpose to NWHC or HC depending on\\n                           input shape\\n    :return: Backdoored image.\\n    '\n    x = np.copy(x)\n    original_dtype = x.dtype\n    shape = x.shape\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 2, 3, 1))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n        x[:, height - distance - 1, width - distance - 1, :] = pixel_value\n        x[:, height - distance, width - distance - 2, :] = pixel_value\n        x[:, height - distance - 2, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n        x[:, height - distance - 1, width - distance - 1] = pixel_value\n        x[:, height - distance, width - distance - 2] = pixel_value\n        x[:, height - distance - 2, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n        x[height - distance - 1, width - distance - 1] = pixel_value\n        x[height - distance, width - distance - 2] = pixel_value\n        x[height - distance - 2, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 3, 1, 2))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    return x.astype(original_dtype)",
            "def add_pattern_bd(x: np.ndarray, distance: int=2, pixel_value: int=1, channels_first: bool=False) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\\n    edge to 1. Works for single images or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NWHC, NHW, or HC. Pixels will be added to all channels.\\n    :param distance: Distance from bottom-right walls.\\n    :param pixel_value: Value used to replace the entries of the image matrix.\\n    :param channels_first: If the data is provided in channels first format we transpose to NWHC or HC depending on\\n                           input shape\\n    :return: Backdoored image.\\n    '\n    x = np.copy(x)\n    original_dtype = x.dtype\n    shape = x.shape\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 2, 3, 1))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    if len(shape) == 4:\n        (height, width) = x.shape[1:3]\n        x[:, height - distance, width - distance, :] = pixel_value\n        x[:, height - distance - 1, width - distance - 1, :] = pixel_value\n        x[:, height - distance, width - distance - 2, :] = pixel_value\n        x[:, height - distance - 2, width - distance, :] = pixel_value\n    elif len(shape) == 3:\n        (height, width) = x.shape[1:]\n        x[:, height - distance, width - distance] = pixel_value\n        x[:, height - distance - 1, width - distance - 1] = pixel_value\n        x[:, height - distance, width - distance - 2] = pixel_value\n        x[:, height - distance - 2, width - distance] = pixel_value\n    elif len(shape) == 2:\n        (height, width) = x.shape\n        x[height - distance, width - distance] = pixel_value\n        x[height - distance - 1, width - distance - 1] = pixel_value\n        x[height - distance, width - distance - 2] = pixel_value\n        x[height - distance - 2, width - distance] = pixel_value\n    else:\n        raise ValueError(f'Invalid array shape: {shape}')\n    if channels_first:\n        if len(shape) == 4:\n            x = np.transpose(x, (0, 3, 1, 2))\n        if len(shape) == 2:\n            x = np.transpose(x)\n    return x.astype(original_dtype)"
        ]
    },
    {
        "func_name": "insert_image",
        "original": "def insert_image(x: np.ndarray, backdoor_path: str='../utils/data/backdoors/alert.png', channels_first: bool=False, random: bool=True, x_shift: int=0, y_shift: int=0, size: Optional[Tuple[int, int]]=None, mode: str='L', blend=0.8) -> np.ndarray:\n    \"\"\"\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\n    edge to 1. Works for single images or a batch of images.\n\n    :param x: A single image or batch of images of shape NHWC, NCHW, or HWC. Input is in range [0,1].\n    :param backdoor_path: The path to the image to insert as a trigger.\n    :param channels_first: Whether the channels axis is in the first or last dimension\n    :param random: Whether or not the image should be randomly placed somewhere on the image.\n    :param x_shift: Number of pixels from the left to shift the trigger (when not using random placement).\n    :param y_shift: Number of pixels from the right to shift the trigger (when not using random placement).\n    :param size: The size the trigger image should be (height, width). Default `None` if no resizing necessary.\n    :param mode: The mode the image should be read in. See PIL documentation\n                 (https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes).\n    :param blend: The blending factor\n    :return: Backdoored image.\n    \"\"\"\n    from PIL import Image\n    n_dim = len(x.shape)\n    if n_dim == 4:\n        return np.array([insert_image(single_img, backdoor_path, channels_first, random, x_shift, y_shift, size, mode, blend) for single_img in x])\n    if n_dim != 3:\n        raise ValueError(f'Invalid array shape {x.shape}')\n    original_dtype = x.dtype\n    data = np.copy(x)\n    if channels_first:\n        data = np.transpose(data, (1, 2, 0))\n    (height, width, num_channels) = data.shape\n    no_color = num_channels == 1\n    orig_img = Image.new('RGBA', (width, height), 0)\n    backdoored_img = Image.new('RGBA', (width, height), 0)\n    if no_color:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8).squeeze(axis=2), mode=mode)\n    else:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8), mode=mode)\n    orig_img.paste(backdoored_input)\n    trigger = Image.open(backdoor_path).convert('RGBA')\n    if size is not None:\n        trigger = trigger.resize((size[1], size[0]))\n    (backdoor_width, backdoor_height) = trigger.size\n    if backdoor_width > width or backdoor_height > height:\n        raise ValueError('Backdoor does not fit inside original image')\n    if random:\n        x_shift = np.random.randint(width - backdoor_width + 1)\n        y_shift = np.random.randint(height - backdoor_height + 1)\n    backdoored_img.paste(trigger, (x_shift, y_shift), mask=trigger)\n    composite = Image.alpha_composite(orig_img, backdoored_img)\n    backdoored_img = Image.blend(orig_img, composite, blend)\n    backdoored_img = backdoored_img.convert(mode)\n    res = np.asarray(backdoored_img) / 255.0\n    if no_color:\n        res = np.expand_dims(res, 2)\n    if channels_first:\n        res = np.transpose(res, (2, 0, 1))\n    return res.astype(original_dtype)",
        "mutated": [
            "def insert_image(x: np.ndarray, backdoor_path: str='../utils/data/backdoors/alert.png', channels_first: bool=False, random: bool=True, x_shift: int=0, y_shift: int=0, size: Optional[Tuple[int, int]]=None, mode: str='L', blend=0.8) -> np.ndarray:\n    if False:\n        i = 10\n    '\\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\\n    edge to 1. Works for single images or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NHWC, NCHW, or HWC. Input is in range [0,1].\\n    :param backdoor_path: The path to the image to insert as a trigger.\\n    :param channels_first: Whether the channels axis is in the first or last dimension\\n    :param random: Whether or not the image should be randomly placed somewhere on the image.\\n    :param x_shift: Number of pixels from the left to shift the trigger (when not using random placement).\\n    :param y_shift: Number of pixels from the right to shift the trigger (when not using random placement).\\n    :param size: The size the trigger image should be (height, width). Default `None` if no resizing necessary.\\n    :param mode: The mode the image should be read in. See PIL documentation\\n                 (https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes).\\n    :param blend: The blending factor\\n    :return: Backdoored image.\\n    '\n    from PIL import Image\n    n_dim = len(x.shape)\n    if n_dim == 4:\n        return np.array([insert_image(single_img, backdoor_path, channels_first, random, x_shift, y_shift, size, mode, blend) for single_img in x])\n    if n_dim != 3:\n        raise ValueError(f'Invalid array shape {x.shape}')\n    original_dtype = x.dtype\n    data = np.copy(x)\n    if channels_first:\n        data = np.transpose(data, (1, 2, 0))\n    (height, width, num_channels) = data.shape\n    no_color = num_channels == 1\n    orig_img = Image.new('RGBA', (width, height), 0)\n    backdoored_img = Image.new('RGBA', (width, height), 0)\n    if no_color:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8).squeeze(axis=2), mode=mode)\n    else:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8), mode=mode)\n    orig_img.paste(backdoored_input)\n    trigger = Image.open(backdoor_path).convert('RGBA')\n    if size is not None:\n        trigger = trigger.resize((size[1], size[0]))\n    (backdoor_width, backdoor_height) = trigger.size\n    if backdoor_width > width or backdoor_height > height:\n        raise ValueError('Backdoor does not fit inside original image')\n    if random:\n        x_shift = np.random.randint(width - backdoor_width + 1)\n        y_shift = np.random.randint(height - backdoor_height + 1)\n    backdoored_img.paste(trigger, (x_shift, y_shift), mask=trigger)\n    composite = Image.alpha_composite(orig_img, backdoored_img)\n    backdoored_img = Image.blend(orig_img, composite, blend)\n    backdoored_img = backdoored_img.convert(mode)\n    res = np.asarray(backdoored_img) / 255.0\n    if no_color:\n        res = np.expand_dims(res, 2)\n    if channels_first:\n        res = np.transpose(res, (2, 0, 1))\n    return res.astype(original_dtype)",
            "def insert_image(x: np.ndarray, backdoor_path: str='../utils/data/backdoors/alert.png', channels_first: bool=False, random: bool=True, x_shift: int=0, y_shift: int=0, size: Optional[Tuple[int, int]]=None, mode: str='L', blend=0.8) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\\n    edge to 1. Works for single images or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NHWC, NCHW, or HWC. Input is in range [0,1].\\n    :param backdoor_path: The path to the image to insert as a trigger.\\n    :param channels_first: Whether the channels axis is in the first or last dimension\\n    :param random: Whether or not the image should be randomly placed somewhere on the image.\\n    :param x_shift: Number of pixels from the left to shift the trigger (when not using random placement).\\n    :param y_shift: Number of pixels from the right to shift the trigger (when not using random placement).\\n    :param size: The size the trigger image should be (height, width). Default `None` if no resizing necessary.\\n    :param mode: The mode the image should be read in. See PIL documentation\\n                 (https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes).\\n    :param blend: The blending factor\\n    :return: Backdoored image.\\n    '\n    from PIL import Image\n    n_dim = len(x.shape)\n    if n_dim == 4:\n        return np.array([insert_image(single_img, backdoor_path, channels_first, random, x_shift, y_shift, size, mode, blend) for single_img in x])\n    if n_dim != 3:\n        raise ValueError(f'Invalid array shape {x.shape}')\n    original_dtype = x.dtype\n    data = np.copy(x)\n    if channels_first:\n        data = np.transpose(data, (1, 2, 0))\n    (height, width, num_channels) = data.shape\n    no_color = num_channels == 1\n    orig_img = Image.new('RGBA', (width, height), 0)\n    backdoored_img = Image.new('RGBA', (width, height), 0)\n    if no_color:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8).squeeze(axis=2), mode=mode)\n    else:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8), mode=mode)\n    orig_img.paste(backdoored_input)\n    trigger = Image.open(backdoor_path).convert('RGBA')\n    if size is not None:\n        trigger = trigger.resize((size[1], size[0]))\n    (backdoor_width, backdoor_height) = trigger.size\n    if backdoor_width > width or backdoor_height > height:\n        raise ValueError('Backdoor does not fit inside original image')\n    if random:\n        x_shift = np.random.randint(width - backdoor_width + 1)\n        y_shift = np.random.randint(height - backdoor_height + 1)\n    backdoored_img.paste(trigger, (x_shift, y_shift), mask=trigger)\n    composite = Image.alpha_composite(orig_img, backdoored_img)\n    backdoored_img = Image.blend(orig_img, composite, blend)\n    backdoored_img = backdoored_img.convert(mode)\n    res = np.asarray(backdoored_img) / 255.0\n    if no_color:\n        res = np.expand_dims(res, 2)\n    if channels_first:\n        res = np.transpose(res, (2, 0, 1))\n    return res.astype(original_dtype)",
            "def insert_image(x: np.ndarray, backdoor_path: str='../utils/data/backdoors/alert.png', channels_first: bool=False, random: bool=True, x_shift: int=0, y_shift: int=0, size: Optional[Tuple[int, int]]=None, mode: str='L', blend=0.8) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\\n    edge to 1. Works for single images or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NHWC, NCHW, or HWC. Input is in range [0,1].\\n    :param backdoor_path: The path to the image to insert as a trigger.\\n    :param channels_first: Whether the channels axis is in the first or last dimension\\n    :param random: Whether or not the image should be randomly placed somewhere on the image.\\n    :param x_shift: Number of pixels from the left to shift the trigger (when not using random placement).\\n    :param y_shift: Number of pixels from the right to shift the trigger (when not using random placement).\\n    :param size: The size the trigger image should be (height, width). Default `None` if no resizing necessary.\\n    :param mode: The mode the image should be read in. See PIL documentation\\n                 (https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes).\\n    :param blend: The blending factor\\n    :return: Backdoored image.\\n    '\n    from PIL import Image\n    n_dim = len(x.shape)\n    if n_dim == 4:\n        return np.array([insert_image(single_img, backdoor_path, channels_first, random, x_shift, y_shift, size, mode, blend) for single_img in x])\n    if n_dim != 3:\n        raise ValueError(f'Invalid array shape {x.shape}')\n    original_dtype = x.dtype\n    data = np.copy(x)\n    if channels_first:\n        data = np.transpose(data, (1, 2, 0))\n    (height, width, num_channels) = data.shape\n    no_color = num_channels == 1\n    orig_img = Image.new('RGBA', (width, height), 0)\n    backdoored_img = Image.new('RGBA', (width, height), 0)\n    if no_color:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8).squeeze(axis=2), mode=mode)\n    else:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8), mode=mode)\n    orig_img.paste(backdoored_input)\n    trigger = Image.open(backdoor_path).convert('RGBA')\n    if size is not None:\n        trigger = trigger.resize((size[1], size[0]))\n    (backdoor_width, backdoor_height) = trigger.size\n    if backdoor_width > width or backdoor_height > height:\n        raise ValueError('Backdoor does not fit inside original image')\n    if random:\n        x_shift = np.random.randint(width - backdoor_width + 1)\n        y_shift = np.random.randint(height - backdoor_height + 1)\n    backdoored_img.paste(trigger, (x_shift, y_shift), mask=trigger)\n    composite = Image.alpha_composite(orig_img, backdoored_img)\n    backdoored_img = Image.blend(orig_img, composite, blend)\n    backdoored_img = backdoored_img.convert(mode)\n    res = np.asarray(backdoored_img) / 255.0\n    if no_color:\n        res = np.expand_dims(res, 2)\n    if channels_first:\n        res = np.transpose(res, (2, 0, 1))\n    return res.astype(original_dtype)",
            "def insert_image(x: np.ndarray, backdoor_path: str='../utils/data/backdoors/alert.png', channels_first: bool=False, random: bool=True, x_shift: int=0, y_shift: int=0, size: Optional[Tuple[int, int]]=None, mode: str='L', blend=0.8) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\\n    edge to 1. Works for single images or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NHWC, NCHW, or HWC. Input is in range [0,1].\\n    :param backdoor_path: The path to the image to insert as a trigger.\\n    :param channels_first: Whether the channels axis is in the first or last dimension\\n    :param random: Whether or not the image should be randomly placed somewhere on the image.\\n    :param x_shift: Number of pixels from the left to shift the trigger (when not using random placement).\\n    :param y_shift: Number of pixels from the right to shift the trigger (when not using random placement).\\n    :param size: The size the trigger image should be (height, width). Default `None` if no resizing necessary.\\n    :param mode: The mode the image should be read in. See PIL documentation\\n                 (https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes).\\n    :param blend: The blending factor\\n    :return: Backdoored image.\\n    '\n    from PIL import Image\n    n_dim = len(x.shape)\n    if n_dim == 4:\n        return np.array([insert_image(single_img, backdoor_path, channels_first, random, x_shift, y_shift, size, mode, blend) for single_img in x])\n    if n_dim != 3:\n        raise ValueError(f'Invalid array shape {x.shape}')\n    original_dtype = x.dtype\n    data = np.copy(x)\n    if channels_first:\n        data = np.transpose(data, (1, 2, 0))\n    (height, width, num_channels) = data.shape\n    no_color = num_channels == 1\n    orig_img = Image.new('RGBA', (width, height), 0)\n    backdoored_img = Image.new('RGBA', (width, height), 0)\n    if no_color:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8).squeeze(axis=2), mode=mode)\n    else:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8), mode=mode)\n    orig_img.paste(backdoored_input)\n    trigger = Image.open(backdoor_path).convert('RGBA')\n    if size is not None:\n        trigger = trigger.resize((size[1], size[0]))\n    (backdoor_width, backdoor_height) = trigger.size\n    if backdoor_width > width or backdoor_height > height:\n        raise ValueError('Backdoor does not fit inside original image')\n    if random:\n        x_shift = np.random.randint(width - backdoor_width + 1)\n        y_shift = np.random.randint(height - backdoor_height + 1)\n    backdoored_img.paste(trigger, (x_shift, y_shift), mask=trigger)\n    composite = Image.alpha_composite(orig_img, backdoored_img)\n    backdoored_img = Image.blend(orig_img, composite, blend)\n    backdoored_img = backdoored_img.convert(mode)\n    res = np.asarray(backdoored_img) / 255.0\n    if no_color:\n        res = np.expand_dims(res, 2)\n    if channels_first:\n        res = np.transpose(res, (2, 0, 1))\n    return res.astype(original_dtype)",
            "def insert_image(x: np.ndarray, backdoor_path: str='../utils/data/backdoors/alert.png', channels_first: bool=False, random: bool=True, x_shift: int=0, y_shift: int=0, size: Optional[Tuple[int, int]]=None, mode: str='L', blend=0.8) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Augments a matrix by setting a checkerboard-like pattern of values some `distance` away from the bottom-right\\n    edge to 1. Works for single images or a batch of images.\\n\\n    :param x: A single image or batch of images of shape NHWC, NCHW, or HWC. Input is in range [0,1].\\n    :param backdoor_path: The path to the image to insert as a trigger.\\n    :param channels_first: Whether the channels axis is in the first or last dimension\\n    :param random: Whether or not the image should be randomly placed somewhere on the image.\\n    :param x_shift: Number of pixels from the left to shift the trigger (when not using random placement).\\n    :param y_shift: Number of pixels from the right to shift the trigger (when not using random placement).\\n    :param size: The size the trigger image should be (height, width). Default `None` if no resizing necessary.\\n    :param mode: The mode the image should be read in. See PIL documentation\\n                 (https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes).\\n    :param blend: The blending factor\\n    :return: Backdoored image.\\n    '\n    from PIL import Image\n    n_dim = len(x.shape)\n    if n_dim == 4:\n        return np.array([insert_image(single_img, backdoor_path, channels_first, random, x_shift, y_shift, size, mode, blend) for single_img in x])\n    if n_dim != 3:\n        raise ValueError(f'Invalid array shape {x.shape}')\n    original_dtype = x.dtype\n    data = np.copy(x)\n    if channels_first:\n        data = np.transpose(data, (1, 2, 0))\n    (height, width, num_channels) = data.shape\n    no_color = num_channels == 1\n    orig_img = Image.new('RGBA', (width, height), 0)\n    backdoored_img = Image.new('RGBA', (width, height), 0)\n    if no_color:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8).squeeze(axis=2), mode=mode)\n    else:\n        backdoored_input = Image.fromarray((data * 255).astype(np.uint8), mode=mode)\n    orig_img.paste(backdoored_input)\n    trigger = Image.open(backdoor_path).convert('RGBA')\n    if size is not None:\n        trigger = trigger.resize((size[1], size[0]))\n    (backdoor_width, backdoor_height) = trigger.size\n    if backdoor_width > width or backdoor_height > height:\n        raise ValueError('Backdoor does not fit inside original image')\n    if random:\n        x_shift = np.random.randint(width - backdoor_width + 1)\n        y_shift = np.random.randint(height - backdoor_height + 1)\n    backdoored_img.paste(trigger, (x_shift, y_shift), mask=trigger)\n    composite = Image.alpha_composite(orig_img, backdoored_img)\n    backdoored_img = Image.blend(orig_img, composite, blend)\n    backdoored_img = backdoored_img.convert(mode)\n    res = np.asarray(backdoored_img) / 255.0\n    if no_color:\n        res = np.expand_dims(res, 2)\n    if channels_first:\n        res = np.transpose(res, (2, 0, 1))\n    return res.astype(original_dtype)"
        ]
    }
]