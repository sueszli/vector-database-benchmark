[
    {
        "func_name": "add_plugin",
        "original": "def add_plugin():\n    pass",
        "mutated": [
            "def add_plugin():\n    if False:\n        i = 10\n    pass",
            "def add_plugin():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    pass",
            "def add_plugin():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    pass",
            "def add_plugin():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    pass",
            "def add_plugin():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    pass"
        ]
    },
    {
        "func_name": "patch",
        "original": "def patch(f):\n    \"\"\"Adds method f to the DataFrame class\"\"\"\n    name = f.__name__\n    setattr(DataFrame, name, _hidden(f))\n    return f",
        "mutated": [
            "def patch(f):\n    if False:\n        i = 10\n    'Adds method f to the DataFrame class'\n    name = f.__name__\n    setattr(DataFrame, name, _hidden(f))\n    return f",
            "def patch(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Adds method f to the DataFrame class'\n    name = f.__name__\n    setattr(DataFrame, name, _hidden(f))\n    return f",
            "def patch(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Adds method f to the DataFrame class'\n    name = f.__name__\n    setattr(DataFrame, name, _hidden(f))\n    return f",
            "def patch(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Adds method f to the DataFrame class'\n    name = f.__name__\n    setattr(DataFrame, name, _hidden(f))\n    return f",
            "def patch(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Adds method f to the DataFrame class'\n    name = f.__name__\n    setattr(DataFrame, name, _hidden(f))\n    return f"
        ]
    },
    {
        "func_name": "wrapper",
        "original": "@functools.wraps(f)\ndef wrapper(self, *args, **kwargs):\n    return f(self.df, *args, **kwargs)",
        "mutated": [
            "@functools.wraps(f)\ndef wrapper(self, *args, **kwargs):\n    if False:\n        i = 10\n    return f(self.df, *args, **kwargs)",
            "@functools.wraps(f)\ndef wrapper(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return f(self.df, *args, **kwargs)",
            "@functools.wraps(f)\ndef wrapper(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return f(self.df, *args, **kwargs)",
            "@functools.wraps(f)\ndef wrapper(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return f(self.df, *args, **kwargs)",
            "@functools.wraps(f)\ndef wrapper(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return f(self.df, *args, **kwargs)"
        ]
    },
    {
        "func_name": "viz_method",
        "original": "def viz_method(f):\n\n    @functools.wraps(f)\n    def wrapper(self, *args, **kwargs):\n        return f(self.df, *args, **kwargs)\n    from . import DataFrameAccessorViz as cls\n    setattr(cls, f.__name__, wrapper)",
        "mutated": [
            "def viz_method(f):\n    if False:\n        i = 10\n\n    @functools.wraps(f)\n    def wrapper(self, *args, **kwargs):\n        return f(self.df, *args, **kwargs)\n    from . import DataFrameAccessorViz as cls\n    setattr(cls, f.__name__, wrapper)",
            "def viz_method(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n\n    @functools.wraps(f)\n    def wrapper(self, *args, **kwargs):\n        return f(self.df, *args, **kwargs)\n    from . import DataFrameAccessorViz as cls\n    setattr(cls, f.__name__, wrapper)",
            "def viz_method(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n    @functools.wraps(f)\n    def wrapper(self, *args, **kwargs):\n        return f(self.df, *args, **kwargs)\n    from . import DataFrameAccessorViz as cls\n    setattr(cls, f.__name__, wrapper)",
            "def viz_method(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n\n    @functools.wraps(f)\n    def wrapper(self, *args, **kwargs):\n        return f(self.df, *args, **kwargs)\n    from . import DataFrameAccessorViz as cls\n    setattr(cls, f.__name__, wrapper)",
            "def viz_method(f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n\n    @functools.wraps(f)\n    def wrapper(self, *args, **kwargs):\n        return f(self.df, *args, **kwargs)\n    from . import DataFrameAccessorViz as cls\n    setattr(cls, f.__name__, wrapper)"
        ]
    },
    {
        "func_name": "plot1d",
        "original": "@patch\ndef plot1d(self, *args, **kwargs):\n    warnings.warn('`plot1d` is deprecated and it will be removed in version 5.x. Please use `df.viz.histogram` instead.')\n    self.viz.histogram(*args, **kwargs)",
        "mutated": [
            "@patch\ndef plot1d(self, *args, **kwargs):\n    if False:\n        i = 10\n    warnings.warn('`plot1d` is deprecated and it will be removed in version 5.x. Please use `df.viz.histogram` instead.')\n    self.viz.histogram(*args, **kwargs)",
            "@patch\ndef plot1d(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    warnings.warn('`plot1d` is deprecated and it will be removed in version 5.x. Please use `df.viz.histogram` instead.')\n    self.viz.histogram(*args, **kwargs)",
            "@patch\ndef plot1d(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    warnings.warn('`plot1d` is deprecated and it will be removed in version 5.x. Please use `df.viz.histogram` instead.')\n    self.viz.histogram(*args, **kwargs)",
            "@patch\ndef plot1d(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    warnings.warn('`plot1d` is deprecated and it will be removed in version 5.x. Please use `df.viz.histogram` instead.')\n    self.viz.histogram(*args, **kwargs)",
            "@patch\ndef plot1d(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    warnings.warn('`plot1d` is deprecated and it will be removed in version 5.x. Please use `df.viz.histogram` instead.')\n    self.viz.histogram(*args, **kwargs)"
        ]
    },
    {
        "func_name": "histogram",
        "original": "@viz_method\n@docsubst\ndef histogram(self, x=None, what='count(*)', grid=None, shape=64, facet=None, limits=None, figsize=None, f='identity', n=None, normalize_axis=None, xlabel=None, ylabel=None, label=None, selection=None, show=False, tight_layout=True, hardcopy=None, progress=None, **kwargs):\n    \"\"\"Plot a histogram.\n\n    Example:\n\n    >>> df.histogram(df.x)\n    >>> df.histogram(df.x, limits=[0, 100], shape=100)\n    >>> df.histogram(df.x, what='mean(y)', limits=[0, 100], shape=100)\n\n    If you want to do a computation yourself, pass the grid argument, but you are responsible for passing the\n    same limits arguments:\n\n    >>> counts = df.mean(df.y, binby=df.x, limits=[0, 100], shape=100)/100.\n    >>> df.histogram(df.x, limits=[0, 100], shape=100, grid=means, label='mean(y)/100')\n\n    :param x: {expression_one}\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum\n    :param grid: {grid}\n    :param shape: {shape}\n    :param facet: Expression to produce facetted plots ( facet='x:0,1,12' will produce 12 plots with x in a range between 0 and 1)\n    :param limits: {limits}\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\n    :param n: normalization function, currently only 'normalize' is supported, or None for no normalization\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\n    :param selection: {selection}\n    :param xlabel: String for label on x axis (may contain latex)\n    :param ylabel: Same for y axis\n    :param: tight_layout: call plt.tight_layout or not\n    :param kwargs: extra argument passed to plt.plot\n    :return:\n    \"\"\"\n    import matplotlib.pyplot as plt\n    f = _parse_f(f)\n    n = _parse_n(n)\n    if type(shape) == int:\n        shape = (shape,)\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    for expression in [x]:\n        if expression is not None:\n            binby = [expression] + binby\n    limits = self.limits(binby, limits)\n    if figsize is not None:\n        plt.figure(num=None, figsize=figsize, dpi=80, facecolor='w', edgecolor='k')\n    fig = plt.gcf()\n    import re\n    if facet is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', facet)\n        if match:\n            groups = match.groups()\n            facet_expression = groups[0]\n            facet_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            facet_count = ast.literal_eval(groups[3])\n            limits.append(facet_limits)\n            binby.append(facet_expression)\n            shape = (facet_count,) + shape\n        else:\n            raise ValueError(\"Could not understand 'facet' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    if grid is None:\n        if what:\n            if isinstance(what, vaex.stat.Expression):\n                grid = what.calculate(self, binby=binby, limits=limits, shape=shape, selection=selection)\n            else:\n                what = what.strip()\n                index = what.index('(')\n                import re\n                groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                if groups and len(groups) == 2:\n                    function = groups[0]\n                    arguments = groups[1].strip()\n                    functions = ['mean', 'sum', 'std', 'count']\n                    if function in functions:\n                        grid = getattr(vaex.stat, function)(arguments).calculate(self, binby=binby, limits=limits, shape=shape, selection=selection, progress=progress)\n                    elif function == 'count' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                    elif function == 'cumulative' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                        grid = np.cumsum(grid)\n                    else:\n                        raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                else:\n                    raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n        else:\n            grid = self.histogram(binby, size=shape, limits=limits, selection=selection)\n    if len(grid.shape) > 1 and _issequence(selection):\n        grid = grid.T\n    fgrid = f(grid)\n    if n is not None:\n        ngrid = fgrid / fgrid.sum()\n    else:\n        ngrid = fgrid\n    (xmin, xmax) = limits[-1]\n    if facet:\n        N = len(grid[-1])\n    else:\n        N = len(grid)\n    xexpression = binby[0]\n    xar = np.arange(N + 1) / (N - 0.0) * (xmax - xmin) + xmin\n    label = str(label or selection or x)\n    if facet:\n        import math\n        (rows, columns) = (int(math.ceil(facet_count / 4.0)), 4)\n        values = np.linspace(facet_limits[0], facet_limits[1], facet_count + 1)\n        for i in range(facet_count):\n            ax = plt.subplot(rows, columns, i + 1)\n            value = ax.plot(xar, ngrid[i], drawstyle='steps-mid', label=label, **kwargs)\n            (v1, v2) = (values[i], values[i + 1])\n            plt.xlabel(xlabel or x)\n            plt.ylabel(ylabel or what)\n            ax.set_title('%3f <= %s < %3f' % (v1, facet_expression, v2))\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = len(labels) // max_labels\n                plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    else:\n        plt.xlabel(xlabel or self.label(x))\n        plt.ylabel(ylabel or what)\n        g = np.concatenate([ngrid[0:1], ngrid])\n        value = plt.plot(xar, g, drawstyle='steps-pre', label=label, **kwargs)\n        if self.iscategory(xexpression):\n            labels = self.category_labels(xexpression)\n            step = len(labels) // max_labels\n            plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    if tight_layout:\n        plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    return value",
        "mutated": [
            "@viz_method\n@docsubst\ndef histogram(self, x=None, what='count(*)', grid=None, shape=64, facet=None, limits=None, figsize=None, f='identity', n=None, normalize_axis=None, xlabel=None, ylabel=None, label=None, selection=None, show=False, tight_layout=True, hardcopy=None, progress=None, **kwargs):\n    if False:\n        i = 10\n    \"Plot a histogram.\\n\\n    Example:\\n\\n    >>> df.histogram(df.x)\\n    >>> df.histogram(df.x, limits=[0, 100], shape=100)\\n    >>> df.histogram(df.x, what='mean(y)', limits=[0, 100], shape=100)\\n\\n    If you want to do a computation yourself, pass the grid argument, but you are responsible for passing the\\n    same limits arguments:\\n\\n    >>> counts = df.mean(df.y, binby=df.x, limits=[0, 100], shape=100)/100.\\n    >>> df.histogram(df.x, limits=[0, 100], shape=100, grid=means, label='mean(y)/100')\\n\\n    :param x: {expression_one}\\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum\\n    :param grid: {grid}\\n    :param shape: {shape}\\n    :param facet: Expression to produce facetted plots ( facet='x:0,1,12' will produce 12 plots with x in a range between 0 and 1)\\n    :param limits: {limits}\\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\\n    :param n: normalization function, currently only 'normalize' is supported, or None for no normalization\\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\\n    :param selection: {selection}\\n    :param xlabel: String for label on x axis (may contain latex)\\n    :param ylabel: Same for y axis\\n    :param: tight_layout: call plt.tight_layout or not\\n    :param kwargs: extra argument passed to plt.plot\\n    :return:\\n    \"\n    import matplotlib.pyplot as plt\n    f = _parse_f(f)\n    n = _parse_n(n)\n    if type(shape) == int:\n        shape = (shape,)\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    for expression in [x]:\n        if expression is not None:\n            binby = [expression] + binby\n    limits = self.limits(binby, limits)\n    if figsize is not None:\n        plt.figure(num=None, figsize=figsize, dpi=80, facecolor='w', edgecolor='k')\n    fig = plt.gcf()\n    import re\n    if facet is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', facet)\n        if match:\n            groups = match.groups()\n            facet_expression = groups[0]\n            facet_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            facet_count = ast.literal_eval(groups[3])\n            limits.append(facet_limits)\n            binby.append(facet_expression)\n            shape = (facet_count,) + shape\n        else:\n            raise ValueError(\"Could not understand 'facet' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    if grid is None:\n        if what:\n            if isinstance(what, vaex.stat.Expression):\n                grid = what.calculate(self, binby=binby, limits=limits, shape=shape, selection=selection)\n            else:\n                what = what.strip()\n                index = what.index('(')\n                import re\n                groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                if groups and len(groups) == 2:\n                    function = groups[0]\n                    arguments = groups[1].strip()\n                    functions = ['mean', 'sum', 'std', 'count']\n                    if function in functions:\n                        grid = getattr(vaex.stat, function)(arguments).calculate(self, binby=binby, limits=limits, shape=shape, selection=selection, progress=progress)\n                    elif function == 'count' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                    elif function == 'cumulative' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                        grid = np.cumsum(grid)\n                    else:\n                        raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                else:\n                    raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n        else:\n            grid = self.histogram(binby, size=shape, limits=limits, selection=selection)\n    if len(grid.shape) > 1 and _issequence(selection):\n        grid = grid.T\n    fgrid = f(grid)\n    if n is not None:\n        ngrid = fgrid / fgrid.sum()\n    else:\n        ngrid = fgrid\n    (xmin, xmax) = limits[-1]\n    if facet:\n        N = len(grid[-1])\n    else:\n        N = len(grid)\n    xexpression = binby[0]\n    xar = np.arange(N + 1) / (N - 0.0) * (xmax - xmin) + xmin\n    label = str(label or selection or x)\n    if facet:\n        import math\n        (rows, columns) = (int(math.ceil(facet_count / 4.0)), 4)\n        values = np.linspace(facet_limits[0], facet_limits[1], facet_count + 1)\n        for i in range(facet_count):\n            ax = plt.subplot(rows, columns, i + 1)\n            value = ax.plot(xar, ngrid[i], drawstyle='steps-mid', label=label, **kwargs)\n            (v1, v2) = (values[i], values[i + 1])\n            plt.xlabel(xlabel or x)\n            plt.ylabel(ylabel or what)\n            ax.set_title('%3f <= %s < %3f' % (v1, facet_expression, v2))\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = len(labels) // max_labels\n                plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    else:\n        plt.xlabel(xlabel or self.label(x))\n        plt.ylabel(ylabel or what)\n        g = np.concatenate([ngrid[0:1], ngrid])\n        value = plt.plot(xar, g, drawstyle='steps-pre', label=label, **kwargs)\n        if self.iscategory(xexpression):\n            labels = self.category_labels(xexpression)\n            step = len(labels) // max_labels\n            plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    if tight_layout:\n        plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    return value",
            "@viz_method\n@docsubst\ndef histogram(self, x=None, what='count(*)', grid=None, shape=64, facet=None, limits=None, figsize=None, f='identity', n=None, normalize_axis=None, xlabel=None, ylabel=None, label=None, selection=None, show=False, tight_layout=True, hardcopy=None, progress=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Plot a histogram.\\n\\n    Example:\\n\\n    >>> df.histogram(df.x)\\n    >>> df.histogram(df.x, limits=[0, 100], shape=100)\\n    >>> df.histogram(df.x, what='mean(y)', limits=[0, 100], shape=100)\\n\\n    If you want to do a computation yourself, pass the grid argument, but you are responsible for passing the\\n    same limits arguments:\\n\\n    >>> counts = df.mean(df.y, binby=df.x, limits=[0, 100], shape=100)/100.\\n    >>> df.histogram(df.x, limits=[0, 100], shape=100, grid=means, label='mean(y)/100')\\n\\n    :param x: {expression_one}\\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum\\n    :param grid: {grid}\\n    :param shape: {shape}\\n    :param facet: Expression to produce facetted plots ( facet='x:0,1,12' will produce 12 plots with x in a range between 0 and 1)\\n    :param limits: {limits}\\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\\n    :param n: normalization function, currently only 'normalize' is supported, or None for no normalization\\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\\n    :param selection: {selection}\\n    :param xlabel: String for label on x axis (may contain latex)\\n    :param ylabel: Same for y axis\\n    :param: tight_layout: call plt.tight_layout or not\\n    :param kwargs: extra argument passed to plt.plot\\n    :return:\\n    \"\n    import matplotlib.pyplot as plt\n    f = _parse_f(f)\n    n = _parse_n(n)\n    if type(shape) == int:\n        shape = (shape,)\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    for expression in [x]:\n        if expression is not None:\n            binby = [expression] + binby\n    limits = self.limits(binby, limits)\n    if figsize is not None:\n        plt.figure(num=None, figsize=figsize, dpi=80, facecolor='w', edgecolor='k')\n    fig = plt.gcf()\n    import re\n    if facet is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', facet)\n        if match:\n            groups = match.groups()\n            facet_expression = groups[0]\n            facet_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            facet_count = ast.literal_eval(groups[3])\n            limits.append(facet_limits)\n            binby.append(facet_expression)\n            shape = (facet_count,) + shape\n        else:\n            raise ValueError(\"Could not understand 'facet' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    if grid is None:\n        if what:\n            if isinstance(what, vaex.stat.Expression):\n                grid = what.calculate(self, binby=binby, limits=limits, shape=shape, selection=selection)\n            else:\n                what = what.strip()\n                index = what.index('(')\n                import re\n                groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                if groups and len(groups) == 2:\n                    function = groups[0]\n                    arguments = groups[1].strip()\n                    functions = ['mean', 'sum', 'std', 'count']\n                    if function in functions:\n                        grid = getattr(vaex.stat, function)(arguments).calculate(self, binby=binby, limits=limits, shape=shape, selection=selection, progress=progress)\n                    elif function == 'count' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                    elif function == 'cumulative' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                        grid = np.cumsum(grid)\n                    else:\n                        raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                else:\n                    raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n        else:\n            grid = self.histogram(binby, size=shape, limits=limits, selection=selection)\n    if len(grid.shape) > 1 and _issequence(selection):\n        grid = grid.T\n    fgrid = f(grid)\n    if n is not None:\n        ngrid = fgrid / fgrid.sum()\n    else:\n        ngrid = fgrid\n    (xmin, xmax) = limits[-1]\n    if facet:\n        N = len(grid[-1])\n    else:\n        N = len(grid)\n    xexpression = binby[0]\n    xar = np.arange(N + 1) / (N - 0.0) * (xmax - xmin) + xmin\n    label = str(label or selection or x)\n    if facet:\n        import math\n        (rows, columns) = (int(math.ceil(facet_count / 4.0)), 4)\n        values = np.linspace(facet_limits[0], facet_limits[1], facet_count + 1)\n        for i in range(facet_count):\n            ax = plt.subplot(rows, columns, i + 1)\n            value = ax.plot(xar, ngrid[i], drawstyle='steps-mid', label=label, **kwargs)\n            (v1, v2) = (values[i], values[i + 1])\n            plt.xlabel(xlabel or x)\n            plt.ylabel(ylabel or what)\n            ax.set_title('%3f <= %s < %3f' % (v1, facet_expression, v2))\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = len(labels) // max_labels\n                plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    else:\n        plt.xlabel(xlabel or self.label(x))\n        plt.ylabel(ylabel or what)\n        g = np.concatenate([ngrid[0:1], ngrid])\n        value = plt.plot(xar, g, drawstyle='steps-pre', label=label, **kwargs)\n        if self.iscategory(xexpression):\n            labels = self.category_labels(xexpression)\n            step = len(labels) // max_labels\n            plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    if tight_layout:\n        plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    return value",
            "@viz_method\n@docsubst\ndef histogram(self, x=None, what='count(*)', grid=None, shape=64, facet=None, limits=None, figsize=None, f='identity', n=None, normalize_axis=None, xlabel=None, ylabel=None, label=None, selection=None, show=False, tight_layout=True, hardcopy=None, progress=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Plot a histogram.\\n\\n    Example:\\n\\n    >>> df.histogram(df.x)\\n    >>> df.histogram(df.x, limits=[0, 100], shape=100)\\n    >>> df.histogram(df.x, what='mean(y)', limits=[0, 100], shape=100)\\n\\n    If you want to do a computation yourself, pass the grid argument, but you are responsible for passing the\\n    same limits arguments:\\n\\n    >>> counts = df.mean(df.y, binby=df.x, limits=[0, 100], shape=100)/100.\\n    >>> df.histogram(df.x, limits=[0, 100], shape=100, grid=means, label='mean(y)/100')\\n\\n    :param x: {expression_one}\\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum\\n    :param grid: {grid}\\n    :param shape: {shape}\\n    :param facet: Expression to produce facetted plots ( facet='x:0,1,12' will produce 12 plots with x in a range between 0 and 1)\\n    :param limits: {limits}\\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\\n    :param n: normalization function, currently only 'normalize' is supported, or None for no normalization\\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\\n    :param selection: {selection}\\n    :param xlabel: String for label on x axis (may contain latex)\\n    :param ylabel: Same for y axis\\n    :param: tight_layout: call plt.tight_layout or not\\n    :param kwargs: extra argument passed to plt.plot\\n    :return:\\n    \"\n    import matplotlib.pyplot as plt\n    f = _parse_f(f)\n    n = _parse_n(n)\n    if type(shape) == int:\n        shape = (shape,)\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    for expression in [x]:\n        if expression is not None:\n            binby = [expression] + binby\n    limits = self.limits(binby, limits)\n    if figsize is not None:\n        plt.figure(num=None, figsize=figsize, dpi=80, facecolor='w', edgecolor='k')\n    fig = plt.gcf()\n    import re\n    if facet is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', facet)\n        if match:\n            groups = match.groups()\n            facet_expression = groups[0]\n            facet_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            facet_count = ast.literal_eval(groups[3])\n            limits.append(facet_limits)\n            binby.append(facet_expression)\n            shape = (facet_count,) + shape\n        else:\n            raise ValueError(\"Could not understand 'facet' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    if grid is None:\n        if what:\n            if isinstance(what, vaex.stat.Expression):\n                grid = what.calculate(self, binby=binby, limits=limits, shape=shape, selection=selection)\n            else:\n                what = what.strip()\n                index = what.index('(')\n                import re\n                groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                if groups and len(groups) == 2:\n                    function = groups[0]\n                    arguments = groups[1].strip()\n                    functions = ['mean', 'sum', 'std', 'count']\n                    if function in functions:\n                        grid = getattr(vaex.stat, function)(arguments).calculate(self, binby=binby, limits=limits, shape=shape, selection=selection, progress=progress)\n                    elif function == 'count' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                    elif function == 'cumulative' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                        grid = np.cumsum(grid)\n                    else:\n                        raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                else:\n                    raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n        else:\n            grid = self.histogram(binby, size=shape, limits=limits, selection=selection)\n    if len(grid.shape) > 1 and _issequence(selection):\n        grid = grid.T\n    fgrid = f(grid)\n    if n is not None:\n        ngrid = fgrid / fgrid.sum()\n    else:\n        ngrid = fgrid\n    (xmin, xmax) = limits[-1]\n    if facet:\n        N = len(grid[-1])\n    else:\n        N = len(grid)\n    xexpression = binby[0]\n    xar = np.arange(N + 1) / (N - 0.0) * (xmax - xmin) + xmin\n    label = str(label or selection or x)\n    if facet:\n        import math\n        (rows, columns) = (int(math.ceil(facet_count / 4.0)), 4)\n        values = np.linspace(facet_limits[0], facet_limits[1], facet_count + 1)\n        for i in range(facet_count):\n            ax = plt.subplot(rows, columns, i + 1)\n            value = ax.plot(xar, ngrid[i], drawstyle='steps-mid', label=label, **kwargs)\n            (v1, v2) = (values[i], values[i + 1])\n            plt.xlabel(xlabel or x)\n            plt.ylabel(ylabel or what)\n            ax.set_title('%3f <= %s < %3f' % (v1, facet_expression, v2))\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = len(labels) // max_labels\n                plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    else:\n        plt.xlabel(xlabel or self.label(x))\n        plt.ylabel(ylabel or what)\n        g = np.concatenate([ngrid[0:1], ngrid])\n        value = plt.plot(xar, g, drawstyle='steps-pre', label=label, **kwargs)\n        if self.iscategory(xexpression):\n            labels = self.category_labels(xexpression)\n            step = len(labels) // max_labels\n            plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    if tight_layout:\n        plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    return value",
            "@viz_method\n@docsubst\ndef histogram(self, x=None, what='count(*)', grid=None, shape=64, facet=None, limits=None, figsize=None, f='identity', n=None, normalize_axis=None, xlabel=None, ylabel=None, label=None, selection=None, show=False, tight_layout=True, hardcopy=None, progress=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Plot a histogram.\\n\\n    Example:\\n\\n    >>> df.histogram(df.x)\\n    >>> df.histogram(df.x, limits=[0, 100], shape=100)\\n    >>> df.histogram(df.x, what='mean(y)', limits=[0, 100], shape=100)\\n\\n    If you want to do a computation yourself, pass the grid argument, but you are responsible for passing the\\n    same limits arguments:\\n\\n    >>> counts = df.mean(df.y, binby=df.x, limits=[0, 100], shape=100)/100.\\n    >>> df.histogram(df.x, limits=[0, 100], shape=100, grid=means, label='mean(y)/100')\\n\\n    :param x: {expression_one}\\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum\\n    :param grid: {grid}\\n    :param shape: {shape}\\n    :param facet: Expression to produce facetted plots ( facet='x:0,1,12' will produce 12 plots with x in a range between 0 and 1)\\n    :param limits: {limits}\\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\\n    :param n: normalization function, currently only 'normalize' is supported, or None for no normalization\\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\\n    :param selection: {selection}\\n    :param xlabel: String for label on x axis (may contain latex)\\n    :param ylabel: Same for y axis\\n    :param: tight_layout: call plt.tight_layout or not\\n    :param kwargs: extra argument passed to plt.plot\\n    :return:\\n    \"\n    import matplotlib.pyplot as plt\n    f = _parse_f(f)\n    n = _parse_n(n)\n    if type(shape) == int:\n        shape = (shape,)\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    for expression in [x]:\n        if expression is not None:\n            binby = [expression] + binby\n    limits = self.limits(binby, limits)\n    if figsize is not None:\n        plt.figure(num=None, figsize=figsize, dpi=80, facecolor='w', edgecolor='k')\n    fig = plt.gcf()\n    import re\n    if facet is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', facet)\n        if match:\n            groups = match.groups()\n            facet_expression = groups[0]\n            facet_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            facet_count = ast.literal_eval(groups[3])\n            limits.append(facet_limits)\n            binby.append(facet_expression)\n            shape = (facet_count,) + shape\n        else:\n            raise ValueError(\"Could not understand 'facet' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    if grid is None:\n        if what:\n            if isinstance(what, vaex.stat.Expression):\n                grid = what.calculate(self, binby=binby, limits=limits, shape=shape, selection=selection)\n            else:\n                what = what.strip()\n                index = what.index('(')\n                import re\n                groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                if groups and len(groups) == 2:\n                    function = groups[0]\n                    arguments = groups[1].strip()\n                    functions = ['mean', 'sum', 'std', 'count']\n                    if function in functions:\n                        grid = getattr(vaex.stat, function)(arguments).calculate(self, binby=binby, limits=limits, shape=shape, selection=selection, progress=progress)\n                    elif function == 'count' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                    elif function == 'cumulative' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                        grid = np.cumsum(grid)\n                    else:\n                        raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                else:\n                    raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n        else:\n            grid = self.histogram(binby, size=shape, limits=limits, selection=selection)\n    if len(grid.shape) > 1 and _issequence(selection):\n        grid = grid.T\n    fgrid = f(grid)\n    if n is not None:\n        ngrid = fgrid / fgrid.sum()\n    else:\n        ngrid = fgrid\n    (xmin, xmax) = limits[-1]\n    if facet:\n        N = len(grid[-1])\n    else:\n        N = len(grid)\n    xexpression = binby[0]\n    xar = np.arange(N + 1) / (N - 0.0) * (xmax - xmin) + xmin\n    label = str(label or selection or x)\n    if facet:\n        import math\n        (rows, columns) = (int(math.ceil(facet_count / 4.0)), 4)\n        values = np.linspace(facet_limits[0], facet_limits[1], facet_count + 1)\n        for i in range(facet_count):\n            ax = plt.subplot(rows, columns, i + 1)\n            value = ax.plot(xar, ngrid[i], drawstyle='steps-mid', label=label, **kwargs)\n            (v1, v2) = (values[i], values[i + 1])\n            plt.xlabel(xlabel or x)\n            plt.ylabel(ylabel or what)\n            ax.set_title('%3f <= %s < %3f' % (v1, facet_expression, v2))\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = len(labels) // max_labels\n                plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    else:\n        plt.xlabel(xlabel or self.label(x))\n        plt.ylabel(ylabel or what)\n        g = np.concatenate([ngrid[0:1], ngrid])\n        value = plt.plot(xar, g, drawstyle='steps-pre', label=label, **kwargs)\n        if self.iscategory(xexpression):\n            labels = self.category_labels(xexpression)\n            step = len(labels) // max_labels\n            plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    if tight_layout:\n        plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    return value",
            "@viz_method\n@docsubst\ndef histogram(self, x=None, what='count(*)', grid=None, shape=64, facet=None, limits=None, figsize=None, f='identity', n=None, normalize_axis=None, xlabel=None, ylabel=None, label=None, selection=None, show=False, tight_layout=True, hardcopy=None, progress=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Plot a histogram.\\n\\n    Example:\\n\\n    >>> df.histogram(df.x)\\n    >>> df.histogram(df.x, limits=[0, 100], shape=100)\\n    >>> df.histogram(df.x, what='mean(y)', limits=[0, 100], shape=100)\\n\\n    If you want to do a computation yourself, pass the grid argument, but you are responsible for passing the\\n    same limits arguments:\\n\\n    >>> counts = df.mean(df.y, binby=df.x, limits=[0, 100], shape=100)/100.\\n    >>> df.histogram(df.x, limits=[0, 100], shape=100, grid=means, label='mean(y)/100')\\n\\n    :param x: {expression_one}\\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum\\n    :param grid: {grid}\\n    :param shape: {shape}\\n    :param facet: Expression to produce facetted plots ( facet='x:0,1,12' will produce 12 plots with x in a range between 0 and 1)\\n    :param limits: {limits}\\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\\n    :param n: normalization function, currently only 'normalize' is supported, or None for no normalization\\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\\n    :param selection: {selection}\\n    :param xlabel: String for label on x axis (may contain latex)\\n    :param ylabel: Same for y axis\\n    :param: tight_layout: call plt.tight_layout or not\\n    :param kwargs: extra argument passed to plt.plot\\n    :return:\\n    \"\n    import matplotlib.pyplot as plt\n    f = _parse_f(f)\n    n = _parse_n(n)\n    if type(shape) == int:\n        shape = (shape,)\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    for expression in [x]:\n        if expression is not None:\n            binby = [expression] + binby\n    limits = self.limits(binby, limits)\n    if figsize is not None:\n        plt.figure(num=None, figsize=figsize, dpi=80, facecolor='w', edgecolor='k')\n    fig = plt.gcf()\n    import re\n    if facet is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', facet)\n        if match:\n            groups = match.groups()\n            facet_expression = groups[0]\n            facet_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            facet_count = ast.literal_eval(groups[3])\n            limits.append(facet_limits)\n            binby.append(facet_expression)\n            shape = (facet_count,) + shape\n        else:\n            raise ValueError(\"Could not understand 'facet' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    if grid is None:\n        if what:\n            if isinstance(what, vaex.stat.Expression):\n                grid = what.calculate(self, binby=binby, limits=limits, shape=shape, selection=selection)\n            else:\n                what = what.strip()\n                index = what.index('(')\n                import re\n                groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                if groups and len(groups) == 2:\n                    function = groups[0]\n                    arguments = groups[1].strip()\n                    functions = ['mean', 'sum', 'std', 'count']\n                    if function in functions:\n                        grid = getattr(vaex.stat, function)(arguments).calculate(self, binby=binby, limits=limits, shape=shape, selection=selection, progress=progress)\n                    elif function == 'count' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                    elif function == 'cumulative' and arguments == '*':\n                        grid = self.count(binby=binby, shape=shape, limits=limits, selection=selection, progress=progress)\n                        grid = np.cumsum(grid)\n                    else:\n                        raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                else:\n                    raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n        else:\n            grid = self.histogram(binby, size=shape, limits=limits, selection=selection)\n    if len(grid.shape) > 1 and _issequence(selection):\n        grid = grid.T\n    fgrid = f(grid)\n    if n is not None:\n        ngrid = fgrid / fgrid.sum()\n    else:\n        ngrid = fgrid\n    (xmin, xmax) = limits[-1]\n    if facet:\n        N = len(grid[-1])\n    else:\n        N = len(grid)\n    xexpression = binby[0]\n    xar = np.arange(N + 1) / (N - 0.0) * (xmax - xmin) + xmin\n    label = str(label or selection or x)\n    if facet:\n        import math\n        (rows, columns) = (int(math.ceil(facet_count / 4.0)), 4)\n        values = np.linspace(facet_limits[0], facet_limits[1], facet_count + 1)\n        for i in range(facet_count):\n            ax = plt.subplot(rows, columns, i + 1)\n            value = ax.plot(xar, ngrid[i], drawstyle='steps-mid', label=label, **kwargs)\n            (v1, v2) = (values[i], values[i + 1])\n            plt.xlabel(xlabel or x)\n            plt.ylabel(ylabel or what)\n            ax.set_title('%3f <= %s < %3f' % (v1, facet_expression, v2))\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = len(labels) // max_labels\n                plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    else:\n        plt.xlabel(xlabel or self.label(x))\n        plt.ylabel(ylabel or what)\n        g = np.concatenate([ngrid[0:1], ngrid])\n        value = plt.plot(xar, g, drawstyle='steps-pre', label=label, **kwargs)\n        if self.iscategory(xexpression):\n            labels = self.category_labels(xexpression)\n            step = len(labels) // max_labels\n            plt.xticks(range(len(labels))[::step], labels[::step], size='small')\n    if tight_layout:\n        plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    return value"
        ]
    },
    {
        "func_name": "scatter",
        "original": "@patch\ndef scatter(self, *args, **kwargs):\n    warnings.warn('`scatter` is deprecated and it will be removed in version 5.x. Please use `df.viz.scatter` instead.')\n    self.viz.scatter(*args, **kwargs)",
        "mutated": [
            "@patch\ndef scatter(self, *args, **kwargs):\n    if False:\n        i = 10\n    warnings.warn('`scatter` is deprecated and it will be removed in version 5.x. Please use `df.viz.scatter` instead.')\n    self.viz.scatter(*args, **kwargs)",
            "@patch\ndef scatter(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    warnings.warn('`scatter` is deprecated and it will be removed in version 5.x. Please use `df.viz.scatter` instead.')\n    self.viz.scatter(*args, **kwargs)",
            "@patch\ndef scatter(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    warnings.warn('`scatter` is deprecated and it will be removed in version 5.x. Please use `df.viz.scatter` instead.')\n    self.viz.scatter(*args, **kwargs)",
            "@patch\ndef scatter(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    warnings.warn('`scatter` is deprecated and it will be removed in version 5.x. Please use `df.viz.scatter` instead.')\n    self.viz.scatter(*args, **kwargs)",
            "@patch\ndef scatter(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    warnings.warn('`scatter` is deprecated and it will be removed in version 5.x. Please use `df.viz.scatter` instead.')\n    self.viz.scatter(*args, **kwargs)"
        ]
    },
    {
        "func_name": "scatter",
        "original": "@viz_method\n@docsubst\ndef scatter(self, x, y, xerr=None, yerr=None, cov=None, corr=None, s_expr=None, c_expr=None, labels=None, selection=None, length_limit=50000, length_check=True, label=None, xlabel=None, ylabel=None, errorbar_kwargs={}, ellipse_kwargs={}, **kwargs):\n    \"\"\"Viz (small amounts) of data in 2d using a scatter plot\n\n    Convenience wrapper around plt.scatter when for working with small DataFrames or selections\n\n    :param x: {expression_one}\n    :param y: {expression_one}\n    :param s_expr: When given, use if for the s (size) argument of plt.scatter\n    :param c_expr: When given, use if for the c (color) argument of plt.scatter\n    :param labels: Annotate the points with these text values\n    :param selection: {selection1}\n    :param length_limit: maximum number of rows it will plot\n    :param length_check: should we do the maximum row check or not?\n    :param label: label for the legend\n    :param xlabel: label for x axis, if None .label(x) is used\n    :param ylabel: label for y axis, if None .label(y) is used\n    :param errorbar_kwargs: extra dict with arguments passed to plt.errorbar\n    :param kwargs: extra arguments passed to plt.scatter\n    :return:\n    \"\"\"\n    import matplotlib.pyplot as plt\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    label = str(label or selection)\n    selection = _ensure_strings_from_expressions(selection)\n    if length_check:\n        count = self.count(selection=selection)\n        if count > length_limit:\n            raise ValueError('the number of rows (%d) is above the limit (%d), pass length_check=False, or increase length_limit' % (count, length_limit))\n    x_values = self.evaluate(x, selection=selection)\n    y_values = self.evaluate(y, selection=selection)\n    if s_expr:\n        kwargs['s'] = self.evaluate(s_expr, selection=selection)\n    if c_expr:\n        kwargs['c'] = self.evaluate(c_expr, selection=selection)\n    plt.xlabel(xlabel or self.label(x))\n    plt.ylabel(ylabel or self.label(y))\n    s = plt.scatter(x_values, y_values, label=label, **kwargs)\n    if labels:\n        label_values = self.evaluate(labels, selection=selection)\n        for (i, label_value) in enumerate(label_values):\n            plt.annotate(label_value, (x_values[i], y_values[i]))\n    xerr_values = None\n    yerr_values = None\n    if cov is not None or corr is not None:\n        from matplotlib.patches import Ellipse\n        sx = self.evaluate(xerr, selection=selection)\n        sy = self.evaluate(yerr, selection=selection)\n        if corr is not None:\n            sxy = self.evaluate(corr, selection=selection) * sx * sy\n        elif cov is not None:\n            sxy = self.evaluate(cov, selection=selection)\n        cov_matrix = np.zeros((len(sx), 2, 2))\n        cov_matrix[:, 0, 0] = sx ** 2\n        cov_matrix[:, 1, 1] = sy ** 2\n        cov_matrix[:, 0, 1] = cov_matrix[:, 1, 0] = sxy\n        ax = plt.gca()\n        ellipse_kwargs = dict(ellipse_kwargs)\n        ellipse_kwargs['facecolor'] = ellipse_kwargs.get('facecolor', 'none')\n        ellipse_kwargs['edgecolor'] = ellipse_kwargs.get('edgecolor', 'black')\n        for i in range(len(sx)):\n            (eigen_values, eigen_vectors) = np.linalg.eig(cov_matrix[i])\n            indices = np.argsort(eigen_values)[::-1]\n            eigen_values = eigen_values[indices]\n            eigen_vectors = eigen_vectors[:, indices]\n            v1 = eigen_vectors[:, 0]\n            v2 = eigen_vectors[:, 1]\n            varx = cov_matrix[i, 0, 0]\n            vary = cov_matrix[i, 1, 1]\n            angle = np.arctan2(v1[1], v1[0])\n            if eigen_values[1] < 0 and abs(eigen_values[1] / eigen_values[0]) < 1e-10:\n                eigen_values[1] = 0\n            if eigen_values[0] < 0 or eigen_values[1] < 0:\n                raise ValueError('neg val')\n            (width, height) = (np.sqrt(np.max(eigen_values)), np.sqrt(np.min(eigen_values)))\n            e = Ellipse(xy=(x_values[i], y_values[i]), width=width, height=height, angle=np.degrees(angle), **ellipse_kwargs)\n            ax.add_artist(e)\n    else:\n        if xerr is not None:\n            if _issequence(xerr):\n                assert len(xerr) == 2, 'if xerr is a sequence it should be of length 2'\n                xerr_values = [self.evaluate(xerr[0], selection=selection), self.evaluate(xerr[1], selection=selection)]\n            else:\n                xerr_values = self.evaluate(xerr, selection=selection)\n        if yerr is not None:\n            if _issequence(yerr):\n                assert len(yerr) == 2, 'if yerr is a sequence it should be of length 2'\n                yerr_values = [self.evaluate(yerr[0], selection=selection), self.evaluate(yerr[1], selection=selection)]\n            else:\n                yerr_values = self.evaluate(yerr, selection=selection)\n        if xerr_values is not None or yerr_values is not None:\n            errorbar_kwargs = dict(errorbar_kwargs)\n            errorbar_kwargs['fmt'] = errorbar_kwargs.get('fmt', 'none')\n            plt.errorbar(x_values, y_values, yerr=yerr_values, xerr=xerr_values, **errorbar_kwargs)\n    return s",
        "mutated": [
            "@viz_method\n@docsubst\ndef scatter(self, x, y, xerr=None, yerr=None, cov=None, corr=None, s_expr=None, c_expr=None, labels=None, selection=None, length_limit=50000, length_check=True, label=None, xlabel=None, ylabel=None, errorbar_kwargs={}, ellipse_kwargs={}, **kwargs):\n    if False:\n        i = 10\n    'Viz (small amounts) of data in 2d using a scatter plot\\n\\n    Convenience wrapper around plt.scatter when for working with small DataFrames or selections\\n\\n    :param x: {expression_one}\\n    :param y: {expression_one}\\n    :param s_expr: When given, use if for the s (size) argument of plt.scatter\\n    :param c_expr: When given, use if for the c (color) argument of plt.scatter\\n    :param labels: Annotate the points with these text values\\n    :param selection: {selection1}\\n    :param length_limit: maximum number of rows it will plot\\n    :param length_check: should we do the maximum row check or not?\\n    :param label: label for the legend\\n    :param xlabel: label for x axis, if None .label(x) is used\\n    :param ylabel: label for y axis, if None .label(y) is used\\n    :param errorbar_kwargs: extra dict with arguments passed to plt.errorbar\\n    :param kwargs: extra arguments passed to plt.scatter\\n    :return:\\n    '\n    import matplotlib.pyplot as plt\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    label = str(label or selection)\n    selection = _ensure_strings_from_expressions(selection)\n    if length_check:\n        count = self.count(selection=selection)\n        if count > length_limit:\n            raise ValueError('the number of rows (%d) is above the limit (%d), pass length_check=False, or increase length_limit' % (count, length_limit))\n    x_values = self.evaluate(x, selection=selection)\n    y_values = self.evaluate(y, selection=selection)\n    if s_expr:\n        kwargs['s'] = self.evaluate(s_expr, selection=selection)\n    if c_expr:\n        kwargs['c'] = self.evaluate(c_expr, selection=selection)\n    plt.xlabel(xlabel or self.label(x))\n    plt.ylabel(ylabel or self.label(y))\n    s = plt.scatter(x_values, y_values, label=label, **kwargs)\n    if labels:\n        label_values = self.evaluate(labels, selection=selection)\n        for (i, label_value) in enumerate(label_values):\n            plt.annotate(label_value, (x_values[i], y_values[i]))\n    xerr_values = None\n    yerr_values = None\n    if cov is not None or corr is not None:\n        from matplotlib.patches import Ellipse\n        sx = self.evaluate(xerr, selection=selection)\n        sy = self.evaluate(yerr, selection=selection)\n        if corr is not None:\n            sxy = self.evaluate(corr, selection=selection) * sx * sy\n        elif cov is not None:\n            sxy = self.evaluate(cov, selection=selection)\n        cov_matrix = np.zeros((len(sx), 2, 2))\n        cov_matrix[:, 0, 0] = sx ** 2\n        cov_matrix[:, 1, 1] = sy ** 2\n        cov_matrix[:, 0, 1] = cov_matrix[:, 1, 0] = sxy\n        ax = plt.gca()\n        ellipse_kwargs = dict(ellipse_kwargs)\n        ellipse_kwargs['facecolor'] = ellipse_kwargs.get('facecolor', 'none')\n        ellipse_kwargs['edgecolor'] = ellipse_kwargs.get('edgecolor', 'black')\n        for i in range(len(sx)):\n            (eigen_values, eigen_vectors) = np.linalg.eig(cov_matrix[i])\n            indices = np.argsort(eigen_values)[::-1]\n            eigen_values = eigen_values[indices]\n            eigen_vectors = eigen_vectors[:, indices]\n            v1 = eigen_vectors[:, 0]\n            v2 = eigen_vectors[:, 1]\n            varx = cov_matrix[i, 0, 0]\n            vary = cov_matrix[i, 1, 1]\n            angle = np.arctan2(v1[1], v1[0])\n            if eigen_values[1] < 0 and abs(eigen_values[1] / eigen_values[0]) < 1e-10:\n                eigen_values[1] = 0\n            if eigen_values[0] < 0 or eigen_values[1] < 0:\n                raise ValueError('neg val')\n            (width, height) = (np.sqrt(np.max(eigen_values)), np.sqrt(np.min(eigen_values)))\n            e = Ellipse(xy=(x_values[i], y_values[i]), width=width, height=height, angle=np.degrees(angle), **ellipse_kwargs)\n            ax.add_artist(e)\n    else:\n        if xerr is not None:\n            if _issequence(xerr):\n                assert len(xerr) == 2, 'if xerr is a sequence it should be of length 2'\n                xerr_values = [self.evaluate(xerr[0], selection=selection), self.evaluate(xerr[1], selection=selection)]\n            else:\n                xerr_values = self.evaluate(xerr, selection=selection)\n        if yerr is not None:\n            if _issequence(yerr):\n                assert len(yerr) == 2, 'if yerr is a sequence it should be of length 2'\n                yerr_values = [self.evaluate(yerr[0], selection=selection), self.evaluate(yerr[1], selection=selection)]\n            else:\n                yerr_values = self.evaluate(yerr, selection=selection)\n        if xerr_values is not None or yerr_values is not None:\n            errorbar_kwargs = dict(errorbar_kwargs)\n            errorbar_kwargs['fmt'] = errorbar_kwargs.get('fmt', 'none')\n            plt.errorbar(x_values, y_values, yerr=yerr_values, xerr=xerr_values, **errorbar_kwargs)\n    return s",
            "@viz_method\n@docsubst\ndef scatter(self, x, y, xerr=None, yerr=None, cov=None, corr=None, s_expr=None, c_expr=None, labels=None, selection=None, length_limit=50000, length_check=True, label=None, xlabel=None, ylabel=None, errorbar_kwargs={}, ellipse_kwargs={}, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Viz (small amounts) of data in 2d using a scatter plot\\n\\n    Convenience wrapper around plt.scatter when for working with small DataFrames or selections\\n\\n    :param x: {expression_one}\\n    :param y: {expression_one}\\n    :param s_expr: When given, use if for the s (size) argument of plt.scatter\\n    :param c_expr: When given, use if for the c (color) argument of plt.scatter\\n    :param labels: Annotate the points with these text values\\n    :param selection: {selection1}\\n    :param length_limit: maximum number of rows it will plot\\n    :param length_check: should we do the maximum row check or not?\\n    :param label: label for the legend\\n    :param xlabel: label for x axis, if None .label(x) is used\\n    :param ylabel: label for y axis, if None .label(y) is used\\n    :param errorbar_kwargs: extra dict with arguments passed to plt.errorbar\\n    :param kwargs: extra arguments passed to plt.scatter\\n    :return:\\n    '\n    import matplotlib.pyplot as plt\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    label = str(label or selection)\n    selection = _ensure_strings_from_expressions(selection)\n    if length_check:\n        count = self.count(selection=selection)\n        if count > length_limit:\n            raise ValueError('the number of rows (%d) is above the limit (%d), pass length_check=False, or increase length_limit' % (count, length_limit))\n    x_values = self.evaluate(x, selection=selection)\n    y_values = self.evaluate(y, selection=selection)\n    if s_expr:\n        kwargs['s'] = self.evaluate(s_expr, selection=selection)\n    if c_expr:\n        kwargs['c'] = self.evaluate(c_expr, selection=selection)\n    plt.xlabel(xlabel or self.label(x))\n    plt.ylabel(ylabel or self.label(y))\n    s = plt.scatter(x_values, y_values, label=label, **kwargs)\n    if labels:\n        label_values = self.evaluate(labels, selection=selection)\n        for (i, label_value) in enumerate(label_values):\n            plt.annotate(label_value, (x_values[i], y_values[i]))\n    xerr_values = None\n    yerr_values = None\n    if cov is not None or corr is not None:\n        from matplotlib.patches import Ellipse\n        sx = self.evaluate(xerr, selection=selection)\n        sy = self.evaluate(yerr, selection=selection)\n        if corr is not None:\n            sxy = self.evaluate(corr, selection=selection) * sx * sy\n        elif cov is not None:\n            sxy = self.evaluate(cov, selection=selection)\n        cov_matrix = np.zeros((len(sx), 2, 2))\n        cov_matrix[:, 0, 0] = sx ** 2\n        cov_matrix[:, 1, 1] = sy ** 2\n        cov_matrix[:, 0, 1] = cov_matrix[:, 1, 0] = sxy\n        ax = plt.gca()\n        ellipse_kwargs = dict(ellipse_kwargs)\n        ellipse_kwargs['facecolor'] = ellipse_kwargs.get('facecolor', 'none')\n        ellipse_kwargs['edgecolor'] = ellipse_kwargs.get('edgecolor', 'black')\n        for i in range(len(sx)):\n            (eigen_values, eigen_vectors) = np.linalg.eig(cov_matrix[i])\n            indices = np.argsort(eigen_values)[::-1]\n            eigen_values = eigen_values[indices]\n            eigen_vectors = eigen_vectors[:, indices]\n            v1 = eigen_vectors[:, 0]\n            v2 = eigen_vectors[:, 1]\n            varx = cov_matrix[i, 0, 0]\n            vary = cov_matrix[i, 1, 1]\n            angle = np.arctan2(v1[1], v1[0])\n            if eigen_values[1] < 0 and abs(eigen_values[1] / eigen_values[0]) < 1e-10:\n                eigen_values[1] = 0\n            if eigen_values[0] < 0 or eigen_values[1] < 0:\n                raise ValueError('neg val')\n            (width, height) = (np.sqrt(np.max(eigen_values)), np.sqrt(np.min(eigen_values)))\n            e = Ellipse(xy=(x_values[i], y_values[i]), width=width, height=height, angle=np.degrees(angle), **ellipse_kwargs)\n            ax.add_artist(e)\n    else:\n        if xerr is not None:\n            if _issequence(xerr):\n                assert len(xerr) == 2, 'if xerr is a sequence it should be of length 2'\n                xerr_values = [self.evaluate(xerr[0], selection=selection), self.evaluate(xerr[1], selection=selection)]\n            else:\n                xerr_values = self.evaluate(xerr, selection=selection)\n        if yerr is not None:\n            if _issequence(yerr):\n                assert len(yerr) == 2, 'if yerr is a sequence it should be of length 2'\n                yerr_values = [self.evaluate(yerr[0], selection=selection), self.evaluate(yerr[1], selection=selection)]\n            else:\n                yerr_values = self.evaluate(yerr, selection=selection)\n        if xerr_values is not None or yerr_values is not None:\n            errorbar_kwargs = dict(errorbar_kwargs)\n            errorbar_kwargs['fmt'] = errorbar_kwargs.get('fmt', 'none')\n            plt.errorbar(x_values, y_values, yerr=yerr_values, xerr=xerr_values, **errorbar_kwargs)\n    return s",
            "@viz_method\n@docsubst\ndef scatter(self, x, y, xerr=None, yerr=None, cov=None, corr=None, s_expr=None, c_expr=None, labels=None, selection=None, length_limit=50000, length_check=True, label=None, xlabel=None, ylabel=None, errorbar_kwargs={}, ellipse_kwargs={}, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Viz (small amounts) of data in 2d using a scatter plot\\n\\n    Convenience wrapper around plt.scatter when for working with small DataFrames or selections\\n\\n    :param x: {expression_one}\\n    :param y: {expression_one}\\n    :param s_expr: When given, use if for the s (size) argument of plt.scatter\\n    :param c_expr: When given, use if for the c (color) argument of plt.scatter\\n    :param labels: Annotate the points with these text values\\n    :param selection: {selection1}\\n    :param length_limit: maximum number of rows it will plot\\n    :param length_check: should we do the maximum row check or not?\\n    :param label: label for the legend\\n    :param xlabel: label for x axis, if None .label(x) is used\\n    :param ylabel: label for y axis, if None .label(y) is used\\n    :param errorbar_kwargs: extra dict with arguments passed to plt.errorbar\\n    :param kwargs: extra arguments passed to plt.scatter\\n    :return:\\n    '\n    import matplotlib.pyplot as plt\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    label = str(label or selection)\n    selection = _ensure_strings_from_expressions(selection)\n    if length_check:\n        count = self.count(selection=selection)\n        if count > length_limit:\n            raise ValueError('the number of rows (%d) is above the limit (%d), pass length_check=False, or increase length_limit' % (count, length_limit))\n    x_values = self.evaluate(x, selection=selection)\n    y_values = self.evaluate(y, selection=selection)\n    if s_expr:\n        kwargs['s'] = self.evaluate(s_expr, selection=selection)\n    if c_expr:\n        kwargs['c'] = self.evaluate(c_expr, selection=selection)\n    plt.xlabel(xlabel or self.label(x))\n    plt.ylabel(ylabel or self.label(y))\n    s = plt.scatter(x_values, y_values, label=label, **kwargs)\n    if labels:\n        label_values = self.evaluate(labels, selection=selection)\n        for (i, label_value) in enumerate(label_values):\n            plt.annotate(label_value, (x_values[i], y_values[i]))\n    xerr_values = None\n    yerr_values = None\n    if cov is not None or corr is not None:\n        from matplotlib.patches import Ellipse\n        sx = self.evaluate(xerr, selection=selection)\n        sy = self.evaluate(yerr, selection=selection)\n        if corr is not None:\n            sxy = self.evaluate(corr, selection=selection) * sx * sy\n        elif cov is not None:\n            sxy = self.evaluate(cov, selection=selection)\n        cov_matrix = np.zeros((len(sx), 2, 2))\n        cov_matrix[:, 0, 0] = sx ** 2\n        cov_matrix[:, 1, 1] = sy ** 2\n        cov_matrix[:, 0, 1] = cov_matrix[:, 1, 0] = sxy\n        ax = plt.gca()\n        ellipse_kwargs = dict(ellipse_kwargs)\n        ellipse_kwargs['facecolor'] = ellipse_kwargs.get('facecolor', 'none')\n        ellipse_kwargs['edgecolor'] = ellipse_kwargs.get('edgecolor', 'black')\n        for i in range(len(sx)):\n            (eigen_values, eigen_vectors) = np.linalg.eig(cov_matrix[i])\n            indices = np.argsort(eigen_values)[::-1]\n            eigen_values = eigen_values[indices]\n            eigen_vectors = eigen_vectors[:, indices]\n            v1 = eigen_vectors[:, 0]\n            v2 = eigen_vectors[:, 1]\n            varx = cov_matrix[i, 0, 0]\n            vary = cov_matrix[i, 1, 1]\n            angle = np.arctan2(v1[1], v1[0])\n            if eigen_values[1] < 0 and abs(eigen_values[1] / eigen_values[0]) < 1e-10:\n                eigen_values[1] = 0\n            if eigen_values[0] < 0 or eigen_values[1] < 0:\n                raise ValueError('neg val')\n            (width, height) = (np.sqrt(np.max(eigen_values)), np.sqrt(np.min(eigen_values)))\n            e = Ellipse(xy=(x_values[i], y_values[i]), width=width, height=height, angle=np.degrees(angle), **ellipse_kwargs)\n            ax.add_artist(e)\n    else:\n        if xerr is not None:\n            if _issequence(xerr):\n                assert len(xerr) == 2, 'if xerr is a sequence it should be of length 2'\n                xerr_values = [self.evaluate(xerr[0], selection=selection), self.evaluate(xerr[1], selection=selection)]\n            else:\n                xerr_values = self.evaluate(xerr, selection=selection)\n        if yerr is not None:\n            if _issequence(yerr):\n                assert len(yerr) == 2, 'if yerr is a sequence it should be of length 2'\n                yerr_values = [self.evaluate(yerr[0], selection=selection), self.evaluate(yerr[1], selection=selection)]\n            else:\n                yerr_values = self.evaluate(yerr, selection=selection)\n        if xerr_values is not None or yerr_values is not None:\n            errorbar_kwargs = dict(errorbar_kwargs)\n            errorbar_kwargs['fmt'] = errorbar_kwargs.get('fmt', 'none')\n            plt.errorbar(x_values, y_values, yerr=yerr_values, xerr=xerr_values, **errorbar_kwargs)\n    return s",
            "@viz_method\n@docsubst\ndef scatter(self, x, y, xerr=None, yerr=None, cov=None, corr=None, s_expr=None, c_expr=None, labels=None, selection=None, length_limit=50000, length_check=True, label=None, xlabel=None, ylabel=None, errorbar_kwargs={}, ellipse_kwargs={}, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Viz (small amounts) of data in 2d using a scatter plot\\n\\n    Convenience wrapper around plt.scatter when for working with small DataFrames or selections\\n\\n    :param x: {expression_one}\\n    :param y: {expression_one}\\n    :param s_expr: When given, use if for the s (size) argument of plt.scatter\\n    :param c_expr: When given, use if for the c (color) argument of plt.scatter\\n    :param labels: Annotate the points with these text values\\n    :param selection: {selection1}\\n    :param length_limit: maximum number of rows it will plot\\n    :param length_check: should we do the maximum row check or not?\\n    :param label: label for the legend\\n    :param xlabel: label for x axis, if None .label(x) is used\\n    :param ylabel: label for y axis, if None .label(y) is used\\n    :param errorbar_kwargs: extra dict with arguments passed to plt.errorbar\\n    :param kwargs: extra arguments passed to plt.scatter\\n    :return:\\n    '\n    import matplotlib.pyplot as plt\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    label = str(label or selection)\n    selection = _ensure_strings_from_expressions(selection)\n    if length_check:\n        count = self.count(selection=selection)\n        if count > length_limit:\n            raise ValueError('the number of rows (%d) is above the limit (%d), pass length_check=False, or increase length_limit' % (count, length_limit))\n    x_values = self.evaluate(x, selection=selection)\n    y_values = self.evaluate(y, selection=selection)\n    if s_expr:\n        kwargs['s'] = self.evaluate(s_expr, selection=selection)\n    if c_expr:\n        kwargs['c'] = self.evaluate(c_expr, selection=selection)\n    plt.xlabel(xlabel or self.label(x))\n    plt.ylabel(ylabel or self.label(y))\n    s = plt.scatter(x_values, y_values, label=label, **kwargs)\n    if labels:\n        label_values = self.evaluate(labels, selection=selection)\n        for (i, label_value) in enumerate(label_values):\n            plt.annotate(label_value, (x_values[i], y_values[i]))\n    xerr_values = None\n    yerr_values = None\n    if cov is not None or corr is not None:\n        from matplotlib.patches import Ellipse\n        sx = self.evaluate(xerr, selection=selection)\n        sy = self.evaluate(yerr, selection=selection)\n        if corr is not None:\n            sxy = self.evaluate(corr, selection=selection) * sx * sy\n        elif cov is not None:\n            sxy = self.evaluate(cov, selection=selection)\n        cov_matrix = np.zeros((len(sx), 2, 2))\n        cov_matrix[:, 0, 0] = sx ** 2\n        cov_matrix[:, 1, 1] = sy ** 2\n        cov_matrix[:, 0, 1] = cov_matrix[:, 1, 0] = sxy\n        ax = plt.gca()\n        ellipse_kwargs = dict(ellipse_kwargs)\n        ellipse_kwargs['facecolor'] = ellipse_kwargs.get('facecolor', 'none')\n        ellipse_kwargs['edgecolor'] = ellipse_kwargs.get('edgecolor', 'black')\n        for i in range(len(sx)):\n            (eigen_values, eigen_vectors) = np.linalg.eig(cov_matrix[i])\n            indices = np.argsort(eigen_values)[::-1]\n            eigen_values = eigen_values[indices]\n            eigen_vectors = eigen_vectors[:, indices]\n            v1 = eigen_vectors[:, 0]\n            v2 = eigen_vectors[:, 1]\n            varx = cov_matrix[i, 0, 0]\n            vary = cov_matrix[i, 1, 1]\n            angle = np.arctan2(v1[1], v1[0])\n            if eigen_values[1] < 0 and abs(eigen_values[1] / eigen_values[0]) < 1e-10:\n                eigen_values[1] = 0\n            if eigen_values[0] < 0 or eigen_values[1] < 0:\n                raise ValueError('neg val')\n            (width, height) = (np.sqrt(np.max(eigen_values)), np.sqrt(np.min(eigen_values)))\n            e = Ellipse(xy=(x_values[i], y_values[i]), width=width, height=height, angle=np.degrees(angle), **ellipse_kwargs)\n            ax.add_artist(e)\n    else:\n        if xerr is not None:\n            if _issequence(xerr):\n                assert len(xerr) == 2, 'if xerr is a sequence it should be of length 2'\n                xerr_values = [self.evaluate(xerr[0], selection=selection), self.evaluate(xerr[1], selection=selection)]\n            else:\n                xerr_values = self.evaluate(xerr, selection=selection)\n        if yerr is not None:\n            if _issequence(yerr):\n                assert len(yerr) == 2, 'if yerr is a sequence it should be of length 2'\n                yerr_values = [self.evaluate(yerr[0], selection=selection), self.evaluate(yerr[1], selection=selection)]\n            else:\n                yerr_values = self.evaluate(yerr, selection=selection)\n        if xerr_values is not None or yerr_values is not None:\n            errorbar_kwargs = dict(errorbar_kwargs)\n            errorbar_kwargs['fmt'] = errorbar_kwargs.get('fmt', 'none')\n            plt.errorbar(x_values, y_values, yerr=yerr_values, xerr=xerr_values, **errorbar_kwargs)\n    return s",
            "@viz_method\n@docsubst\ndef scatter(self, x, y, xerr=None, yerr=None, cov=None, corr=None, s_expr=None, c_expr=None, labels=None, selection=None, length_limit=50000, length_check=True, label=None, xlabel=None, ylabel=None, errorbar_kwargs={}, ellipse_kwargs={}, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Viz (small amounts) of data in 2d using a scatter plot\\n\\n    Convenience wrapper around plt.scatter when for working with small DataFrames or selections\\n\\n    :param x: {expression_one}\\n    :param y: {expression_one}\\n    :param s_expr: When given, use if for the s (size) argument of plt.scatter\\n    :param c_expr: When given, use if for the c (color) argument of plt.scatter\\n    :param labels: Annotate the points with these text values\\n    :param selection: {selection1}\\n    :param length_limit: maximum number of rows it will plot\\n    :param length_check: should we do the maximum row check or not?\\n    :param label: label for the legend\\n    :param xlabel: label for x axis, if None .label(x) is used\\n    :param ylabel: label for y axis, if None .label(y) is used\\n    :param errorbar_kwargs: extra dict with arguments passed to plt.errorbar\\n    :param kwargs: extra arguments passed to plt.scatter\\n    :return:\\n    '\n    import matplotlib.pyplot as plt\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    label = str(label or selection)\n    selection = _ensure_strings_from_expressions(selection)\n    if length_check:\n        count = self.count(selection=selection)\n        if count > length_limit:\n            raise ValueError('the number of rows (%d) is above the limit (%d), pass length_check=False, or increase length_limit' % (count, length_limit))\n    x_values = self.evaluate(x, selection=selection)\n    y_values = self.evaluate(y, selection=selection)\n    if s_expr:\n        kwargs['s'] = self.evaluate(s_expr, selection=selection)\n    if c_expr:\n        kwargs['c'] = self.evaluate(c_expr, selection=selection)\n    plt.xlabel(xlabel or self.label(x))\n    plt.ylabel(ylabel or self.label(y))\n    s = plt.scatter(x_values, y_values, label=label, **kwargs)\n    if labels:\n        label_values = self.evaluate(labels, selection=selection)\n        for (i, label_value) in enumerate(label_values):\n            plt.annotate(label_value, (x_values[i], y_values[i]))\n    xerr_values = None\n    yerr_values = None\n    if cov is not None or corr is not None:\n        from matplotlib.patches import Ellipse\n        sx = self.evaluate(xerr, selection=selection)\n        sy = self.evaluate(yerr, selection=selection)\n        if corr is not None:\n            sxy = self.evaluate(corr, selection=selection) * sx * sy\n        elif cov is not None:\n            sxy = self.evaluate(cov, selection=selection)\n        cov_matrix = np.zeros((len(sx), 2, 2))\n        cov_matrix[:, 0, 0] = sx ** 2\n        cov_matrix[:, 1, 1] = sy ** 2\n        cov_matrix[:, 0, 1] = cov_matrix[:, 1, 0] = sxy\n        ax = plt.gca()\n        ellipse_kwargs = dict(ellipse_kwargs)\n        ellipse_kwargs['facecolor'] = ellipse_kwargs.get('facecolor', 'none')\n        ellipse_kwargs['edgecolor'] = ellipse_kwargs.get('edgecolor', 'black')\n        for i in range(len(sx)):\n            (eigen_values, eigen_vectors) = np.linalg.eig(cov_matrix[i])\n            indices = np.argsort(eigen_values)[::-1]\n            eigen_values = eigen_values[indices]\n            eigen_vectors = eigen_vectors[:, indices]\n            v1 = eigen_vectors[:, 0]\n            v2 = eigen_vectors[:, 1]\n            varx = cov_matrix[i, 0, 0]\n            vary = cov_matrix[i, 1, 1]\n            angle = np.arctan2(v1[1], v1[0])\n            if eigen_values[1] < 0 and abs(eigen_values[1] / eigen_values[0]) < 1e-10:\n                eigen_values[1] = 0\n            if eigen_values[0] < 0 or eigen_values[1] < 0:\n                raise ValueError('neg val')\n            (width, height) = (np.sqrt(np.max(eigen_values)), np.sqrt(np.min(eigen_values)))\n            e = Ellipse(xy=(x_values[i], y_values[i]), width=width, height=height, angle=np.degrees(angle), **ellipse_kwargs)\n            ax.add_artist(e)\n    else:\n        if xerr is not None:\n            if _issequence(xerr):\n                assert len(xerr) == 2, 'if xerr is a sequence it should be of length 2'\n                xerr_values = [self.evaluate(xerr[0], selection=selection), self.evaluate(xerr[1], selection=selection)]\n            else:\n                xerr_values = self.evaluate(xerr, selection=selection)\n        if yerr is not None:\n            if _issequence(yerr):\n                assert len(yerr) == 2, 'if yerr is a sequence it should be of length 2'\n                yerr_values = [self.evaluate(yerr[0], selection=selection), self.evaluate(yerr[1], selection=selection)]\n            else:\n                yerr_values = self.evaluate(yerr, selection=selection)\n        if xerr_values is not None or yerr_values is not None:\n            errorbar_kwargs = dict(errorbar_kwargs)\n            errorbar_kwargs['fmt'] = errorbar_kwargs.get('fmt', 'none')\n            plt.errorbar(x_values, y_values, yerr=yerr_values, xerr=xerr_values, **errorbar_kwargs)\n    return s"
        ]
    },
    {
        "func_name": "plot",
        "original": "@patch\ndef plot(self, *args, **kwargs):\n    warnings.warn('`plot` is deprecated and it will be removed in version 5.x. Please `df.viz.heatmap` instead.')\n    self.viz.heatmap(*args, **kwargs)",
        "mutated": [
            "@patch\ndef plot(self, *args, **kwargs):\n    if False:\n        i = 10\n    warnings.warn('`plot` is deprecated and it will be removed in version 5.x. Please `df.viz.heatmap` instead.')\n    self.viz.heatmap(*args, **kwargs)",
            "@patch\ndef plot(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    warnings.warn('`plot` is deprecated and it will be removed in version 5.x. Please `df.viz.heatmap` instead.')\n    self.viz.heatmap(*args, **kwargs)",
            "@patch\ndef plot(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    warnings.warn('`plot` is deprecated and it will be removed in version 5.x. Please `df.viz.heatmap` instead.')\n    self.viz.heatmap(*args, **kwargs)",
            "@patch\ndef plot(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    warnings.warn('`plot` is deprecated and it will be removed in version 5.x. Please `df.viz.heatmap` instead.')\n    self.viz.heatmap(*args, **kwargs)",
            "@patch\ndef plot(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    warnings.warn('`plot` is deprecated and it will be removed in version 5.x. Please `df.viz.heatmap` instead.')\n    self.viz.heatmap(*args, **kwargs)"
        ]
    },
    {
        "func_name": "invert",
        "original": "def invert(x):\n    return dict(((v, k) for (k, v) in x.items()))",
        "mutated": [
            "def invert(x):\n    if False:\n        i = 10\n    return dict(((v, k) for (k, v) in x.items()))",
            "def invert(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return dict(((v, k) for (k, v) in x.items()))",
            "def invert(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return dict(((v, k) for (k, v) in x.items()))",
            "def invert(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return dict(((v, k) for (k, v) in x.items()))",
            "def invert(x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return dict(((v, k) for (k, v) in x.items()))"
        ]
    },
    {
        "func_name": "_selection_name",
        "original": "def _selection_name(name):\n    if name in [None, False]:\n        return 'selection: all'\n    elif name in ['default', True]:\n        return 'selection: default'\n    else:\n        return 'selection: %s' % name",
        "mutated": [
            "def _selection_name(name):\n    if False:\n        i = 10\n    if name in [None, False]:\n        return 'selection: all'\n    elif name in ['default', True]:\n        return 'selection: default'\n    else:\n        return 'selection: %s' % name",
            "def _selection_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if name in [None, False]:\n        return 'selection: all'\n    elif name in ['default', True]:\n        return 'selection: default'\n    else:\n        return 'selection: %s' % name",
            "def _selection_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if name in [None, False]:\n        return 'selection: all'\n    elif name in ['default', True]:\n        return 'selection: default'\n    else:\n        return 'selection: %s' % name",
            "def _selection_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if name in [None, False]:\n        return 'selection: all'\n    elif name in ['default', True]:\n        return 'selection: default'\n    else:\n        return 'selection: %s' % name",
            "def _selection_name(name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if name in [None, False]:\n        return 'selection: all'\n    elif name in ['default', True]:\n        return 'selection: default'\n    else:\n        return 'selection: %s' % name"
        ]
    },
    {
        "func_name": "label",
        "original": "def label(index, label, expression):\n    if label and _issequence(label):\n        return label[i]\n    else:\n        return self.label(expression)",
        "mutated": [
            "def label(index, label, expression):\n    if False:\n        i = 10\n    if label and _issequence(label):\n        return label[i]\n    else:\n        return self.label(expression)",
            "def label(index, label, expression):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if label and _issequence(label):\n        return label[i]\n    else:\n        return self.label(expression)",
            "def label(index, label, expression):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if label and _issequence(label):\n        return label[i]\n    else:\n        return self.label(expression)",
            "def label(index, label, expression):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if label and _issequence(label):\n        return label[i]\n    else:\n        return self.label(expression)",
            "def label(index, label, expression):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if label and _issequence(label):\n        return label[i]\n    else:\n        return self.label(expression)"
        ]
    },
    {
        "func_name": "heatmap",
        "original": "@viz_method\n@docsubst\ndef heatmap(self, x=None, y=None, z=None, what='count(*)', vwhat=None, reduce=['colormap'], f=None, normalize='normalize', normalize_axis='what', vmin=None, vmax=None, shape=256, vshape=32, limits=None, grid=None, colormap='afmhot', figsize=None, xlabel=None, ylabel=None, aspect='auto', tight_layout=True, interpolation='nearest', show=False, colorbar=True, colorbar_label=None, selection=None, selection_labels=None, title=None, background_color='white', pre_blend=False, background_alpha=1.0, visual=dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what'), smooth_pre=None, smooth_post=None, wrap=True, wrap_columns=4, return_extra=False, hardcopy=None):\n    \"\"\"Viz data in a 2d histogram/heatmap.\n\n    Declarative plotting of statistical plots using matplotlib, supports subplots, selections, layers.\n\n    Instead of passing x and y, pass a list as x argument for multiple panels. Give what a list of options to have multiple\n    panels. When both are present then will be origanized in a column/row order.\n\n    This methods creates a 6 dimensional 'grid', where each dimension can map the a visual dimension.\n    The grid dimensions are:\n\n    * x: shape determined by shape, content by x argument or the first dimension of each space\n    * y:   ,,\n    * z:  related to the z argument\n    * selection: shape equals length of selection argument\n    * what: shape equals length of what argument\n    * space: shape equals length of x argument if multiple values are given\n\n     By default, this its shape is (1, 1, 1, 1, shape, shape) (where x is the last dimension)\n\n    The visual dimensions are\n\n    * x: x coordinate on a plot / image (default maps to grid's x)\n    * y: y   ,,                         (default maps to grid's y)\n    * layer: each image in this dimension is blended togeher to one image (default maps to z)\n    * fade: each image is shown faded after the next image (default mapt to selection)\n    * row: rows of subplots (default maps to space)\n    * columns: columns of subplot (default maps to what)\n\n    All these mappings can be changes by the visual argument, some examples:\n\n    >>> df.viz.heatmap('x', 'y', what=['mean(x)', 'correlation(vx, vy)'])\n\n    Will plot each 'what' as a column.\n\n    >>> df.viz.heatmap('x', 'y', selection=['FeH < -3', '(FeH >= -3) & (FeH < -2)'], visual=dict(column='selection'))\n\n    Will plot each selection as a column, instead of a faded on top of each other.\n\n\n\n\n\n    :param x: Expression to bin in the x direction (by default maps to x), or list of pairs, like [['x', 'y'], ['x', 'z']], if multiple pairs are given, this dimension maps to rows by default\n    :param y:                          y           (by default maps to y)\n    :param z: Expression to bin in the z direction, followed by a :start,end,shape  signature, like 'FeH:-3,1:5' will produce 5 layers between -10 and 10 (by default maps to layer)\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum, std('x') the standard deviation, correlation('vx', 'vy') the correlation coefficient. Can also be a list of values, like ['count(x)', std('vx')], (by default maps to column)\n    :param reduce:\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\n    :param normalize: normalization function, currently only 'normalize' is supported\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\n    :param vmin: instead of automatic normalization, (using normalize and normalization_axis) scale the data between vmin and vmax to [0, 1]\n    :param vmax: see vmin\n    :param shape: {shape}\n    :param limits: {limits}\n    :param grid: {grid}\n    :param colormap: matplotlib colormap to use\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\n    :param xlabel:\n    :param ylabel:\n    :param aspect:\n    :param tight_layout: call plt.tight_layout or not\n    :param colorbar: plot a colorbar or not\n    :param selection: {selection1}\n    :param interpolation: interpolation for imshow, possible options are: 'nearest', 'bilinear', 'bicubic', see matplotlib for more\n    :param return_extra:\n    :return:\n    \"\"\"\n    import matplotlib\n    import matplotlib.pyplot as plt\n    n = _parse_n(normalize)\n    if type(shape) == int:\n        shape = (shape,) * 2\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    for expression in [y, x]:\n        if expression is not None:\n            binby = [expression] + binby\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    import re\n    what_units = None\n    whats = _ensure_list(what)\n    selections = _ensure_list(selection)\n    selections = _ensure_strings_from_expressions(selections)\n    if y is None:\n        (waslist, [x]) = listify(x)\n    else:\n        (waslist, [x, y]) = listify(x, y)\n        x = list(zip(x, y))\n        limits = [limits]\n    vwhats = _expand_limits(vwhat, len(x))\n    logger.debug('x: %s', x)\n    (limits, shape) = self.limits(x, limits, shape=shape)\n    shape = shape[0]\n    logger.debug('limits: %r', limits)\n    labels = {}\n    shape = _expand_shape(shape, 2)\n    vshape = _expand_shape(shape, 2)\n    if z is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', z)\n        if match:\n            groups = match.groups()\n            import ast\n            z_expression = groups[0]\n            logger.debug('found groups: %r', list(groups))\n            z_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            z_shape = ast.literal_eval(groups[3])\n            x = [[z_expression] + list(k) for k in x]\n            limits = np.array([[z_limits] + list(k) for k in limits])\n            shape = (z_shape,) + shape\n            vshape = (z_shape,) + vshape\n            logger.debug('x = %r', x)\n            values = np.linspace(z_limits[0], z_limits[1], num=z_shape + 1)\n            labels['z'] = list(['%s <= %s < %s' % (v1, z_expression, v2) for (v1, v2) in zip(values[:-1], values[1:])])\n        else:\n            raise ValueError(\"Could not understand 'z' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    else:\n        z_shape = 1\n    if z is None:\n        total_grid = np.zeros((len(x), len(whats), len(selections), 1) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections), 1) + vshape, dtype=float)\n    else:\n        total_grid = np.zeros((len(x), len(whats), len(selections)) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections)) + vshape, dtype=float)\n    logger.debug('shape of total grid: %r', total_grid.shape)\n    axis = dict(plot=0, what=1, selection=2)\n    xlimits = limits\n    grid_axes = dict(x=-1, y=-2, z=-3, selection=-4, what=-5, subspace=-6)\n    visual_axes = dict(x=-1, y=-2, layer=-3, fade=-4, column=-5, row=-6)\n    visual_default = dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what')\n\n    def invert(x):\n        return dict(((v, k) for (k, v) in x.items()))\n    free_visual_axes = list(visual_default.keys())\n    logger.debug('1: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual.items():\n        if visual_name in free_visual_axes:\n            free_visual_axes.remove(visual_name)\n        else:\n            raise ValueError('visual axes %s used multiple times' % visual_name)\n    logger.debug('2: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name in free_visual_axes and grid_name not in visual.values():\n            free_visual_axes.remove(visual_name)\n            visual[visual_name] = grid_name\n    logger.debug('3: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name not in free_visual_axes and grid_name not in visual.values():\n            visual[free_visual_axes.pop(0)] = grid_name\n    logger.debug('4: %r %r', visual, free_visual_axes)\n    visual_reverse = invert(visual)\n    (visual, visual_reverse) = (visual_reverse, visual)\n    move = {}\n    for (grid_name, visual_name) in visual.items():\n        if visual_axes[visual_name] in visual.values():\n            index = visual.values().find(visual_name)\n            key = visual.keys()[index]\n            raise ValueError('trying to map %s to %s while, it is already mapped by %s' % (grid_name, visual_name, key))\n        move[grid_axes[grid_name]] = visual_axes[visual_name]\n    fs = _expand(f, total_grid.shape[grid_axes[normalize_axis]])\n    what_labels = []\n    if grid is None:\n        grid_of_grids = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            grid_of_grids.append([])\n            for (j, what) in enumerate(whats):\n                if isinstance(what, vaex.stat.Expression):\n                    grid = what.calculate(self, binby=binby, shape=shape, limits=limits, selection=selections, delay=True)\n                else:\n                    what = what.strip()\n                    index = what.index('(')\n                    import re\n                    groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                    if groups and len(groups) == 2:\n                        function = groups[0]\n                        arguments = groups[1].strip()\n                        if ',' in arguments:\n                            arguments = arguments.split(',')\n                        functions = ['mean', 'sum', 'std', 'var', 'correlation', 'covar', 'min', 'max', 'median_approx']\n                        unit_expression = None\n                        if function in ['mean', 'sum', 'std', 'min', 'max', 'median']:\n                            unit_expression = arguments\n                        if function in ['var']:\n                            unit_expression = '(%s) * (%s)' % (arguments, arguments)\n                        if function in ['covar']:\n                            unit_expression = '(%s) * (%s)' % arguments\n                        if unit_expression:\n                            unit = self.unit(unit_expression)\n                            if unit:\n                                what_units = unit.to_string('latex_inline')\n                        if function in functions:\n                            grid = getattr(self, function)(arguments, binby=binby, limits=limits, shape=shape, selection=selections, delay=True)\n                        elif function == 'count':\n                            grid = self.count(arguments, binby, shape=shape, limits=limits, selection=selections, delay=True)\n                        else:\n                            raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                    else:\n                        raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n                if i == 0:\n                    what_label = str(whats[j])\n                    if what_units:\n                        what_label += ' (%s)' % what_units\n                    if fs[j]:\n                        what_label = fs[j] + ' ' + what_label\n                    what_labels.append(what_label)\n                grid_of_grids[-1].append(grid)\n        self.execute()\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            for (j, what) in enumerate(whats):\n                grid = grid_of_grids[i][j].get()\n                total_grid[i, j, :, :] = grid[:, None, ...]\n        labels['what'] = what_labels\n    else:\n        dims_left = 6 - len(grid.shape)\n        total_grid = np.broadcast_to(grid, (1,) * dims_left + grid.shape)\n\n    def _selection_name(name):\n        if name in [None, False]:\n            return 'selection: all'\n        elif name in ['default', True]:\n            return 'selection: default'\n        else:\n            return 'selection: %s' % name\n    if selection_labels is None:\n        labels['selection'] = list([_selection_name(k) for k in selections])\n    else:\n        labels['selection'] = selection_labels\n    axes = [None] * len(move)\n    for (key, value) in move.items():\n        axes[value] = key\n    visual_grid = np.transpose(total_grid, axes)\n    logger.debug('grid shape: %r', total_grid.shape)\n    logger.debug('visual: %r', visual.items())\n    logger.debug('move: %r', move)\n    logger.debug('visual grid shape: %r', visual_grid.shape)\n    xexpressions = []\n    yexpressions = []\n    for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n        xexpressions.append(binby[0])\n        yexpressions.append(binby[1])\n    if xlabel is None:\n        xlabels = []\n        ylabels = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            if z is not None:\n                xlabels.append(self.label(binby[1]))\n                ylabels.append(self.label(binby[2]))\n            else:\n                xlabels.append(self.label(binby[0]))\n                ylabels.append(self.label(binby[1]))\n    else:\n        Nl = visual_grid.shape[visual_axes['row']]\n        xlabels = _expand(xlabel, Nl)\n        ylabels = _expand(ylabel, Nl)\n    labels['x'] = xlabels\n    labels['y'] = ylabels\n    axes = []\n    background_color = np.array(matplotlib.colors.colorConverter.to_rgb(background_color))\n    import math\n    facet_columns = None\n    facets = visual_grid.shape[visual_axes['row']] * visual_grid.shape[visual_axes['column']]\n    if visual_grid.shape[visual_axes['column']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['row']])\n        wrapped = True\n    elif visual_grid.shape[visual_axes['row']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['column']])\n        wrapped = True\n    else:\n        wrapped = False\n        facet_columns = visual_grid.shape[visual_axes['column']]\n    facet_rows = int(math.ceil(facets / facet_columns))\n    logger.debug('facet_rows: %r', facet_rows)\n    logger.debug('facet_columns: %r', facet_columns)\n    grid = visual_grid * 1.0\n    fgrid = visual_grid * 1.0\n    ngrid = visual_grid * 1.0\n    vmins = _expand(vmin, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    vmaxs = _expand(vmax, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    visual_grid\n    if smooth_pre:\n        grid = vaex.grids.gf(grid, smooth_pre)\n    if 1:\n        axis = visual_axes[visual[normalize_axis]]\n        for i in range(visual_grid.shape[axis]):\n            item = [slice(None, None, None)] * len(visual_grid.shape)\n            item[axis] = i\n            item = tuple(item)\n            f = _parse_f(fs[i])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                fgrid.__setitem__(item, f(grid.__getitem__(item)))\n            if vmins[i] is not None and vmaxs[i] is not None:\n                nsubgrid = fgrid.__getitem__(item) * 1\n                nsubgrid -= vmins[i]\n                nsubgrid /= vmaxs[i] - vmins[i]\n            else:\n                (nsubgrid, vmin, vmax) = n(fgrid.__getitem__(item))\n                vmins[i] = vmin\n                vmaxs[i] = vmax\n            ngrid.__setitem__(item, nsubgrid)\n    if 0:\n        grid = visual_grid[i]\n        f = _parse_f(fs[i])\n        fgrid = f(grid)\n        finite_mask = np.isfinite(grid)\n        finite_mask = np.any(finite_mask, axis=0)\n        if vmin is not None and vmax is not None:\n            ngrid = fgrid * 1\n            ngrid -= vmin\n            ngrid /= vmax - vmin\n            ngrid = np.clip(ngrid, 0, 1)\n        else:\n            (ngrid, vmin, vmax) = n(fgrid)\n    (rows, columns) = (int(math.ceil(facets / float(facet_columns))), facet_columns)\n    colorbar_location = 'individual'\n    if visual['what'] == 'row' and visual_grid.shape[1] == facet_columns:\n        colorbar_location = 'per_row'\n    if visual['what'] == 'column' and visual_grid.shape[0] == facet_rows:\n        colorbar_location = 'per_column'\n    logger.debug('rows: %r, columns: %r', rows, columns)\n    import matplotlib.gridspec as gridspec\n    column_scale = 1\n    row_scale = 1\n    row_offset = 0\n    if facets > 1:\n        if colorbar_location == 'per_row':\n            column_scale = 4\n            gs = gridspec.GridSpec(rows, columns * column_scale + 1)\n        elif colorbar_location == 'per_column':\n            row_offset = 1\n            row_scale = 4\n            gs = gridspec.GridSpec(rows * row_scale + 1, columns)\n        else:\n            gs = gridspec.GridSpec(rows, columns)\n    facet_index = 0\n    fs = _expand(f, len(whats))\n    colormaps = _expand(colormap, len(whats))\n    for i in range(visual_grid.shape[0]):\n        for j in range(visual_grid.shape[1]):\n            if colorbar and colorbar_location == 'per_column' and (i == 0):\n                norm = matplotlib.colors.Normalize(vmins[j], vmaxs[j])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[j])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[0, j])\n                    colorbar = fig.colorbar(sm, cax=ax, orientation='horizontal')\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                if 'what' in labels:\n                    label = labels['what'][j]\n                    if facets > 1:\n                        colorbar.ax.set_title(label)\n                    else:\n                        colorbar.ax.set_ylabel(colorbar_label or label)\n            if colorbar and colorbar_location == 'per_row' and (j == 0):\n                norm = matplotlib.colors.Normalize(vmins[i], vmaxs[i])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[i])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[i, -1])\n                    colorbar = fig.colorbar(sm, cax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][i]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            rgrid = ngrid[i, j] * 1.0\n            for k in range(rgrid.shape[0]):\n                for l in range(rgrid.shape[0]):\n                    if smooth_post is not None:\n                        rgrid[k, l] = vaex.grids.gf(rgrid, smooth_post)\n            if visual['what'] == 'column':\n                what_index = j\n            elif visual['what'] == 'row':\n                what_index = i\n            else:\n                what_index = 0\n            if visual[normalize_axis] == 'column':\n                normalize_index = j\n            elif visual[normalize_axis] == 'row':\n                normalize_index = i\n            else:\n                normalize_index = 0\n            for r in reduce:\n                r = _parse_reduction(r, colormaps[what_index], [])\n                rgrid = r(rgrid)\n            row = facet_index // facet_columns\n            column = facet_index % facet_columns\n            if colorbar and colorbar_location == 'individual':\n                norm = matplotlib.colors.Normalize(vmins[normalize_index], vmaxs[normalize_index])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[what_index])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[row, column])\n                    colorbar = fig.colorbar(sm, ax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][what_index]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            if facets > 1:\n                ax = plt.subplot(gs[row_offset + row * row_scale:row_offset + (row + 1) * row_scale, column * column_scale:(column + 1) * column_scale])\n            else:\n                ax = plt.gca()\n            axes.append(ax)\n            logger.debug('rgrid: %r', rgrid.shape)\n            plot_rgrid = rgrid\n            assert plot_rgrid.shape[1] == 1, 'no layers supported yet'\n            plot_rgrid = plot_rgrid[:, 0]\n            if plot_rgrid.shape[0] > 1:\n                plot_rgrid = vaex.image.fade(plot_rgrid[::-1])\n            else:\n                plot_rgrid = plot_rgrid[0]\n            extend = None\n            if visual['subspace'] == 'row':\n                subplot_index = i\n            elif visual['subspace'] == 'column':\n                subplot_index = j\n            else:\n                subplot_index = 0\n            extend = np.array(xlimits[subplot_index][-2:]).flatten()\n            logger.debug('plot rgrid: %r', plot_rgrid.shape)\n            plot_rgrid = np.transpose(plot_rgrid, (1, 0, 2))\n            im = ax.imshow(plot_rgrid, extent=extend.tolist(), origin='lower', aspect=aspect, interpolation=interpolation)\n\n            def label(index, label, expression):\n                if label and _issequence(label):\n                    return label[i]\n                else:\n                    return self.label(expression)\n            if visual_reverse['x'] == 'x':\n                labelsx = labels['x']\n                plt.xlabel(labelsx[subplot_index])\n            if visual_reverse['x'] == 'x':\n                labelsy = labels['y']\n                plt.ylabel(labelsy[subplot_index])\n            if visual['z'] in ['row']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[i])\n            if visual['z'] in ['column']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[j])\n            max_labels = 10\n            xexpression = xexpressions[subplot_index]\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.xticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            yexpression = yexpressions[subplot_index]\n            if self.iscategory(yexpression):\n                labels = self.category_labels(yexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.yticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            facet_index += 1\n    if title:\n        fig.suptitle(title, fontsize='x-large')\n    if tight_layout:\n        if title:\n            plt.tight_layout(rect=[0, 0.03, 1, 0.95])\n        else:\n            plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    if return_extra:\n        return (im, grid, fgrid, ngrid, rgrid)\n    else:\n        return im",
        "mutated": [
            "@viz_method\n@docsubst\ndef heatmap(self, x=None, y=None, z=None, what='count(*)', vwhat=None, reduce=['colormap'], f=None, normalize='normalize', normalize_axis='what', vmin=None, vmax=None, shape=256, vshape=32, limits=None, grid=None, colormap='afmhot', figsize=None, xlabel=None, ylabel=None, aspect='auto', tight_layout=True, interpolation='nearest', show=False, colorbar=True, colorbar_label=None, selection=None, selection_labels=None, title=None, background_color='white', pre_blend=False, background_alpha=1.0, visual=dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what'), smooth_pre=None, smooth_post=None, wrap=True, wrap_columns=4, return_extra=False, hardcopy=None):\n    if False:\n        i = 10\n    \"Viz data in a 2d histogram/heatmap.\\n\\n    Declarative plotting of statistical plots using matplotlib, supports subplots, selections, layers.\\n\\n    Instead of passing x and y, pass a list as x argument for multiple panels. Give what a list of options to have multiple\\n    panels. When both are present then will be origanized in a column/row order.\\n\\n    This methods creates a 6 dimensional 'grid', where each dimension can map the a visual dimension.\\n    The grid dimensions are:\\n\\n    * x: shape determined by shape, content by x argument or the first dimension of each space\\n    * y:   ,,\\n    * z:  related to the z argument\\n    * selection: shape equals length of selection argument\\n    * what: shape equals length of what argument\\n    * space: shape equals length of x argument if multiple values are given\\n\\n     By default, this its shape is (1, 1, 1, 1, shape, shape) (where x is the last dimension)\\n\\n    The visual dimensions are\\n\\n    * x: x coordinate on a plot / image (default maps to grid's x)\\n    * y: y   ,,                         (default maps to grid's y)\\n    * layer: each image in this dimension is blended togeher to one image (default maps to z)\\n    * fade: each image is shown faded after the next image (default mapt to selection)\\n    * row: rows of subplots (default maps to space)\\n    * columns: columns of subplot (default maps to what)\\n\\n    All these mappings can be changes by the visual argument, some examples:\\n\\n    >>> df.viz.heatmap('x', 'y', what=['mean(x)', 'correlation(vx, vy)'])\\n\\n    Will plot each 'what' as a column.\\n\\n    >>> df.viz.heatmap('x', 'y', selection=['FeH < -3', '(FeH >= -3) & (FeH < -2)'], visual=dict(column='selection'))\\n\\n    Will plot each selection as a column, instead of a faded on top of each other.\\n\\n\\n\\n\\n\\n    :param x: Expression to bin in the x direction (by default maps to x), or list of pairs, like [['x', 'y'], ['x', 'z']], if multiple pairs are given, this dimension maps to rows by default\\n    :param y:                          y           (by default maps to y)\\n    :param z: Expression to bin in the z direction, followed by a :start,end,shape  signature, like 'FeH:-3,1:5' will produce 5 layers between -10 and 10 (by default maps to layer)\\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum, std('x') the standard deviation, correlation('vx', 'vy') the correlation coefficient. Can also be a list of values, like ['count(x)', std('vx')], (by default maps to column)\\n    :param reduce:\\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\\n    :param normalize: normalization function, currently only 'normalize' is supported\\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\\n    :param vmin: instead of automatic normalization, (using normalize and normalization_axis) scale the data between vmin and vmax to [0, 1]\\n    :param vmax: see vmin\\n    :param shape: {shape}\\n    :param limits: {limits}\\n    :param grid: {grid}\\n    :param colormap: matplotlib colormap to use\\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\\n    :param xlabel:\\n    :param ylabel:\\n    :param aspect:\\n    :param tight_layout: call plt.tight_layout or not\\n    :param colorbar: plot a colorbar or not\\n    :param selection: {selection1}\\n    :param interpolation: interpolation for imshow, possible options are: 'nearest', 'bilinear', 'bicubic', see matplotlib for more\\n    :param return_extra:\\n    :return:\\n    \"\n    import matplotlib\n    import matplotlib.pyplot as plt\n    n = _parse_n(normalize)\n    if type(shape) == int:\n        shape = (shape,) * 2\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    for expression in [y, x]:\n        if expression is not None:\n            binby = [expression] + binby\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    import re\n    what_units = None\n    whats = _ensure_list(what)\n    selections = _ensure_list(selection)\n    selections = _ensure_strings_from_expressions(selections)\n    if y is None:\n        (waslist, [x]) = listify(x)\n    else:\n        (waslist, [x, y]) = listify(x, y)\n        x = list(zip(x, y))\n        limits = [limits]\n    vwhats = _expand_limits(vwhat, len(x))\n    logger.debug('x: %s', x)\n    (limits, shape) = self.limits(x, limits, shape=shape)\n    shape = shape[0]\n    logger.debug('limits: %r', limits)\n    labels = {}\n    shape = _expand_shape(shape, 2)\n    vshape = _expand_shape(shape, 2)\n    if z is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', z)\n        if match:\n            groups = match.groups()\n            import ast\n            z_expression = groups[0]\n            logger.debug('found groups: %r', list(groups))\n            z_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            z_shape = ast.literal_eval(groups[3])\n            x = [[z_expression] + list(k) for k in x]\n            limits = np.array([[z_limits] + list(k) for k in limits])\n            shape = (z_shape,) + shape\n            vshape = (z_shape,) + vshape\n            logger.debug('x = %r', x)\n            values = np.linspace(z_limits[0], z_limits[1], num=z_shape + 1)\n            labels['z'] = list(['%s <= %s < %s' % (v1, z_expression, v2) for (v1, v2) in zip(values[:-1], values[1:])])\n        else:\n            raise ValueError(\"Could not understand 'z' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    else:\n        z_shape = 1\n    if z is None:\n        total_grid = np.zeros((len(x), len(whats), len(selections), 1) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections), 1) + vshape, dtype=float)\n    else:\n        total_grid = np.zeros((len(x), len(whats), len(selections)) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections)) + vshape, dtype=float)\n    logger.debug('shape of total grid: %r', total_grid.shape)\n    axis = dict(plot=0, what=1, selection=2)\n    xlimits = limits\n    grid_axes = dict(x=-1, y=-2, z=-3, selection=-4, what=-5, subspace=-6)\n    visual_axes = dict(x=-1, y=-2, layer=-3, fade=-4, column=-5, row=-6)\n    visual_default = dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what')\n\n    def invert(x):\n        return dict(((v, k) for (k, v) in x.items()))\n    free_visual_axes = list(visual_default.keys())\n    logger.debug('1: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual.items():\n        if visual_name in free_visual_axes:\n            free_visual_axes.remove(visual_name)\n        else:\n            raise ValueError('visual axes %s used multiple times' % visual_name)\n    logger.debug('2: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name in free_visual_axes and grid_name not in visual.values():\n            free_visual_axes.remove(visual_name)\n            visual[visual_name] = grid_name\n    logger.debug('3: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name not in free_visual_axes and grid_name not in visual.values():\n            visual[free_visual_axes.pop(0)] = grid_name\n    logger.debug('4: %r %r', visual, free_visual_axes)\n    visual_reverse = invert(visual)\n    (visual, visual_reverse) = (visual_reverse, visual)\n    move = {}\n    for (grid_name, visual_name) in visual.items():\n        if visual_axes[visual_name] in visual.values():\n            index = visual.values().find(visual_name)\n            key = visual.keys()[index]\n            raise ValueError('trying to map %s to %s while, it is already mapped by %s' % (grid_name, visual_name, key))\n        move[grid_axes[grid_name]] = visual_axes[visual_name]\n    fs = _expand(f, total_grid.shape[grid_axes[normalize_axis]])\n    what_labels = []\n    if grid is None:\n        grid_of_grids = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            grid_of_grids.append([])\n            for (j, what) in enumerate(whats):\n                if isinstance(what, vaex.stat.Expression):\n                    grid = what.calculate(self, binby=binby, shape=shape, limits=limits, selection=selections, delay=True)\n                else:\n                    what = what.strip()\n                    index = what.index('(')\n                    import re\n                    groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                    if groups and len(groups) == 2:\n                        function = groups[0]\n                        arguments = groups[1].strip()\n                        if ',' in arguments:\n                            arguments = arguments.split(',')\n                        functions = ['mean', 'sum', 'std', 'var', 'correlation', 'covar', 'min', 'max', 'median_approx']\n                        unit_expression = None\n                        if function in ['mean', 'sum', 'std', 'min', 'max', 'median']:\n                            unit_expression = arguments\n                        if function in ['var']:\n                            unit_expression = '(%s) * (%s)' % (arguments, arguments)\n                        if function in ['covar']:\n                            unit_expression = '(%s) * (%s)' % arguments\n                        if unit_expression:\n                            unit = self.unit(unit_expression)\n                            if unit:\n                                what_units = unit.to_string('latex_inline')\n                        if function in functions:\n                            grid = getattr(self, function)(arguments, binby=binby, limits=limits, shape=shape, selection=selections, delay=True)\n                        elif function == 'count':\n                            grid = self.count(arguments, binby, shape=shape, limits=limits, selection=selections, delay=True)\n                        else:\n                            raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                    else:\n                        raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n                if i == 0:\n                    what_label = str(whats[j])\n                    if what_units:\n                        what_label += ' (%s)' % what_units\n                    if fs[j]:\n                        what_label = fs[j] + ' ' + what_label\n                    what_labels.append(what_label)\n                grid_of_grids[-1].append(grid)\n        self.execute()\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            for (j, what) in enumerate(whats):\n                grid = grid_of_grids[i][j].get()\n                total_grid[i, j, :, :] = grid[:, None, ...]\n        labels['what'] = what_labels\n    else:\n        dims_left = 6 - len(grid.shape)\n        total_grid = np.broadcast_to(grid, (1,) * dims_left + grid.shape)\n\n    def _selection_name(name):\n        if name in [None, False]:\n            return 'selection: all'\n        elif name in ['default', True]:\n            return 'selection: default'\n        else:\n            return 'selection: %s' % name\n    if selection_labels is None:\n        labels['selection'] = list([_selection_name(k) for k in selections])\n    else:\n        labels['selection'] = selection_labels\n    axes = [None] * len(move)\n    for (key, value) in move.items():\n        axes[value] = key\n    visual_grid = np.transpose(total_grid, axes)\n    logger.debug('grid shape: %r', total_grid.shape)\n    logger.debug('visual: %r', visual.items())\n    logger.debug('move: %r', move)\n    logger.debug('visual grid shape: %r', visual_grid.shape)\n    xexpressions = []\n    yexpressions = []\n    for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n        xexpressions.append(binby[0])\n        yexpressions.append(binby[1])\n    if xlabel is None:\n        xlabels = []\n        ylabels = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            if z is not None:\n                xlabels.append(self.label(binby[1]))\n                ylabels.append(self.label(binby[2]))\n            else:\n                xlabels.append(self.label(binby[0]))\n                ylabels.append(self.label(binby[1]))\n    else:\n        Nl = visual_grid.shape[visual_axes['row']]\n        xlabels = _expand(xlabel, Nl)\n        ylabels = _expand(ylabel, Nl)\n    labels['x'] = xlabels\n    labels['y'] = ylabels\n    axes = []\n    background_color = np.array(matplotlib.colors.colorConverter.to_rgb(background_color))\n    import math\n    facet_columns = None\n    facets = visual_grid.shape[visual_axes['row']] * visual_grid.shape[visual_axes['column']]\n    if visual_grid.shape[visual_axes['column']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['row']])\n        wrapped = True\n    elif visual_grid.shape[visual_axes['row']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['column']])\n        wrapped = True\n    else:\n        wrapped = False\n        facet_columns = visual_grid.shape[visual_axes['column']]\n    facet_rows = int(math.ceil(facets / facet_columns))\n    logger.debug('facet_rows: %r', facet_rows)\n    logger.debug('facet_columns: %r', facet_columns)\n    grid = visual_grid * 1.0\n    fgrid = visual_grid * 1.0\n    ngrid = visual_grid * 1.0\n    vmins = _expand(vmin, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    vmaxs = _expand(vmax, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    visual_grid\n    if smooth_pre:\n        grid = vaex.grids.gf(grid, smooth_pre)\n    if 1:\n        axis = visual_axes[visual[normalize_axis]]\n        for i in range(visual_grid.shape[axis]):\n            item = [slice(None, None, None)] * len(visual_grid.shape)\n            item[axis] = i\n            item = tuple(item)\n            f = _parse_f(fs[i])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                fgrid.__setitem__(item, f(grid.__getitem__(item)))\n            if vmins[i] is not None and vmaxs[i] is not None:\n                nsubgrid = fgrid.__getitem__(item) * 1\n                nsubgrid -= vmins[i]\n                nsubgrid /= vmaxs[i] - vmins[i]\n            else:\n                (nsubgrid, vmin, vmax) = n(fgrid.__getitem__(item))\n                vmins[i] = vmin\n                vmaxs[i] = vmax\n            ngrid.__setitem__(item, nsubgrid)\n    if 0:\n        grid = visual_grid[i]\n        f = _parse_f(fs[i])\n        fgrid = f(grid)\n        finite_mask = np.isfinite(grid)\n        finite_mask = np.any(finite_mask, axis=0)\n        if vmin is not None and vmax is not None:\n            ngrid = fgrid * 1\n            ngrid -= vmin\n            ngrid /= vmax - vmin\n            ngrid = np.clip(ngrid, 0, 1)\n        else:\n            (ngrid, vmin, vmax) = n(fgrid)\n    (rows, columns) = (int(math.ceil(facets / float(facet_columns))), facet_columns)\n    colorbar_location = 'individual'\n    if visual['what'] == 'row' and visual_grid.shape[1] == facet_columns:\n        colorbar_location = 'per_row'\n    if visual['what'] == 'column' and visual_grid.shape[0] == facet_rows:\n        colorbar_location = 'per_column'\n    logger.debug('rows: %r, columns: %r', rows, columns)\n    import matplotlib.gridspec as gridspec\n    column_scale = 1\n    row_scale = 1\n    row_offset = 0\n    if facets > 1:\n        if colorbar_location == 'per_row':\n            column_scale = 4\n            gs = gridspec.GridSpec(rows, columns * column_scale + 1)\n        elif colorbar_location == 'per_column':\n            row_offset = 1\n            row_scale = 4\n            gs = gridspec.GridSpec(rows * row_scale + 1, columns)\n        else:\n            gs = gridspec.GridSpec(rows, columns)\n    facet_index = 0\n    fs = _expand(f, len(whats))\n    colormaps = _expand(colormap, len(whats))\n    for i in range(visual_grid.shape[0]):\n        for j in range(visual_grid.shape[1]):\n            if colorbar and colorbar_location == 'per_column' and (i == 0):\n                norm = matplotlib.colors.Normalize(vmins[j], vmaxs[j])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[j])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[0, j])\n                    colorbar = fig.colorbar(sm, cax=ax, orientation='horizontal')\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                if 'what' in labels:\n                    label = labels['what'][j]\n                    if facets > 1:\n                        colorbar.ax.set_title(label)\n                    else:\n                        colorbar.ax.set_ylabel(colorbar_label or label)\n            if colorbar and colorbar_location == 'per_row' and (j == 0):\n                norm = matplotlib.colors.Normalize(vmins[i], vmaxs[i])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[i])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[i, -1])\n                    colorbar = fig.colorbar(sm, cax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][i]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            rgrid = ngrid[i, j] * 1.0\n            for k in range(rgrid.shape[0]):\n                for l in range(rgrid.shape[0]):\n                    if smooth_post is not None:\n                        rgrid[k, l] = vaex.grids.gf(rgrid, smooth_post)\n            if visual['what'] == 'column':\n                what_index = j\n            elif visual['what'] == 'row':\n                what_index = i\n            else:\n                what_index = 0\n            if visual[normalize_axis] == 'column':\n                normalize_index = j\n            elif visual[normalize_axis] == 'row':\n                normalize_index = i\n            else:\n                normalize_index = 0\n            for r in reduce:\n                r = _parse_reduction(r, colormaps[what_index], [])\n                rgrid = r(rgrid)\n            row = facet_index // facet_columns\n            column = facet_index % facet_columns\n            if colorbar and colorbar_location == 'individual':\n                norm = matplotlib.colors.Normalize(vmins[normalize_index], vmaxs[normalize_index])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[what_index])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[row, column])\n                    colorbar = fig.colorbar(sm, ax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][what_index]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            if facets > 1:\n                ax = plt.subplot(gs[row_offset + row * row_scale:row_offset + (row + 1) * row_scale, column * column_scale:(column + 1) * column_scale])\n            else:\n                ax = plt.gca()\n            axes.append(ax)\n            logger.debug('rgrid: %r', rgrid.shape)\n            plot_rgrid = rgrid\n            assert plot_rgrid.shape[1] == 1, 'no layers supported yet'\n            plot_rgrid = plot_rgrid[:, 0]\n            if plot_rgrid.shape[0] > 1:\n                plot_rgrid = vaex.image.fade(plot_rgrid[::-1])\n            else:\n                plot_rgrid = plot_rgrid[0]\n            extend = None\n            if visual['subspace'] == 'row':\n                subplot_index = i\n            elif visual['subspace'] == 'column':\n                subplot_index = j\n            else:\n                subplot_index = 0\n            extend = np.array(xlimits[subplot_index][-2:]).flatten()\n            logger.debug('plot rgrid: %r', plot_rgrid.shape)\n            plot_rgrid = np.transpose(plot_rgrid, (1, 0, 2))\n            im = ax.imshow(plot_rgrid, extent=extend.tolist(), origin='lower', aspect=aspect, interpolation=interpolation)\n\n            def label(index, label, expression):\n                if label and _issequence(label):\n                    return label[i]\n                else:\n                    return self.label(expression)\n            if visual_reverse['x'] == 'x':\n                labelsx = labels['x']\n                plt.xlabel(labelsx[subplot_index])\n            if visual_reverse['x'] == 'x':\n                labelsy = labels['y']\n                plt.ylabel(labelsy[subplot_index])\n            if visual['z'] in ['row']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[i])\n            if visual['z'] in ['column']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[j])\n            max_labels = 10\n            xexpression = xexpressions[subplot_index]\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.xticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            yexpression = yexpressions[subplot_index]\n            if self.iscategory(yexpression):\n                labels = self.category_labels(yexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.yticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            facet_index += 1\n    if title:\n        fig.suptitle(title, fontsize='x-large')\n    if tight_layout:\n        if title:\n            plt.tight_layout(rect=[0, 0.03, 1, 0.95])\n        else:\n            plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    if return_extra:\n        return (im, grid, fgrid, ngrid, rgrid)\n    else:\n        return im",
            "@viz_method\n@docsubst\ndef heatmap(self, x=None, y=None, z=None, what='count(*)', vwhat=None, reduce=['colormap'], f=None, normalize='normalize', normalize_axis='what', vmin=None, vmax=None, shape=256, vshape=32, limits=None, grid=None, colormap='afmhot', figsize=None, xlabel=None, ylabel=None, aspect='auto', tight_layout=True, interpolation='nearest', show=False, colorbar=True, colorbar_label=None, selection=None, selection_labels=None, title=None, background_color='white', pre_blend=False, background_alpha=1.0, visual=dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what'), smooth_pre=None, smooth_post=None, wrap=True, wrap_columns=4, return_extra=False, hardcopy=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Viz data in a 2d histogram/heatmap.\\n\\n    Declarative plotting of statistical plots using matplotlib, supports subplots, selections, layers.\\n\\n    Instead of passing x and y, pass a list as x argument for multiple panels. Give what a list of options to have multiple\\n    panels. When both are present then will be origanized in a column/row order.\\n\\n    This methods creates a 6 dimensional 'grid', where each dimension can map the a visual dimension.\\n    The grid dimensions are:\\n\\n    * x: shape determined by shape, content by x argument or the first dimension of each space\\n    * y:   ,,\\n    * z:  related to the z argument\\n    * selection: shape equals length of selection argument\\n    * what: shape equals length of what argument\\n    * space: shape equals length of x argument if multiple values are given\\n\\n     By default, this its shape is (1, 1, 1, 1, shape, shape) (where x is the last dimension)\\n\\n    The visual dimensions are\\n\\n    * x: x coordinate on a plot / image (default maps to grid's x)\\n    * y: y   ,,                         (default maps to grid's y)\\n    * layer: each image in this dimension is blended togeher to one image (default maps to z)\\n    * fade: each image is shown faded after the next image (default mapt to selection)\\n    * row: rows of subplots (default maps to space)\\n    * columns: columns of subplot (default maps to what)\\n\\n    All these mappings can be changes by the visual argument, some examples:\\n\\n    >>> df.viz.heatmap('x', 'y', what=['mean(x)', 'correlation(vx, vy)'])\\n\\n    Will plot each 'what' as a column.\\n\\n    >>> df.viz.heatmap('x', 'y', selection=['FeH < -3', '(FeH >= -3) & (FeH < -2)'], visual=dict(column='selection'))\\n\\n    Will plot each selection as a column, instead of a faded on top of each other.\\n\\n\\n\\n\\n\\n    :param x: Expression to bin in the x direction (by default maps to x), or list of pairs, like [['x', 'y'], ['x', 'z']], if multiple pairs are given, this dimension maps to rows by default\\n    :param y:                          y           (by default maps to y)\\n    :param z: Expression to bin in the z direction, followed by a :start,end,shape  signature, like 'FeH:-3,1:5' will produce 5 layers between -10 and 10 (by default maps to layer)\\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum, std('x') the standard deviation, correlation('vx', 'vy') the correlation coefficient. Can also be a list of values, like ['count(x)', std('vx')], (by default maps to column)\\n    :param reduce:\\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\\n    :param normalize: normalization function, currently only 'normalize' is supported\\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\\n    :param vmin: instead of automatic normalization, (using normalize and normalization_axis) scale the data between vmin and vmax to [0, 1]\\n    :param vmax: see vmin\\n    :param shape: {shape}\\n    :param limits: {limits}\\n    :param grid: {grid}\\n    :param colormap: matplotlib colormap to use\\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\\n    :param xlabel:\\n    :param ylabel:\\n    :param aspect:\\n    :param tight_layout: call plt.tight_layout or not\\n    :param colorbar: plot a colorbar or not\\n    :param selection: {selection1}\\n    :param interpolation: interpolation for imshow, possible options are: 'nearest', 'bilinear', 'bicubic', see matplotlib for more\\n    :param return_extra:\\n    :return:\\n    \"\n    import matplotlib\n    import matplotlib.pyplot as plt\n    n = _parse_n(normalize)\n    if type(shape) == int:\n        shape = (shape,) * 2\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    for expression in [y, x]:\n        if expression is not None:\n            binby = [expression] + binby\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    import re\n    what_units = None\n    whats = _ensure_list(what)\n    selections = _ensure_list(selection)\n    selections = _ensure_strings_from_expressions(selections)\n    if y is None:\n        (waslist, [x]) = listify(x)\n    else:\n        (waslist, [x, y]) = listify(x, y)\n        x = list(zip(x, y))\n        limits = [limits]\n    vwhats = _expand_limits(vwhat, len(x))\n    logger.debug('x: %s', x)\n    (limits, shape) = self.limits(x, limits, shape=shape)\n    shape = shape[0]\n    logger.debug('limits: %r', limits)\n    labels = {}\n    shape = _expand_shape(shape, 2)\n    vshape = _expand_shape(shape, 2)\n    if z is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', z)\n        if match:\n            groups = match.groups()\n            import ast\n            z_expression = groups[0]\n            logger.debug('found groups: %r', list(groups))\n            z_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            z_shape = ast.literal_eval(groups[3])\n            x = [[z_expression] + list(k) for k in x]\n            limits = np.array([[z_limits] + list(k) for k in limits])\n            shape = (z_shape,) + shape\n            vshape = (z_shape,) + vshape\n            logger.debug('x = %r', x)\n            values = np.linspace(z_limits[0], z_limits[1], num=z_shape + 1)\n            labels['z'] = list(['%s <= %s < %s' % (v1, z_expression, v2) for (v1, v2) in zip(values[:-1], values[1:])])\n        else:\n            raise ValueError(\"Could not understand 'z' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    else:\n        z_shape = 1\n    if z is None:\n        total_grid = np.zeros((len(x), len(whats), len(selections), 1) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections), 1) + vshape, dtype=float)\n    else:\n        total_grid = np.zeros((len(x), len(whats), len(selections)) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections)) + vshape, dtype=float)\n    logger.debug('shape of total grid: %r', total_grid.shape)\n    axis = dict(plot=0, what=1, selection=2)\n    xlimits = limits\n    grid_axes = dict(x=-1, y=-2, z=-3, selection=-4, what=-5, subspace=-6)\n    visual_axes = dict(x=-1, y=-2, layer=-3, fade=-4, column=-5, row=-6)\n    visual_default = dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what')\n\n    def invert(x):\n        return dict(((v, k) for (k, v) in x.items()))\n    free_visual_axes = list(visual_default.keys())\n    logger.debug('1: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual.items():\n        if visual_name in free_visual_axes:\n            free_visual_axes.remove(visual_name)\n        else:\n            raise ValueError('visual axes %s used multiple times' % visual_name)\n    logger.debug('2: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name in free_visual_axes and grid_name not in visual.values():\n            free_visual_axes.remove(visual_name)\n            visual[visual_name] = grid_name\n    logger.debug('3: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name not in free_visual_axes and grid_name not in visual.values():\n            visual[free_visual_axes.pop(0)] = grid_name\n    logger.debug('4: %r %r', visual, free_visual_axes)\n    visual_reverse = invert(visual)\n    (visual, visual_reverse) = (visual_reverse, visual)\n    move = {}\n    for (grid_name, visual_name) in visual.items():\n        if visual_axes[visual_name] in visual.values():\n            index = visual.values().find(visual_name)\n            key = visual.keys()[index]\n            raise ValueError('trying to map %s to %s while, it is already mapped by %s' % (grid_name, visual_name, key))\n        move[grid_axes[grid_name]] = visual_axes[visual_name]\n    fs = _expand(f, total_grid.shape[grid_axes[normalize_axis]])\n    what_labels = []\n    if grid is None:\n        grid_of_grids = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            grid_of_grids.append([])\n            for (j, what) in enumerate(whats):\n                if isinstance(what, vaex.stat.Expression):\n                    grid = what.calculate(self, binby=binby, shape=shape, limits=limits, selection=selections, delay=True)\n                else:\n                    what = what.strip()\n                    index = what.index('(')\n                    import re\n                    groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                    if groups and len(groups) == 2:\n                        function = groups[0]\n                        arguments = groups[1].strip()\n                        if ',' in arguments:\n                            arguments = arguments.split(',')\n                        functions = ['mean', 'sum', 'std', 'var', 'correlation', 'covar', 'min', 'max', 'median_approx']\n                        unit_expression = None\n                        if function in ['mean', 'sum', 'std', 'min', 'max', 'median']:\n                            unit_expression = arguments\n                        if function in ['var']:\n                            unit_expression = '(%s) * (%s)' % (arguments, arguments)\n                        if function in ['covar']:\n                            unit_expression = '(%s) * (%s)' % arguments\n                        if unit_expression:\n                            unit = self.unit(unit_expression)\n                            if unit:\n                                what_units = unit.to_string('latex_inline')\n                        if function in functions:\n                            grid = getattr(self, function)(arguments, binby=binby, limits=limits, shape=shape, selection=selections, delay=True)\n                        elif function == 'count':\n                            grid = self.count(arguments, binby, shape=shape, limits=limits, selection=selections, delay=True)\n                        else:\n                            raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                    else:\n                        raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n                if i == 0:\n                    what_label = str(whats[j])\n                    if what_units:\n                        what_label += ' (%s)' % what_units\n                    if fs[j]:\n                        what_label = fs[j] + ' ' + what_label\n                    what_labels.append(what_label)\n                grid_of_grids[-1].append(grid)\n        self.execute()\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            for (j, what) in enumerate(whats):\n                grid = grid_of_grids[i][j].get()\n                total_grid[i, j, :, :] = grid[:, None, ...]\n        labels['what'] = what_labels\n    else:\n        dims_left = 6 - len(grid.shape)\n        total_grid = np.broadcast_to(grid, (1,) * dims_left + grid.shape)\n\n    def _selection_name(name):\n        if name in [None, False]:\n            return 'selection: all'\n        elif name in ['default', True]:\n            return 'selection: default'\n        else:\n            return 'selection: %s' % name\n    if selection_labels is None:\n        labels['selection'] = list([_selection_name(k) for k in selections])\n    else:\n        labels['selection'] = selection_labels\n    axes = [None] * len(move)\n    for (key, value) in move.items():\n        axes[value] = key\n    visual_grid = np.transpose(total_grid, axes)\n    logger.debug('grid shape: %r', total_grid.shape)\n    logger.debug('visual: %r', visual.items())\n    logger.debug('move: %r', move)\n    logger.debug('visual grid shape: %r', visual_grid.shape)\n    xexpressions = []\n    yexpressions = []\n    for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n        xexpressions.append(binby[0])\n        yexpressions.append(binby[1])\n    if xlabel is None:\n        xlabels = []\n        ylabels = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            if z is not None:\n                xlabels.append(self.label(binby[1]))\n                ylabels.append(self.label(binby[2]))\n            else:\n                xlabels.append(self.label(binby[0]))\n                ylabels.append(self.label(binby[1]))\n    else:\n        Nl = visual_grid.shape[visual_axes['row']]\n        xlabels = _expand(xlabel, Nl)\n        ylabels = _expand(ylabel, Nl)\n    labels['x'] = xlabels\n    labels['y'] = ylabels\n    axes = []\n    background_color = np.array(matplotlib.colors.colorConverter.to_rgb(background_color))\n    import math\n    facet_columns = None\n    facets = visual_grid.shape[visual_axes['row']] * visual_grid.shape[visual_axes['column']]\n    if visual_grid.shape[visual_axes['column']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['row']])\n        wrapped = True\n    elif visual_grid.shape[visual_axes['row']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['column']])\n        wrapped = True\n    else:\n        wrapped = False\n        facet_columns = visual_grid.shape[visual_axes['column']]\n    facet_rows = int(math.ceil(facets / facet_columns))\n    logger.debug('facet_rows: %r', facet_rows)\n    logger.debug('facet_columns: %r', facet_columns)\n    grid = visual_grid * 1.0\n    fgrid = visual_grid * 1.0\n    ngrid = visual_grid * 1.0\n    vmins = _expand(vmin, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    vmaxs = _expand(vmax, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    visual_grid\n    if smooth_pre:\n        grid = vaex.grids.gf(grid, smooth_pre)\n    if 1:\n        axis = visual_axes[visual[normalize_axis]]\n        for i in range(visual_grid.shape[axis]):\n            item = [slice(None, None, None)] * len(visual_grid.shape)\n            item[axis] = i\n            item = tuple(item)\n            f = _parse_f(fs[i])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                fgrid.__setitem__(item, f(grid.__getitem__(item)))\n            if vmins[i] is not None and vmaxs[i] is not None:\n                nsubgrid = fgrid.__getitem__(item) * 1\n                nsubgrid -= vmins[i]\n                nsubgrid /= vmaxs[i] - vmins[i]\n            else:\n                (nsubgrid, vmin, vmax) = n(fgrid.__getitem__(item))\n                vmins[i] = vmin\n                vmaxs[i] = vmax\n            ngrid.__setitem__(item, nsubgrid)\n    if 0:\n        grid = visual_grid[i]\n        f = _parse_f(fs[i])\n        fgrid = f(grid)\n        finite_mask = np.isfinite(grid)\n        finite_mask = np.any(finite_mask, axis=0)\n        if vmin is not None and vmax is not None:\n            ngrid = fgrid * 1\n            ngrid -= vmin\n            ngrid /= vmax - vmin\n            ngrid = np.clip(ngrid, 0, 1)\n        else:\n            (ngrid, vmin, vmax) = n(fgrid)\n    (rows, columns) = (int(math.ceil(facets / float(facet_columns))), facet_columns)\n    colorbar_location = 'individual'\n    if visual['what'] == 'row' and visual_grid.shape[1] == facet_columns:\n        colorbar_location = 'per_row'\n    if visual['what'] == 'column' and visual_grid.shape[0] == facet_rows:\n        colorbar_location = 'per_column'\n    logger.debug('rows: %r, columns: %r', rows, columns)\n    import matplotlib.gridspec as gridspec\n    column_scale = 1\n    row_scale = 1\n    row_offset = 0\n    if facets > 1:\n        if colorbar_location == 'per_row':\n            column_scale = 4\n            gs = gridspec.GridSpec(rows, columns * column_scale + 1)\n        elif colorbar_location == 'per_column':\n            row_offset = 1\n            row_scale = 4\n            gs = gridspec.GridSpec(rows * row_scale + 1, columns)\n        else:\n            gs = gridspec.GridSpec(rows, columns)\n    facet_index = 0\n    fs = _expand(f, len(whats))\n    colormaps = _expand(colormap, len(whats))\n    for i in range(visual_grid.shape[0]):\n        for j in range(visual_grid.shape[1]):\n            if colorbar and colorbar_location == 'per_column' and (i == 0):\n                norm = matplotlib.colors.Normalize(vmins[j], vmaxs[j])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[j])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[0, j])\n                    colorbar = fig.colorbar(sm, cax=ax, orientation='horizontal')\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                if 'what' in labels:\n                    label = labels['what'][j]\n                    if facets > 1:\n                        colorbar.ax.set_title(label)\n                    else:\n                        colorbar.ax.set_ylabel(colorbar_label or label)\n            if colorbar and colorbar_location == 'per_row' and (j == 0):\n                norm = matplotlib.colors.Normalize(vmins[i], vmaxs[i])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[i])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[i, -1])\n                    colorbar = fig.colorbar(sm, cax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][i]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            rgrid = ngrid[i, j] * 1.0\n            for k in range(rgrid.shape[0]):\n                for l in range(rgrid.shape[0]):\n                    if smooth_post is not None:\n                        rgrid[k, l] = vaex.grids.gf(rgrid, smooth_post)\n            if visual['what'] == 'column':\n                what_index = j\n            elif visual['what'] == 'row':\n                what_index = i\n            else:\n                what_index = 0\n            if visual[normalize_axis] == 'column':\n                normalize_index = j\n            elif visual[normalize_axis] == 'row':\n                normalize_index = i\n            else:\n                normalize_index = 0\n            for r in reduce:\n                r = _parse_reduction(r, colormaps[what_index], [])\n                rgrid = r(rgrid)\n            row = facet_index // facet_columns\n            column = facet_index % facet_columns\n            if colorbar and colorbar_location == 'individual':\n                norm = matplotlib.colors.Normalize(vmins[normalize_index], vmaxs[normalize_index])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[what_index])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[row, column])\n                    colorbar = fig.colorbar(sm, ax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][what_index]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            if facets > 1:\n                ax = plt.subplot(gs[row_offset + row * row_scale:row_offset + (row + 1) * row_scale, column * column_scale:(column + 1) * column_scale])\n            else:\n                ax = plt.gca()\n            axes.append(ax)\n            logger.debug('rgrid: %r', rgrid.shape)\n            plot_rgrid = rgrid\n            assert plot_rgrid.shape[1] == 1, 'no layers supported yet'\n            plot_rgrid = plot_rgrid[:, 0]\n            if plot_rgrid.shape[0] > 1:\n                plot_rgrid = vaex.image.fade(plot_rgrid[::-1])\n            else:\n                plot_rgrid = plot_rgrid[0]\n            extend = None\n            if visual['subspace'] == 'row':\n                subplot_index = i\n            elif visual['subspace'] == 'column':\n                subplot_index = j\n            else:\n                subplot_index = 0\n            extend = np.array(xlimits[subplot_index][-2:]).flatten()\n            logger.debug('plot rgrid: %r', plot_rgrid.shape)\n            plot_rgrid = np.transpose(plot_rgrid, (1, 0, 2))\n            im = ax.imshow(plot_rgrid, extent=extend.tolist(), origin='lower', aspect=aspect, interpolation=interpolation)\n\n            def label(index, label, expression):\n                if label and _issequence(label):\n                    return label[i]\n                else:\n                    return self.label(expression)\n            if visual_reverse['x'] == 'x':\n                labelsx = labels['x']\n                plt.xlabel(labelsx[subplot_index])\n            if visual_reverse['x'] == 'x':\n                labelsy = labels['y']\n                plt.ylabel(labelsy[subplot_index])\n            if visual['z'] in ['row']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[i])\n            if visual['z'] in ['column']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[j])\n            max_labels = 10\n            xexpression = xexpressions[subplot_index]\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.xticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            yexpression = yexpressions[subplot_index]\n            if self.iscategory(yexpression):\n                labels = self.category_labels(yexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.yticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            facet_index += 1\n    if title:\n        fig.suptitle(title, fontsize='x-large')\n    if tight_layout:\n        if title:\n            plt.tight_layout(rect=[0, 0.03, 1, 0.95])\n        else:\n            plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    if return_extra:\n        return (im, grid, fgrid, ngrid, rgrid)\n    else:\n        return im",
            "@viz_method\n@docsubst\ndef heatmap(self, x=None, y=None, z=None, what='count(*)', vwhat=None, reduce=['colormap'], f=None, normalize='normalize', normalize_axis='what', vmin=None, vmax=None, shape=256, vshape=32, limits=None, grid=None, colormap='afmhot', figsize=None, xlabel=None, ylabel=None, aspect='auto', tight_layout=True, interpolation='nearest', show=False, colorbar=True, colorbar_label=None, selection=None, selection_labels=None, title=None, background_color='white', pre_blend=False, background_alpha=1.0, visual=dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what'), smooth_pre=None, smooth_post=None, wrap=True, wrap_columns=4, return_extra=False, hardcopy=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Viz data in a 2d histogram/heatmap.\\n\\n    Declarative plotting of statistical plots using matplotlib, supports subplots, selections, layers.\\n\\n    Instead of passing x and y, pass a list as x argument for multiple panels. Give what a list of options to have multiple\\n    panels. When both are present then will be origanized in a column/row order.\\n\\n    This methods creates a 6 dimensional 'grid', where each dimension can map the a visual dimension.\\n    The grid dimensions are:\\n\\n    * x: shape determined by shape, content by x argument or the first dimension of each space\\n    * y:   ,,\\n    * z:  related to the z argument\\n    * selection: shape equals length of selection argument\\n    * what: shape equals length of what argument\\n    * space: shape equals length of x argument if multiple values are given\\n\\n     By default, this its shape is (1, 1, 1, 1, shape, shape) (where x is the last dimension)\\n\\n    The visual dimensions are\\n\\n    * x: x coordinate on a plot / image (default maps to grid's x)\\n    * y: y   ,,                         (default maps to grid's y)\\n    * layer: each image in this dimension is blended togeher to one image (default maps to z)\\n    * fade: each image is shown faded after the next image (default mapt to selection)\\n    * row: rows of subplots (default maps to space)\\n    * columns: columns of subplot (default maps to what)\\n\\n    All these mappings can be changes by the visual argument, some examples:\\n\\n    >>> df.viz.heatmap('x', 'y', what=['mean(x)', 'correlation(vx, vy)'])\\n\\n    Will plot each 'what' as a column.\\n\\n    >>> df.viz.heatmap('x', 'y', selection=['FeH < -3', '(FeH >= -3) & (FeH < -2)'], visual=dict(column='selection'))\\n\\n    Will plot each selection as a column, instead of a faded on top of each other.\\n\\n\\n\\n\\n\\n    :param x: Expression to bin in the x direction (by default maps to x), or list of pairs, like [['x', 'y'], ['x', 'z']], if multiple pairs are given, this dimension maps to rows by default\\n    :param y:                          y           (by default maps to y)\\n    :param z: Expression to bin in the z direction, followed by a :start,end,shape  signature, like 'FeH:-3,1:5' will produce 5 layers between -10 and 10 (by default maps to layer)\\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum, std('x') the standard deviation, correlation('vx', 'vy') the correlation coefficient. Can also be a list of values, like ['count(x)', std('vx')], (by default maps to column)\\n    :param reduce:\\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\\n    :param normalize: normalization function, currently only 'normalize' is supported\\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\\n    :param vmin: instead of automatic normalization, (using normalize and normalization_axis) scale the data between vmin and vmax to [0, 1]\\n    :param vmax: see vmin\\n    :param shape: {shape}\\n    :param limits: {limits}\\n    :param grid: {grid}\\n    :param colormap: matplotlib colormap to use\\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\\n    :param xlabel:\\n    :param ylabel:\\n    :param aspect:\\n    :param tight_layout: call plt.tight_layout or not\\n    :param colorbar: plot a colorbar or not\\n    :param selection: {selection1}\\n    :param interpolation: interpolation for imshow, possible options are: 'nearest', 'bilinear', 'bicubic', see matplotlib for more\\n    :param return_extra:\\n    :return:\\n    \"\n    import matplotlib\n    import matplotlib.pyplot as plt\n    n = _parse_n(normalize)\n    if type(shape) == int:\n        shape = (shape,) * 2\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    for expression in [y, x]:\n        if expression is not None:\n            binby = [expression] + binby\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    import re\n    what_units = None\n    whats = _ensure_list(what)\n    selections = _ensure_list(selection)\n    selections = _ensure_strings_from_expressions(selections)\n    if y is None:\n        (waslist, [x]) = listify(x)\n    else:\n        (waslist, [x, y]) = listify(x, y)\n        x = list(zip(x, y))\n        limits = [limits]\n    vwhats = _expand_limits(vwhat, len(x))\n    logger.debug('x: %s', x)\n    (limits, shape) = self.limits(x, limits, shape=shape)\n    shape = shape[0]\n    logger.debug('limits: %r', limits)\n    labels = {}\n    shape = _expand_shape(shape, 2)\n    vshape = _expand_shape(shape, 2)\n    if z is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', z)\n        if match:\n            groups = match.groups()\n            import ast\n            z_expression = groups[0]\n            logger.debug('found groups: %r', list(groups))\n            z_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            z_shape = ast.literal_eval(groups[3])\n            x = [[z_expression] + list(k) for k in x]\n            limits = np.array([[z_limits] + list(k) for k in limits])\n            shape = (z_shape,) + shape\n            vshape = (z_shape,) + vshape\n            logger.debug('x = %r', x)\n            values = np.linspace(z_limits[0], z_limits[1], num=z_shape + 1)\n            labels['z'] = list(['%s <= %s < %s' % (v1, z_expression, v2) for (v1, v2) in zip(values[:-1], values[1:])])\n        else:\n            raise ValueError(\"Could not understand 'z' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    else:\n        z_shape = 1\n    if z is None:\n        total_grid = np.zeros((len(x), len(whats), len(selections), 1) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections), 1) + vshape, dtype=float)\n    else:\n        total_grid = np.zeros((len(x), len(whats), len(selections)) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections)) + vshape, dtype=float)\n    logger.debug('shape of total grid: %r', total_grid.shape)\n    axis = dict(plot=0, what=1, selection=2)\n    xlimits = limits\n    grid_axes = dict(x=-1, y=-2, z=-3, selection=-4, what=-5, subspace=-6)\n    visual_axes = dict(x=-1, y=-2, layer=-3, fade=-4, column=-5, row=-6)\n    visual_default = dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what')\n\n    def invert(x):\n        return dict(((v, k) for (k, v) in x.items()))\n    free_visual_axes = list(visual_default.keys())\n    logger.debug('1: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual.items():\n        if visual_name in free_visual_axes:\n            free_visual_axes.remove(visual_name)\n        else:\n            raise ValueError('visual axes %s used multiple times' % visual_name)\n    logger.debug('2: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name in free_visual_axes and grid_name not in visual.values():\n            free_visual_axes.remove(visual_name)\n            visual[visual_name] = grid_name\n    logger.debug('3: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name not in free_visual_axes and grid_name not in visual.values():\n            visual[free_visual_axes.pop(0)] = grid_name\n    logger.debug('4: %r %r', visual, free_visual_axes)\n    visual_reverse = invert(visual)\n    (visual, visual_reverse) = (visual_reverse, visual)\n    move = {}\n    for (grid_name, visual_name) in visual.items():\n        if visual_axes[visual_name] in visual.values():\n            index = visual.values().find(visual_name)\n            key = visual.keys()[index]\n            raise ValueError('trying to map %s to %s while, it is already mapped by %s' % (grid_name, visual_name, key))\n        move[grid_axes[grid_name]] = visual_axes[visual_name]\n    fs = _expand(f, total_grid.shape[grid_axes[normalize_axis]])\n    what_labels = []\n    if grid is None:\n        grid_of_grids = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            grid_of_grids.append([])\n            for (j, what) in enumerate(whats):\n                if isinstance(what, vaex.stat.Expression):\n                    grid = what.calculate(self, binby=binby, shape=shape, limits=limits, selection=selections, delay=True)\n                else:\n                    what = what.strip()\n                    index = what.index('(')\n                    import re\n                    groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                    if groups and len(groups) == 2:\n                        function = groups[0]\n                        arguments = groups[1].strip()\n                        if ',' in arguments:\n                            arguments = arguments.split(',')\n                        functions = ['mean', 'sum', 'std', 'var', 'correlation', 'covar', 'min', 'max', 'median_approx']\n                        unit_expression = None\n                        if function in ['mean', 'sum', 'std', 'min', 'max', 'median']:\n                            unit_expression = arguments\n                        if function in ['var']:\n                            unit_expression = '(%s) * (%s)' % (arguments, arguments)\n                        if function in ['covar']:\n                            unit_expression = '(%s) * (%s)' % arguments\n                        if unit_expression:\n                            unit = self.unit(unit_expression)\n                            if unit:\n                                what_units = unit.to_string('latex_inline')\n                        if function in functions:\n                            grid = getattr(self, function)(arguments, binby=binby, limits=limits, shape=shape, selection=selections, delay=True)\n                        elif function == 'count':\n                            grid = self.count(arguments, binby, shape=shape, limits=limits, selection=selections, delay=True)\n                        else:\n                            raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                    else:\n                        raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n                if i == 0:\n                    what_label = str(whats[j])\n                    if what_units:\n                        what_label += ' (%s)' % what_units\n                    if fs[j]:\n                        what_label = fs[j] + ' ' + what_label\n                    what_labels.append(what_label)\n                grid_of_grids[-1].append(grid)\n        self.execute()\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            for (j, what) in enumerate(whats):\n                grid = grid_of_grids[i][j].get()\n                total_grid[i, j, :, :] = grid[:, None, ...]\n        labels['what'] = what_labels\n    else:\n        dims_left = 6 - len(grid.shape)\n        total_grid = np.broadcast_to(grid, (1,) * dims_left + grid.shape)\n\n    def _selection_name(name):\n        if name in [None, False]:\n            return 'selection: all'\n        elif name in ['default', True]:\n            return 'selection: default'\n        else:\n            return 'selection: %s' % name\n    if selection_labels is None:\n        labels['selection'] = list([_selection_name(k) for k in selections])\n    else:\n        labels['selection'] = selection_labels\n    axes = [None] * len(move)\n    for (key, value) in move.items():\n        axes[value] = key\n    visual_grid = np.transpose(total_grid, axes)\n    logger.debug('grid shape: %r', total_grid.shape)\n    logger.debug('visual: %r', visual.items())\n    logger.debug('move: %r', move)\n    logger.debug('visual grid shape: %r', visual_grid.shape)\n    xexpressions = []\n    yexpressions = []\n    for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n        xexpressions.append(binby[0])\n        yexpressions.append(binby[1])\n    if xlabel is None:\n        xlabels = []\n        ylabels = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            if z is not None:\n                xlabels.append(self.label(binby[1]))\n                ylabels.append(self.label(binby[2]))\n            else:\n                xlabels.append(self.label(binby[0]))\n                ylabels.append(self.label(binby[1]))\n    else:\n        Nl = visual_grid.shape[visual_axes['row']]\n        xlabels = _expand(xlabel, Nl)\n        ylabels = _expand(ylabel, Nl)\n    labels['x'] = xlabels\n    labels['y'] = ylabels\n    axes = []\n    background_color = np.array(matplotlib.colors.colorConverter.to_rgb(background_color))\n    import math\n    facet_columns = None\n    facets = visual_grid.shape[visual_axes['row']] * visual_grid.shape[visual_axes['column']]\n    if visual_grid.shape[visual_axes['column']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['row']])\n        wrapped = True\n    elif visual_grid.shape[visual_axes['row']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['column']])\n        wrapped = True\n    else:\n        wrapped = False\n        facet_columns = visual_grid.shape[visual_axes['column']]\n    facet_rows = int(math.ceil(facets / facet_columns))\n    logger.debug('facet_rows: %r', facet_rows)\n    logger.debug('facet_columns: %r', facet_columns)\n    grid = visual_grid * 1.0\n    fgrid = visual_grid * 1.0\n    ngrid = visual_grid * 1.0\n    vmins = _expand(vmin, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    vmaxs = _expand(vmax, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    visual_grid\n    if smooth_pre:\n        grid = vaex.grids.gf(grid, smooth_pre)\n    if 1:\n        axis = visual_axes[visual[normalize_axis]]\n        for i in range(visual_grid.shape[axis]):\n            item = [slice(None, None, None)] * len(visual_grid.shape)\n            item[axis] = i\n            item = tuple(item)\n            f = _parse_f(fs[i])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                fgrid.__setitem__(item, f(grid.__getitem__(item)))\n            if vmins[i] is not None and vmaxs[i] is not None:\n                nsubgrid = fgrid.__getitem__(item) * 1\n                nsubgrid -= vmins[i]\n                nsubgrid /= vmaxs[i] - vmins[i]\n            else:\n                (nsubgrid, vmin, vmax) = n(fgrid.__getitem__(item))\n                vmins[i] = vmin\n                vmaxs[i] = vmax\n            ngrid.__setitem__(item, nsubgrid)\n    if 0:\n        grid = visual_grid[i]\n        f = _parse_f(fs[i])\n        fgrid = f(grid)\n        finite_mask = np.isfinite(grid)\n        finite_mask = np.any(finite_mask, axis=0)\n        if vmin is not None and vmax is not None:\n            ngrid = fgrid * 1\n            ngrid -= vmin\n            ngrid /= vmax - vmin\n            ngrid = np.clip(ngrid, 0, 1)\n        else:\n            (ngrid, vmin, vmax) = n(fgrid)\n    (rows, columns) = (int(math.ceil(facets / float(facet_columns))), facet_columns)\n    colorbar_location = 'individual'\n    if visual['what'] == 'row' and visual_grid.shape[1] == facet_columns:\n        colorbar_location = 'per_row'\n    if visual['what'] == 'column' and visual_grid.shape[0] == facet_rows:\n        colorbar_location = 'per_column'\n    logger.debug('rows: %r, columns: %r', rows, columns)\n    import matplotlib.gridspec as gridspec\n    column_scale = 1\n    row_scale = 1\n    row_offset = 0\n    if facets > 1:\n        if colorbar_location == 'per_row':\n            column_scale = 4\n            gs = gridspec.GridSpec(rows, columns * column_scale + 1)\n        elif colorbar_location == 'per_column':\n            row_offset = 1\n            row_scale = 4\n            gs = gridspec.GridSpec(rows * row_scale + 1, columns)\n        else:\n            gs = gridspec.GridSpec(rows, columns)\n    facet_index = 0\n    fs = _expand(f, len(whats))\n    colormaps = _expand(colormap, len(whats))\n    for i in range(visual_grid.shape[0]):\n        for j in range(visual_grid.shape[1]):\n            if colorbar and colorbar_location == 'per_column' and (i == 0):\n                norm = matplotlib.colors.Normalize(vmins[j], vmaxs[j])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[j])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[0, j])\n                    colorbar = fig.colorbar(sm, cax=ax, orientation='horizontal')\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                if 'what' in labels:\n                    label = labels['what'][j]\n                    if facets > 1:\n                        colorbar.ax.set_title(label)\n                    else:\n                        colorbar.ax.set_ylabel(colorbar_label or label)\n            if colorbar and colorbar_location == 'per_row' and (j == 0):\n                norm = matplotlib.colors.Normalize(vmins[i], vmaxs[i])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[i])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[i, -1])\n                    colorbar = fig.colorbar(sm, cax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][i]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            rgrid = ngrid[i, j] * 1.0\n            for k in range(rgrid.shape[0]):\n                for l in range(rgrid.shape[0]):\n                    if smooth_post is not None:\n                        rgrid[k, l] = vaex.grids.gf(rgrid, smooth_post)\n            if visual['what'] == 'column':\n                what_index = j\n            elif visual['what'] == 'row':\n                what_index = i\n            else:\n                what_index = 0\n            if visual[normalize_axis] == 'column':\n                normalize_index = j\n            elif visual[normalize_axis] == 'row':\n                normalize_index = i\n            else:\n                normalize_index = 0\n            for r in reduce:\n                r = _parse_reduction(r, colormaps[what_index], [])\n                rgrid = r(rgrid)\n            row = facet_index // facet_columns\n            column = facet_index % facet_columns\n            if colorbar and colorbar_location == 'individual':\n                norm = matplotlib.colors.Normalize(vmins[normalize_index], vmaxs[normalize_index])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[what_index])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[row, column])\n                    colorbar = fig.colorbar(sm, ax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][what_index]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            if facets > 1:\n                ax = plt.subplot(gs[row_offset + row * row_scale:row_offset + (row + 1) * row_scale, column * column_scale:(column + 1) * column_scale])\n            else:\n                ax = plt.gca()\n            axes.append(ax)\n            logger.debug('rgrid: %r', rgrid.shape)\n            plot_rgrid = rgrid\n            assert plot_rgrid.shape[1] == 1, 'no layers supported yet'\n            plot_rgrid = plot_rgrid[:, 0]\n            if plot_rgrid.shape[0] > 1:\n                plot_rgrid = vaex.image.fade(plot_rgrid[::-1])\n            else:\n                plot_rgrid = plot_rgrid[0]\n            extend = None\n            if visual['subspace'] == 'row':\n                subplot_index = i\n            elif visual['subspace'] == 'column':\n                subplot_index = j\n            else:\n                subplot_index = 0\n            extend = np.array(xlimits[subplot_index][-2:]).flatten()\n            logger.debug('plot rgrid: %r', plot_rgrid.shape)\n            plot_rgrid = np.transpose(plot_rgrid, (1, 0, 2))\n            im = ax.imshow(plot_rgrid, extent=extend.tolist(), origin='lower', aspect=aspect, interpolation=interpolation)\n\n            def label(index, label, expression):\n                if label and _issequence(label):\n                    return label[i]\n                else:\n                    return self.label(expression)\n            if visual_reverse['x'] == 'x':\n                labelsx = labels['x']\n                plt.xlabel(labelsx[subplot_index])\n            if visual_reverse['x'] == 'x':\n                labelsy = labels['y']\n                plt.ylabel(labelsy[subplot_index])\n            if visual['z'] in ['row']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[i])\n            if visual['z'] in ['column']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[j])\n            max_labels = 10\n            xexpression = xexpressions[subplot_index]\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.xticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            yexpression = yexpressions[subplot_index]\n            if self.iscategory(yexpression):\n                labels = self.category_labels(yexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.yticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            facet_index += 1\n    if title:\n        fig.suptitle(title, fontsize='x-large')\n    if tight_layout:\n        if title:\n            plt.tight_layout(rect=[0, 0.03, 1, 0.95])\n        else:\n            plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    if return_extra:\n        return (im, grid, fgrid, ngrid, rgrid)\n    else:\n        return im",
            "@viz_method\n@docsubst\ndef heatmap(self, x=None, y=None, z=None, what='count(*)', vwhat=None, reduce=['colormap'], f=None, normalize='normalize', normalize_axis='what', vmin=None, vmax=None, shape=256, vshape=32, limits=None, grid=None, colormap='afmhot', figsize=None, xlabel=None, ylabel=None, aspect='auto', tight_layout=True, interpolation='nearest', show=False, colorbar=True, colorbar_label=None, selection=None, selection_labels=None, title=None, background_color='white', pre_blend=False, background_alpha=1.0, visual=dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what'), smooth_pre=None, smooth_post=None, wrap=True, wrap_columns=4, return_extra=False, hardcopy=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Viz data in a 2d histogram/heatmap.\\n\\n    Declarative plotting of statistical plots using matplotlib, supports subplots, selections, layers.\\n\\n    Instead of passing x and y, pass a list as x argument for multiple panels. Give what a list of options to have multiple\\n    panels. When both are present then will be origanized in a column/row order.\\n\\n    This methods creates a 6 dimensional 'grid', where each dimension can map the a visual dimension.\\n    The grid dimensions are:\\n\\n    * x: shape determined by shape, content by x argument or the first dimension of each space\\n    * y:   ,,\\n    * z:  related to the z argument\\n    * selection: shape equals length of selection argument\\n    * what: shape equals length of what argument\\n    * space: shape equals length of x argument if multiple values are given\\n\\n     By default, this its shape is (1, 1, 1, 1, shape, shape) (where x is the last dimension)\\n\\n    The visual dimensions are\\n\\n    * x: x coordinate on a plot / image (default maps to grid's x)\\n    * y: y   ,,                         (default maps to grid's y)\\n    * layer: each image in this dimension is blended togeher to one image (default maps to z)\\n    * fade: each image is shown faded after the next image (default mapt to selection)\\n    * row: rows of subplots (default maps to space)\\n    * columns: columns of subplot (default maps to what)\\n\\n    All these mappings can be changes by the visual argument, some examples:\\n\\n    >>> df.viz.heatmap('x', 'y', what=['mean(x)', 'correlation(vx, vy)'])\\n\\n    Will plot each 'what' as a column.\\n\\n    >>> df.viz.heatmap('x', 'y', selection=['FeH < -3', '(FeH >= -3) & (FeH < -2)'], visual=dict(column='selection'))\\n\\n    Will plot each selection as a column, instead of a faded on top of each other.\\n\\n\\n\\n\\n\\n    :param x: Expression to bin in the x direction (by default maps to x), or list of pairs, like [['x', 'y'], ['x', 'z']], if multiple pairs are given, this dimension maps to rows by default\\n    :param y:                          y           (by default maps to y)\\n    :param z: Expression to bin in the z direction, followed by a :start,end,shape  signature, like 'FeH:-3,1:5' will produce 5 layers between -10 and 10 (by default maps to layer)\\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum, std('x') the standard deviation, correlation('vx', 'vy') the correlation coefficient. Can also be a list of values, like ['count(x)', std('vx')], (by default maps to column)\\n    :param reduce:\\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\\n    :param normalize: normalization function, currently only 'normalize' is supported\\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\\n    :param vmin: instead of automatic normalization, (using normalize and normalization_axis) scale the data between vmin and vmax to [0, 1]\\n    :param vmax: see vmin\\n    :param shape: {shape}\\n    :param limits: {limits}\\n    :param grid: {grid}\\n    :param colormap: matplotlib colormap to use\\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\\n    :param xlabel:\\n    :param ylabel:\\n    :param aspect:\\n    :param tight_layout: call plt.tight_layout or not\\n    :param colorbar: plot a colorbar or not\\n    :param selection: {selection1}\\n    :param interpolation: interpolation for imshow, possible options are: 'nearest', 'bilinear', 'bicubic', see matplotlib for more\\n    :param return_extra:\\n    :return:\\n    \"\n    import matplotlib\n    import matplotlib.pyplot as plt\n    n = _parse_n(normalize)\n    if type(shape) == int:\n        shape = (shape,) * 2\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    for expression in [y, x]:\n        if expression is not None:\n            binby = [expression] + binby\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    import re\n    what_units = None\n    whats = _ensure_list(what)\n    selections = _ensure_list(selection)\n    selections = _ensure_strings_from_expressions(selections)\n    if y is None:\n        (waslist, [x]) = listify(x)\n    else:\n        (waslist, [x, y]) = listify(x, y)\n        x = list(zip(x, y))\n        limits = [limits]\n    vwhats = _expand_limits(vwhat, len(x))\n    logger.debug('x: %s', x)\n    (limits, shape) = self.limits(x, limits, shape=shape)\n    shape = shape[0]\n    logger.debug('limits: %r', limits)\n    labels = {}\n    shape = _expand_shape(shape, 2)\n    vshape = _expand_shape(shape, 2)\n    if z is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', z)\n        if match:\n            groups = match.groups()\n            import ast\n            z_expression = groups[0]\n            logger.debug('found groups: %r', list(groups))\n            z_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            z_shape = ast.literal_eval(groups[3])\n            x = [[z_expression] + list(k) for k in x]\n            limits = np.array([[z_limits] + list(k) for k in limits])\n            shape = (z_shape,) + shape\n            vshape = (z_shape,) + vshape\n            logger.debug('x = %r', x)\n            values = np.linspace(z_limits[0], z_limits[1], num=z_shape + 1)\n            labels['z'] = list(['%s <= %s < %s' % (v1, z_expression, v2) for (v1, v2) in zip(values[:-1], values[1:])])\n        else:\n            raise ValueError(\"Could not understand 'z' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    else:\n        z_shape = 1\n    if z is None:\n        total_grid = np.zeros((len(x), len(whats), len(selections), 1) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections), 1) + vshape, dtype=float)\n    else:\n        total_grid = np.zeros((len(x), len(whats), len(selections)) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections)) + vshape, dtype=float)\n    logger.debug('shape of total grid: %r', total_grid.shape)\n    axis = dict(plot=0, what=1, selection=2)\n    xlimits = limits\n    grid_axes = dict(x=-1, y=-2, z=-3, selection=-4, what=-5, subspace=-6)\n    visual_axes = dict(x=-1, y=-2, layer=-3, fade=-4, column=-5, row=-6)\n    visual_default = dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what')\n\n    def invert(x):\n        return dict(((v, k) for (k, v) in x.items()))\n    free_visual_axes = list(visual_default.keys())\n    logger.debug('1: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual.items():\n        if visual_name in free_visual_axes:\n            free_visual_axes.remove(visual_name)\n        else:\n            raise ValueError('visual axes %s used multiple times' % visual_name)\n    logger.debug('2: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name in free_visual_axes and grid_name not in visual.values():\n            free_visual_axes.remove(visual_name)\n            visual[visual_name] = grid_name\n    logger.debug('3: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name not in free_visual_axes and grid_name not in visual.values():\n            visual[free_visual_axes.pop(0)] = grid_name\n    logger.debug('4: %r %r', visual, free_visual_axes)\n    visual_reverse = invert(visual)\n    (visual, visual_reverse) = (visual_reverse, visual)\n    move = {}\n    for (grid_name, visual_name) in visual.items():\n        if visual_axes[visual_name] in visual.values():\n            index = visual.values().find(visual_name)\n            key = visual.keys()[index]\n            raise ValueError('trying to map %s to %s while, it is already mapped by %s' % (grid_name, visual_name, key))\n        move[grid_axes[grid_name]] = visual_axes[visual_name]\n    fs = _expand(f, total_grid.shape[grid_axes[normalize_axis]])\n    what_labels = []\n    if grid is None:\n        grid_of_grids = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            grid_of_grids.append([])\n            for (j, what) in enumerate(whats):\n                if isinstance(what, vaex.stat.Expression):\n                    grid = what.calculate(self, binby=binby, shape=shape, limits=limits, selection=selections, delay=True)\n                else:\n                    what = what.strip()\n                    index = what.index('(')\n                    import re\n                    groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                    if groups and len(groups) == 2:\n                        function = groups[0]\n                        arguments = groups[1].strip()\n                        if ',' in arguments:\n                            arguments = arguments.split(',')\n                        functions = ['mean', 'sum', 'std', 'var', 'correlation', 'covar', 'min', 'max', 'median_approx']\n                        unit_expression = None\n                        if function in ['mean', 'sum', 'std', 'min', 'max', 'median']:\n                            unit_expression = arguments\n                        if function in ['var']:\n                            unit_expression = '(%s) * (%s)' % (arguments, arguments)\n                        if function in ['covar']:\n                            unit_expression = '(%s) * (%s)' % arguments\n                        if unit_expression:\n                            unit = self.unit(unit_expression)\n                            if unit:\n                                what_units = unit.to_string('latex_inline')\n                        if function in functions:\n                            grid = getattr(self, function)(arguments, binby=binby, limits=limits, shape=shape, selection=selections, delay=True)\n                        elif function == 'count':\n                            grid = self.count(arguments, binby, shape=shape, limits=limits, selection=selections, delay=True)\n                        else:\n                            raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                    else:\n                        raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n                if i == 0:\n                    what_label = str(whats[j])\n                    if what_units:\n                        what_label += ' (%s)' % what_units\n                    if fs[j]:\n                        what_label = fs[j] + ' ' + what_label\n                    what_labels.append(what_label)\n                grid_of_grids[-1].append(grid)\n        self.execute()\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            for (j, what) in enumerate(whats):\n                grid = grid_of_grids[i][j].get()\n                total_grid[i, j, :, :] = grid[:, None, ...]\n        labels['what'] = what_labels\n    else:\n        dims_left = 6 - len(grid.shape)\n        total_grid = np.broadcast_to(grid, (1,) * dims_left + grid.shape)\n\n    def _selection_name(name):\n        if name in [None, False]:\n            return 'selection: all'\n        elif name in ['default', True]:\n            return 'selection: default'\n        else:\n            return 'selection: %s' % name\n    if selection_labels is None:\n        labels['selection'] = list([_selection_name(k) for k in selections])\n    else:\n        labels['selection'] = selection_labels\n    axes = [None] * len(move)\n    for (key, value) in move.items():\n        axes[value] = key\n    visual_grid = np.transpose(total_grid, axes)\n    logger.debug('grid shape: %r', total_grid.shape)\n    logger.debug('visual: %r', visual.items())\n    logger.debug('move: %r', move)\n    logger.debug('visual grid shape: %r', visual_grid.shape)\n    xexpressions = []\n    yexpressions = []\n    for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n        xexpressions.append(binby[0])\n        yexpressions.append(binby[1])\n    if xlabel is None:\n        xlabels = []\n        ylabels = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            if z is not None:\n                xlabels.append(self.label(binby[1]))\n                ylabels.append(self.label(binby[2]))\n            else:\n                xlabels.append(self.label(binby[0]))\n                ylabels.append(self.label(binby[1]))\n    else:\n        Nl = visual_grid.shape[visual_axes['row']]\n        xlabels = _expand(xlabel, Nl)\n        ylabels = _expand(ylabel, Nl)\n    labels['x'] = xlabels\n    labels['y'] = ylabels\n    axes = []\n    background_color = np.array(matplotlib.colors.colorConverter.to_rgb(background_color))\n    import math\n    facet_columns = None\n    facets = visual_grid.shape[visual_axes['row']] * visual_grid.shape[visual_axes['column']]\n    if visual_grid.shape[visual_axes['column']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['row']])\n        wrapped = True\n    elif visual_grid.shape[visual_axes['row']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['column']])\n        wrapped = True\n    else:\n        wrapped = False\n        facet_columns = visual_grid.shape[visual_axes['column']]\n    facet_rows = int(math.ceil(facets / facet_columns))\n    logger.debug('facet_rows: %r', facet_rows)\n    logger.debug('facet_columns: %r', facet_columns)\n    grid = visual_grid * 1.0\n    fgrid = visual_grid * 1.0\n    ngrid = visual_grid * 1.0\n    vmins = _expand(vmin, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    vmaxs = _expand(vmax, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    visual_grid\n    if smooth_pre:\n        grid = vaex.grids.gf(grid, smooth_pre)\n    if 1:\n        axis = visual_axes[visual[normalize_axis]]\n        for i in range(visual_grid.shape[axis]):\n            item = [slice(None, None, None)] * len(visual_grid.shape)\n            item[axis] = i\n            item = tuple(item)\n            f = _parse_f(fs[i])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                fgrid.__setitem__(item, f(grid.__getitem__(item)))\n            if vmins[i] is not None and vmaxs[i] is not None:\n                nsubgrid = fgrid.__getitem__(item) * 1\n                nsubgrid -= vmins[i]\n                nsubgrid /= vmaxs[i] - vmins[i]\n            else:\n                (nsubgrid, vmin, vmax) = n(fgrid.__getitem__(item))\n                vmins[i] = vmin\n                vmaxs[i] = vmax\n            ngrid.__setitem__(item, nsubgrid)\n    if 0:\n        grid = visual_grid[i]\n        f = _parse_f(fs[i])\n        fgrid = f(grid)\n        finite_mask = np.isfinite(grid)\n        finite_mask = np.any(finite_mask, axis=0)\n        if vmin is not None and vmax is not None:\n            ngrid = fgrid * 1\n            ngrid -= vmin\n            ngrid /= vmax - vmin\n            ngrid = np.clip(ngrid, 0, 1)\n        else:\n            (ngrid, vmin, vmax) = n(fgrid)\n    (rows, columns) = (int(math.ceil(facets / float(facet_columns))), facet_columns)\n    colorbar_location = 'individual'\n    if visual['what'] == 'row' and visual_grid.shape[1] == facet_columns:\n        colorbar_location = 'per_row'\n    if visual['what'] == 'column' and visual_grid.shape[0] == facet_rows:\n        colorbar_location = 'per_column'\n    logger.debug('rows: %r, columns: %r', rows, columns)\n    import matplotlib.gridspec as gridspec\n    column_scale = 1\n    row_scale = 1\n    row_offset = 0\n    if facets > 1:\n        if colorbar_location == 'per_row':\n            column_scale = 4\n            gs = gridspec.GridSpec(rows, columns * column_scale + 1)\n        elif colorbar_location == 'per_column':\n            row_offset = 1\n            row_scale = 4\n            gs = gridspec.GridSpec(rows * row_scale + 1, columns)\n        else:\n            gs = gridspec.GridSpec(rows, columns)\n    facet_index = 0\n    fs = _expand(f, len(whats))\n    colormaps = _expand(colormap, len(whats))\n    for i in range(visual_grid.shape[0]):\n        for j in range(visual_grid.shape[1]):\n            if colorbar and colorbar_location == 'per_column' and (i == 0):\n                norm = matplotlib.colors.Normalize(vmins[j], vmaxs[j])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[j])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[0, j])\n                    colorbar = fig.colorbar(sm, cax=ax, orientation='horizontal')\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                if 'what' in labels:\n                    label = labels['what'][j]\n                    if facets > 1:\n                        colorbar.ax.set_title(label)\n                    else:\n                        colorbar.ax.set_ylabel(colorbar_label or label)\n            if colorbar and colorbar_location == 'per_row' and (j == 0):\n                norm = matplotlib.colors.Normalize(vmins[i], vmaxs[i])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[i])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[i, -1])\n                    colorbar = fig.colorbar(sm, cax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][i]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            rgrid = ngrid[i, j] * 1.0\n            for k in range(rgrid.shape[0]):\n                for l in range(rgrid.shape[0]):\n                    if smooth_post is not None:\n                        rgrid[k, l] = vaex.grids.gf(rgrid, smooth_post)\n            if visual['what'] == 'column':\n                what_index = j\n            elif visual['what'] == 'row':\n                what_index = i\n            else:\n                what_index = 0\n            if visual[normalize_axis] == 'column':\n                normalize_index = j\n            elif visual[normalize_axis] == 'row':\n                normalize_index = i\n            else:\n                normalize_index = 0\n            for r in reduce:\n                r = _parse_reduction(r, colormaps[what_index], [])\n                rgrid = r(rgrid)\n            row = facet_index // facet_columns\n            column = facet_index % facet_columns\n            if colorbar and colorbar_location == 'individual':\n                norm = matplotlib.colors.Normalize(vmins[normalize_index], vmaxs[normalize_index])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[what_index])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[row, column])\n                    colorbar = fig.colorbar(sm, ax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][what_index]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            if facets > 1:\n                ax = plt.subplot(gs[row_offset + row * row_scale:row_offset + (row + 1) * row_scale, column * column_scale:(column + 1) * column_scale])\n            else:\n                ax = plt.gca()\n            axes.append(ax)\n            logger.debug('rgrid: %r', rgrid.shape)\n            plot_rgrid = rgrid\n            assert plot_rgrid.shape[1] == 1, 'no layers supported yet'\n            plot_rgrid = plot_rgrid[:, 0]\n            if plot_rgrid.shape[0] > 1:\n                plot_rgrid = vaex.image.fade(plot_rgrid[::-1])\n            else:\n                plot_rgrid = plot_rgrid[0]\n            extend = None\n            if visual['subspace'] == 'row':\n                subplot_index = i\n            elif visual['subspace'] == 'column':\n                subplot_index = j\n            else:\n                subplot_index = 0\n            extend = np.array(xlimits[subplot_index][-2:]).flatten()\n            logger.debug('plot rgrid: %r', plot_rgrid.shape)\n            plot_rgrid = np.transpose(plot_rgrid, (1, 0, 2))\n            im = ax.imshow(plot_rgrid, extent=extend.tolist(), origin='lower', aspect=aspect, interpolation=interpolation)\n\n            def label(index, label, expression):\n                if label and _issequence(label):\n                    return label[i]\n                else:\n                    return self.label(expression)\n            if visual_reverse['x'] == 'x':\n                labelsx = labels['x']\n                plt.xlabel(labelsx[subplot_index])\n            if visual_reverse['x'] == 'x':\n                labelsy = labels['y']\n                plt.ylabel(labelsy[subplot_index])\n            if visual['z'] in ['row']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[i])\n            if visual['z'] in ['column']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[j])\n            max_labels = 10\n            xexpression = xexpressions[subplot_index]\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.xticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            yexpression = yexpressions[subplot_index]\n            if self.iscategory(yexpression):\n                labels = self.category_labels(yexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.yticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            facet_index += 1\n    if title:\n        fig.suptitle(title, fontsize='x-large')\n    if tight_layout:\n        if title:\n            plt.tight_layout(rect=[0, 0.03, 1, 0.95])\n        else:\n            plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    if return_extra:\n        return (im, grid, fgrid, ngrid, rgrid)\n    else:\n        return im",
            "@viz_method\n@docsubst\ndef heatmap(self, x=None, y=None, z=None, what='count(*)', vwhat=None, reduce=['colormap'], f=None, normalize='normalize', normalize_axis='what', vmin=None, vmax=None, shape=256, vshape=32, limits=None, grid=None, colormap='afmhot', figsize=None, xlabel=None, ylabel=None, aspect='auto', tight_layout=True, interpolation='nearest', show=False, colorbar=True, colorbar_label=None, selection=None, selection_labels=None, title=None, background_color='white', pre_blend=False, background_alpha=1.0, visual=dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what'), smooth_pre=None, smooth_post=None, wrap=True, wrap_columns=4, return_extra=False, hardcopy=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Viz data in a 2d histogram/heatmap.\\n\\n    Declarative plotting of statistical plots using matplotlib, supports subplots, selections, layers.\\n\\n    Instead of passing x and y, pass a list as x argument for multiple panels. Give what a list of options to have multiple\\n    panels. When both are present then will be origanized in a column/row order.\\n\\n    This methods creates a 6 dimensional 'grid', where each dimension can map the a visual dimension.\\n    The grid dimensions are:\\n\\n    * x: shape determined by shape, content by x argument or the first dimension of each space\\n    * y:   ,,\\n    * z:  related to the z argument\\n    * selection: shape equals length of selection argument\\n    * what: shape equals length of what argument\\n    * space: shape equals length of x argument if multiple values are given\\n\\n     By default, this its shape is (1, 1, 1, 1, shape, shape) (where x is the last dimension)\\n\\n    The visual dimensions are\\n\\n    * x: x coordinate on a plot / image (default maps to grid's x)\\n    * y: y   ,,                         (default maps to grid's y)\\n    * layer: each image in this dimension is blended togeher to one image (default maps to z)\\n    * fade: each image is shown faded after the next image (default mapt to selection)\\n    * row: rows of subplots (default maps to space)\\n    * columns: columns of subplot (default maps to what)\\n\\n    All these mappings can be changes by the visual argument, some examples:\\n\\n    >>> df.viz.heatmap('x', 'y', what=['mean(x)', 'correlation(vx, vy)'])\\n\\n    Will plot each 'what' as a column.\\n\\n    >>> df.viz.heatmap('x', 'y', selection=['FeH < -3', '(FeH >= -3) & (FeH < -2)'], visual=dict(column='selection'))\\n\\n    Will plot each selection as a column, instead of a faded on top of each other.\\n\\n\\n\\n\\n\\n    :param x: Expression to bin in the x direction (by default maps to x), or list of pairs, like [['x', 'y'], ['x', 'z']], if multiple pairs are given, this dimension maps to rows by default\\n    :param y:                          y           (by default maps to y)\\n    :param z: Expression to bin in the z direction, followed by a :start,end,shape  signature, like 'FeH:-3,1:5' will produce 5 layers between -10 and 10 (by default maps to layer)\\n    :param what: What to plot, count(*) will show a N-d histogram, mean('x'), the mean of the x column, sum('x') the sum, std('x') the standard deviation, correlation('vx', 'vy') the correlation coefficient. Can also be a list of values, like ['count(x)', std('vx')], (by default maps to column)\\n    :param reduce:\\n    :param f: transform values by: 'identity' does nothing 'log' or 'log10' will show the log of the value\\n    :param normalize: normalization function, currently only 'normalize' is supported\\n    :param normalize_axis: which axes to normalize on, None means normalize by the global maximum.\\n    :param vmin: instead of automatic normalization, (using normalize and normalization_axis) scale the data between vmin and vmax to [0, 1]\\n    :param vmax: see vmin\\n    :param shape: {shape}\\n    :param limits: {limits}\\n    :param grid: {grid}\\n    :param colormap: matplotlib colormap to use\\n    :param figsize: (x, y) tuple passed to plt.figure for setting the figure size\\n    :param xlabel:\\n    :param ylabel:\\n    :param aspect:\\n    :param tight_layout: call plt.tight_layout or not\\n    :param colorbar: plot a colorbar or not\\n    :param selection: {selection1}\\n    :param interpolation: interpolation for imshow, possible options are: 'nearest', 'bilinear', 'bicubic', see matplotlib for more\\n    :param return_extra:\\n    :return:\\n    \"\n    import matplotlib\n    import matplotlib.pyplot as plt\n    n = _parse_n(normalize)\n    if type(shape) == int:\n        shape = (shape,) * 2\n    binby = []\n    x = _ensure_strings_from_expressions(x)\n    y = _ensure_strings_from_expressions(y)\n    for expression in [y, x]:\n        if expression is not None:\n            binby = [expression] + binby\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    import re\n    what_units = None\n    whats = _ensure_list(what)\n    selections = _ensure_list(selection)\n    selections = _ensure_strings_from_expressions(selections)\n    if y is None:\n        (waslist, [x]) = listify(x)\n    else:\n        (waslist, [x, y]) = listify(x, y)\n        x = list(zip(x, y))\n        limits = [limits]\n    vwhats = _expand_limits(vwhat, len(x))\n    logger.debug('x: %s', x)\n    (limits, shape) = self.limits(x, limits, shape=shape)\n    shape = shape[0]\n    logger.debug('limits: %r', limits)\n    labels = {}\n    shape = _expand_shape(shape, 2)\n    vshape = _expand_shape(shape, 2)\n    if z is not None:\n        match = re.match('(.*):(.*),(.*),(.*)', z)\n        if match:\n            groups = match.groups()\n            import ast\n            z_expression = groups[0]\n            logger.debug('found groups: %r', list(groups))\n            z_limits = [ast.literal_eval(groups[1]), ast.literal_eval(groups[2])]\n            z_shape = ast.literal_eval(groups[3])\n            x = [[z_expression] + list(k) for k in x]\n            limits = np.array([[z_limits] + list(k) for k in limits])\n            shape = (z_shape,) + shape\n            vshape = (z_shape,) + vshape\n            logger.debug('x = %r', x)\n            values = np.linspace(z_limits[0], z_limits[1], num=z_shape + 1)\n            labels['z'] = list(['%s <= %s < %s' % (v1, z_expression, v2) for (v1, v2) in zip(values[:-1], values[1:])])\n        else:\n            raise ValueError(\"Could not understand 'z' argument %r, expected something in form: 'column:-1,10:5'\" % facet)\n    else:\n        z_shape = 1\n    if z is None:\n        total_grid = np.zeros((len(x), len(whats), len(selections), 1) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections), 1) + vshape, dtype=float)\n    else:\n        total_grid = np.zeros((len(x), len(whats), len(selections)) + shape, dtype=float)\n        total_vgrid = np.zeros((len(x), len(whats), len(selections)) + vshape, dtype=float)\n    logger.debug('shape of total grid: %r', total_grid.shape)\n    axis = dict(plot=0, what=1, selection=2)\n    xlimits = limits\n    grid_axes = dict(x=-1, y=-2, z=-3, selection=-4, what=-5, subspace=-6)\n    visual_axes = dict(x=-1, y=-2, layer=-3, fade=-4, column=-5, row=-6)\n    visual_default = dict(x='x', y='y', layer='z', fade='selection', row='subspace', column='what')\n\n    def invert(x):\n        return dict(((v, k) for (k, v) in x.items()))\n    free_visual_axes = list(visual_default.keys())\n    logger.debug('1: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual.items():\n        if visual_name in free_visual_axes:\n            free_visual_axes.remove(visual_name)\n        else:\n            raise ValueError('visual axes %s used multiple times' % visual_name)\n    logger.debug('2: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name in free_visual_axes and grid_name not in visual.values():\n            free_visual_axes.remove(visual_name)\n            visual[visual_name] = grid_name\n    logger.debug('3: %r %r', visual, free_visual_axes)\n    for (visual_name, grid_name) in visual_default.items():\n        if visual_name not in free_visual_axes and grid_name not in visual.values():\n            visual[free_visual_axes.pop(0)] = grid_name\n    logger.debug('4: %r %r', visual, free_visual_axes)\n    visual_reverse = invert(visual)\n    (visual, visual_reverse) = (visual_reverse, visual)\n    move = {}\n    for (grid_name, visual_name) in visual.items():\n        if visual_axes[visual_name] in visual.values():\n            index = visual.values().find(visual_name)\n            key = visual.keys()[index]\n            raise ValueError('trying to map %s to %s while, it is already mapped by %s' % (grid_name, visual_name, key))\n        move[grid_axes[grid_name]] = visual_axes[visual_name]\n    fs = _expand(f, total_grid.shape[grid_axes[normalize_axis]])\n    what_labels = []\n    if grid is None:\n        grid_of_grids = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            grid_of_grids.append([])\n            for (j, what) in enumerate(whats):\n                if isinstance(what, vaex.stat.Expression):\n                    grid = what.calculate(self, binby=binby, shape=shape, limits=limits, selection=selections, delay=True)\n                else:\n                    what = what.strip()\n                    index = what.index('(')\n                    import re\n                    groups = re.match('(.*)\\\\((.*)\\\\)', what).groups()\n                    if groups and len(groups) == 2:\n                        function = groups[0]\n                        arguments = groups[1].strip()\n                        if ',' in arguments:\n                            arguments = arguments.split(',')\n                        functions = ['mean', 'sum', 'std', 'var', 'correlation', 'covar', 'min', 'max', 'median_approx']\n                        unit_expression = None\n                        if function in ['mean', 'sum', 'std', 'min', 'max', 'median']:\n                            unit_expression = arguments\n                        if function in ['var']:\n                            unit_expression = '(%s) * (%s)' % (arguments, arguments)\n                        if function in ['covar']:\n                            unit_expression = '(%s) * (%s)' % arguments\n                        if unit_expression:\n                            unit = self.unit(unit_expression)\n                            if unit:\n                                what_units = unit.to_string('latex_inline')\n                        if function in functions:\n                            grid = getattr(self, function)(arguments, binby=binby, limits=limits, shape=shape, selection=selections, delay=True)\n                        elif function == 'count':\n                            grid = self.count(arguments, binby, shape=shape, limits=limits, selection=selections, delay=True)\n                        else:\n                            raise ValueError(\"Could not understand method: %s, expected one of %r'\" % (function, functions))\n                    else:\n                        raise ValueError(\"Could not understand 'what' argument %r, expected something in form: 'count(*)', 'mean(x)'\" % what)\n                if i == 0:\n                    what_label = str(whats[j])\n                    if what_units:\n                        what_label += ' (%s)' % what_units\n                    if fs[j]:\n                        what_label = fs[j] + ' ' + what_label\n                    what_labels.append(what_label)\n                grid_of_grids[-1].append(grid)\n        self.execute()\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            for (j, what) in enumerate(whats):\n                grid = grid_of_grids[i][j].get()\n                total_grid[i, j, :, :] = grid[:, None, ...]\n        labels['what'] = what_labels\n    else:\n        dims_left = 6 - len(grid.shape)\n        total_grid = np.broadcast_to(grid, (1,) * dims_left + grid.shape)\n\n    def _selection_name(name):\n        if name in [None, False]:\n            return 'selection: all'\n        elif name in ['default', True]:\n            return 'selection: default'\n        else:\n            return 'selection: %s' % name\n    if selection_labels is None:\n        labels['selection'] = list([_selection_name(k) for k in selections])\n    else:\n        labels['selection'] = selection_labels\n    axes = [None] * len(move)\n    for (key, value) in move.items():\n        axes[value] = key\n    visual_grid = np.transpose(total_grid, axes)\n    logger.debug('grid shape: %r', total_grid.shape)\n    logger.debug('visual: %r', visual.items())\n    logger.debug('move: %r', move)\n    logger.debug('visual grid shape: %r', visual_grid.shape)\n    xexpressions = []\n    yexpressions = []\n    for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n        xexpressions.append(binby[0])\n        yexpressions.append(binby[1])\n    if xlabel is None:\n        xlabels = []\n        ylabels = []\n        for (i, (binby, limits)) in enumerate(zip(x, xlimits)):\n            if z is not None:\n                xlabels.append(self.label(binby[1]))\n                ylabels.append(self.label(binby[2]))\n            else:\n                xlabels.append(self.label(binby[0]))\n                ylabels.append(self.label(binby[1]))\n    else:\n        Nl = visual_grid.shape[visual_axes['row']]\n        xlabels = _expand(xlabel, Nl)\n        ylabels = _expand(ylabel, Nl)\n    labels['x'] = xlabels\n    labels['y'] = ylabels\n    axes = []\n    background_color = np.array(matplotlib.colors.colorConverter.to_rgb(background_color))\n    import math\n    facet_columns = None\n    facets = visual_grid.shape[visual_axes['row']] * visual_grid.shape[visual_axes['column']]\n    if visual_grid.shape[visual_axes['column']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['row']])\n        wrapped = True\n    elif visual_grid.shape[visual_axes['row']] == 1 and wrap:\n        facet_columns = min(wrap_columns, visual_grid.shape[visual_axes['column']])\n        wrapped = True\n    else:\n        wrapped = False\n        facet_columns = visual_grid.shape[visual_axes['column']]\n    facet_rows = int(math.ceil(facets / facet_columns))\n    logger.debug('facet_rows: %r', facet_rows)\n    logger.debug('facet_columns: %r', facet_columns)\n    grid = visual_grid * 1.0\n    fgrid = visual_grid * 1.0\n    ngrid = visual_grid * 1.0\n    vmins = _expand(vmin, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    vmaxs = _expand(vmax, visual_grid.shape[visual_axes[visual[normalize_axis]]], type=list)\n    visual_grid\n    if smooth_pre:\n        grid = vaex.grids.gf(grid, smooth_pre)\n    if 1:\n        axis = visual_axes[visual[normalize_axis]]\n        for i in range(visual_grid.shape[axis]):\n            item = [slice(None, None, None)] * len(visual_grid.shape)\n            item[axis] = i\n            item = tuple(item)\n            f = _parse_f(fs[i])\n            with np.errstate(divide='ignore', invalid='ignore'):\n                fgrid.__setitem__(item, f(grid.__getitem__(item)))\n            if vmins[i] is not None and vmaxs[i] is not None:\n                nsubgrid = fgrid.__getitem__(item) * 1\n                nsubgrid -= vmins[i]\n                nsubgrid /= vmaxs[i] - vmins[i]\n            else:\n                (nsubgrid, vmin, vmax) = n(fgrid.__getitem__(item))\n                vmins[i] = vmin\n                vmaxs[i] = vmax\n            ngrid.__setitem__(item, nsubgrid)\n    if 0:\n        grid = visual_grid[i]\n        f = _parse_f(fs[i])\n        fgrid = f(grid)\n        finite_mask = np.isfinite(grid)\n        finite_mask = np.any(finite_mask, axis=0)\n        if vmin is not None and vmax is not None:\n            ngrid = fgrid * 1\n            ngrid -= vmin\n            ngrid /= vmax - vmin\n            ngrid = np.clip(ngrid, 0, 1)\n        else:\n            (ngrid, vmin, vmax) = n(fgrid)\n    (rows, columns) = (int(math.ceil(facets / float(facet_columns))), facet_columns)\n    colorbar_location = 'individual'\n    if visual['what'] == 'row' and visual_grid.shape[1] == facet_columns:\n        colorbar_location = 'per_row'\n    if visual['what'] == 'column' and visual_grid.shape[0] == facet_rows:\n        colorbar_location = 'per_column'\n    logger.debug('rows: %r, columns: %r', rows, columns)\n    import matplotlib.gridspec as gridspec\n    column_scale = 1\n    row_scale = 1\n    row_offset = 0\n    if facets > 1:\n        if colorbar_location == 'per_row':\n            column_scale = 4\n            gs = gridspec.GridSpec(rows, columns * column_scale + 1)\n        elif colorbar_location == 'per_column':\n            row_offset = 1\n            row_scale = 4\n            gs = gridspec.GridSpec(rows * row_scale + 1, columns)\n        else:\n            gs = gridspec.GridSpec(rows, columns)\n    facet_index = 0\n    fs = _expand(f, len(whats))\n    colormaps = _expand(colormap, len(whats))\n    for i in range(visual_grid.shape[0]):\n        for j in range(visual_grid.shape[1]):\n            if colorbar and colorbar_location == 'per_column' and (i == 0):\n                norm = matplotlib.colors.Normalize(vmins[j], vmaxs[j])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[j])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[0, j])\n                    colorbar = fig.colorbar(sm, cax=ax, orientation='horizontal')\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                if 'what' in labels:\n                    label = labels['what'][j]\n                    if facets > 1:\n                        colorbar.ax.set_title(label)\n                    else:\n                        colorbar.ax.set_ylabel(colorbar_label or label)\n            if colorbar and colorbar_location == 'per_row' and (j == 0):\n                norm = matplotlib.colors.Normalize(vmins[i], vmaxs[i])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[i])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[i, -1])\n                    colorbar = fig.colorbar(sm, cax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][i]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            rgrid = ngrid[i, j] * 1.0\n            for k in range(rgrid.shape[0]):\n                for l in range(rgrid.shape[0]):\n                    if smooth_post is not None:\n                        rgrid[k, l] = vaex.grids.gf(rgrid, smooth_post)\n            if visual['what'] == 'column':\n                what_index = j\n            elif visual['what'] == 'row':\n                what_index = i\n            else:\n                what_index = 0\n            if visual[normalize_axis] == 'column':\n                normalize_index = j\n            elif visual[normalize_axis] == 'row':\n                normalize_index = i\n            else:\n                normalize_index = 0\n            for r in reduce:\n                r = _parse_reduction(r, colormaps[what_index], [])\n                rgrid = r(rgrid)\n            row = facet_index // facet_columns\n            column = facet_index % facet_columns\n            if colorbar and colorbar_location == 'individual':\n                norm = matplotlib.colors.Normalize(vmins[normalize_index], vmaxs[normalize_index])\n                sm = matplotlib.cm.ScalarMappable(norm, colormaps[what_index])\n                sm.set_array(1)\n                if facets > 1:\n                    ax = plt.subplot(gs[row, column])\n                    colorbar = fig.colorbar(sm, ax=ax)\n                else:\n                    colorbar = fig.colorbar(sm, ax=plt.gca())\n                label = labels['what'][what_index]\n                colorbar.ax.set_ylabel(colorbar_label or label)\n            if facets > 1:\n                ax = plt.subplot(gs[row_offset + row * row_scale:row_offset + (row + 1) * row_scale, column * column_scale:(column + 1) * column_scale])\n            else:\n                ax = plt.gca()\n            axes.append(ax)\n            logger.debug('rgrid: %r', rgrid.shape)\n            plot_rgrid = rgrid\n            assert plot_rgrid.shape[1] == 1, 'no layers supported yet'\n            plot_rgrid = plot_rgrid[:, 0]\n            if plot_rgrid.shape[0] > 1:\n                plot_rgrid = vaex.image.fade(plot_rgrid[::-1])\n            else:\n                plot_rgrid = plot_rgrid[0]\n            extend = None\n            if visual['subspace'] == 'row':\n                subplot_index = i\n            elif visual['subspace'] == 'column':\n                subplot_index = j\n            else:\n                subplot_index = 0\n            extend = np.array(xlimits[subplot_index][-2:]).flatten()\n            logger.debug('plot rgrid: %r', plot_rgrid.shape)\n            plot_rgrid = np.transpose(plot_rgrid, (1, 0, 2))\n            im = ax.imshow(plot_rgrid, extent=extend.tolist(), origin='lower', aspect=aspect, interpolation=interpolation)\n\n            def label(index, label, expression):\n                if label and _issequence(label):\n                    return label[i]\n                else:\n                    return self.label(expression)\n            if visual_reverse['x'] == 'x':\n                labelsx = labels['x']\n                plt.xlabel(labelsx[subplot_index])\n            if visual_reverse['x'] == 'x':\n                labelsy = labels['y']\n                plt.ylabel(labelsy[subplot_index])\n            if visual['z'] in ['row']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[i])\n            if visual['z'] in ['column']:\n                labelsz = labels['z']\n                ax.set_title(labelsz[j])\n            max_labels = 10\n            xexpression = xexpressions[subplot_index]\n            if self.iscategory(xexpression):\n                labels = self.category_labels(xexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.xticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            yexpression = yexpressions[subplot_index]\n            if self.iscategory(yexpression):\n                labels = self.category_labels(yexpression)\n                step = max(len(labels) // max_labels, 1)\n                plt.yticks(np.arange(len(labels))[::step], labels[::step], size='small')\n            facet_index += 1\n    if title:\n        fig.suptitle(title, fontsize='x-large')\n    if tight_layout:\n        if title:\n            plt.tight_layout(rect=[0, 0.03, 1, 0.95])\n        else:\n            plt.tight_layout()\n    if hardcopy:\n        plt.savefig(hardcopy)\n    if show:\n        plt.show()\n    if return_extra:\n        return (im, grid, fgrid, ngrid, rgrid)\n    else:\n        return im"
        ]
    },
    {
        "func_name": "healpix_plot",
        "original": "@patch\ndef healpix_plot(self, *args, **kwargs):\n    warnings.warn('`healpix_plot` is deprecated and it will be removed in version 5.x. Please `df.viz.healpix_heatmap` instead.')\n    self.viz.healpix_heatmap(*args, **kwargs)",
        "mutated": [
            "@patch\ndef healpix_plot(self, *args, **kwargs):\n    if False:\n        i = 10\n    warnings.warn('`healpix_plot` is deprecated and it will be removed in version 5.x. Please `df.viz.healpix_heatmap` instead.')\n    self.viz.healpix_heatmap(*args, **kwargs)",
            "@patch\ndef healpix_plot(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    warnings.warn('`healpix_plot` is deprecated and it will be removed in version 5.x. Please `df.viz.healpix_heatmap` instead.')\n    self.viz.healpix_heatmap(*args, **kwargs)",
            "@patch\ndef healpix_plot(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    warnings.warn('`healpix_plot` is deprecated and it will be removed in version 5.x. Please `df.viz.healpix_heatmap` instead.')\n    self.viz.healpix_heatmap(*args, **kwargs)",
            "@patch\ndef healpix_plot(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    warnings.warn('`healpix_plot` is deprecated and it will be removed in version 5.x. Please `df.viz.healpix_heatmap` instead.')\n    self.viz.healpix_heatmap(*args, **kwargs)",
            "@patch\ndef healpix_plot(self, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    warnings.warn('`healpix_plot` is deprecated and it will be removed in version 5.x. Please `df.viz.healpix_heatmap` instead.')\n    self.viz.healpix_heatmap(*args, **kwargs)"
        ]
    },
    {
        "func_name": "healpix_heatmap",
        "original": "@viz_method\ndef healpix_heatmap(self, healpix_expression='source_id/34359738368', healpix_max_level=12, healpix_level=8, what='count(*)', selection=None, grid=None, healpix_input='equatorial', healpix_output='galactic', f=None, colormap='afmhot', grid_limits=None, image_size=800, nest=True, figsize=None, interactive=False, title='', smooth=None, show=False, colorbar=True, rotation=(0, 0, 0), **kwargs):\n    \"\"\"Viz data in 2d using a healpix column.\n\n    :param healpix_expression: {healpix_max_level}\n    :param healpix_max_level: {healpix_max_level}\n    :param healpix_level: {healpix_level}\n    :param what: {what}\n    :param selection: {selection}\n    :param grid: {grid}\n    :param healpix_input: Specificy if the healpix index is in \"equatorial\", \"galactic\" or \"ecliptic\".\n    :param healpix_output: Plot in \"equatorial\", \"galactic\" or \"ecliptic\".\n    :param f: function to apply to the data\n    :param colormap: matplotlib colormap\n    :param grid_limits: Optional sequence [minvalue, maxvalue] that determine the min and max value that map to the colormap (values below and above these are clipped to the the min/max). (default is [min(f(grid)), max(f(grid)))\n    :param image_size: size for the image that healpy uses for rendering\n    :param nest: If the healpix data is in nested (True) or ring (False)\n    :param figsize: If given, modify the matplotlib figure size. Example (14,9)\n    :param interactive: (Experimental, uses healpy.mollzoom is True)\n    :param title: Title of figure\n    :param smooth: apply gaussian smoothing, in degrees\n    :param show: Call matplotlib's show (True) or not (False, defaut)\n    :param rotation: Rotatate the plot, in format (lon, lat, psi) such that (lon, lat) is the center, and rotate on the screen by angle psi. All angles are degrees.\n    :return:\n    \"\"\"\n    import healpy as hp\n    import matplotlib.pyplot as plt\n    if grid is None:\n        reduce_level = healpix_max_level - healpix_level\n        NSIDE = 2 ** healpix_level\n        nmax = hp.nside2npix(NSIDE)\n        scaling = 4 ** reduce_level\n        epsilon = 1.0 / scaling / 2\n        grid = self._stat(what=what, binby='%s/%s' % (healpix_expression, scaling), limits=[-epsilon, nmax - epsilon], shape=nmax, selection=selection)\n    if grid_limits:\n        (grid_min, grid_max) = grid_limits\n    else:\n        grid_min = grid_max = None\n    f_org = f\n    f = _parse_f(f)\n    if smooth:\n        if nest:\n            grid = hp.reorder(grid, inp='NEST', out='RING')\n            nest = False\n        grid = hp.smoothing(grid, sigma=np.radians(smooth))\n    fgrid = f(grid)\n    coord_map = dict(equatorial='C', galactic='G', ecliptic='E')\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    what_label = what\n    if f_org:\n        what_label = f_org + ' ' + what_label\n    f = hp.mollzoom if interactive else hp.mollview\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore')\n        coord = (coord_map[healpix_input], coord_map[healpix_output])\n        if coord_map[healpix_input] == coord_map[healpix_output]:\n            coord = None\n        f(fgrid, unit=what_label, rot=rotation, nest=nest, title=title, coord=coord, cmap=colormap, hold=True, xsize=image_size, min=grid_min, max=grid_max, cbar=colorbar, **kwargs)\n    if show:\n        plt.show()",
        "mutated": [
            "@viz_method\ndef healpix_heatmap(self, healpix_expression='source_id/34359738368', healpix_max_level=12, healpix_level=8, what='count(*)', selection=None, grid=None, healpix_input='equatorial', healpix_output='galactic', f=None, colormap='afmhot', grid_limits=None, image_size=800, nest=True, figsize=None, interactive=False, title='', smooth=None, show=False, colorbar=True, rotation=(0, 0, 0), **kwargs):\n    if False:\n        i = 10\n    'Viz data in 2d using a healpix column.\\n\\n    :param healpix_expression: {healpix_max_level}\\n    :param healpix_max_level: {healpix_max_level}\\n    :param healpix_level: {healpix_level}\\n    :param what: {what}\\n    :param selection: {selection}\\n    :param grid: {grid}\\n    :param healpix_input: Specificy if the healpix index is in \"equatorial\", \"galactic\" or \"ecliptic\".\\n    :param healpix_output: Plot in \"equatorial\", \"galactic\" or \"ecliptic\".\\n    :param f: function to apply to the data\\n    :param colormap: matplotlib colormap\\n    :param grid_limits: Optional sequence [minvalue, maxvalue] that determine the min and max value that map to the colormap (values below and above these are clipped to the the min/max). (default is [min(f(grid)), max(f(grid)))\\n    :param image_size: size for the image that healpy uses for rendering\\n    :param nest: If the healpix data is in nested (True) or ring (False)\\n    :param figsize: If given, modify the matplotlib figure size. Example (14,9)\\n    :param interactive: (Experimental, uses healpy.mollzoom is True)\\n    :param title: Title of figure\\n    :param smooth: apply gaussian smoothing, in degrees\\n    :param show: Call matplotlib\\'s show (True) or not (False, defaut)\\n    :param rotation: Rotatate the plot, in format (lon, lat, psi) such that (lon, lat) is the center, and rotate on the screen by angle psi. All angles are degrees.\\n    :return:\\n    '\n    import healpy as hp\n    import matplotlib.pyplot as plt\n    if grid is None:\n        reduce_level = healpix_max_level - healpix_level\n        NSIDE = 2 ** healpix_level\n        nmax = hp.nside2npix(NSIDE)\n        scaling = 4 ** reduce_level\n        epsilon = 1.0 / scaling / 2\n        grid = self._stat(what=what, binby='%s/%s' % (healpix_expression, scaling), limits=[-epsilon, nmax - epsilon], shape=nmax, selection=selection)\n    if grid_limits:\n        (grid_min, grid_max) = grid_limits\n    else:\n        grid_min = grid_max = None\n    f_org = f\n    f = _parse_f(f)\n    if smooth:\n        if nest:\n            grid = hp.reorder(grid, inp='NEST', out='RING')\n            nest = False\n        grid = hp.smoothing(grid, sigma=np.radians(smooth))\n    fgrid = f(grid)\n    coord_map = dict(equatorial='C', galactic='G', ecliptic='E')\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    what_label = what\n    if f_org:\n        what_label = f_org + ' ' + what_label\n    f = hp.mollzoom if interactive else hp.mollview\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore')\n        coord = (coord_map[healpix_input], coord_map[healpix_output])\n        if coord_map[healpix_input] == coord_map[healpix_output]:\n            coord = None\n        f(fgrid, unit=what_label, rot=rotation, nest=nest, title=title, coord=coord, cmap=colormap, hold=True, xsize=image_size, min=grid_min, max=grid_max, cbar=colorbar, **kwargs)\n    if show:\n        plt.show()",
            "@viz_method\ndef healpix_heatmap(self, healpix_expression='source_id/34359738368', healpix_max_level=12, healpix_level=8, what='count(*)', selection=None, grid=None, healpix_input='equatorial', healpix_output='galactic', f=None, colormap='afmhot', grid_limits=None, image_size=800, nest=True, figsize=None, interactive=False, title='', smooth=None, show=False, colorbar=True, rotation=(0, 0, 0), **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Viz data in 2d using a healpix column.\\n\\n    :param healpix_expression: {healpix_max_level}\\n    :param healpix_max_level: {healpix_max_level}\\n    :param healpix_level: {healpix_level}\\n    :param what: {what}\\n    :param selection: {selection}\\n    :param grid: {grid}\\n    :param healpix_input: Specificy if the healpix index is in \"equatorial\", \"galactic\" or \"ecliptic\".\\n    :param healpix_output: Plot in \"equatorial\", \"galactic\" or \"ecliptic\".\\n    :param f: function to apply to the data\\n    :param colormap: matplotlib colormap\\n    :param grid_limits: Optional sequence [minvalue, maxvalue] that determine the min and max value that map to the colormap (values below and above these are clipped to the the min/max). (default is [min(f(grid)), max(f(grid)))\\n    :param image_size: size for the image that healpy uses for rendering\\n    :param nest: If the healpix data is in nested (True) or ring (False)\\n    :param figsize: If given, modify the matplotlib figure size. Example (14,9)\\n    :param interactive: (Experimental, uses healpy.mollzoom is True)\\n    :param title: Title of figure\\n    :param smooth: apply gaussian smoothing, in degrees\\n    :param show: Call matplotlib\\'s show (True) or not (False, defaut)\\n    :param rotation: Rotatate the plot, in format (lon, lat, psi) such that (lon, lat) is the center, and rotate on the screen by angle psi. All angles are degrees.\\n    :return:\\n    '\n    import healpy as hp\n    import matplotlib.pyplot as plt\n    if grid is None:\n        reduce_level = healpix_max_level - healpix_level\n        NSIDE = 2 ** healpix_level\n        nmax = hp.nside2npix(NSIDE)\n        scaling = 4 ** reduce_level\n        epsilon = 1.0 / scaling / 2\n        grid = self._stat(what=what, binby='%s/%s' % (healpix_expression, scaling), limits=[-epsilon, nmax - epsilon], shape=nmax, selection=selection)\n    if grid_limits:\n        (grid_min, grid_max) = grid_limits\n    else:\n        grid_min = grid_max = None\n    f_org = f\n    f = _parse_f(f)\n    if smooth:\n        if nest:\n            grid = hp.reorder(grid, inp='NEST', out='RING')\n            nest = False\n        grid = hp.smoothing(grid, sigma=np.radians(smooth))\n    fgrid = f(grid)\n    coord_map = dict(equatorial='C', galactic='G', ecliptic='E')\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    what_label = what\n    if f_org:\n        what_label = f_org + ' ' + what_label\n    f = hp.mollzoom if interactive else hp.mollview\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore')\n        coord = (coord_map[healpix_input], coord_map[healpix_output])\n        if coord_map[healpix_input] == coord_map[healpix_output]:\n            coord = None\n        f(fgrid, unit=what_label, rot=rotation, nest=nest, title=title, coord=coord, cmap=colormap, hold=True, xsize=image_size, min=grid_min, max=grid_max, cbar=colorbar, **kwargs)\n    if show:\n        plt.show()",
            "@viz_method\ndef healpix_heatmap(self, healpix_expression='source_id/34359738368', healpix_max_level=12, healpix_level=8, what='count(*)', selection=None, grid=None, healpix_input='equatorial', healpix_output='galactic', f=None, colormap='afmhot', grid_limits=None, image_size=800, nest=True, figsize=None, interactive=False, title='', smooth=None, show=False, colorbar=True, rotation=(0, 0, 0), **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Viz data in 2d using a healpix column.\\n\\n    :param healpix_expression: {healpix_max_level}\\n    :param healpix_max_level: {healpix_max_level}\\n    :param healpix_level: {healpix_level}\\n    :param what: {what}\\n    :param selection: {selection}\\n    :param grid: {grid}\\n    :param healpix_input: Specificy if the healpix index is in \"equatorial\", \"galactic\" or \"ecliptic\".\\n    :param healpix_output: Plot in \"equatorial\", \"galactic\" or \"ecliptic\".\\n    :param f: function to apply to the data\\n    :param colormap: matplotlib colormap\\n    :param grid_limits: Optional sequence [minvalue, maxvalue] that determine the min and max value that map to the colormap (values below and above these are clipped to the the min/max). (default is [min(f(grid)), max(f(grid)))\\n    :param image_size: size for the image that healpy uses for rendering\\n    :param nest: If the healpix data is in nested (True) or ring (False)\\n    :param figsize: If given, modify the matplotlib figure size. Example (14,9)\\n    :param interactive: (Experimental, uses healpy.mollzoom is True)\\n    :param title: Title of figure\\n    :param smooth: apply gaussian smoothing, in degrees\\n    :param show: Call matplotlib\\'s show (True) or not (False, defaut)\\n    :param rotation: Rotatate the plot, in format (lon, lat, psi) such that (lon, lat) is the center, and rotate on the screen by angle psi. All angles are degrees.\\n    :return:\\n    '\n    import healpy as hp\n    import matplotlib.pyplot as plt\n    if grid is None:\n        reduce_level = healpix_max_level - healpix_level\n        NSIDE = 2 ** healpix_level\n        nmax = hp.nside2npix(NSIDE)\n        scaling = 4 ** reduce_level\n        epsilon = 1.0 / scaling / 2\n        grid = self._stat(what=what, binby='%s/%s' % (healpix_expression, scaling), limits=[-epsilon, nmax - epsilon], shape=nmax, selection=selection)\n    if grid_limits:\n        (grid_min, grid_max) = grid_limits\n    else:\n        grid_min = grid_max = None\n    f_org = f\n    f = _parse_f(f)\n    if smooth:\n        if nest:\n            grid = hp.reorder(grid, inp='NEST', out='RING')\n            nest = False\n        grid = hp.smoothing(grid, sigma=np.radians(smooth))\n    fgrid = f(grid)\n    coord_map = dict(equatorial='C', galactic='G', ecliptic='E')\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    what_label = what\n    if f_org:\n        what_label = f_org + ' ' + what_label\n    f = hp.mollzoom if interactive else hp.mollview\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore')\n        coord = (coord_map[healpix_input], coord_map[healpix_output])\n        if coord_map[healpix_input] == coord_map[healpix_output]:\n            coord = None\n        f(fgrid, unit=what_label, rot=rotation, nest=nest, title=title, coord=coord, cmap=colormap, hold=True, xsize=image_size, min=grid_min, max=grid_max, cbar=colorbar, **kwargs)\n    if show:\n        plt.show()",
            "@viz_method\ndef healpix_heatmap(self, healpix_expression='source_id/34359738368', healpix_max_level=12, healpix_level=8, what='count(*)', selection=None, grid=None, healpix_input='equatorial', healpix_output='galactic', f=None, colormap='afmhot', grid_limits=None, image_size=800, nest=True, figsize=None, interactive=False, title='', smooth=None, show=False, colorbar=True, rotation=(0, 0, 0), **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Viz data in 2d using a healpix column.\\n\\n    :param healpix_expression: {healpix_max_level}\\n    :param healpix_max_level: {healpix_max_level}\\n    :param healpix_level: {healpix_level}\\n    :param what: {what}\\n    :param selection: {selection}\\n    :param grid: {grid}\\n    :param healpix_input: Specificy if the healpix index is in \"equatorial\", \"galactic\" or \"ecliptic\".\\n    :param healpix_output: Plot in \"equatorial\", \"galactic\" or \"ecliptic\".\\n    :param f: function to apply to the data\\n    :param colormap: matplotlib colormap\\n    :param grid_limits: Optional sequence [minvalue, maxvalue] that determine the min and max value that map to the colormap (values below and above these are clipped to the the min/max). (default is [min(f(grid)), max(f(grid)))\\n    :param image_size: size for the image that healpy uses for rendering\\n    :param nest: If the healpix data is in nested (True) or ring (False)\\n    :param figsize: If given, modify the matplotlib figure size. Example (14,9)\\n    :param interactive: (Experimental, uses healpy.mollzoom is True)\\n    :param title: Title of figure\\n    :param smooth: apply gaussian smoothing, in degrees\\n    :param show: Call matplotlib\\'s show (True) or not (False, defaut)\\n    :param rotation: Rotatate the plot, in format (lon, lat, psi) such that (lon, lat) is the center, and rotate on the screen by angle psi. All angles are degrees.\\n    :return:\\n    '\n    import healpy as hp\n    import matplotlib.pyplot as plt\n    if grid is None:\n        reduce_level = healpix_max_level - healpix_level\n        NSIDE = 2 ** healpix_level\n        nmax = hp.nside2npix(NSIDE)\n        scaling = 4 ** reduce_level\n        epsilon = 1.0 / scaling / 2\n        grid = self._stat(what=what, binby='%s/%s' % (healpix_expression, scaling), limits=[-epsilon, nmax - epsilon], shape=nmax, selection=selection)\n    if grid_limits:\n        (grid_min, grid_max) = grid_limits\n    else:\n        grid_min = grid_max = None\n    f_org = f\n    f = _parse_f(f)\n    if smooth:\n        if nest:\n            grid = hp.reorder(grid, inp='NEST', out='RING')\n            nest = False\n        grid = hp.smoothing(grid, sigma=np.radians(smooth))\n    fgrid = f(grid)\n    coord_map = dict(equatorial='C', galactic='G', ecliptic='E')\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    what_label = what\n    if f_org:\n        what_label = f_org + ' ' + what_label\n    f = hp.mollzoom if interactive else hp.mollview\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore')\n        coord = (coord_map[healpix_input], coord_map[healpix_output])\n        if coord_map[healpix_input] == coord_map[healpix_output]:\n            coord = None\n        f(fgrid, unit=what_label, rot=rotation, nest=nest, title=title, coord=coord, cmap=colormap, hold=True, xsize=image_size, min=grid_min, max=grid_max, cbar=colorbar, **kwargs)\n    if show:\n        plt.show()",
            "@viz_method\ndef healpix_heatmap(self, healpix_expression='source_id/34359738368', healpix_max_level=12, healpix_level=8, what='count(*)', selection=None, grid=None, healpix_input='equatorial', healpix_output='galactic', f=None, colormap='afmhot', grid_limits=None, image_size=800, nest=True, figsize=None, interactive=False, title='', smooth=None, show=False, colorbar=True, rotation=(0, 0, 0), **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Viz data in 2d using a healpix column.\\n\\n    :param healpix_expression: {healpix_max_level}\\n    :param healpix_max_level: {healpix_max_level}\\n    :param healpix_level: {healpix_level}\\n    :param what: {what}\\n    :param selection: {selection}\\n    :param grid: {grid}\\n    :param healpix_input: Specificy if the healpix index is in \"equatorial\", \"galactic\" or \"ecliptic\".\\n    :param healpix_output: Plot in \"equatorial\", \"galactic\" or \"ecliptic\".\\n    :param f: function to apply to the data\\n    :param colormap: matplotlib colormap\\n    :param grid_limits: Optional sequence [minvalue, maxvalue] that determine the min and max value that map to the colormap (values below and above these are clipped to the the min/max). (default is [min(f(grid)), max(f(grid)))\\n    :param image_size: size for the image that healpy uses for rendering\\n    :param nest: If the healpix data is in nested (True) or ring (False)\\n    :param figsize: If given, modify the matplotlib figure size. Example (14,9)\\n    :param interactive: (Experimental, uses healpy.mollzoom is True)\\n    :param title: Title of figure\\n    :param smooth: apply gaussian smoothing, in degrees\\n    :param show: Call matplotlib\\'s show (True) or not (False, defaut)\\n    :param rotation: Rotatate the plot, in format (lon, lat, psi) such that (lon, lat) is the center, and rotate on the screen by angle psi. All angles are degrees.\\n    :return:\\n    '\n    import healpy as hp\n    import matplotlib.pyplot as plt\n    if grid is None:\n        reduce_level = healpix_max_level - healpix_level\n        NSIDE = 2 ** healpix_level\n        nmax = hp.nside2npix(NSIDE)\n        scaling = 4 ** reduce_level\n        epsilon = 1.0 / scaling / 2\n        grid = self._stat(what=what, binby='%s/%s' % (healpix_expression, scaling), limits=[-epsilon, nmax - epsilon], shape=nmax, selection=selection)\n    if grid_limits:\n        (grid_min, grid_max) = grid_limits\n    else:\n        grid_min = grid_max = None\n    f_org = f\n    f = _parse_f(f)\n    if smooth:\n        if nest:\n            grid = hp.reorder(grid, inp='NEST', out='RING')\n            nest = False\n        grid = hp.smoothing(grid, sigma=np.radians(smooth))\n    fgrid = f(grid)\n    coord_map = dict(equatorial='C', galactic='G', ecliptic='E')\n    fig = plt.gcf()\n    if figsize is not None:\n        fig.set_size_inches(*figsize)\n    what_label = what\n    if f_org:\n        what_label = f_org + ' ' + what_label\n    f = hp.mollzoom if interactive else hp.mollview\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore')\n        coord = (coord_map[healpix_input], coord_map[healpix_output])\n        if coord_map[healpix_input] == coord_map[healpix_output]:\n            coord = None\n        f(fgrid, unit=what_label, rot=rotation, nest=nest, title=title, coord=coord, cmap=colormap, hold=True, xsize=image_size, min=grid_min, max=grid_max, cbar=colorbar, **kwargs)\n    if show:\n        plt.show()"
        ]
    }
]