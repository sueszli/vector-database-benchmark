[
    {
        "func_name": "GPA",
        "original": "def GPA(A, ff=None, vgQ=None, T=None, max_tries=501, rotation_method='orthogonal', tol=1e-05):\n    \"\"\"\n    The gradient projection algorithm (GPA) minimizes a target function\n    :math:`\\\\phi(L)`, where :math:`L` is a matrix with rotated factors.\n\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\n    rotations relax the orthogonality constraint in order to gain simplicity\n    in the interpretation.\n\n    Parameters\n    ----------\n    A : numpy matrix\n        non rotated factors\n    T : numpy matrix (default identity matrix)\n        initial guess of rotation matrix\n    ff : function (defualt None)\n        criterion :math:`\\\\phi` to optimize. Should have A, T, L as keyword\n        arguments\n        and mapping to a float. Only used (and required) if vgQ is not\n        provided.\n    vgQ : function (defualt None)\n        criterion :math:`\\\\phi` to optimize and its derivative. Should have\n         A, T, L as keyword arguments and mapping to a tuple containing a\n        float and vector. Can be omitted if ff is provided.\n    max_tries : int (default 501)\n        maximum number of iterations\n    rotation_method : str\n        should be one of {orthogonal, oblique}\n    tol : float\n        stop criterion, algorithm stops if Frobenius norm of gradient is\n        smaller then tol\n    \"\"\"\n    if rotation_method not in ['orthogonal', 'oblique']:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    if vgQ is None:\n        if ff is None:\n            raise ValueError('ff should be provided if vgQ is not')\n        derivative_free = True\n        Gff = lambda x: Gf(x, lambda y: ff(T=y, A=A, L=None))\n    else:\n        derivative_free = False\n    if T is None:\n        T = np.eye(A.shape[1])\n    al = 1\n    table = []\n    if derivative_free:\n        f = ff(T=T, A=A, L=None)\n        G = Gff(T)\n    elif rotation_method == 'orthogonal':\n        L = A.dot(T)\n        (f, Gq) = vgQ(L=L)\n        G = A.T.dot(Gq)\n    else:\n        Ti = np.linalg.inv(T)\n        L = A.dot(Ti.T)\n        (f, Gq) = vgQ(L=L)\n        G = -L.T.dot(Gq).dot(Ti).T\n    for i_try in range(0, max_tries):\n        if rotation_method == 'orthogonal':\n            M = T.T.dot(G)\n            S = (M + M.T) / 2\n            Gp = G - T.dot(S)\n        else:\n            Gp = G - T.dot(np.diag(np.sum(T * G, axis=0)))\n        s = np.linalg.norm(Gp, 'fro')\n        table.append([i_try, f, np.log10(s), al])\n        if s < tol:\n            break\n        al = 2 * al\n        for i in range(11):\n            X = T - al * Gp\n            if rotation_method == 'orthogonal':\n                (U, D, V) = np.linalg.svd(X, full_matrices=False)\n                Tt = U.dot(V)\n            else:\n                v = 1 / np.sqrt(np.sum(X ** 2, axis=0))\n                Tt = X.dot(np.diag(v))\n            if derivative_free:\n                ft = ff(T=Tt, A=A, L=None)\n            elif rotation_method == 'orthogonal':\n                L = A.dot(Tt)\n                (ft, Gq) = vgQ(L=L)\n            else:\n                Ti = np.linalg.inv(Tt)\n                L = A.dot(Ti.T)\n                (ft, Gq) = vgQ(L=L)\n            if ft < f - 0.5 * s ** 2 * al:\n                break\n            al = al / 2\n        T = Tt\n        f = ft\n        if derivative_free:\n            G = Gff(T)\n        elif rotation_method == 'orthogonal':\n            G = A.T.dot(Gq)\n        else:\n            G = -L.T.dot(Gq).dot(Ti).T\n    Th = T\n    Lh = rotateA(A, T, rotation_method=rotation_method)\n    Phi = T.T.dot(T)\n    return (Lh, Phi, Th, table)",
        "mutated": [
            "def GPA(A, ff=None, vgQ=None, T=None, max_tries=501, rotation_method='orthogonal', tol=1e-05):\n    if False:\n        i = 10\n    '\\n    The gradient projection algorithm (GPA) minimizes a target function\\n    :math:`\\\\phi(L)`, where :math:`L` is a matrix with rotated factors.\\n\\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\\n    rotations relax the orthogonality constraint in order to gain simplicity\\n    in the interpretation.\\n\\n    Parameters\\n    ----------\\n    A : numpy matrix\\n        non rotated factors\\n    T : numpy matrix (default identity matrix)\\n        initial guess of rotation matrix\\n    ff : function (defualt None)\\n        criterion :math:`\\\\phi` to optimize. Should have A, T, L as keyword\\n        arguments\\n        and mapping to a float. Only used (and required) if vgQ is not\\n        provided.\\n    vgQ : function (defualt None)\\n        criterion :math:`\\\\phi` to optimize and its derivative. Should have\\n         A, T, L as keyword arguments and mapping to a tuple containing a\\n        float and vector. Can be omitted if ff is provided.\\n    max_tries : int (default 501)\\n        maximum number of iterations\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    tol : float\\n        stop criterion, algorithm stops if Frobenius norm of gradient is\\n        smaller then tol\\n    '\n    if rotation_method not in ['orthogonal', 'oblique']:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    if vgQ is None:\n        if ff is None:\n            raise ValueError('ff should be provided if vgQ is not')\n        derivative_free = True\n        Gff = lambda x: Gf(x, lambda y: ff(T=y, A=A, L=None))\n    else:\n        derivative_free = False\n    if T is None:\n        T = np.eye(A.shape[1])\n    al = 1\n    table = []\n    if derivative_free:\n        f = ff(T=T, A=A, L=None)\n        G = Gff(T)\n    elif rotation_method == 'orthogonal':\n        L = A.dot(T)\n        (f, Gq) = vgQ(L=L)\n        G = A.T.dot(Gq)\n    else:\n        Ti = np.linalg.inv(T)\n        L = A.dot(Ti.T)\n        (f, Gq) = vgQ(L=L)\n        G = -L.T.dot(Gq).dot(Ti).T\n    for i_try in range(0, max_tries):\n        if rotation_method == 'orthogonal':\n            M = T.T.dot(G)\n            S = (M + M.T) / 2\n            Gp = G - T.dot(S)\n        else:\n            Gp = G - T.dot(np.diag(np.sum(T * G, axis=0)))\n        s = np.linalg.norm(Gp, 'fro')\n        table.append([i_try, f, np.log10(s), al])\n        if s < tol:\n            break\n        al = 2 * al\n        for i in range(11):\n            X = T - al * Gp\n            if rotation_method == 'orthogonal':\n                (U, D, V) = np.linalg.svd(X, full_matrices=False)\n                Tt = U.dot(V)\n            else:\n                v = 1 / np.sqrt(np.sum(X ** 2, axis=0))\n                Tt = X.dot(np.diag(v))\n            if derivative_free:\n                ft = ff(T=Tt, A=A, L=None)\n            elif rotation_method == 'orthogonal':\n                L = A.dot(Tt)\n                (ft, Gq) = vgQ(L=L)\n            else:\n                Ti = np.linalg.inv(Tt)\n                L = A.dot(Ti.T)\n                (ft, Gq) = vgQ(L=L)\n            if ft < f - 0.5 * s ** 2 * al:\n                break\n            al = al / 2\n        T = Tt\n        f = ft\n        if derivative_free:\n            G = Gff(T)\n        elif rotation_method == 'orthogonal':\n            G = A.T.dot(Gq)\n        else:\n            G = -L.T.dot(Gq).dot(Ti).T\n    Th = T\n    Lh = rotateA(A, T, rotation_method=rotation_method)\n    Phi = T.T.dot(T)\n    return (Lh, Phi, Th, table)",
            "def GPA(A, ff=None, vgQ=None, T=None, max_tries=501, rotation_method='orthogonal', tol=1e-05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The gradient projection algorithm (GPA) minimizes a target function\\n    :math:`\\\\phi(L)`, where :math:`L` is a matrix with rotated factors.\\n\\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\\n    rotations relax the orthogonality constraint in order to gain simplicity\\n    in the interpretation.\\n\\n    Parameters\\n    ----------\\n    A : numpy matrix\\n        non rotated factors\\n    T : numpy matrix (default identity matrix)\\n        initial guess of rotation matrix\\n    ff : function (defualt None)\\n        criterion :math:`\\\\phi` to optimize. Should have A, T, L as keyword\\n        arguments\\n        and mapping to a float. Only used (and required) if vgQ is not\\n        provided.\\n    vgQ : function (defualt None)\\n        criterion :math:`\\\\phi` to optimize and its derivative. Should have\\n         A, T, L as keyword arguments and mapping to a tuple containing a\\n        float and vector. Can be omitted if ff is provided.\\n    max_tries : int (default 501)\\n        maximum number of iterations\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    tol : float\\n        stop criterion, algorithm stops if Frobenius norm of gradient is\\n        smaller then tol\\n    '\n    if rotation_method not in ['orthogonal', 'oblique']:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    if vgQ is None:\n        if ff is None:\n            raise ValueError('ff should be provided if vgQ is not')\n        derivative_free = True\n        Gff = lambda x: Gf(x, lambda y: ff(T=y, A=A, L=None))\n    else:\n        derivative_free = False\n    if T is None:\n        T = np.eye(A.shape[1])\n    al = 1\n    table = []\n    if derivative_free:\n        f = ff(T=T, A=A, L=None)\n        G = Gff(T)\n    elif rotation_method == 'orthogonal':\n        L = A.dot(T)\n        (f, Gq) = vgQ(L=L)\n        G = A.T.dot(Gq)\n    else:\n        Ti = np.linalg.inv(T)\n        L = A.dot(Ti.T)\n        (f, Gq) = vgQ(L=L)\n        G = -L.T.dot(Gq).dot(Ti).T\n    for i_try in range(0, max_tries):\n        if rotation_method == 'orthogonal':\n            M = T.T.dot(G)\n            S = (M + M.T) / 2\n            Gp = G - T.dot(S)\n        else:\n            Gp = G - T.dot(np.diag(np.sum(T * G, axis=0)))\n        s = np.linalg.norm(Gp, 'fro')\n        table.append([i_try, f, np.log10(s), al])\n        if s < tol:\n            break\n        al = 2 * al\n        for i in range(11):\n            X = T - al * Gp\n            if rotation_method == 'orthogonal':\n                (U, D, V) = np.linalg.svd(X, full_matrices=False)\n                Tt = U.dot(V)\n            else:\n                v = 1 / np.sqrt(np.sum(X ** 2, axis=0))\n                Tt = X.dot(np.diag(v))\n            if derivative_free:\n                ft = ff(T=Tt, A=A, L=None)\n            elif rotation_method == 'orthogonal':\n                L = A.dot(Tt)\n                (ft, Gq) = vgQ(L=L)\n            else:\n                Ti = np.linalg.inv(Tt)\n                L = A.dot(Ti.T)\n                (ft, Gq) = vgQ(L=L)\n            if ft < f - 0.5 * s ** 2 * al:\n                break\n            al = al / 2\n        T = Tt\n        f = ft\n        if derivative_free:\n            G = Gff(T)\n        elif rotation_method == 'orthogonal':\n            G = A.T.dot(Gq)\n        else:\n            G = -L.T.dot(Gq).dot(Ti).T\n    Th = T\n    Lh = rotateA(A, T, rotation_method=rotation_method)\n    Phi = T.T.dot(T)\n    return (Lh, Phi, Th, table)",
            "def GPA(A, ff=None, vgQ=None, T=None, max_tries=501, rotation_method='orthogonal', tol=1e-05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The gradient projection algorithm (GPA) minimizes a target function\\n    :math:`\\\\phi(L)`, where :math:`L` is a matrix with rotated factors.\\n\\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\\n    rotations relax the orthogonality constraint in order to gain simplicity\\n    in the interpretation.\\n\\n    Parameters\\n    ----------\\n    A : numpy matrix\\n        non rotated factors\\n    T : numpy matrix (default identity matrix)\\n        initial guess of rotation matrix\\n    ff : function (defualt None)\\n        criterion :math:`\\\\phi` to optimize. Should have A, T, L as keyword\\n        arguments\\n        and mapping to a float. Only used (and required) if vgQ is not\\n        provided.\\n    vgQ : function (defualt None)\\n        criterion :math:`\\\\phi` to optimize and its derivative. Should have\\n         A, T, L as keyword arguments and mapping to a tuple containing a\\n        float and vector. Can be omitted if ff is provided.\\n    max_tries : int (default 501)\\n        maximum number of iterations\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    tol : float\\n        stop criterion, algorithm stops if Frobenius norm of gradient is\\n        smaller then tol\\n    '\n    if rotation_method not in ['orthogonal', 'oblique']:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    if vgQ is None:\n        if ff is None:\n            raise ValueError('ff should be provided if vgQ is not')\n        derivative_free = True\n        Gff = lambda x: Gf(x, lambda y: ff(T=y, A=A, L=None))\n    else:\n        derivative_free = False\n    if T is None:\n        T = np.eye(A.shape[1])\n    al = 1\n    table = []\n    if derivative_free:\n        f = ff(T=T, A=A, L=None)\n        G = Gff(T)\n    elif rotation_method == 'orthogonal':\n        L = A.dot(T)\n        (f, Gq) = vgQ(L=L)\n        G = A.T.dot(Gq)\n    else:\n        Ti = np.linalg.inv(T)\n        L = A.dot(Ti.T)\n        (f, Gq) = vgQ(L=L)\n        G = -L.T.dot(Gq).dot(Ti).T\n    for i_try in range(0, max_tries):\n        if rotation_method == 'orthogonal':\n            M = T.T.dot(G)\n            S = (M + M.T) / 2\n            Gp = G - T.dot(S)\n        else:\n            Gp = G - T.dot(np.diag(np.sum(T * G, axis=0)))\n        s = np.linalg.norm(Gp, 'fro')\n        table.append([i_try, f, np.log10(s), al])\n        if s < tol:\n            break\n        al = 2 * al\n        for i in range(11):\n            X = T - al * Gp\n            if rotation_method == 'orthogonal':\n                (U, D, V) = np.linalg.svd(X, full_matrices=False)\n                Tt = U.dot(V)\n            else:\n                v = 1 / np.sqrt(np.sum(X ** 2, axis=0))\n                Tt = X.dot(np.diag(v))\n            if derivative_free:\n                ft = ff(T=Tt, A=A, L=None)\n            elif rotation_method == 'orthogonal':\n                L = A.dot(Tt)\n                (ft, Gq) = vgQ(L=L)\n            else:\n                Ti = np.linalg.inv(Tt)\n                L = A.dot(Ti.T)\n                (ft, Gq) = vgQ(L=L)\n            if ft < f - 0.5 * s ** 2 * al:\n                break\n            al = al / 2\n        T = Tt\n        f = ft\n        if derivative_free:\n            G = Gff(T)\n        elif rotation_method == 'orthogonal':\n            G = A.T.dot(Gq)\n        else:\n            G = -L.T.dot(Gq).dot(Ti).T\n    Th = T\n    Lh = rotateA(A, T, rotation_method=rotation_method)\n    Phi = T.T.dot(T)\n    return (Lh, Phi, Th, table)",
            "def GPA(A, ff=None, vgQ=None, T=None, max_tries=501, rotation_method='orthogonal', tol=1e-05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The gradient projection algorithm (GPA) minimizes a target function\\n    :math:`\\\\phi(L)`, where :math:`L` is a matrix with rotated factors.\\n\\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\\n    rotations relax the orthogonality constraint in order to gain simplicity\\n    in the interpretation.\\n\\n    Parameters\\n    ----------\\n    A : numpy matrix\\n        non rotated factors\\n    T : numpy matrix (default identity matrix)\\n        initial guess of rotation matrix\\n    ff : function (defualt None)\\n        criterion :math:`\\\\phi` to optimize. Should have A, T, L as keyword\\n        arguments\\n        and mapping to a float. Only used (and required) if vgQ is not\\n        provided.\\n    vgQ : function (defualt None)\\n        criterion :math:`\\\\phi` to optimize and its derivative. Should have\\n         A, T, L as keyword arguments and mapping to a tuple containing a\\n        float and vector. Can be omitted if ff is provided.\\n    max_tries : int (default 501)\\n        maximum number of iterations\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    tol : float\\n        stop criterion, algorithm stops if Frobenius norm of gradient is\\n        smaller then tol\\n    '\n    if rotation_method not in ['orthogonal', 'oblique']:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    if vgQ is None:\n        if ff is None:\n            raise ValueError('ff should be provided if vgQ is not')\n        derivative_free = True\n        Gff = lambda x: Gf(x, lambda y: ff(T=y, A=A, L=None))\n    else:\n        derivative_free = False\n    if T is None:\n        T = np.eye(A.shape[1])\n    al = 1\n    table = []\n    if derivative_free:\n        f = ff(T=T, A=A, L=None)\n        G = Gff(T)\n    elif rotation_method == 'orthogonal':\n        L = A.dot(T)\n        (f, Gq) = vgQ(L=L)\n        G = A.T.dot(Gq)\n    else:\n        Ti = np.linalg.inv(T)\n        L = A.dot(Ti.T)\n        (f, Gq) = vgQ(L=L)\n        G = -L.T.dot(Gq).dot(Ti).T\n    for i_try in range(0, max_tries):\n        if rotation_method == 'orthogonal':\n            M = T.T.dot(G)\n            S = (M + M.T) / 2\n            Gp = G - T.dot(S)\n        else:\n            Gp = G - T.dot(np.diag(np.sum(T * G, axis=0)))\n        s = np.linalg.norm(Gp, 'fro')\n        table.append([i_try, f, np.log10(s), al])\n        if s < tol:\n            break\n        al = 2 * al\n        for i in range(11):\n            X = T - al * Gp\n            if rotation_method == 'orthogonal':\n                (U, D, V) = np.linalg.svd(X, full_matrices=False)\n                Tt = U.dot(V)\n            else:\n                v = 1 / np.sqrt(np.sum(X ** 2, axis=0))\n                Tt = X.dot(np.diag(v))\n            if derivative_free:\n                ft = ff(T=Tt, A=A, L=None)\n            elif rotation_method == 'orthogonal':\n                L = A.dot(Tt)\n                (ft, Gq) = vgQ(L=L)\n            else:\n                Ti = np.linalg.inv(Tt)\n                L = A.dot(Ti.T)\n                (ft, Gq) = vgQ(L=L)\n            if ft < f - 0.5 * s ** 2 * al:\n                break\n            al = al / 2\n        T = Tt\n        f = ft\n        if derivative_free:\n            G = Gff(T)\n        elif rotation_method == 'orthogonal':\n            G = A.T.dot(Gq)\n        else:\n            G = -L.T.dot(Gq).dot(Ti).T\n    Th = T\n    Lh = rotateA(A, T, rotation_method=rotation_method)\n    Phi = T.T.dot(T)\n    return (Lh, Phi, Th, table)",
            "def GPA(A, ff=None, vgQ=None, T=None, max_tries=501, rotation_method='orthogonal', tol=1e-05):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The gradient projection algorithm (GPA) minimizes a target function\\n    :math:`\\\\phi(L)`, where :math:`L` is a matrix with rotated factors.\\n\\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\\n    rotations relax the orthogonality constraint in order to gain simplicity\\n    in the interpretation.\\n\\n    Parameters\\n    ----------\\n    A : numpy matrix\\n        non rotated factors\\n    T : numpy matrix (default identity matrix)\\n        initial guess of rotation matrix\\n    ff : function (defualt None)\\n        criterion :math:`\\\\phi` to optimize. Should have A, T, L as keyword\\n        arguments\\n        and mapping to a float. Only used (and required) if vgQ is not\\n        provided.\\n    vgQ : function (defualt None)\\n        criterion :math:`\\\\phi` to optimize and its derivative. Should have\\n         A, T, L as keyword arguments and mapping to a tuple containing a\\n        float and vector. Can be omitted if ff is provided.\\n    max_tries : int (default 501)\\n        maximum number of iterations\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    tol : float\\n        stop criterion, algorithm stops if Frobenius norm of gradient is\\n        smaller then tol\\n    '\n    if rotation_method not in ['orthogonal', 'oblique']:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    if vgQ is None:\n        if ff is None:\n            raise ValueError('ff should be provided if vgQ is not')\n        derivative_free = True\n        Gff = lambda x: Gf(x, lambda y: ff(T=y, A=A, L=None))\n    else:\n        derivative_free = False\n    if T is None:\n        T = np.eye(A.shape[1])\n    al = 1\n    table = []\n    if derivative_free:\n        f = ff(T=T, A=A, L=None)\n        G = Gff(T)\n    elif rotation_method == 'orthogonal':\n        L = A.dot(T)\n        (f, Gq) = vgQ(L=L)\n        G = A.T.dot(Gq)\n    else:\n        Ti = np.linalg.inv(T)\n        L = A.dot(Ti.T)\n        (f, Gq) = vgQ(L=L)\n        G = -L.T.dot(Gq).dot(Ti).T\n    for i_try in range(0, max_tries):\n        if rotation_method == 'orthogonal':\n            M = T.T.dot(G)\n            S = (M + M.T) / 2\n            Gp = G - T.dot(S)\n        else:\n            Gp = G - T.dot(np.diag(np.sum(T * G, axis=0)))\n        s = np.linalg.norm(Gp, 'fro')\n        table.append([i_try, f, np.log10(s), al])\n        if s < tol:\n            break\n        al = 2 * al\n        for i in range(11):\n            X = T - al * Gp\n            if rotation_method == 'orthogonal':\n                (U, D, V) = np.linalg.svd(X, full_matrices=False)\n                Tt = U.dot(V)\n            else:\n                v = 1 / np.sqrt(np.sum(X ** 2, axis=0))\n                Tt = X.dot(np.diag(v))\n            if derivative_free:\n                ft = ff(T=Tt, A=A, L=None)\n            elif rotation_method == 'orthogonal':\n                L = A.dot(Tt)\n                (ft, Gq) = vgQ(L=L)\n            else:\n                Ti = np.linalg.inv(Tt)\n                L = A.dot(Ti.T)\n                (ft, Gq) = vgQ(L=L)\n            if ft < f - 0.5 * s ** 2 * al:\n                break\n            al = al / 2\n        T = Tt\n        f = ft\n        if derivative_free:\n            G = Gff(T)\n        elif rotation_method == 'orthogonal':\n            G = A.T.dot(Gq)\n        else:\n            G = -L.T.dot(Gq).dot(Ti).T\n    Th = T\n    Lh = rotateA(A, T, rotation_method=rotation_method)\n    Phi = T.T.dot(T)\n    return (Lh, Phi, Th, table)"
        ]
    },
    {
        "func_name": "Gf",
        "original": "def Gf(T, ff):\n    \"\"\"\n    Subroutine for the gradient of f using numerical derivatives.\n    \"\"\"\n    k = T.shape[0]\n    ep = 0.0001\n    G = np.zeros((k, k))\n    for r in range(k):\n        for s in range(k):\n            dT = np.zeros((k, k))\n            dT[r, s] = ep\n            G[r, s] = (ff(T + dT) - ff(T - dT)) / (2 * ep)\n    return G",
        "mutated": [
            "def Gf(T, ff):\n    if False:\n        i = 10\n    '\\n    Subroutine for the gradient of f using numerical derivatives.\\n    '\n    k = T.shape[0]\n    ep = 0.0001\n    G = np.zeros((k, k))\n    for r in range(k):\n        for s in range(k):\n            dT = np.zeros((k, k))\n            dT[r, s] = ep\n            G[r, s] = (ff(T + dT) - ff(T - dT)) / (2 * ep)\n    return G",
            "def Gf(T, ff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Subroutine for the gradient of f using numerical derivatives.\\n    '\n    k = T.shape[0]\n    ep = 0.0001\n    G = np.zeros((k, k))\n    for r in range(k):\n        for s in range(k):\n            dT = np.zeros((k, k))\n            dT[r, s] = ep\n            G[r, s] = (ff(T + dT) - ff(T - dT)) / (2 * ep)\n    return G",
            "def Gf(T, ff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Subroutine for the gradient of f using numerical derivatives.\\n    '\n    k = T.shape[0]\n    ep = 0.0001\n    G = np.zeros((k, k))\n    for r in range(k):\n        for s in range(k):\n            dT = np.zeros((k, k))\n            dT[r, s] = ep\n            G[r, s] = (ff(T + dT) - ff(T - dT)) / (2 * ep)\n    return G",
            "def Gf(T, ff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Subroutine for the gradient of f using numerical derivatives.\\n    '\n    k = T.shape[0]\n    ep = 0.0001\n    G = np.zeros((k, k))\n    for r in range(k):\n        for s in range(k):\n            dT = np.zeros((k, k))\n            dT[r, s] = ep\n            G[r, s] = (ff(T + dT) - ff(T - dT)) / (2 * ep)\n    return G",
            "def Gf(T, ff):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Subroutine for the gradient of f using numerical derivatives.\\n    '\n    k = T.shape[0]\n    ep = 0.0001\n    G = np.zeros((k, k))\n    for r in range(k):\n        for s in range(k):\n            dT = np.zeros((k, k))\n            dT[r, s] = ep\n            G[r, s] = (ff(T + dT) - ff(T - dT)) / (2 * ep)\n    return G"
        ]
    },
    {
        "func_name": "rotateA",
        "original": "def rotateA(A, T, rotation_method='orthogonal'):\n    \"\"\"\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\n    rotations relax the orthogonality constraint in order to gain simplicity\n    in the interpretation.\n    \"\"\"\n    if rotation_method == 'orthogonal':\n        L = A.dot(T)\n    elif rotation_method == 'oblique':\n        L = A.dot(np.linalg.inv(T.T))\n    else:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    return L",
        "mutated": [
            "def rotateA(A, T, rotation_method='orthogonal'):\n    if False:\n        i = 10\n    '\\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\\n    rotations relax the orthogonality constraint in order to gain simplicity\\n    in the interpretation.\\n    '\n    if rotation_method == 'orthogonal':\n        L = A.dot(T)\n    elif rotation_method == 'oblique':\n        L = A.dot(np.linalg.inv(T.T))\n    else:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    return L",
            "def rotateA(A, T, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\\n    rotations relax the orthogonality constraint in order to gain simplicity\\n    in the interpretation.\\n    '\n    if rotation_method == 'orthogonal':\n        L = A.dot(T)\n    elif rotation_method == 'oblique':\n        L = A.dot(np.linalg.inv(T.T))\n    else:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    return L",
            "def rotateA(A, T, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\\n    rotations relax the orthogonality constraint in order to gain simplicity\\n    in the interpretation.\\n    '\n    if rotation_method == 'orthogonal':\n        L = A.dot(T)\n    elif rotation_method == 'oblique':\n        L = A.dot(np.linalg.inv(T.T))\n    else:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    return L",
            "def rotateA(A, T, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\\n    rotations relax the orthogonality constraint in order to gain simplicity\\n    in the interpretation.\\n    '\n    if rotation_method == 'orthogonal':\n        L = A.dot(T)\n    elif rotation_method == 'oblique':\n        L = A.dot(np.linalg.inv(T.T))\n    else:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    return L",
            "def rotateA(A, T, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    For orthogonal rotation methods :math:`L=AT`, where :math:`T` is an\\n    orthogonal matrix. For oblique rotation matrices :math:`L=A(T^*)^{-1}`,\\n    where :math:`T` is a normal matrix, i.e., :math:`TT^*=T^*T`. Oblique\\n    rotations relax the orthogonality constraint in order to gain simplicity\\n    in the interpretation.\\n    '\n    if rotation_method == 'orthogonal':\n        L = A.dot(T)\n    elif rotation_method == 'oblique':\n        L = A.dot(np.linalg.inv(T.T))\n    else:\n        raise ValueError('rotation_method should be one of {orthogonal, oblique}')\n    return L"
        ]
    },
    {
        "func_name": "oblimin_objective",
        "original": "def oblimin_objective(L=None, A=None, T=None, gamma=0, rotation_method='orthogonal', return_gradient=True):\n    \"\"\"\n    Objective function for the oblimin family for orthogonal or\n    oblique rotation wich minimizes:\n\n    .. math::\n        \\\\phi(L) = \\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)N),\n\n    where :math:`L` is a :math:`p\\\\times k` matrix, :math:`N` is\n    :math:`k\\\\times k`\n    matrix with zeros on the diagonal and ones elsewhere, :math:`C` is a\n    :math:`p\\\\times p` matrix with elements equal to :math:`1/p`,\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\n    :math:`\\\\circ`\n    is the element-wise product or Hadamard product.\n\n    The gradient is given by\n\n    .. math::\n        L\\\\circ\\\\left[(I-\\\\gamma C) (L \\\\circ L)N\\\\right].\n\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\n    provided.\n\n    For orthogonal rotations :math:`L` satisfies\n\n    .. math::\n        L =  AT,\n\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\n    satisfies\n\n    .. math::\n        L =  A(T^*)^{-1},\n\n    where :math:`T` is a normal matrix.\n\n    The oblimin family is parametrized by the parameter :math:`\\\\gamma`. For\n    orthogonal rotations:\n\n    * :math:`\\\\gamma=0` corresponds to quartimax,\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\n    * :math:`\\\\gamma=1` corresponds to varimax,\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\n    For oblique rotations rotations:\n\n    * :math:`\\\\gamma=0` corresponds to quartimin,\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimin.\n\n    Parameters\n    ----------\n    L : numpy matrix (default None)\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\n    A : numpy matrix (default None)\n        non rotated factors\n    T : numpy matrix (default None)\n        rotation matrix\n    gamma : float (default 0)\n        a parameter\n    rotation_method : str\n        should be one of {orthogonal, oblique}\n    return_gradient : bool (default True)\n        toggles return of gradient\n    \"\"\"\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    N = np.ones((k, k)) - np.eye(k)\n    if np.isclose(gamma, 0):\n        X = L2.dot(N)\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2).dot(N)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi",
        "mutated": [
            "def oblimin_objective(L=None, A=None, T=None, gamma=0, rotation_method='orthogonal', return_gradient=True):\n    if False:\n        i = 10\n    '\\n    Objective function for the oblimin family for orthogonal or\\n    oblique rotation wich minimizes:\\n\\n    .. math::\\n        \\\\phi(L) = \\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)N),\\n\\n    where :math:`L` is a :math:`p\\\\times k` matrix, :math:`N` is\\n    :math:`k\\\\times k`\\n    matrix with zeros on the diagonal and ones elsewhere, :math:`C` is a\\n    :math:`p\\\\times p` matrix with elements equal to :math:`1/p`,\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ`\\n    is the element-wise product or Hadamard product.\\n\\n    The gradient is given by\\n\\n    .. math::\\n        L\\\\circ\\\\left[(I-\\\\gamma C) (L \\\\circ L)N\\\\right].\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    The oblimin family is parametrized by the parameter :math:`\\\\gamma`. For\\n    orthogonal rotations:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\\n    * :math:`\\\\gamma=1` corresponds to varimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\\n    For oblique rotations rotations:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimin,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimin.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    N = np.ones((k, k)) - np.eye(k)\n    if np.isclose(gamma, 0):\n        X = L2.dot(N)\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2).dot(N)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def oblimin_objective(L=None, A=None, T=None, gamma=0, rotation_method='orthogonal', return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Objective function for the oblimin family for orthogonal or\\n    oblique rotation wich minimizes:\\n\\n    .. math::\\n        \\\\phi(L) = \\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)N),\\n\\n    where :math:`L` is a :math:`p\\\\times k` matrix, :math:`N` is\\n    :math:`k\\\\times k`\\n    matrix with zeros on the diagonal and ones elsewhere, :math:`C` is a\\n    :math:`p\\\\times p` matrix with elements equal to :math:`1/p`,\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ`\\n    is the element-wise product or Hadamard product.\\n\\n    The gradient is given by\\n\\n    .. math::\\n        L\\\\circ\\\\left[(I-\\\\gamma C) (L \\\\circ L)N\\\\right].\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    The oblimin family is parametrized by the parameter :math:`\\\\gamma`. For\\n    orthogonal rotations:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\\n    * :math:`\\\\gamma=1` corresponds to varimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\\n    For oblique rotations rotations:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimin,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimin.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    N = np.ones((k, k)) - np.eye(k)\n    if np.isclose(gamma, 0):\n        X = L2.dot(N)\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2).dot(N)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def oblimin_objective(L=None, A=None, T=None, gamma=0, rotation_method='orthogonal', return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Objective function for the oblimin family for orthogonal or\\n    oblique rotation wich minimizes:\\n\\n    .. math::\\n        \\\\phi(L) = \\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)N),\\n\\n    where :math:`L` is a :math:`p\\\\times k` matrix, :math:`N` is\\n    :math:`k\\\\times k`\\n    matrix with zeros on the diagonal and ones elsewhere, :math:`C` is a\\n    :math:`p\\\\times p` matrix with elements equal to :math:`1/p`,\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ`\\n    is the element-wise product or Hadamard product.\\n\\n    The gradient is given by\\n\\n    .. math::\\n        L\\\\circ\\\\left[(I-\\\\gamma C) (L \\\\circ L)N\\\\right].\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    The oblimin family is parametrized by the parameter :math:`\\\\gamma`. For\\n    orthogonal rotations:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\\n    * :math:`\\\\gamma=1` corresponds to varimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\\n    For oblique rotations rotations:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimin,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimin.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    N = np.ones((k, k)) - np.eye(k)\n    if np.isclose(gamma, 0):\n        X = L2.dot(N)\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2).dot(N)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def oblimin_objective(L=None, A=None, T=None, gamma=0, rotation_method='orthogonal', return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Objective function for the oblimin family for orthogonal or\\n    oblique rotation wich minimizes:\\n\\n    .. math::\\n        \\\\phi(L) = \\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)N),\\n\\n    where :math:`L` is a :math:`p\\\\times k` matrix, :math:`N` is\\n    :math:`k\\\\times k`\\n    matrix with zeros on the diagonal and ones elsewhere, :math:`C` is a\\n    :math:`p\\\\times p` matrix with elements equal to :math:`1/p`,\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ`\\n    is the element-wise product or Hadamard product.\\n\\n    The gradient is given by\\n\\n    .. math::\\n        L\\\\circ\\\\left[(I-\\\\gamma C) (L \\\\circ L)N\\\\right].\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    The oblimin family is parametrized by the parameter :math:`\\\\gamma`. For\\n    orthogonal rotations:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\\n    * :math:`\\\\gamma=1` corresponds to varimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\\n    For oblique rotations rotations:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimin,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimin.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    N = np.ones((k, k)) - np.eye(k)\n    if np.isclose(gamma, 0):\n        X = L2.dot(N)\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2).dot(N)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def oblimin_objective(L=None, A=None, T=None, gamma=0, rotation_method='orthogonal', return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Objective function for the oblimin family for orthogonal or\\n    oblique rotation wich minimizes:\\n\\n    .. math::\\n        \\\\phi(L) = \\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)N),\\n\\n    where :math:`L` is a :math:`p\\\\times k` matrix, :math:`N` is\\n    :math:`k\\\\times k`\\n    matrix with zeros on the diagonal and ones elsewhere, :math:`C` is a\\n    :math:`p\\\\times p` matrix with elements equal to :math:`1/p`,\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ`\\n    is the element-wise product or Hadamard product.\\n\\n    The gradient is given by\\n\\n    .. math::\\n        L\\\\circ\\\\left[(I-\\\\gamma C) (L \\\\circ L)N\\\\right].\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    The oblimin family is parametrized by the parameter :math:`\\\\gamma`. For\\n    orthogonal rotations:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\\n    * :math:`\\\\gamma=1` corresponds to varimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\\n    For oblique rotations rotations:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimin,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimin.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    N = np.ones((k, k)) - np.eye(k)\n    if np.isclose(gamma, 0):\n        X = L2.dot(N)\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2).dot(N)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi"
        ]
    },
    {
        "func_name": "orthomax_objective",
        "original": "def orthomax_objective(L=None, A=None, T=None, gamma=0, return_gradient=True):\n    \"\"\"\n    Objective function for the orthomax family for orthogonal\n    rotation wich minimizes the following objective:\n\n    .. math::\n        \\\\phi(L) = -\\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)),\n\n    where :math:`0\\\\leq\\\\gamma\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\n    :math:`C` is a  :math:`p\\\\times p` matrix with elements equal to\n    :math:`1/p`,\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\n\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\n    provided.\n\n    For orthogonal rotations :math:`L` satisfies\n\n    .. math::\n        L =  AT,\n\n    where :math:`T` is an orthogonal matrix.\n\n    The orthomax family is parametrized by the parameter :math:`\\\\gamma`:\n\n    * :math:`\\\\gamma=0` corresponds to quartimax,\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\n    * :math:`\\\\gamma=1` corresponds to varimax,\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\n\n    Parameters\n    ----------\n    L : numpy matrix (default None)\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\n    A : numpy matrix (default None)\n        non rotated factors\n    T : numpy matrix (default None)\n        rotation matrix\n    gamma : float (default 0)\n        a parameter\n    return_gradient : bool (default True)\n        toggles return of gradient\n    \"\"\"\n    assert 0 <= gamma <= 1, 'Gamma should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    (p, k) = L.shape\n    L2 = L ** 2\n    if np.isclose(gamma, 0):\n        X = L2\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2)\n    phi = -np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = -L * X\n        return (phi, Gphi)\n    else:\n        return phi",
        "mutated": [
            "def orthomax_objective(L=None, A=None, T=None, gamma=0, return_gradient=True):\n    if False:\n        i = 10\n    '\\n    Objective function for the orthomax family for orthogonal\\n    rotation wich minimizes the following objective:\\n\\n    .. math::\\n        \\\\phi(L) = -\\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)),\\n\\n    where :math:`0\\\\leq\\\\gamma\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\\n    :math:`C` is a  :math:`p\\\\times p` matrix with elements equal to\\n    :math:`1/p`,\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    The orthomax family is parametrized by the parameter :math:`\\\\gamma`:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\\n    * :math:`\\\\gamma=1` corresponds to varimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    assert 0 <= gamma <= 1, 'Gamma should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    (p, k) = L.shape\n    L2 = L ** 2\n    if np.isclose(gamma, 0):\n        X = L2\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2)\n    phi = -np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = -L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def orthomax_objective(L=None, A=None, T=None, gamma=0, return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Objective function for the orthomax family for orthogonal\\n    rotation wich minimizes the following objective:\\n\\n    .. math::\\n        \\\\phi(L) = -\\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)),\\n\\n    where :math:`0\\\\leq\\\\gamma\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\\n    :math:`C` is a  :math:`p\\\\times p` matrix with elements equal to\\n    :math:`1/p`,\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    The orthomax family is parametrized by the parameter :math:`\\\\gamma`:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\\n    * :math:`\\\\gamma=1` corresponds to varimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    assert 0 <= gamma <= 1, 'Gamma should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    (p, k) = L.shape\n    L2 = L ** 2\n    if np.isclose(gamma, 0):\n        X = L2\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2)\n    phi = -np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = -L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def orthomax_objective(L=None, A=None, T=None, gamma=0, return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Objective function for the orthomax family for orthogonal\\n    rotation wich minimizes the following objective:\\n\\n    .. math::\\n        \\\\phi(L) = -\\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)),\\n\\n    where :math:`0\\\\leq\\\\gamma\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\\n    :math:`C` is a  :math:`p\\\\times p` matrix with elements equal to\\n    :math:`1/p`,\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    The orthomax family is parametrized by the parameter :math:`\\\\gamma`:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\\n    * :math:`\\\\gamma=1` corresponds to varimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    assert 0 <= gamma <= 1, 'Gamma should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    (p, k) = L.shape\n    L2 = L ** 2\n    if np.isclose(gamma, 0):\n        X = L2\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2)\n    phi = -np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = -L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def orthomax_objective(L=None, A=None, T=None, gamma=0, return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Objective function for the orthomax family for orthogonal\\n    rotation wich minimizes the following objective:\\n\\n    .. math::\\n        \\\\phi(L) = -\\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)),\\n\\n    where :math:`0\\\\leq\\\\gamma\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\\n    :math:`C` is a  :math:`p\\\\times p` matrix with elements equal to\\n    :math:`1/p`,\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    The orthomax family is parametrized by the parameter :math:`\\\\gamma`:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\\n    * :math:`\\\\gamma=1` corresponds to varimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    assert 0 <= gamma <= 1, 'Gamma should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    (p, k) = L.shape\n    L2 = L ** 2\n    if np.isclose(gamma, 0):\n        X = L2\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2)\n    phi = -np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = -L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def orthomax_objective(L=None, A=None, T=None, gamma=0, return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Objective function for the orthomax family for orthogonal\\n    rotation wich minimizes the following objective:\\n\\n    .. math::\\n        \\\\phi(L) = -\\\\frac{1}{4}(L\\\\circ L,(I-\\\\gamma C)(L\\\\circ L)),\\n\\n    where :math:`0\\\\leq\\\\gamma\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\\n    :math:`C` is a  :math:`p\\\\times p` matrix with elements equal to\\n    :math:`1/p`,\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    The orthomax family is parametrized by the parameter :math:`\\\\gamma`:\\n\\n    * :math:`\\\\gamma=0` corresponds to quartimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{2}` corresponds to biquartimax,\\n    * :math:`\\\\gamma=1` corresponds to varimax,\\n    * :math:`\\\\gamma=\\\\frac{1}{p}` corresponds to equamax.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    assert 0 <= gamma <= 1, 'Gamma should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    (p, k) = L.shape\n    L2 = L ** 2\n    if np.isclose(gamma, 0):\n        X = L2\n    else:\n        C = np.ones((p, p)) / p\n        X = (np.eye(p) - gamma * C).dot(L2)\n    phi = -np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = -L * X\n        return (phi, Gphi)\n    else:\n        return phi"
        ]
    },
    {
        "func_name": "CF_objective",
        "original": "def CF_objective(L=None, A=None, T=None, kappa=0, rotation_method='orthogonal', return_gradient=True):\n    \"\"\"\n    Objective function for the Crawford-Ferguson family for orthogonal\n    and oblique rotation wich minimizes the following objective:\n\n    .. math::\n        \\\\phi(L) =\\\\frac{1-\\\\kappa}{4} (L\\\\circ L,(L\\\\circ L)N)\n                  -\\\\frac{1}{4}(L\\\\circ L,M(L\\\\circ L)),\n\n    where :math:`0\\\\leq\\\\kappa\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\n    :math:`N` is :math:`k\\\\times k` matrix with zeros on the diagonal and ones\n    elsewhere,\n    :math:`M` is :math:`p\\\\times p` matrix with zeros on the diagonal and ones\n    elsewhere\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\n\n    The gradient is given by\n\n    .. math::\n       d\\\\phi(L) = (1-\\\\kappa) L\\\\circ\\\\left[(L\\\\circ L)N\\\\right]\n                   -\\\\kappa L\\\\circ \\\\left[M(L\\\\circ L)\\\\right].\n\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\n    provided.\n\n    For orthogonal rotations :math:`L` satisfies\n\n    .. math::\n        L =  AT,\n\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\n    satisfies\n\n    .. math::\n        L =  A(T^*)^{-1},\n\n    where :math:`T` is a normal matrix.\n\n    For orthogonal rotations the oblimin (and orthomax) family of rotations is\n    equivalent to the Crawford-Ferguson family. To be more precise:\n\n    * :math:`\\\\kappa=0` corresponds to quartimax,\n    * :math:`\\\\kappa=\\\\frac{1}{p}` corresponds to variamx,\n    * :math:`\\\\kappa=\\\\frac{k-1}{p+k-2}` corresponds to parsimax,\n    * :math:`\\\\kappa=1` corresponds to factor parsimony.\n\n    Parameters\n    ----------\n    L : numpy matrix (default None)\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\n    A : numpy matrix (default None)\n        non rotated factors\n    T : numpy matrix (default None)\n        rotation matrix\n    gamma : float (default 0)\n        a parameter\n    rotation_method : str\n        should be one of {orthogonal, oblique}\n    return_gradient : bool (default True)\n        toggles return of gradient\n    \"\"\"\n    assert 0 <= kappa <= 1, 'Kappa should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    X = None\n    if not np.isclose(kappa, 1):\n        N = np.ones((k, k)) - np.eye(k)\n        X = (1 - kappa) * L2.dot(N)\n    if not np.isclose(kappa, 0):\n        M = np.ones((p, p)) - np.eye(p)\n        if X is None:\n            X = kappa * M.dot(L2)\n        else:\n            X += kappa * M.dot(L2)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi",
        "mutated": [
            "def CF_objective(L=None, A=None, T=None, kappa=0, rotation_method='orthogonal', return_gradient=True):\n    if False:\n        i = 10\n    '\\n    Objective function for the Crawford-Ferguson family for orthogonal\\n    and oblique rotation wich minimizes the following objective:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1-\\\\kappa}{4} (L\\\\circ L,(L\\\\circ L)N)\\n                  -\\\\frac{1}{4}(L\\\\circ L,M(L\\\\circ L)),\\n\\n    where :math:`0\\\\leq\\\\kappa\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\\n    :math:`N` is :math:`k\\\\times k` matrix with zeros on the diagonal and ones\\n    elsewhere,\\n    :math:`M` is :math:`p\\\\times p` matrix with zeros on the diagonal and ones\\n    elsewhere\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\\n\\n    The gradient is given by\\n\\n    .. math::\\n       d\\\\phi(L) = (1-\\\\kappa) L\\\\circ\\\\left[(L\\\\circ L)N\\\\right]\\n                   -\\\\kappa L\\\\circ \\\\left[M(L\\\\circ L)\\\\right].\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    For orthogonal rotations the oblimin (and orthomax) family of rotations is\\n    equivalent to the Crawford-Ferguson family. To be more precise:\\n\\n    * :math:`\\\\kappa=0` corresponds to quartimax,\\n    * :math:`\\\\kappa=\\\\frac{1}{p}` corresponds to variamx,\\n    * :math:`\\\\kappa=\\\\frac{k-1}{p+k-2}` corresponds to parsimax,\\n    * :math:`\\\\kappa=1` corresponds to factor parsimony.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    assert 0 <= kappa <= 1, 'Kappa should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    X = None\n    if not np.isclose(kappa, 1):\n        N = np.ones((k, k)) - np.eye(k)\n        X = (1 - kappa) * L2.dot(N)\n    if not np.isclose(kappa, 0):\n        M = np.ones((p, p)) - np.eye(p)\n        if X is None:\n            X = kappa * M.dot(L2)\n        else:\n            X += kappa * M.dot(L2)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def CF_objective(L=None, A=None, T=None, kappa=0, rotation_method='orthogonal', return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Objective function for the Crawford-Ferguson family for orthogonal\\n    and oblique rotation wich minimizes the following objective:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1-\\\\kappa}{4} (L\\\\circ L,(L\\\\circ L)N)\\n                  -\\\\frac{1}{4}(L\\\\circ L,M(L\\\\circ L)),\\n\\n    where :math:`0\\\\leq\\\\kappa\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\\n    :math:`N` is :math:`k\\\\times k` matrix with zeros on the diagonal and ones\\n    elsewhere,\\n    :math:`M` is :math:`p\\\\times p` matrix with zeros on the diagonal and ones\\n    elsewhere\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\\n\\n    The gradient is given by\\n\\n    .. math::\\n       d\\\\phi(L) = (1-\\\\kappa) L\\\\circ\\\\left[(L\\\\circ L)N\\\\right]\\n                   -\\\\kappa L\\\\circ \\\\left[M(L\\\\circ L)\\\\right].\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    For orthogonal rotations the oblimin (and orthomax) family of rotations is\\n    equivalent to the Crawford-Ferguson family. To be more precise:\\n\\n    * :math:`\\\\kappa=0` corresponds to quartimax,\\n    * :math:`\\\\kappa=\\\\frac{1}{p}` corresponds to variamx,\\n    * :math:`\\\\kappa=\\\\frac{k-1}{p+k-2}` corresponds to parsimax,\\n    * :math:`\\\\kappa=1` corresponds to factor parsimony.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    assert 0 <= kappa <= 1, 'Kappa should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    X = None\n    if not np.isclose(kappa, 1):\n        N = np.ones((k, k)) - np.eye(k)\n        X = (1 - kappa) * L2.dot(N)\n    if not np.isclose(kappa, 0):\n        M = np.ones((p, p)) - np.eye(p)\n        if X is None:\n            X = kappa * M.dot(L2)\n        else:\n            X += kappa * M.dot(L2)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def CF_objective(L=None, A=None, T=None, kappa=0, rotation_method='orthogonal', return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Objective function for the Crawford-Ferguson family for orthogonal\\n    and oblique rotation wich minimizes the following objective:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1-\\\\kappa}{4} (L\\\\circ L,(L\\\\circ L)N)\\n                  -\\\\frac{1}{4}(L\\\\circ L,M(L\\\\circ L)),\\n\\n    where :math:`0\\\\leq\\\\kappa\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\\n    :math:`N` is :math:`k\\\\times k` matrix with zeros on the diagonal and ones\\n    elsewhere,\\n    :math:`M` is :math:`p\\\\times p` matrix with zeros on the diagonal and ones\\n    elsewhere\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\\n\\n    The gradient is given by\\n\\n    .. math::\\n       d\\\\phi(L) = (1-\\\\kappa) L\\\\circ\\\\left[(L\\\\circ L)N\\\\right]\\n                   -\\\\kappa L\\\\circ \\\\left[M(L\\\\circ L)\\\\right].\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    For orthogonal rotations the oblimin (and orthomax) family of rotations is\\n    equivalent to the Crawford-Ferguson family. To be more precise:\\n\\n    * :math:`\\\\kappa=0` corresponds to quartimax,\\n    * :math:`\\\\kappa=\\\\frac{1}{p}` corresponds to variamx,\\n    * :math:`\\\\kappa=\\\\frac{k-1}{p+k-2}` corresponds to parsimax,\\n    * :math:`\\\\kappa=1` corresponds to factor parsimony.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    assert 0 <= kappa <= 1, 'Kappa should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    X = None\n    if not np.isclose(kappa, 1):\n        N = np.ones((k, k)) - np.eye(k)\n        X = (1 - kappa) * L2.dot(N)\n    if not np.isclose(kappa, 0):\n        M = np.ones((p, p)) - np.eye(p)\n        if X is None:\n            X = kappa * M.dot(L2)\n        else:\n            X += kappa * M.dot(L2)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def CF_objective(L=None, A=None, T=None, kappa=0, rotation_method='orthogonal', return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Objective function for the Crawford-Ferguson family for orthogonal\\n    and oblique rotation wich minimizes the following objective:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1-\\\\kappa}{4} (L\\\\circ L,(L\\\\circ L)N)\\n                  -\\\\frac{1}{4}(L\\\\circ L,M(L\\\\circ L)),\\n\\n    where :math:`0\\\\leq\\\\kappa\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\\n    :math:`N` is :math:`k\\\\times k` matrix with zeros on the diagonal and ones\\n    elsewhere,\\n    :math:`M` is :math:`p\\\\times p` matrix with zeros on the diagonal and ones\\n    elsewhere\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\\n\\n    The gradient is given by\\n\\n    .. math::\\n       d\\\\phi(L) = (1-\\\\kappa) L\\\\circ\\\\left[(L\\\\circ L)N\\\\right]\\n                   -\\\\kappa L\\\\circ \\\\left[M(L\\\\circ L)\\\\right].\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    For orthogonal rotations the oblimin (and orthomax) family of rotations is\\n    equivalent to the Crawford-Ferguson family. To be more precise:\\n\\n    * :math:`\\\\kappa=0` corresponds to quartimax,\\n    * :math:`\\\\kappa=\\\\frac{1}{p}` corresponds to variamx,\\n    * :math:`\\\\kappa=\\\\frac{k-1}{p+k-2}` corresponds to parsimax,\\n    * :math:`\\\\kappa=1` corresponds to factor parsimony.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    assert 0 <= kappa <= 1, 'Kappa should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    X = None\n    if not np.isclose(kappa, 1):\n        N = np.ones((k, k)) - np.eye(k)\n        X = (1 - kappa) * L2.dot(N)\n    if not np.isclose(kappa, 0):\n        M = np.ones((p, p)) - np.eye(p)\n        if X is None:\n            X = kappa * M.dot(L2)\n        else:\n            X += kappa * M.dot(L2)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi",
            "def CF_objective(L=None, A=None, T=None, kappa=0, rotation_method='orthogonal', return_gradient=True):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Objective function for the Crawford-Ferguson family for orthogonal\\n    and oblique rotation wich minimizes the following objective:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1-\\\\kappa}{4} (L\\\\circ L,(L\\\\circ L)N)\\n                  -\\\\frac{1}{4}(L\\\\circ L,M(L\\\\circ L)),\\n\\n    where :math:`0\\\\leq\\\\kappa\\\\leq1`, :math:`L` is a :math:`p\\\\times k` matrix,\\n    :math:`N` is :math:`k\\\\times k` matrix with zeros on the diagonal and ones\\n    elsewhere,\\n    :math:`M` is :math:`p\\\\times p` matrix with zeros on the diagonal and ones\\n    elsewhere\\n    :math:`(X,Y)=\\\\operatorname{Tr}(X^*Y)` is the Frobenius norm and\\n    :math:`\\\\circ` is the element-wise product or Hadamard product.\\n\\n    The gradient is given by\\n\\n    .. math::\\n       d\\\\phi(L) = (1-\\\\kappa) L\\\\circ\\\\left[(L\\\\circ L)N\\\\right]\\n                   -\\\\kappa L\\\\circ \\\\left[M(L\\\\circ L)\\\\right].\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    For orthogonal rotations the oblimin (and orthomax) family of rotations is\\n    equivalent to the Crawford-Ferguson family. To be more precise:\\n\\n    * :math:`\\\\kappa=0` corresponds to quartimax,\\n    * :math:`\\\\kappa=\\\\frac{1}{p}` corresponds to variamx,\\n    * :math:`\\\\kappa=\\\\frac{k-1}{p+k-2}` corresponds to parsimax,\\n    * :math:`\\\\kappa=1` corresponds to factor parsimony.\\n\\n    Parameters\\n    ----------\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    gamma : float (default 0)\\n        a parameter\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    return_gradient : bool (default True)\\n        toggles return of gradient\\n    '\n    assert 0 <= kappa <= 1, 'Kappa should be between 0 and 1'\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    (p, k) = L.shape\n    L2 = L ** 2\n    X = None\n    if not np.isclose(kappa, 1):\n        N = np.ones((k, k)) - np.eye(k)\n        X = (1 - kappa) * L2.dot(N)\n    if not np.isclose(kappa, 0):\n        M = np.ones((p, p)) - np.eye(p)\n        if X is None:\n            X = kappa * M.dot(L2)\n        else:\n            X += kappa * M.dot(L2)\n    phi = np.sum(L2 * X) / 4\n    if return_gradient:\n        Gphi = L * X\n        return (phi, Gphi)\n    else:\n        return phi"
        ]
    },
    {
        "func_name": "vgQ_target",
        "original": "def vgQ_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    \"\"\"\n    Subroutine for the value of vgQ using orthogonal or oblique rotation\n    towards a target matrix, i.e., we minimize:\n\n    .. math::\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2\n\n    and the gradient is given by\n\n    .. math::\n        d\\\\phi(L)=L-H.\n\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\n    provided.\n\n    For orthogonal rotations :math:`L` satisfies\n\n    .. math::\n        L =  AT,\n\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\n    satisfies\n\n    .. math::\n        L =  A(T^*)^{-1},\n\n    where :math:`T` is a normal matrix.\n\n    Parameters\n    ----------\n    H : numpy matrix\n        target matrix\n    L : numpy matrix (default None)\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\n    A : numpy matrix (default None)\n        non rotated factors\n    T : numpy matrix (default None)\n        rotation matrix\n    rotation_method : str\n        should be one of {orthogonal, oblique}\n    \"\"\"\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    q = np.linalg.norm(L - H, 'fro') ** 2\n    Gq = 2 * (L - H)\n    return (q, Gq)",
        "mutated": [
            "def vgQ_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    if False:\n        i = 10\n    '\\n    Subroutine for the value of vgQ using orthogonal or oblique rotation\\n    towards a target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2\\n\\n    and the gradient is given by\\n\\n    .. math::\\n        d\\\\phi(L)=L-H.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    q = np.linalg.norm(L - H, 'fro') ** 2\n    Gq = 2 * (L - H)\n    return (q, Gq)",
            "def vgQ_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Subroutine for the value of vgQ using orthogonal or oblique rotation\\n    towards a target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2\\n\\n    and the gradient is given by\\n\\n    .. math::\\n        d\\\\phi(L)=L-H.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    q = np.linalg.norm(L - H, 'fro') ** 2\n    Gq = 2 * (L - H)\n    return (q, Gq)",
            "def vgQ_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Subroutine for the value of vgQ using orthogonal or oblique rotation\\n    towards a target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2\\n\\n    and the gradient is given by\\n\\n    .. math::\\n        d\\\\phi(L)=L-H.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    q = np.linalg.norm(L - H, 'fro') ** 2\n    Gq = 2 * (L - H)\n    return (q, Gq)",
            "def vgQ_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Subroutine for the value of vgQ using orthogonal or oblique rotation\\n    towards a target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2\\n\\n    and the gradient is given by\\n\\n    .. math::\\n        d\\\\phi(L)=L-H.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    q = np.linalg.norm(L - H, 'fro') ** 2\n    Gq = 2 * (L - H)\n    return (q, Gq)",
            "def vgQ_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Subroutine for the value of vgQ using orthogonal or oblique rotation\\n    towards a target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2\\n\\n    and the gradient is given by\\n\\n    .. math::\\n        d\\\\phi(L)=L-H.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations :math:`L`\\n    satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    q = np.linalg.norm(L - H, 'fro') ** 2\n    Gq = 2 * (L - H)\n    return (q, Gq)"
        ]
    },
    {
        "func_name": "ff_target",
        "original": "def ff_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    \"\"\"\n    Subroutine for the value of f using (orthogonal or oblique) rotation\n    towards a target matrix, i.e., we minimize:\n\n    .. math::\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2.\n\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\n    provided. For orthogonal rotations :math:`L` satisfies\n\n    .. math::\n        L =  AT,\n\n    where :math:`T` is an orthogonal matrix. For oblique rotations\n    :math:`L` satisfies\n\n    .. math::\n        L =  A(T^*)^{-1},\n\n    where :math:`T` is a normal matrix.\n\n    Parameters\n    ----------\n    H : numpy matrix\n        target matrix\n    L : numpy matrix (default None)\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\n    A : numpy matrix (default None)\n        non rotated factors\n    T : numpy matrix (default None)\n        rotation matrix\n    rotation_method : str\n        should be one of {orthogonal, oblique}\n    \"\"\"\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    return np.linalg.norm(L - H, 'fro') ** 2",
        "mutated": [
            "def ff_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    if False:\n        i = 10\n    '\\n    Subroutine for the value of f using (orthogonal or oblique) rotation\\n    towards a target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided. For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations\\n    :math:`L` satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    return np.linalg.norm(L - H, 'fro') ** 2",
            "def ff_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Subroutine for the value of f using (orthogonal or oblique) rotation\\n    towards a target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided. For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations\\n    :math:`L` satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    return np.linalg.norm(L - H, 'fro') ** 2",
            "def ff_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Subroutine for the value of f using (orthogonal or oblique) rotation\\n    towards a target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided. For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations\\n    :math:`L` satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    return np.linalg.norm(L - H, 'fro') ** 2",
            "def ff_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Subroutine for the value of f using (orthogonal or oblique) rotation\\n    towards a target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided. For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations\\n    :math:`L` satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    return np.linalg.norm(L - H, 'fro') ** 2",
            "def ff_target(H, L=None, A=None, T=None, rotation_method='orthogonal'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Subroutine for the value of f using (orthogonal or oblique) rotation\\n    towards a target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|L-H\\\\|^2.\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided. For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix. For oblique rotations\\n    :math:`L` satisfies\\n\\n    .. math::\\n        L =  A(T^*)^{-1},\\n\\n    where :math:`T` is a normal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    rotation_method : str\\n        should be one of {orthogonal, oblique}\\n    '\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method=rotation_method)\n    return np.linalg.norm(L - H, 'fro') ** 2"
        ]
    },
    {
        "func_name": "vgQ_partial_target",
        "original": "def vgQ_partial_target(H, W=None, L=None, A=None, T=None):\n    \"\"\"\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\n    target matrix, i.e., we minimize:\n\n    .. math::\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\n\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\n    :math:`W` is a matrix whose entries can only be one or zero. The gradient\n    is given by\n\n    .. math::\n        d\\\\phi(L)=W\\\\circ(L-H).\n\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\n    provided.\n\n    For orthogonal rotations :math:`L` satisfies\n\n    .. math::\n        L =  AT,\n\n    where :math:`T` is an orthogonal matrix.\n\n    Parameters\n    ----------\n    H : numpy matrix\n        target matrix\n    W : numpy matrix (default matrix with equal weight one for all entries)\n        matrix with weights, entries can either be one or zero\n    L : numpy matrix (default None)\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\n    A : numpy matrix (default None)\n        non rotated factors\n    T : numpy matrix (default None)\n        rotation matrix\n    \"\"\"\n    if W is None:\n        return vgQ_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    Gq = 2 * W * (L - H)\n    return (q, Gq)",
        "mutated": [
            "def vgQ_partial_target(H, W=None, L=None, A=None, T=None):\n    if False:\n        i = 10\n    '\\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\\n    target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\\n\\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\\n    :math:`W` is a matrix whose entries can only be one or zero. The gradient\\n    is given by\\n\\n    .. math::\\n        d\\\\phi(L)=W\\\\circ(L-H).\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    W : numpy matrix (default matrix with equal weight one for all entries)\\n        matrix with weights, entries can either be one or zero\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    '\n    if W is None:\n        return vgQ_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    Gq = 2 * W * (L - H)\n    return (q, Gq)",
            "def vgQ_partial_target(H, W=None, L=None, A=None, T=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\\n    target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\\n\\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\\n    :math:`W` is a matrix whose entries can only be one or zero. The gradient\\n    is given by\\n\\n    .. math::\\n        d\\\\phi(L)=W\\\\circ(L-H).\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    W : numpy matrix (default matrix with equal weight one for all entries)\\n        matrix with weights, entries can either be one or zero\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    '\n    if W is None:\n        return vgQ_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    Gq = 2 * W * (L - H)\n    return (q, Gq)",
            "def vgQ_partial_target(H, W=None, L=None, A=None, T=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\\n    target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\\n\\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\\n    :math:`W` is a matrix whose entries can only be one or zero. The gradient\\n    is given by\\n\\n    .. math::\\n        d\\\\phi(L)=W\\\\circ(L-H).\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    W : numpy matrix (default matrix with equal weight one for all entries)\\n        matrix with weights, entries can either be one or zero\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    '\n    if W is None:\n        return vgQ_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    Gq = 2 * W * (L - H)\n    return (q, Gq)",
            "def vgQ_partial_target(H, W=None, L=None, A=None, T=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\\n    target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\\n\\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\\n    :math:`W` is a matrix whose entries can only be one or zero. The gradient\\n    is given by\\n\\n    .. math::\\n        d\\\\phi(L)=W\\\\circ(L-H).\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    W : numpy matrix (default matrix with equal weight one for all entries)\\n        matrix with weights, entries can either be one or zero\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    '\n    if W is None:\n        return vgQ_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    Gq = 2 * W * (L - H)\n    return (q, Gq)",
            "def vgQ_partial_target(H, W=None, L=None, A=None, T=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\\n    target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\\n\\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\\n    :math:`W` is a matrix whose entries can only be one or zero. The gradient\\n    is given by\\n\\n    .. math::\\n        d\\\\phi(L)=W\\\\circ(L-H).\\n\\n    Either :math:`L` should be provided or :math:`A` and :math:`T` should be\\n    provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    W : numpy matrix (default matrix with equal weight one for all entries)\\n        matrix with weights, entries can either be one or zero\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    '\n    if W is None:\n        return vgQ_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    Gq = 2 * W * (L - H)\n    return (q, Gq)"
        ]
    },
    {
        "func_name": "ff_partial_target",
        "original": "def ff_partial_target(H, W=None, L=None, A=None, T=None):\n    \"\"\"\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\n    target matrix, i.e., we minimize:\n\n    .. math::\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\n\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\n    :math:`W` is a matrix whose entries can only be one or zero. Either\n    :math:`L` should be provided or :math:`A` and :math:`T` should be provided.\n\n    For orthogonal rotations :math:`L` satisfies\n\n    .. math::\n        L =  AT,\n\n    where :math:`T` is an orthogonal matrix.\n\n    Parameters\n    ----------\n    H : numpy matrix\n        target matrix\n    W : numpy matrix (default matrix with equal weight one for all entries)\n        matrix with weights, entries can either be one or zero\n    L : numpy matrix (default None)\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\n    A : numpy matrix (default None)\n        non rotated factors\n    T : numpy matrix (default None)\n        rotation matrix\n    \"\"\"\n    if W is None:\n        return ff_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    return q",
        "mutated": [
            "def ff_partial_target(H, W=None, L=None, A=None, T=None):\n    if False:\n        i = 10\n    '\\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\\n    target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\\n\\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\\n    :math:`W` is a matrix whose entries can only be one or zero. Either\\n    :math:`L` should be provided or :math:`A` and :math:`T` should be provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    W : numpy matrix (default matrix with equal weight one for all entries)\\n        matrix with weights, entries can either be one or zero\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    '\n    if W is None:\n        return ff_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    return q",
            "def ff_partial_target(H, W=None, L=None, A=None, T=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\\n    target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\\n\\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\\n    :math:`W` is a matrix whose entries can only be one or zero. Either\\n    :math:`L` should be provided or :math:`A` and :math:`T` should be provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    W : numpy matrix (default matrix with equal weight one for all entries)\\n        matrix with weights, entries can either be one or zero\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    '\n    if W is None:\n        return ff_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    return q",
            "def ff_partial_target(H, W=None, L=None, A=None, T=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\\n    target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\\n\\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\\n    :math:`W` is a matrix whose entries can only be one or zero. Either\\n    :math:`L` should be provided or :math:`A` and :math:`T` should be provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    W : numpy matrix (default matrix with equal weight one for all entries)\\n        matrix with weights, entries can either be one or zero\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    '\n    if W is None:\n        return ff_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    return q",
            "def ff_partial_target(H, W=None, L=None, A=None, T=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\\n    target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\\n\\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\\n    :math:`W` is a matrix whose entries can only be one or zero. Either\\n    :math:`L` should be provided or :math:`A` and :math:`T` should be provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    W : numpy matrix (default matrix with equal weight one for all entries)\\n        matrix with weights, entries can either be one or zero\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    '\n    if W is None:\n        return ff_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    return q",
            "def ff_partial_target(H, W=None, L=None, A=None, T=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Subroutine for the value of vgQ using orthogonal rotation towards a partial\\n    target matrix, i.e., we minimize:\\n\\n    .. math::\\n        \\\\phi(L) =\\\\frac{1}{2}\\\\|W\\\\circ(L-H)\\\\|^2,\\n\\n    where :math:`\\\\circ` is the element-wise product or Hadamard product and\\n    :math:`W` is a matrix whose entries can only be one or zero. Either\\n    :math:`L` should be provided or :math:`A` and :math:`T` should be provided.\\n\\n    For orthogonal rotations :math:`L` satisfies\\n\\n    .. math::\\n        L =  AT,\\n\\n    where :math:`T` is an orthogonal matrix.\\n\\n    Parameters\\n    ----------\\n    H : numpy matrix\\n        target matrix\\n    W : numpy matrix (default matrix with equal weight one for all entries)\\n        matrix with weights, entries can either be one or zero\\n    L : numpy matrix (default None)\\n        rotated factors, i.e., :math:`L=A(T^*)^{-1}=AT`\\n    A : numpy matrix (default None)\\n        non rotated factors\\n    T : numpy matrix (default None)\\n        rotation matrix\\n    '\n    if W is None:\n        return ff_target(H, L=L, A=A, T=T)\n    if L is None:\n        assert A is not None and T is not None\n        L = rotateA(A, T, rotation_method='orthogonal')\n    q = np.linalg.norm(W * (L - H), 'fro') ** 2\n    return q"
        ]
    }
]