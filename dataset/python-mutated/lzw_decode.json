[
    {
        "func_name": "__init__",
        "original": "def __init__(self, input: bytes):\n    self._src: bytes = input\n    self._pos: int = -1\n    self._buffer: typing.List[int] = []\n    self._default_to_return: int = 256",
        "mutated": [
            "def __init__(self, input: bytes):\n    if False:\n        i = 10\n    self._src: bytes = input\n    self._pos: int = -1\n    self._buffer: typing.List[int] = []\n    self._default_to_return: int = 256",
            "def __init__(self, input: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._src: bytes = input\n    self._pos: int = -1\n    self._buffer: typing.List[int] = []\n    self._default_to_return: int = 256",
            "def __init__(self, input: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._src: bytes = input\n    self._pos: int = -1\n    self._buffer: typing.List[int] = []\n    self._default_to_return: int = 256",
            "def __init__(self, input: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._src: bytes = input\n    self._pos: int = -1\n    self._buffer: typing.List[int] = []\n    self._default_to_return: int = 256",
            "def __init__(self, input: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._src: bytes = input\n    self._pos: int = -1\n    self._buffer: typing.List[int] = []\n    self._default_to_return: int = 256"
        ]
    },
    {
        "func_name": "_read_next_byte",
        "original": "def _read_next_byte(self):\n    self._pos += 1\n    self._buffer += [int(x) for x in '{0:08b}'.format(self._src[self._pos])]",
        "mutated": [
            "def _read_next_byte(self):\n    if False:\n        i = 10\n    self._pos += 1\n    self._buffer += [int(x) for x in '{0:08b}'.format(self._src[self._pos])]",
            "def _read_next_byte(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._pos += 1\n    self._buffer += [int(x) for x in '{0:08b}'.format(self._src[self._pos])]",
            "def _read_next_byte(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._pos += 1\n    self._buffer += [int(x) for x in '{0:08b}'.format(self._src[self._pos])]",
            "def _read_next_byte(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._pos += 1\n    self._buffer += [int(x) for x in '{0:08b}'.format(self._src[self._pos])]",
            "def _read_next_byte(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._pos += 1\n    self._buffer += [int(x) for x in '{0:08b}'.format(self._src[self._pos])]"
        ]
    },
    {
        "func_name": "next",
        "original": "def next(self, n) -> int:\n    \"\"\"\n        This function reads the next n bits from the input\n        :param n:   the number of bits to retrieve\n        :return:    the next n bits from the input as an integer\n        \"\"\"\n    try:\n        while n > len(self._buffer):\n            self._read_next_byte()\n        x: typing.List[int] = self._buffer[:n]\n        self._buffer = self._buffer[n:]\n        return int(''.join([str(y) for y in x]), 2)\n    except:\n        return self._default_to_return",
        "mutated": [
            "def next(self, n) -> int:\n    if False:\n        i = 10\n    '\\n        This function reads the next n bits from the input\\n        :param n:   the number of bits to retrieve\\n        :return:    the next n bits from the input as an integer\\n        '\n    try:\n        while n > len(self._buffer):\n            self._read_next_byte()\n        x: typing.List[int] = self._buffer[:n]\n        self._buffer = self._buffer[n:]\n        return int(''.join([str(y) for y in x]), 2)\n    except:\n        return self._default_to_return",
            "def next(self, n) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        This function reads the next n bits from the input\\n        :param n:   the number of bits to retrieve\\n        :return:    the next n bits from the input as an integer\\n        '\n    try:\n        while n > len(self._buffer):\n            self._read_next_byte()\n        x: typing.List[int] = self._buffer[:n]\n        self._buffer = self._buffer[n:]\n        return int(''.join([str(y) for y in x]), 2)\n    except:\n        return self._default_to_return",
            "def next(self, n) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        This function reads the next n bits from the input\\n        :param n:   the number of bits to retrieve\\n        :return:    the next n bits from the input as an integer\\n        '\n    try:\n        while n > len(self._buffer):\n            self._read_next_byte()\n        x: typing.List[int] = self._buffer[:n]\n        self._buffer = self._buffer[n:]\n        return int(''.join([str(y) for y in x]), 2)\n    except:\n        return self._default_to_return",
            "def next(self, n) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        This function reads the next n bits from the input\\n        :param n:   the number of bits to retrieve\\n        :return:    the next n bits from the input as an integer\\n        '\n    try:\n        while n > len(self._buffer):\n            self._read_next_byte()\n        x: typing.List[int] = self._buffer[:n]\n        self._buffer = self._buffer[n:]\n        return int(''.join([str(y) for y in x]), 2)\n    except:\n        return self._default_to_return",
            "def next(self, n) -> int:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        This function reads the next n bits from the input\\n        :param n:   the number of bits to retrieve\\n        :return:    the next n bits from the input as an integer\\n        '\n    try:\n        while n > len(self._buffer):\n            self._read_next_byte()\n        x: typing.List[int] = self._buffer[:n]\n        self._buffer = self._buffer[n:]\n        return int(''.join([str(y) for y in x]), 2)\n    except:\n        return self._default_to_return"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    self._bits_to_read: int = 9\n    self._lookup_table: typing.Dict[int, bytearray] = {}\n    self._table_index: int = 0",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    self._bits_to_read: int = 9\n    self._lookup_table: typing.Dict[int, bytearray] = {}\n    self._table_index: int = 0",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._bits_to_read: int = 9\n    self._lookup_table: typing.Dict[int, bytearray] = {}\n    self._table_index: int = 0",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._bits_to_read: int = 9\n    self._lookup_table: typing.Dict[int, bytearray] = {}\n    self._table_index: int = 0",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._bits_to_read: int = 9\n    self._lookup_table: typing.Dict[int, bytearray] = {}\n    self._table_index: int = 0",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._bits_to_read: int = 9\n    self._lookup_table: typing.Dict[int, bytearray] = {}\n    self._table_index: int = 0"
        ]
    },
    {
        "func_name": "_add_to_lookup_table",
        "original": "def _add_to_lookup_table(self, prev_bytes: bytearray, new_bytes: bytes):\n    self._lookup_table[self._table_index] = prev_bytes + new_bytes\n    self._table_index += 1\n    if self._table_index == 511:\n        self._bits_to_read = 10\n    elif self._table_index == 1023:\n        self._bits_to_read = 11\n    elif self._table_index == 2047:\n        self._bits_to_read = 12",
        "mutated": [
            "def _add_to_lookup_table(self, prev_bytes: bytearray, new_bytes: bytes):\n    if False:\n        i = 10\n    self._lookup_table[self._table_index] = prev_bytes + new_bytes\n    self._table_index += 1\n    if self._table_index == 511:\n        self._bits_to_read = 10\n    elif self._table_index == 1023:\n        self._bits_to_read = 11\n    elif self._table_index == 2047:\n        self._bits_to_read = 12",
            "def _add_to_lookup_table(self, prev_bytes: bytearray, new_bytes: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._lookup_table[self._table_index] = prev_bytes + new_bytes\n    self._table_index += 1\n    if self._table_index == 511:\n        self._bits_to_read = 10\n    elif self._table_index == 1023:\n        self._bits_to_read = 11\n    elif self._table_index == 2047:\n        self._bits_to_read = 12",
            "def _add_to_lookup_table(self, prev_bytes: bytearray, new_bytes: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._lookup_table[self._table_index] = prev_bytes + new_bytes\n    self._table_index += 1\n    if self._table_index == 511:\n        self._bits_to_read = 10\n    elif self._table_index == 1023:\n        self._bits_to_read = 11\n    elif self._table_index == 2047:\n        self._bits_to_read = 12",
            "def _add_to_lookup_table(self, prev_bytes: bytearray, new_bytes: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._lookup_table[self._table_index] = prev_bytes + new_bytes\n    self._table_index += 1\n    if self._table_index == 511:\n        self._bits_to_read = 10\n    elif self._table_index == 1023:\n        self._bits_to_read = 11\n    elif self._table_index == 2047:\n        self._bits_to_read = 12",
            "def _add_to_lookup_table(self, prev_bytes: bytearray, new_bytes: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._lookup_table[self._table_index] = prev_bytes + new_bytes\n    self._table_index += 1\n    if self._table_index == 511:\n        self._bits_to_read = 10\n    elif self._table_index == 1023:\n        self._bits_to_read = 11\n    elif self._table_index == 2047:\n        self._bits_to_read = 12"
        ]
    },
    {
        "func_name": "_init_lookup_table",
        "original": "def _init_lookup_table(self):\n    self._lookup_table = {i: i.to_bytes(1, 'big') for i in range(0, 256)}\n    self._table_index = 258\n    self._bits_to_read = 9",
        "mutated": [
            "def _init_lookup_table(self):\n    if False:\n        i = 10\n    self._lookup_table = {i: i.to_bytes(1, 'big') for i in range(0, 256)}\n    self._table_index = 258\n    self._bits_to_read = 9",
            "def _init_lookup_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self._lookup_table = {i: i.to_bytes(1, 'big') for i in range(0, 256)}\n    self._table_index = 258\n    self._bits_to_read = 9",
            "def _init_lookup_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self._lookup_table = {i: i.to_bytes(1, 'big') for i in range(0, 256)}\n    self._table_index = 258\n    self._bits_to_read = 9",
            "def _init_lookup_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self._lookup_table = {i: i.to_bytes(1, 'big') for i in range(0, 256)}\n    self._table_index = 258\n    self._bits_to_read = 9",
            "def _init_lookup_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self._lookup_table = {i: i.to_bytes(1, 'big') for i in range(0, 256)}\n    self._table_index = 258\n    self._bits_to_read = 9"
        ]
    },
    {
        "func_name": "decode",
        "original": "def decode(self, input: bytes):\n    \"\"\"\n        Decompresses data encoded using the LZW (Lempel-Ziv-Welch)\n        adaptive compression method\n        \"\"\"\n    bytes_out: bytearray = bytearray()\n    bit_input: bitarray = bitarray(input)\n    prev_code: int = 0\n    code: int = 0\n    while code != 257:\n        code = bit_input.next(self._bits_to_read)\n        if code == 257:\n            break\n        if code == 256:\n            self._init_lookup_table()\n            code = bit_input.next(self._bits_to_read)\n            if code == 257:\n                break\n            bytes_out += self._lookup_table[code]\n            prev_code = code\n            continue\n        x: bytearray = bytearray()\n        if code < self._table_index:\n            x = self._lookup_table[code]\n            bytes_out += x\n            self._add_to_lookup_table(self._lookup_table[prev_code], x[0:1])\n            prev_code = code\n        else:\n            x = self._lookup_table[prev_code]\n            x = x + x[0:1]\n            bytes_out += x\n            self._add_to_lookup_table(x, bytearray())\n            prev_code = code\n    return bytes_out",
        "mutated": [
            "def decode(self, input: bytes):\n    if False:\n        i = 10\n    '\\n        Decompresses data encoded using the LZW (Lempel-Ziv-Welch)\\n        adaptive compression method\\n        '\n    bytes_out: bytearray = bytearray()\n    bit_input: bitarray = bitarray(input)\n    prev_code: int = 0\n    code: int = 0\n    while code != 257:\n        code = bit_input.next(self._bits_to_read)\n        if code == 257:\n            break\n        if code == 256:\n            self._init_lookup_table()\n            code = bit_input.next(self._bits_to_read)\n            if code == 257:\n                break\n            bytes_out += self._lookup_table[code]\n            prev_code = code\n            continue\n        x: bytearray = bytearray()\n        if code < self._table_index:\n            x = self._lookup_table[code]\n            bytes_out += x\n            self._add_to_lookup_table(self._lookup_table[prev_code], x[0:1])\n            prev_code = code\n        else:\n            x = self._lookup_table[prev_code]\n            x = x + x[0:1]\n            bytes_out += x\n            self._add_to_lookup_table(x, bytearray())\n            prev_code = code\n    return bytes_out",
            "def decode(self, input: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Decompresses data encoded using the LZW (Lempel-Ziv-Welch)\\n        adaptive compression method\\n        '\n    bytes_out: bytearray = bytearray()\n    bit_input: bitarray = bitarray(input)\n    prev_code: int = 0\n    code: int = 0\n    while code != 257:\n        code = bit_input.next(self._bits_to_read)\n        if code == 257:\n            break\n        if code == 256:\n            self._init_lookup_table()\n            code = bit_input.next(self._bits_to_read)\n            if code == 257:\n                break\n            bytes_out += self._lookup_table[code]\n            prev_code = code\n            continue\n        x: bytearray = bytearray()\n        if code < self._table_index:\n            x = self._lookup_table[code]\n            bytes_out += x\n            self._add_to_lookup_table(self._lookup_table[prev_code], x[0:1])\n            prev_code = code\n        else:\n            x = self._lookup_table[prev_code]\n            x = x + x[0:1]\n            bytes_out += x\n            self._add_to_lookup_table(x, bytearray())\n            prev_code = code\n    return bytes_out",
            "def decode(self, input: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Decompresses data encoded using the LZW (Lempel-Ziv-Welch)\\n        adaptive compression method\\n        '\n    bytes_out: bytearray = bytearray()\n    bit_input: bitarray = bitarray(input)\n    prev_code: int = 0\n    code: int = 0\n    while code != 257:\n        code = bit_input.next(self._bits_to_read)\n        if code == 257:\n            break\n        if code == 256:\n            self._init_lookup_table()\n            code = bit_input.next(self._bits_to_read)\n            if code == 257:\n                break\n            bytes_out += self._lookup_table[code]\n            prev_code = code\n            continue\n        x: bytearray = bytearray()\n        if code < self._table_index:\n            x = self._lookup_table[code]\n            bytes_out += x\n            self._add_to_lookup_table(self._lookup_table[prev_code], x[0:1])\n            prev_code = code\n        else:\n            x = self._lookup_table[prev_code]\n            x = x + x[0:1]\n            bytes_out += x\n            self._add_to_lookup_table(x, bytearray())\n            prev_code = code\n    return bytes_out",
            "def decode(self, input: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Decompresses data encoded using the LZW (Lempel-Ziv-Welch)\\n        adaptive compression method\\n        '\n    bytes_out: bytearray = bytearray()\n    bit_input: bitarray = bitarray(input)\n    prev_code: int = 0\n    code: int = 0\n    while code != 257:\n        code = bit_input.next(self._bits_to_read)\n        if code == 257:\n            break\n        if code == 256:\n            self._init_lookup_table()\n            code = bit_input.next(self._bits_to_read)\n            if code == 257:\n                break\n            bytes_out += self._lookup_table[code]\n            prev_code = code\n            continue\n        x: bytearray = bytearray()\n        if code < self._table_index:\n            x = self._lookup_table[code]\n            bytes_out += x\n            self._add_to_lookup_table(self._lookup_table[prev_code], x[0:1])\n            prev_code = code\n        else:\n            x = self._lookup_table[prev_code]\n            x = x + x[0:1]\n            bytes_out += x\n            self._add_to_lookup_table(x, bytearray())\n            prev_code = code\n    return bytes_out",
            "def decode(self, input: bytes):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Decompresses data encoded using the LZW (Lempel-Ziv-Welch)\\n        adaptive compression method\\n        '\n    bytes_out: bytearray = bytearray()\n    bit_input: bitarray = bitarray(input)\n    prev_code: int = 0\n    code: int = 0\n    while code != 257:\n        code = bit_input.next(self._bits_to_read)\n        if code == 257:\n            break\n        if code == 256:\n            self._init_lookup_table()\n            code = bit_input.next(self._bits_to_read)\n            if code == 257:\n                break\n            bytes_out += self._lookup_table[code]\n            prev_code = code\n            continue\n        x: bytearray = bytearray()\n        if code < self._table_index:\n            x = self._lookup_table[code]\n            bytes_out += x\n            self._add_to_lookup_table(self._lookup_table[prev_code], x[0:1])\n            prev_code = code\n        else:\n            x = self._lookup_table[prev_code]\n            x = x + x[0:1]\n            bytes_out += x\n            self._add_to_lookup_table(x, bytearray())\n            prev_code = code\n    return bytes_out"
        ]
    }
]