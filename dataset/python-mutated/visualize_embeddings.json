[
    {
        "func_name": "images_to_sprite",
        "original": "def images_to_sprite(data):\n    \"\"\"Creates the sprite image along with any necessary padding.\n\n  Taken from: https://github.com/tensorflow/tensorflow/issues/6322\n\n  Args:\n    data: NxHxW[x3] tensor containing the images.\n\n  Returns:\n    data: Properly shaped HxWx3 image with any necessary padding.\n  \"\"\"\n    if len(data.shape) == 3:\n        data = np.tile(data[..., np.newaxis], (1, 1, 1, 3))\n    data = data.astype(np.float32)\n    min_v = np.min(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) - min_v).transpose(3, 0, 1, 2)\n    max_v = np.max(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) / max_v).transpose(3, 0, 1, 2)\n    n = int(np.ceil(np.sqrt(data.shape[0])))\n    padding = ((0, n ** 2 - data.shape[0]), (0, 0), (0, 0)) + ((0, 0),) * (data.ndim - 3)\n    data = np.pad(data, padding, mode='constant', constant_values=0)\n    data = data.reshape((n, n) + data.shape[1:]).transpose((0, 2, 1, 3) + tuple(range(4, data.ndim + 1)))\n    data = data.reshape((n * data.shape[1], n * data.shape[3]) + data.shape[4:])\n    data = (data * 255).astype(np.uint8)\n    return data",
        "mutated": [
            "def images_to_sprite(data):\n    if False:\n        i = 10\n    'Creates the sprite image along with any necessary padding.\\n\\n  Taken from: https://github.com/tensorflow/tensorflow/issues/6322\\n\\n  Args:\\n    data: NxHxW[x3] tensor containing the images.\\n\\n  Returns:\\n    data: Properly shaped HxWx3 image with any necessary padding.\\n  '\n    if len(data.shape) == 3:\n        data = np.tile(data[..., np.newaxis], (1, 1, 1, 3))\n    data = data.astype(np.float32)\n    min_v = np.min(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) - min_v).transpose(3, 0, 1, 2)\n    max_v = np.max(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) / max_v).transpose(3, 0, 1, 2)\n    n = int(np.ceil(np.sqrt(data.shape[0])))\n    padding = ((0, n ** 2 - data.shape[0]), (0, 0), (0, 0)) + ((0, 0),) * (data.ndim - 3)\n    data = np.pad(data, padding, mode='constant', constant_values=0)\n    data = data.reshape((n, n) + data.shape[1:]).transpose((0, 2, 1, 3) + tuple(range(4, data.ndim + 1)))\n    data = data.reshape((n * data.shape[1], n * data.shape[3]) + data.shape[4:])\n    data = (data * 255).astype(np.uint8)\n    return data",
            "def images_to_sprite(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Creates the sprite image along with any necessary padding.\\n\\n  Taken from: https://github.com/tensorflow/tensorflow/issues/6322\\n\\n  Args:\\n    data: NxHxW[x3] tensor containing the images.\\n\\n  Returns:\\n    data: Properly shaped HxWx3 image with any necessary padding.\\n  '\n    if len(data.shape) == 3:\n        data = np.tile(data[..., np.newaxis], (1, 1, 1, 3))\n    data = data.astype(np.float32)\n    min_v = np.min(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) - min_v).transpose(3, 0, 1, 2)\n    max_v = np.max(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) / max_v).transpose(3, 0, 1, 2)\n    n = int(np.ceil(np.sqrt(data.shape[0])))\n    padding = ((0, n ** 2 - data.shape[0]), (0, 0), (0, 0)) + ((0, 0),) * (data.ndim - 3)\n    data = np.pad(data, padding, mode='constant', constant_values=0)\n    data = data.reshape((n, n) + data.shape[1:]).transpose((0, 2, 1, 3) + tuple(range(4, data.ndim + 1)))\n    data = data.reshape((n * data.shape[1], n * data.shape[3]) + data.shape[4:])\n    data = (data * 255).astype(np.uint8)\n    return data",
            "def images_to_sprite(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Creates the sprite image along with any necessary padding.\\n\\n  Taken from: https://github.com/tensorflow/tensorflow/issues/6322\\n\\n  Args:\\n    data: NxHxW[x3] tensor containing the images.\\n\\n  Returns:\\n    data: Properly shaped HxWx3 image with any necessary padding.\\n  '\n    if len(data.shape) == 3:\n        data = np.tile(data[..., np.newaxis], (1, 1, 1, 3))\n    data = data.astype(np.float32)\n    min_v = np.min(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) - min_v).transpose(3, 0, 1, 2)\n    max_v = np.max(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) / max_v).transpose(3, 0, 1, 2)\n    n = int(np.ceil(np.sqrt(data.shape[0])))\n    padding = ((0, n ** 2 - data.shape[0]), (0, 0), (0, 0)) + ((0, 0),) * (data.ndim - 3)\n    data = np.pad(data, padding, mode='constant', constant_values=0)\n    data = data.reshape((n, n) + data.shape[1:]).transpose((0, 2, 1, 3) + tuple(range(4, data.ndim + 1)))\n    data = data.reshape((n * data.shape[1], n * data.shape[3]) + data.shape[4:])\n    data = (data * 255).astype(np.uint8)\n    return data",
            "def images_to_sprite(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Creates the sprite image along with any necessary padding.\\n\\n  Taken from: https://github.com/tensorflow/tensorflow/issues/6322\\n\\n  Args:\\n    data: NxHxW[x3] tensor containing the images.\\n\\n  Returns:\\n    data: Properly shaped HxWx3 image with any necessary padding.\\n  '\n    if len(data.shape) == 3:\n        data = np.tile(data[..., np.newaxis], (1, 1, 1, 3))\n    data = data.astype(np.float32)\n    min_v = np.min(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) - min_v).transpose(3, 0, 1, 2)\n    max_v = np.max(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) / max_v).transpose(3, 0, 1, 2)\n    n = int(np.ceil(np.sqrt(data.shape[0])))\n    padding = ((0, n ** 2 - data.shape[0]), (0, 0), (0, 0)) + ((0, 0),) * (data.ndim - 3)\n    data = np.pad(data, padding, mode='constant', constant_values=0)\n    data = data.reshape((n, n) + data.shape[1:]).transpose((0, 2, 1, 3) + tuple(range(4, data.ndim + 1)))\n    data = data.reshape((n * data.shape[1], n * data.shape[3]) + data.shape[4:])\n    data = (data * 255).astype(np.uint8)\n    return data",
            "def images_to_sprite(data):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Creates the sprite image along with any necessary padding.\\n\\n  Taken from: https://github.com/tensorflow/tensorflow/issues/6322\\n\\n  Args:\\n    data: NxHxW[x3] tensor containing the images.\\n\\n  Returns:\\n    data: Properly shaped HxWx3 image with any necessary padding.\\n  '\n    if len(data.shape) == 3:\n        data = np.tile(data[..., np.newaxis], (1, 1, 1, 3))\n    data = data.astype(np.float32)\n    min_v = np.min(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) - min_v).transpose(3, 0, 1, 2)\n    max_v = np.max(data.reshape((data.shape[0], -1)), axis=1)\n    data = (data.transpose(1, 2, 3, 0) / max_v).transpose(3, 0, 1, 2)\n    n = int(np.ceil(np.sqrt(data.shape[0])))\n    padding = ((0, n ** 2 - data.shape[0]), (0, 0), (0, 0)) + ((0, 0),) * (data.ndim - 3)\n    data = np.pad(data, padding, mode='constant', constant_values=0)\n    data = data.reshape((n, n) + data.shape[1:]).transpose((0, 2, 1, 3) + tuple(range(4, data.ndim + 1)))\n    data = data.reshape((n * data.shape[1], n * data.shape[3]) + data.shape[4:])\n    data = (data * 255).astype(np.uint8)\n    return data"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(_):\n    \"\"\"Runs main labeled eval loop.\"\"\"\n    config = util.ParseConfigsToLuaTable(FLAGS.config_paths, FLAGS.model_params)\n    checkpointdir = FLAGS.checkpointdir\n    checkpoint_path = os.path.join('%s/model.ckpt-%s' % (checkpointdir, FLAGS.checkpoint_iter))\n    estimator = get_estimator(config, checkpointdir)\n    validation_dir = FLAGS.embedding_records\n    validation_records = util.GetFilesRecursively(validation_dir)\n    sequences_to_data = {}\n    for (view_embeddings, view_raw_image_strings, seqname) in estimator.inference(validation_records, checkpoint_path, config.data.embed_batch_size, num_sequences=FLAGS.num_sequences):\n        sequences_to_data[seqname] = {'embeddings': view_embeddings, 'images': view_raw_image_strings}\n    all_embeddings = np.zeros((0, config.embedding_size))\n    all_ims = []\n    all_seqnames = []\n    num_embeddings = FLAGS.num_embed\n    for (seqname, data) in sequences_to_data.iteritems():\n        embs = data['embeddings']\n        ims = data['images']\n        for v in range(config.data.num_views):\n            for (emb, im) in zip(embs[v], ims[v]):\n                all_embeddings = np.append(all_embeddings, [emb], axis=0)\n                all_ims.append(im)\n                all_seqnames.append(seqname)\n    random_indices = range(all_embeddings.shape[0])\n    random.shuffle(random_indices)\n    viz_indices = random_indices[:num_embeddings]\n    viz_embs = np.array(all_embeddings[viz_indices])\n    viz_ims = list(np.array(all_ims)[viz_indices])\n    decoded_ims = []\n    sprite_dim = FLAGS.sprite_dim\n    for (i, im) in enumerate(viz_ims):\n        if i % 100 == 0:\n            print('Decoding image %d/%d.' % (i, num_embeddings))\n        nparr_i = np.fromstring(str(im), np.uint8)\n        img_np = cv2.imdecode(nparr_i, 1)\n        img_np = img_np[..., [2, 1, 0]]\n        img_np = imresize(img_np, [sprite_dim, sprite_dim, 3])\n        decoded_ims.append(img_np)\n    decoded_ims = np.array(decoded_ims)\n    outdir = FLAGS.outdir\n    embedding_var = tf.Variable(viz_embs, name='viz_embs')\n    with tf.Session() as sess:\n        sess.run(embedding_var.initializer)\n        summary_writer = tf.summary.FileWriter(outdir)\n        config = projector.ProjectorConfig()\n        embedding = config.embeddings.add()\n        embedding.tensor_name = embedding_var.name\n        embedding.sprite.image_path = os.path.join(outdir, 'sprite.png')\n        embedding.sprite.single_image_dim.extend([decoded_ims.shape[1], decoded_ims.shape[1]])\n        projector.visualize_embeddings(summary_writer, config)\n        saver = tf.train.Saver([embedding_var])\n        saver.save(sess, os.path.join(outdir, 'model2.ckpt'), 1)\n    sprite = images_to_sprite(decoded_ims)\n    imsave(os.path.join(outdir, 'sprite.png'), sprite)",
        "mutated": [
            "def main(_):\n    if False:\n        i = 10\n    'Runs main labeled eval loop.'\n    config = util.ParseConfigsToLuaTable(FLAGS.config_paths, FLAGS.model_params)\n    checkpointdir = FLAGS.checkpointdir\n    checkpoint_path = os.path.join('%s/model.ckpt-%s' % (checkpointdir, FLAGS.checkpoint_iter))\n    estimator = get_estimator(config, checkpointdir)\n    validation_dir = FLAGS.embedding_records\n    validation_records = util.GetFilesRecursively(validation_dir)\n    sequences_to_data = {}\n    for (view_embeddings, view_raw_image_strings, seqname) in estimator.inference(validation_records, checkpoint_path, config.data.embed_batch_size, num_sequences=FLAGS.num_sequences):\n        sequences_to_data[seqname] = {'embeddings': view_embeddings, 'images': view_raw_image_strings}\n    all_embeddings = np.zeros((0, config.embedding_size))\n    all_ims = []\n    all_seqnames = []\n    num_embeddings = FLAGS.num_embed\n    for (seqname, data) in sequences_to_data.iteritems():\n        embs = data['embeddings']\n        ims = data['images']\n        for v in range(config.data.num_views):\n            for (emb, im) in zip(embs[v], ims[v]):\n                all_embeddings = np.append(all_embeddings, [emb], axis=0)\n                all_ims.append(im)\n                all_seqnames.append(seqname)\n    random_indices = range(all_embeddings.shape[0])\n    random.shuffle(random_indices)\n    viz_indices = random_indices[:num_embeddings]\n    viz_embs = np.array(all_embeddings[viz_indices])\n    viz_ims = list(np.array(all_ims)[viz_indices])\n    decoded_ims = []\n    sprite_dim = FLAGS.sprite_dim\n    for (i, im) in enumerate(viz_ims):\n        if i % 100 == 0:\n            print('Decoding image %d/%d.' % (i, num_embeddings))\n        nparr_i = np.fromstring(str(im), np.uint8)\n        img_np = cv2.imdecode(nparr_i, 1)\n        img_np = img_np[..., [2, 1, 0]]\n        img_np = imresize(img_np, [sprite_dim, sprite_dim, 3])\n        decoded_ims.append(img_np)\n    decoded_ims = np.array(decoded_ims)\n    outdir = FLAGS.outdir\n    embedding_var = tf.Variable(viz_embs, name='viz_embs')\n    with tf.Session() as sess:\n        sess.run(embedding_var.initializer)\n        summary_writer = tf.summary.FileWriter(outdir)\n        config = projector.ProjectorConfig()\n        embedding = config.embeddings.add()\n        embedding.tensor_name = embedding_var.name\n        embedding.sprite.image_path = os.path.join(outdir, 'sprite.png')\n        embedding.sprite.single_image_dim.extend([decoded_ims.shape[1], decoded_ims.shape[1]])\n        projector.visualize_embeddings(summary_writer, config)\n        saver = tf.train.Saver([embedding_var])\n        saver.save(sess, os.path.join(outdir, 'model2.ckpt'), 1)\n    sprite = images_to_sprite(decoded_ims)\n    imsave(os.path.join(outdir, 'sprite.png'), sprite)",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Runs main labeled eval loop.'\n    config = util.ParseConfigsToLuaTable(FLAGS.config_paths, FLAGS.model_params)\n    checkpointdir = FLAGS.checkpointdir\n    checkpoint_path = os.path.join('%s/model.ckpt-%s' % (checkpointdir, FLAGS.checkpoint_iter))\n    estimator = get_estimator(config, checkpointdir)\n    validation_dir = FLAGS.embedding_records\n    validation_records = util.GetFilesRecursively(validation_dir)\n    sequences_to_data = {}\n    for (view_embeddings, view_raw_image_strings, seqname) in estimator.inference(validation_records, checkpoint_path, config.data.embed_batch_size, num_sequences=FLAGS.num_sequences):\n        sequences_to_data[seqname] = {'embeddings': view_embeddings, 'images': view_raw_image_strings}\n    all_embeddings = np.zeros((0, config.embedding_size))\n    all_ims = []\n    all_seqnames = []\n    num_embeddings = FLAGS.num_embed\n    for (seqname, data) in sequences_to_data.iteritems():\n        embs = data['embeddings']\n        ims = data['images']\n        for v in range(config.data.num_views):\n            for (emb, im) in zip(embs[v], ims[v]):\n                all_embeddings = np.append(all_embeddings, [emb], axis=0)\n                all_ims.append(im)\n                all_seqnames.append(seqname)\n    random_indices = range(all_embeddings.shape[0])\n    random.shuffle(random_indices)\n    viz_indices = random_indices[:num_embeddings]\n    viz_embs = np.array(all_embeddings[viz_indices])\n    viz_ims = list(np.array(all_ims)[viz_indices])\n    decoded_ims = []\n    sprite_dim = FLAGS.sprite_dim\n    for (i, im) in enumerate(viz_ims):\n        if i % 100 == 0:\n            print('Decoding image %d/%d.' % (i, num_embeddings))\n        nparr_i = np.fromstring(str(im), np.uint8)\n        img_np = cv2.imdecode(nparr_i, 1)\n        img_np = img_np[..., [2, 1, 0]]\n        img_np = imresize(img_np, [sprite_dim, sprite_dim, 3])\n        decoded_ims.append(img_np)\n    decoded_ims = np.array(decoded_ims)\n    outdir = FLAGS.outdir\n    embedding_var = tf.Variable(viz_embs, name='viz_embs')\n    with tf.Session() as sess:\n        sess.run(embedding_var.initializer)\n        summary_writer = tf.summary.FileWriter(outdir)\n        config = projector.ProjectorConfig()\n        embedding = config.embeddings.add()\n        embedding.tensor_name = embedding_var.name\n        embedding.sprite.image_path = os.path.join(outdir, 'sprite.png')\n        embedding.sprite.single_image_dim.extend([decoded_ims.shape[1], decoded_ims.shape[1]])\n        projector.visualize_embeddings(summary_writer, config)\n        saver = tf.train.Saver([embedding_var])\n        saver.save(sess, os.path.join(outdir, 'model2.ckpt'), 1)\n    sprite = images_to_sprite(decoded_ims)\n    imsave(os.path.join(outdir, 'sprite.png'), sprite)",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Runs main labeled eval loop.'\n    config = util.ParseConfigsToLuaTable(FLAGS.config_paths, FLAGS.model_params)\n    checkpointdir = FLAGS.checkpointdir\n    checkpoint_path = os.path.join('%s/model.ckpt-%s' % (checkpointdir, FLAGS.checkpoint_iter))\n    estimator = get_estimator(config, checkpointdir)\n    validation_dir = FLAGS.embedding_records\n    validation_records = util.GetFilesRecursively(validation_dir)\n    sequences_to_data = {}\n    for (view_embeddings, view_raw_image_strings, seqname) in estimator.inference(validation_records, checkpoint_path, config.data.embed_batch_size, num_sequences=FLAGS.num_sequences):\n        sequences_to_data[seqname] = {'embeddings': view_embeddings, 'images': view_raw_image_strings}\n    all_embeddings = np.zeros((0, config.embedding_size))\n    all_ims = []\n    all_seqnames = []\n    num_embeddings = FLAGS.num_embed\n    for (seqname, data) in sequences_to_data.iteritems():\n        embs = data['embeddings']\n        ims = data['images']\n        for v in range(config.data.num_views):\n            for (emb, im) in zip(embs[v], ims[v]):\n                all_embeddings = np.append(all_embeddings, [emb], axis=0)\n                all_ims.append(im)\n                all_seqnames.append(seqname)\n    random_indices = range(all_embeddings.shape[0])\n    random.shuffle(random_indices)\n    viz_indices = random_indices[:num_embeddings]\n    viz_embs = np.array(all_embeddings[viz_indices])\n    viz_ims = list(np.array(all_ims)[viz_indices])\n    decoded_ims = []\n    sprite_dim = FLAGS.sprite_dim\n    for (i, im) in enumerate(viz_ims):\n        if i % 100 == 0:\n            print('Decoding image %d/%d.' % (i, num_embeddings))\n        nparr_i = np.fromstring(str(im), np.uint8)\n        img_np = cv2.imdecode(nparr_i, 1)\n        img_np = img_np[..., [2, 1, 0]]\n        img_np = imresize(img_np, [sprite_dim, sprite_dim, 3])\n        decoded_ims.append(img_np)\n    decoded_ims = np.array(decoded_ims)\n    outdir = FLAGS.outdir\n    embedding_var = tf.Variable(viz_embs, name='viz_embs')\n    with tf.Session() as sess:\n        sess.run(embedding_var.initializer)\n        summary_writer = tf.summary.FileWriter(outdir)\n        config = projector.ProjectorConfig()\n        embedding = config.embeddings.add()\n        embedding.tensor_name = embedding_var.name\n        embedding.sprite.image_path = os.path.join(outdir, 'sprite.png')\n        embedding.sprite.single_image_dim.extend([decoded_ims.shape[1], decoded_ims.shape[1]])\n        projector.visualize_embeddings(summary_writer, config)\n        saver = tf.train.Saver([embedding_var])\n        saver.save(sess, os.path.join(outdir, 'model2.ckpt'), 1)\n    sprite = images_to_sprite(decoded_ims)\n    imsave(os.path.join(outdir, 'sprite.png'), sprite)",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Runs main labeled eval loop.'\n    config = util.ParseConfigsToLuaTable(FLAGS.config_paths, FLAGS.model_params)\n    checkpointdir = FLAGS.checkpointdir\n    checkpoint_path = os.path.join('%s/model.ckpt-%s' % (checkpointdir, FLAGS.checkpoint_iter))\n    estimator = get_estimator(config, checkpointdir)\n    validation_dir = FLAGS.embedding_records\n    validation_records = util.GetFilesRecursively(validation_dir)\n    sequences_to_data = {}\n    for (view_embeddings, view_raw_image_strings, seqname) in estimator.inference(validation_records, checkpoint_path, config.data.embed_batch_size, num_sequences=FLAGS.num_sequences):\n        sequences_to_data[seqname] = {'embeddings': view_embeddings, 'images': view_raw_image_strings}\n    all_embeddings = np.zeros((0, config.embedding_size))\n    all_ims = []\n    all_seqnames = []\n    num_embeddings = FLAGS.num_embed\n    for (seqname, data) in sequences_to_data.iteritems():\n        embs = data['embeddings']\n        ims = data['images']\n        for v in range(config.data.num_views):\n            for (emb, im) in zip(embs[v], ims[v]):\n                all_embeddings = np.append(all_embeddings, [emb], axis=0)\n                all_ims.append(im)\n                all_seqnames.append(seqname)\n    random_indices = range(all_embeddings.shape[0])\n    random.shuffle(random_indices)\n    viz_indices = random_indices[:num_embeddings]\n    viz_embs = np.array(all_embeddings[viz_indices])\n    viz_ims = list(np.array(all_ims)[viz_indices])\n    decoded_ims = []\n    sprite_dim = FLAGS.sprite_dim\n    for (i, im) in enumerate(viz_ims):\n        if i % 100 == 0:\n            print('Decoding image %d/%d.' % (i, num_embeddings))\n        nparr_i = np.fromstring(str(im), np.uint8)\n        img_np = cv2.imdecode(nparr_i, 1)\n        img_np = img_np[..., [2, 1, 0]]\n        img_np = imresize(img_np, [sprite_dim, sprite_dim, 3])\n        decoded_ims.append(img_np)\n    decoded_ims = np.array(decoded_ims)\n    outdir = FLAGS.outdir\n    embedding_var = tf.Variable(viz_embs, name='viz_embs')\n    with tf.Session() as sess:\n        sess.run(embedding_var.initializer)\n        summary_writer = tf.summary.FileWriter(outdir)\n        config = projector.ProjectorConfig()\n        embedding = config.embeddings.add()\n        embedding.tensor_name = embedding_var.name\n        embedding.sprite.image_path = os.path.join(outdir, 'sprite.png')\n        embedding.sprite.single_image_dim.extend([decoded_ims.shape[1], decoded_ims.shape[1]])\n        projector.visualize_embeddings(summary_writer, config)\n        saver = tf.train.Saver([embedding_var])\n        saver.save(sess, os.path.join(outdir, 'model2.ckpt'), 1)\n    sprite = images_to_sprite(decoded_ims)\n    imsave(os.path.join(outdir, 'sprite.png'), sprite)",
            "def main(_):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Runs main labeled eval loop.'\n    config = util.ParseConfigsToLuaTable(FLAGS.config_paths, FLAGS.model_params)\n    checkpointdir = FLAGS.checkpointdir\n    checkpoint_path = os.path.join('%s/model.ckpt-%s' % (checkpointdir, FLAGS.checkpoint_iter))\n    estimator = get_estimator(config, checkpointdir)\n    validation_dir = FLAGS.embedding_records\n    validation_records = util.GetFilesRecursively(validation_dir)\n    sequences_to_data = {}\n    for (view_embeddings, view_raw_image_strings, seqname) in estimator.inference(validation_records, checkpoint_path, config.data.embed_batch_size, num_sequences=FLAGS.num_sequences):\n        sequences_to_data[seqname] = {'embeddings': view_embeddings, 'images': view_raw_image_strings}\n    all_embeddings = np.zeros((0, config.embedding_size))\n    all_ims = []\n    all_seqnames = []\n    num_embeddings = FLAGS.num_embed\n    for (seqname, data) in sequences_to_data.iteritems():\n        embs = data['embeddings']\n        ims = data['images']\n        for v in range(config.data.num_views):\n            for (emb, im) in zip(embs[v], ims[v]):\n                all_embeddings = np.append(all_embeddings, [emb], axis=0)\n                all_ims.append(im)\n                all_seqnames.append(seqname)\n    random_indices = range(all_embeddings.shape[0])\n    random.shuffle(random_indices)\n    viz_indices = random_indices[:num_embeddings]\n    viz_embs = np.array(all_embeddings[viz_indices])\n    viz_ims = list(np.array(all_ims)[viz_indices])\n    decoded_ims = []\n    sprite_dim = FLAGS.sprite_dim\n    for (i, im) in enumerate(viz_ims):\n        if i % 100 == 0:\n            print('Decoding image %d/%d.' % (i, num_embeddings))\n        nparr_i = np.fromstring(str(im), np.uint8)\n        img_np = cv2.imdecode(nparr_i, 1)\n        img_np = img_np[..., [2, 1, 0]]\n        img_np = imresize(img_np, [sprite_dim, sprite_dim, 3])\n        decoded_ims.append(img_np)\n    decoded_ims = np.array(decoded_ims)\n    outdir = FLAGS.outdir\n    embedding_var = tf.Variable(viz_embs, name='viz_embs')\n    with tf.Session() as sess:\n        sess.run(embedding_var.initializer)\n        summary_writer = tf.summary.FileWriter(outdir)\n        config = projector.ProjectorConfig()\n        embedding = config.embeddings.add()\n        embedding.tensor_name = embedding_var.name\n        embedding.sprite.image_path = os.path.join(outdir, 'sprite.png')\n        embedding.sprite.single_image_dim.extend([decoded_ims.shape[1], decoded_ims.shape[1]])\n        projector.visualize_embeddings(summary_writer, config)\n        saver = tf.train.Saver([embedding_var])\n        saver.save(sess, os.path.join(outdir, 'model2.ckpt'), 1)\n    sprite = images_to_sprite(decoded_ims)\n    imsave(os.path.join(outdir, 'sprite.png'), sprite)"
        ]
    }
]