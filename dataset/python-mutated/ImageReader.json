[
    {
        "func_name": "__init__",
        "original": "def __init__(self) -> None:\n    super().__init__()\n    self._supported_extensions = ['.jpg', '.jpeg', '.bmp', '.gif', '.png']\n    self._ui = ImageReaderUI(self)",
        "mutated": [
            "def __init__(self) -> None:\n    if False:\n        i = 10\n    super().__init__()\n    self._supported_extensions = ['.jpg', '.jpeg', '.bmp', '.gif', '.png']\n    self._ui = ImageReaderUI(self)",
            "def __init__(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__()\n    self._supported_extensions = ['.jpg', '.jpeg', '.bmp', '.gif', '.png']\n    self._ui = ImageReaderUI(self)",
            "def __init__(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__()\n    self._supported_extensions = ['.jpg', '.jpeg', '.bmp', '.gif', '.png']\n    self._ui = ImageReaderUI(self)",
            "def __init__(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__()\n    self._supported_extensions = ['.jpg', '.jpeg', '.bmp', '.gif', '.png']\n    self._ui = ImageReaderUI(self)",
            "def __init__(self) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__()\n    self._supported_extensions = ['.jpg', '.jpeg', '.bmp', '.gif', '.png']\n    self._ui = ImageReaderUI(self)"
        ]
    },
    {
        "func_name": "preRead",
        "original": "def preRead(self, file_name, *args, **kwargs):\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return MeshReader.PreReadResult.failed\n    width = img.width()\n    depth = img.height()\n    largest = max(width, depth)\n    width = width / largest * self._ui.default_width\n    depth = depth / largest * self._ui.default_depth\n    self._ui.setWidthAndDepth(width, depth)\n    self._ui.showConfigUI()\n    self._ui.waitForUIToClose()\n    if self._ui.getCancelled():\n        return MeshReader.PreReadResult.cancelled\n    return MeshReader.PreReadResult.accepted",
        "mutated": [
            "def preRead(self, file_name, *args, **kwargs):\n    if False:\n        i = 10\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return MeshReader.PreReadResult.failed\n    width = img.width()\n    depth = img.height()\n    largest = max(width, depth)\n    width = width / largest * self._ui.default_width\n    depth = depth / largest * self._ui.default_depth\n    self._ui.setWidthAndDepth(width, depth)\n    self._ui.showConfigUI()\n    self._ui.waitForUIToClose()\n    if self._ui.getCancelled():\n        return MeshReader.PreReadResult.cancelled\n    return MeshReader.PreReadResult.accepted",
            "def preRead(self, file_name, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return MeshReader.PreReadResult.failed\n    width = img.width()\n    depth = img.height()\n    largest = max(width, depth)\n    width = width / largest * self._ui.default_width\n    depth = depth / largest * self._ui.default_depth\n    self._ui.setWidthAndDepth(width, depth)\n    self._ui.showConfigUI()\n    self._ui.waitForUIToClose()\n    if self._ui.getCancelled():\n        return MeshReader.PreReadResult.cancelled\n    return MeshReader.PreReadResult.accepted",
            "def preRead(self, file_name, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return MeshReader.PreReadResult.failed\n    width = img.width()\n    depth = img.height()\n    largest = max(width, depth)\n    width = width / largest * self._ui.default_width\n    depth = depth / largest * self._ui.default_depth\n    self._ui.setWidthAndDepth(width, depth)\n    self._ui.showConfigUI()\n    self._ui.waitForUIToClose()\n    if self._ui.getCancelled():\n        return MeshReader.PreReadResult.cancelled\n    return MeshReader.PreReadResult.accepted",
            "def preRead(self, file_name, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return MeshReader.PreReadResult.failed\n    width = img.width()\n    depth = img.height()\n    largest = max(width, depth)\n    width = width / largest * self._ui.default_width\n    depth = depth / largest * self._ui.default_depth\n    self._ui.setWidthAndDepth(width, depth)\n    self._ui.showConfigUI()\n    self._ui.waitForUIToClose()\n    if self._ui.getCancelled():\n        return MeshReader.PreReadResult.cancelled\n    return MeshReader.PreReadResult.accepted",
            "def preRead(self, file_name, *args, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return MeshReader.PreReadResult.failed\n    width = img.width()\n    depth = img.height()\n    largest = max(width, depth)\n    width = width / largest * self._ui.default_width\n    depth = depth / largest * self._ui.default_depth\n    self._ui.setWidthAndDepth(width, depth)\n    self._ui.showConfigUI()\n    self._ui.waitForUIToClose()\n    if self._ui.getCancelled():\n        return MeshReader.PreReadResult.cancelled\n    return MeshReader.PreReadResult.accepted"
        ]
    },
    {
        "func_name": "_read",
        "original": "def _read(self, file_name):\n    size = max(self._ui.getWidth(), self._ui.getDepth())\n    return self._generateSceneNode(file_name, size, self._ui.peak_height, self._ui.base_height, self._ui.smoothing, 512, self._ui.lighter_is_higher, self._ui.use_transparency_model, self._ui.transmittance_1mm)",
        "mutated": [
            "def _read(self, file_name):\n    if False:\n        i = 10\n    size = max(self._ui.getWidth(), self._ui.getDepth())\n    return self._generateSceneNode(file_name, size, self._ui.peak_height, self._ui.base_height, self._ui.smoothing, 512, self._ui.lighter_is_higher, self._ui.use_transparency_model, self._ui.transmittance_1mm)",
            "def _read(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    size = max(self._ui.getWidth(), self._ui.getDepth())\n    return self._generateSceneNode(file_name, size, self._ui.peak_height, self._ui.base_height, self._ui.smoothing, 512, self._ui.lighter_is_higher, self._ui.use_transparency_model, self._ui.transmittance_1mm)",
            "def _read(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    size = max(self._ui.getWidth(), self._ui.getDepth())\n    return self._generateSceneNode(file_name, size, self._ui.peak_height, self._ui.base_height, self._ui.smoothing, 512, self._ui.lighter_is_higher, self._ui.use_transparency_model, self._ui.transmittance_1mm)",
            "def _read(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    size = max(self._ui.getWidth(), self._ui.getDepth())\n    return self._generateSceneNode(file_name, size, self._ui.peak_height, self._ui.base_height, self._ui.smoothing, 512, self._ui.lighter_is_higher, self._ui.use_transparency_model, self._ui.transmittance_1mm)",
            "def _read(self, file_name):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    size = max(self._ui.getWidth(), self._ui.getDepth())\n    return self._generateSceneNode(file_name, size, self._ui.peak_height, self._ui.base_height, self._ui.smoothing, 512, self._ui.lighter_is_higher, self._ui.use_transparency_model, self._ui.transmittance_1mm)"
        ]
    },
    {
        "func_name": "_generateSceneNode",
        "original": "def _generateSceneNode(self, file_name, xz_size, height_from_base, base_height, blur_iterations, max_size, lighter_is_higher, use_transparency_model, transmittance_1mm):\n    scene_node = SceneNode()\n    mesh = MeshBuilder()\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return None\n    width = max(img.width(), 2)\n    height = max(img.height(), 2)\n    aspect = height / width\n    if img.width() < 2 or img.height() < 2:\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    height_from_base = max(height_from_base, 0)\n    base_height = max(base_height, 0)\n    xz_size = max(xz_size, 1)\n    scale_vector = Vector(xz_size, height_from_base, xz_size)\n    if width > height:\n        scale_vector = scale_vector.set(z=scale_vector.z * aspect)\n    elif height > width:\n        scale_vector = scale_vector.set(x=scale_vector.x / aspect)\n    if width > max_size or height > max_size:\n        scale_factor = max_size / width\n        if height > width:\n            scale_factor = max_size / height\n        width = int(max(round(width * scale_factor), 2))\n        height = int(max(round(height * scale_factor), 2))\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    width_minus_one = width - 1\n    height_minus_one = height - 1\n    Job.yieldThread()\n    texel_width = 1.0 / width_minus_one * scale_vector.x\n    texel_height = 1.0 / height_minus_one * scale_vector.z\n    height_data = numpy.zeros((height, width), dtype=numpy.float32)\n    for x in range(0, width):\n        for y in range(0, height):\n            qrgb = img.pixel(x, y)\n            if use_transparency_model:\n                height_data[y, x] = 0.299 * math.pow(qRed(qrgb) / 255.0, 2.2) + 0.587 * math.pow(qGreen(qrgb) / 255.0, 2.2) + 0.114 * math.pow(qBlue(qrgb) / 255.0, 2.2)\n            else:\n                height_data[y, x] = (0.212655 * qRed(qrgb) + 0.715158 * qGreen(qrgb) + 0.072187 * qBlue(qrgb)) / 255\n    Job.yieldThread()\n    if lighter_is_higher == use_transparency_model:\n        height_data = 1 - height_data\n    for _ in range(0, blur_iterations):\n        copy = numpy.pad(height_data, ((1, 1), (1, 1)), mode='edge')\n        height_data += copy[1:-1, 2:]\n        height_data += copy[1:-1, :-2]\n        height_data += copy[2:, 1:-1]\n        height_data += copy[:-2, 1:-1]\n        height_data += copy[2:, 2:]\n        height_data += copy[:-2, 2:]\n        height_data += copy[2:, :-2]\n        height_data += copy[:-2, :-2]\n        height_data /= 9\n        Job.yieldThread()\n    if use_transparency_model:\n        divisor = 1.0 / math.log(transmittance_1mm / 100.0)\n        min_luminance = (transmittance_1mm / 100.0) ** height_from_base\n        for (y, x) in numpy.ndindex(height_data.shape):\n            mapped_luminance = min_luminance + (1.0 - min_luminance) * height_data[y, x]\n            height_data[y, x] = base_height + divisor * math.log(mapped_luminance)\n    else:\n        height_data *= scale_vector.y\n        height_data += base_height\n    if img.hasAlphaChannel():\n        for x in range(0, width):\n            for y in range(0, height):\n                height_data[y, x] *= qAlpha(img.pixel(x, y)) / 255.0\n    heightmap_face_count = 2 * height_minus_one * width_minus_one\n    total_face_count = heightmap_face_count + width_minus_one * 2 * (height_minus_one * 2) + 2\n    mesh.reserveFaceCount(total_face_count)\n    heightmap_vertices = numpy.zeros((width_minus_one * height_minus_one, 6, 3), dtype=numpy.float32)\n    heightmap_vertices = heightmap_vertices + numpy.array([[[0, base_height, 0], [0, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, 0], [0, base_height, 0]]], dtype=numpy.float32)\n    (offsetsz, offsetsx) = numpy.mgrid[0:height_minus_one, 0:width - 1]\n    offsetsx = numpy.array(offsetsx, numpy.float32).reshape(-1, 1) * texel_width\n    offsetsz = numpy.array(offsetsz, numpy.float32).reshape(-1, 1) * texel_height\n    heightmap_vertex_offsets = numpy.concatenate([offsetsx, numpy.zeros((offsetsx.shape[0], offsetsx.shape[1]), dtype=numpy.float32), offsetsz], 1)\n    heightmap_vertices += heightmap_vertex_offsets.repeat(6, 0).reshape(-1, 6, 3)\n    heightmap_vertices[:, 0, 1] = heightmap_vertices[:, 5, 1] = height_data[:-1, :-1].reshape(-1)\n    heightmap_vertices[:, 1, 1] = height_data[1:, :-1].reshape(-1)\n    heightmap_vertices[:, 2, 1] = heightmap_vertices[:, 3, 1] = height_data[1:, 1:].reshape(-1)\n    heightmap_vertices[:, 4, 1] = height_data[:-1, 1:].reshape(-1)\n    heightmap_indices = numpy.array(numpy.mgrid[0:heightmap_face_count * 3], dtype=numpy.int32).reshape(-1, 3)\n    mesh._vertices[0:heightmap_vertices.size // 3, :] = heightmap_vertices.reshape(-1, 3)\n    mesh._indices[0:heightmap_indices.size // 3, :] = heightmap_indices\n    mesh._vertex_count = heightmap_vertices.size // 3\n    mesh._face_count = heightmap_indices.size // 3\n    geo_width = width_minus_one * texel_width\n    geo_height = height_minus_one * texel_height\n    mesh.addFaceByPoints(0, 0, 0, 0, 0, geo_height, geo_width, 0, geo_height)\n    mesh.addFaceByPoints(geo_width, 0, geo_height, geo_width, 0, 0, 0, 0, 0)\n    for n in range(0, width_minus_one):\n        x = n * texel_width\n        nx = (n + 1) * texel_width\n        hn0 = height_data[0, n]\n        hn1 = height_data[0, n + 1]\n        hs0 = height_data[height_minus_one, n]\n        hs1 = height_data[height_minus_one, n + 1]\n        mesh.addFaceByPoints(x, 0, 0, nx, 0, 0, nx, hn1, 0)\n        mesh.addFaceByPoints(nx, hn1, 0, x, hn0, 0, x, 0, 0)\n        mesh.addFaceByPoints(x, 0, geo_height, nx, 0, geo_height, nx, hs1, geo_height)\n        mesh.addFaceByPoints(nx, hs1, geo_height, x, hs0, geo_height, x, 0, geo_height)\n    for n in range(0, height_minus_one):\n        y = n * texel_height\n        ny = (n + 1) * texel_height\n        hw0 = height_data[n, 0]\n        hw1 = height_data[n + 1, 0]\n        he0 = height_data[n, width_minus_one]\n        he1 = height_data[n + 1, width_minus_one]\n        mesh.addFaceByPoints(0, 0, y, 0, 0, ny, 0, hw1, ny)\n        mesh.addFaceByPoints(0, hw1, ny, 0, hw0, y, 0, 0, y)\n        mesh.addFaceByPoints(geo_width, 0, y, geo_width, 0, ny, geo_width, he1, ny)\n        mesh.addFaceByPoints(geo_width, he1, ny, geo_width, he0, y, geo_width, 0, y)\n    mesh.calculateNormals(fast=True)\n    scene_node.setMeshData(mesh.build())\n    return scene_node",
        "mutated": [
            "def _generateSceneNode(self, file_name, xz_size, height_from_base, base_height, blur_iterations, max_size, lighter_is_higher, use_transparency_model, transmittance_1mm):\n    if False:\n        i = 10\n    scene_node = SceneNode()\n    mesh = MeshBuilder()\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return None\n    width = max(img.width(), 2)\n    height = max(img.height(), 2)\n    aspect = height / width\n    if img.width() < 2 or img.height() < 2:\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    height_from_base = max(height_from_base, 0)\n    base_height = max(base_height, 0)\n    xz_size = max(xz_size, 1)\n    scale_vector = Vector(xz_size, height_from_base, xz_size)\n    if width > height:\n        scale_vector = scale_vector.set(z=scale_vector.z * aspect)\n    elif height > width:\n        scale_vector = scale_vector.set(x=scale_vector.x / aspect)\n    if width > max_size or height > max_size:\n        scale_factor = max_size / width\n        if height > width:\n            scale_factor = max_size / height\n        width = int(max(round(width * scale_factor), 2))\n        height = int(max(round(height * scale_factor), 2))\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    width_minus_one = width - 1\n    height_minus_one = height - 1\n    Job.yieldThread()\n    texel_width = 1.0 / width_minus_one * scale_vector.x\n    texel_height = 1.0 / height_minus_one * scale_vector.z\n    height_data = numpy.zeros((height, width), dtype=numpy.float32)\n    for x in range(0, width):\n        for y in range(0, height):\n            qrgb = img.pixel(x, y)\n            if use_transparency_model:\n                height_data[y, x] = 0.299 * math.pow(qRed(qrgb) / 255.0, 2.2) + 0.587 * math.pow(qGreen(qrgb) / 255.0, 2.2) + 0.114 * math.pow(qBlue(qrgb) / 255.0, 2.2)\n            else:\n                height_data[y, x] = (0.212655 * qRed(qrgb) + 0.715158 * qGreen(qrgb) + 0.072187 * qBlue(qrgb)) / 255\n    Job.yieldThread()\n    if lighter_is_higher == use_transparency_model:\n        height_data = 1 - height_data\n    for _ in range(0, blur_iterations):\n        copy = numpy.pad(height_data, ((1, 1), (1, 1)), mode='edge')\n        height_data += copy[1:-1, 2:]\n        height_data += copy[1:-1, :-2]\n        height_data += copy[2:, 1:-1]\n        height_data += copy[:-2, 1:-1]\n        height_data += copy[2:, 2:]\n        height_data += copy[:-2, 2:]\n        height_data += copy[2:, :-2]\n        height_data += copy[:-2, :-2]\n        height_data /= 9\n        Job.yieldThread()\n    if use_transparency_model:\n        divisor = 1.0 / math.log(transmittance_1mm / 100.0)\n        min_luminance = (transmittance_1mm / 100.0) ** height_from_base\n        for (y, x) in numpy.ndindex(height_data.shape):\n            mapped_luminance = min_luminance + (1.0 - min_luminance) * height_data[y, x]\n            height_data[y, x] = base_height + divisor * math.log(mapped_luminance)\n    else:\n        height_data *= scale_vector.y\n        height_data += base_height\n    if img.hasAlphaChannel():\n        for x in range(0, width):\n            for y in range(0, height):\n                height_data[y, x] *= qAlpha(img.pixel(x, y)) / 255.0\n    heightmap_face_count = 2 * height_minus_one * width_minus_one\n    total_face_count = heightmap_face_count + width_minus_one * 2 * (height_minus_one * 2) + 2\n    mesh.reserveFaceCount(total_face_count)\n    heightmap_vertices = numpy.zeros((width_minus_one * height_minus_one, 6, 3), dtype=numpy.float32)\n    heightmap_vertices = heightmap_vertices + numpy.array([[[0, base_height, 0], [0, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, 0], [0, base_height, 0]]], dtype=numpy.float32)\n    (offsetsz, offsetsx) = numpy.mgrid[0:height_minus_one, 0:width - 1]\n    offsetsx = numpy.array(offsetsx, numpy.float32).reshape(-1, 1) * texel_width\n    offsetsz = numpy.array(offsetsz, numpy.float32).reshape(-1, 1) * texel_height\n    heightmap_vertex_offsets = numpy.concatenate([offsetsx, numpy.zeros((offsetsx.shape[0], offsetsx.shape[1]), dtype=numpy.float32), offsetsz], 1)\n    heightmap_vertices += heightmap_vertex_offsets.repeat(6, 0).reshape(-1, 6, 3)\n    heightmap_vertices[:, 0, 1] = heightmap_vertices[:, 5, 1] = height_data[:-1, :-1].reshape(-1)\n    heightmap_vertices[:, 1, 1] = height_data[1:, :-1].reshape(-1)\n    heightmap_vertices[:, 2, 1] = heightmap_vertices[:, 3, 1] = height_data[1:, 1:].reshape(-1)\n    heightmap_vertices[:, 4, 1] = height_data[:-1, 1:].reshape(-1)\n    heightmap_indices = numpy.array(numpy.mgrid[0:heightmap_face_count * 3], dtype=numpy.int32).reshape(-1, 3)\n    mesh._vertices[0:heightmap_vertices.size // 3, :] = heightmap_vertices.reshape(-1, 3)\n    mesh._indices[0:heightmap_indices.size // 3, :] = heightmap_indices\n    mesh._vertex_count = heightmap_vertices.size // 3\n    mesh._face_count = heightmap_indices.size // 3\n    geo_width = width_minus_one * texel_width\n    geo_height = height_minus_one * texel_height\n    mesh.addFaceByPoints(0, 0, 0, 0, 0, geo_height, geo_width, 0, geo_height)\n    mesh.addFaceByPoints(geo_width, 0, geo_height, geo_width, 0, 0, 0, 0, 0)\n    for n in range(0, width_minus_one):\n        x = n * texel_width\n        nx = (n + 1) * texel_width\n        hn0 = height_data[0, n]\n        hn1 = height_data[0, n + 1]\n        hs0 = height_data[height_minus_one, n]\n        hs1 = height_data[height_minus_one, n + 1]\n        mesh.addFaceByPoints(x, 0, 0, nx, 0, 0, nx, hn1, 0)\n        mesh.addFaceByPoints(nx, hn1, 0, x, hn0, 0, x, 0, 0)\n        mesh.addFaceByPoints(x, 0, geo_height, nx, 0, geo_height, nx, hs1, geo_height)\n        mesh.addFaceByPoints(nx, hs1, geo_height, x, hs0, geo_height, x, 0, geo_height)\n    for n in range(0, height_minus_one):\n        y = n * texel_height\n        ny = (n + 1) * texel_height\n        hw0 = height_data[n, 0]\n        hw1 = height_data[n + 1, 0]\n        he0 = height_data[n, width_minus_one]\n        he1 = height_data[n + 1, width_minus_one]\n        mesh.addFaceByPoints(0, 0, y, 0, 0, ny, 0, hw1, ny)\n        mesh.addFaceByPoints(0, hw1, ny, 0, hw0, y, 0, 0, y)\n        mesh.addFaceByPoints(geo_width, 0, y, geo_width, 0, ny, geo_width, he1, ny)\n        mesh.addFaceByPoints(geo_width, he1, ny, geo_width, he0, y, geo_width, 0, y)\n    mesh.calculateNormals(fast=True)\n    scene_node.setMeshData(mesh.build())\n    return scene_node",
            "def _generateSceneNode(self, file_name, xz_size, height_from_base, base_height, blur_iterations, max_size, lighter_is_higher, use_transparency_model, transmittance_1mm):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    scene_node = SceneNode()\n    mesh = MeshBuilder()\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return None\n    width = max(img.width(), 2)\n    height = max(img.height(), 2)\n    aspect = height / width\n    if img.width() < 2 or img.height() < 2:\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    height_from_base = max(height_from_base, 0)\n    base_height = max(base_height, 0)\n    xz_size = max(xz_size, 1)\n    scale_vector = Vector(xz_size, height_from_base, xz_size)\n    if width > height:\n        scale_vector = scale_vector.set(z=scale_vector.z * aspect)\n    elif height > width:\n        scale_vector = scale_vector.set(x=scale_vector.x / aspect)\n    if width > max_size or height > max_size:\n        scale_factor = max_size / width\n        if height > width:\n            scale_factor = max_size / height\n        width = int(max(round(width * scale_factor), 2))\n        height = int(max(round(height * scale_factor), 2))\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    width_minus_one = width - 1\n    height_minus_one = height - 1\n    Job.yieldThread()\n    texel_width = 1.0 / width_minus_one * scale_vector.x\n    texel_height = 1.0 / height_minus_one * scale_vector.z\n    height_data = numpy.zeros((height, width), dtype=numpy.float32)\n    for x in range(0, width):\n        for y in range(0, height):\n            qrgb = img.pixel(x, y)\n            if use_transparency_model:\n                height_data[y, x] = 0.299 * math.pow(qRed(qrgb) / 255.0, 2.2) + 0.587 * math.pow(qGreen(qrgb) / 255.0, 2.2) + 0.114 * math.pow(qBlue(qrgb) / 255.0, 2.2)\n            else:\n                height_data[y, x] = (0.212655 * qRed(qrgb) + 0.715158 * qGreen(qrgb) + 0.072187 * qBlue(qrgb)) / 255\n    Job.yieldThread()\n    if lighter_is_higher == use_transparency_model:\n        height_data = 1 - height_data\n    for _ in range(0, blur_iterations):\n        copy = numpy.pad(height_data, ((1, 1), (1, 1)), mode='edge')\n        height_data += copy[1:-1, 2:]\n        height_data += copy[1:-1, :-2]\n        height_data += copy[2:, 1:-1]\n        height_data += copy[:-2, 1:-1]\n        height_data += copy[2:, 2:]\n        height_data += copy[:-2, 2:]\n        height_data += copy[2:, :-2]\n        height_data += copy[:-2, :-2]\n        height_data /= 9\n        Job.yieldThread()\n    if use_transparency_model:\n        divisor = 1.0 / math.log(transmittance_1mm / 100.0)\n        min_luminance = (transmittance_1mm / 100.0) ** height_from_base\n        for (y, x) in numpy.ndindex(height_data.shape):\n            mapped_luminance = min_luminance + (1.0 - min_luminance) * height_data[y, x]\n            height_data[y, x] = base_height + divisor * math.log(mapped_luminance)\n    else:\n        height_data *= scale_vector.y\n        height_data += base_height\n    if img.hasAlphaChannel():\n        for x in range(0, width):\n            for y in range(0, height):\n                height_data[y, x] *= qAlpha(img.pixel(x, y)) / 255.0\n    heightmap_face_count = 2 * height_minus_one * width_minus_one\n    total_face_count = heightmap_face_count + width_minus_one * 2 * (height_minus_one * 2) + 2\n    mesh.reserveFaceCount(total_face_count)\n    heightmap_vertices = numpy.zeros((width_minus_one * height_minus_one, 6, 3), dtype=numpy.float32)\n    heightmap_vertices = heightmap_vertices + numpy.array([[[0, base_height, 0], [0, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, 0], [0, base_height, 0]]], dtype=numpy.float32)\n    (offsetsz, offsetsx) = numpy.mgrid[0:height_minus_one, 0:width - 1]\n    offsetsx = numpy.array(offsetsx, numpy.float32).reshape(-1, 1) * texel_width\n    offsetsz = numpy.array(offsetsz, numpy.float32).reshape(-1, 1) * texel_height\n    heightmap_vertex_offsets = numpy.concatenate([offsetsx, numpy.zeros((offsetsx.shape[0], offsetsx.shape[1]), dtype=numpy.float32), offsetsz], 1)\n    heightmap_vertices += heightmap_vertex_offsets.repeat(6, 0).reshape(-1, 6, 3)\n    heightmap_vertices[:, 0, 1] = heightmap_vertices[:, 5, 1] = height_data[:-1, :-1].reshape(-1)\n    heightmap_vertices[:, 1, 1] = height_data[1:, :-1].reshape(-1)\n    heightmap_vertices[:, 2, 1] = heightmap_vertices[:, 3, 1] = height_data[1:, 1:].reshape(-1)\n    heightmap_vertices[:, 4, 1] = height_data[:-1, 1:].reshape(-1)\n    heightmap_indices = numpy.array(numpy.mgrid[0:heightmap_face_count * 3], dtype=numpy.int32).reshape(-1, 3)\n    mesh._vertices[0:heightmap_vertices.size // 3, :] = heightmap_vertices.reshape(-1, 3)\n    mesh._indices[0:heightmap_indices.size // 3, :] = heightmap_indices\n    mesh._vertex_count = heightmap_vertices.size // 3\n    mesh._face_count = heightmap_indices.size // 3\n    geo_width = width_minus_one * texel_width\n    geo_height = height_minus_one * texel_height\n    mesh.addFaceByPoints(0, 0, 0, 0, 0, geo_height, geo_width, 0, geo_height)\n    mesh.addFaceByPoints(geo_width, 0, geo_height, geo_width, 0, 0, 0, 0, 0)\n    for n in range(0, width_minus_one):\n        x = n * texel_width\n        nx = (n + 1) * texel_width\n        hn0 = height_data[0, n]\n        hn1 = height_data[0, n + 1]\n        hs0 = height_data[height_minus_one, n]\n        hs1 = height_data[height_minus_one, n + 1]\n        mesh.addFaceByPoints(x, 0, 0, nx, 0, 0, nx, hn1, 0)\n        mesh.addFaceByPoints(nx, hn1, 0, x, hn0, 0, x, 0, 0)\n        mesh.addFaceByPoints(x, 0, geo_height, nx, 0, geo_height, nx, hs1, geo_height)\n        mesh.addFaceByPoints(nx, hs1, geo_height, x, hs0, geo_height, x, 0, geo_height)\n    for n in range(0, height_minus_one):\n        y = n * texel_height\n        ny = (n + 1) * texel_height\n        hw0 = height_data[n, 0]\n        hw1 = height_data[n + 1, 0]\n        he0 = height_data[n, width_minus_one]\n        he1 = height_data[n + 1, width_minus_one]\n        mesh.addFaceByPoints(0, 0, y, 0, 0, ny, 0, hw1, ny)\n        mesh.addFaceByPoints(0, hw1, ny, 0, hw0, y, 0, 0, y)\n        mesh.addFaceByPoints(geo_width, 0, y, geo_width, 0, ny, geo_width, he1, ny)\n        mesh.addFaceByPoints(geo_width, he1, ny, geo_width, he0, y, geo_width, 0, y)\n    mesh.calculateNormals(fast=True)\n    scene_node.setMeshData(mesh.build())\n    return scene_node",
            "def _generateSceneNode(self, file_name, xz_size, height_from_base, base_height, blur_iterations, max_size, lighter_is_higher, use_transparency_model, transmittance_1mm):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    scene_node = SceneNode()\n    mesh = MeshBuilder()\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return None\n    width = max(img.width(), 2)\n    height = max(img.height(), 2)\n    aspect = height / width\n    if img.width() < 2 or img.height() < 2:\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    height_from_base = max(height_from_base, 0)\n    base_height = max(base_height, 0)\n    xz_size = max(xz_size, 1)\n    scale_vector = Vector(xz_size, height_from_base, xz_size)\n    if width > height:\n        scale_vector = scale_vector.set(z=scale_vector.z * aspect)\n    elif height > width:\n        scale_vector = scale_vector.set(x=scale_vector.x / aspect)\n    if width > max_size or height > max_size:\n        scale_factor = max_size / width\n        if height > width:\n            scale_factor = max_size / height\n        width = int(max(round(width * scale_factor), 2))\n        height = int(max(round(height * scale_factor), 2))\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    width_minus_one = width - 1\n    height_minus_one = height - 1\n    Job.yieldThread()\n    texel_width = 1.0 / width_minus_one * scale_vector.x\n    texel_height = 1.0 / height_minus_one * scale_vector.z\n    height_data = numpy.zeros((height, width), dtype=numpy.float32)\n    for x in range(0, width):\n        for y in range(0, height):\n            qrgb = img.pixel(x, y)\n            if use_transparency_model:\n                height_data[y, x] = 0.299 * math.pow(qRed(qrgb) / 255.0, 2.2) + 0.587 * math.pow(qGreen(qrgb) / 255.0, 2.2) + 0.114 * math.pow(qBlue(qrgb) / 255.0, 2.2)\n            else:\n                height_data[y, x] = (0.212655 * qRed(qrgb) + 0.715158 * qGreen(qrgb) + 0.072187 * qBlue(qrgb)) / 255\n    Job.yieldThread()\n    if lighter_is_higher == use_transparency_model:\n        height_data = 1 - height_data\n    for _ in range(0, blur_iterations):\n        copy = numpy.pad(height_data, ((1, 1), (1, 1)), mode='edge')\n        height_data += copy[1:-1, 2:]\n        height_data += copy[1:-1, :-2]\n        height_data += copy[2:, 1:-1]\n        height_data += copy[:-2, 1:-1]\n        height_data += copy[2:, 2:]\n        height_data += copy[:-2, 2:]\n        height_data += copy[2:, :-2]\n        height_data += copy[:-2, :-2]\n        height_data /= 9\n        Job.yieldThread()\n    if use_transparency_model:\n        divisor = 1.0 / math.log(transmittance_1mm / 100.0)\n        min_luminance = (transmittance_1mm / 100.0) ** height_from_base\n        for (y, x) in numpy.ndindex(height_data.shape):\n            mapped_luminance = min_luminance + (1.0 - min_luminance) * height_data[y, x]\n            height_data[y, x] = base_height + divisor * math.log(mapped_luminance)\n    else:\n        height_data *= scale_vector.y\n        height_data += base_height\n    if img.hasAlphaChannel():\n        for x in range(0, width):\n            for y in range(0, height):\n                height_data[y, x] *= qAlpha(img.pixel(x, y)) / 255.0\n    heightmap_face_count = 2 * height_minus_one * width_minus_one\n    total_face_count = heightmap_face_count + width_minus_one * 2 * (height_minus_one * 2) + 2\n    mesh.reserveFaceCount(total_face_count)\n    heightmap_vertices = numpy.zeros((width_minus_one * height_minus_one, 6, 3), dtype=numpy.float32)\n    heightmap_vertices = heightmap_vertices + numpy.array([[[0, base_height, 0], [0, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, 0], [0, base_height, 0]]], dtype=numpy.float32)\n    (offsetsz, offsetsx) = numpy.mgrid[0:height_minus_one, 0:width - 1]\n    offsetsx = numpy.array(offsetsx, numpy.float32).reshape(-1, 1) * texel_width\n    offsetsz = numpy.array(offsetsz, numpy.float32).reshape(-1, 1) * texel_height\n    heightmap_vertex_offsets = numpy.concatenate([offsetsx, numpy.zeros((offsetsx.shape[0], offsetsx.shape[1]), dtype=numpy.float32), offsetsz], 1)\n    heightmap_vertices += heightmap_vertex_offsets.repeat(6, 0).reshape(-1, 6, 3)\n    heightmap_vertices[:, 0, 1] = heightmap_vertices[:, 5, 1] = height_data[:-1, :-1].reshape(-1)\n    heightmap_vertices[:, 1, 1] = height_data[1:, :-1].reshape(-1)\n    heightmap_vertices[:, 2, 1] = heightmap_vertices[:, 3, 1] = height_data[1:, 1:].reshape(-1)\n    heightmap_vertices[:, 4, 1] = height_data[:-1, 1:].reshape(-1)\n    heightmap_indices = numpy.array(numpy.mgrid[0:heightmap_face_count * 3], dtype=numpy.int32).reshape(-1, 3)\n    mesh._vertices[0:heightmap_vertices.size // 3, :] = heightmap_vertices.reshape(-1, 3)\n    mesh._indices[0:heightmap_indices.size // 3, :] = heightmap_indices\n    mesh._vertex_count = heightmap_vertices.size // 3\n    mesh._face_count = heightmap_indices.size // 3\n    geo_width = width_minus_one * texel_width\n    geo_height = height_minus_one * texel_height\n    mesh.addFaceByPoints(0, 0, 0, 0, 0, geo_height, geo_width, 0, geo_height)\n    mesh.addFaceByPoints(geo_width, 0, geo_height, geo_width, 0, 0, 0, 0, 0)\n    for n in range(0, width_minus_one):\n        x = n * texel_width\n        nx = (n + 1) * texel_width\n        hn0 = height_data[0, n]\n        hn1 = height_data[0, n + 1]\n        hs0 = height_data[height_minus_one, n]\n        hs1 = height_data[height_minus_one, n + 1]\n        mesh.addFaceByPoints(x, 0, 0, nx, 0, 0, nx, hn1, 0)\n        mesh.addFaceByPoints(nx, hn1, 0, x, hn0, 0, x, 0, 0)\n        mesh.addFaceByPoints(x, 0, geo_height, nx, 0, geo_height, nx, hs1, geo_height)\n        mesh.addFaceByPoints(nx, hs1, geo_height, x, hs0, geo_height, x, 0, geo_height)\n    for n in range(0, height_minus_one):\n        y = n * texel_height\n        ny = (n + 1) * texel_height\n        hw0 = height_data[n, 0]\n        hw1 = height_data[n + 1, 0]\n        he0 = height_data[n, width_minus_one]\n        he1 = height_data[n + 1, width_minus_one]\n        mesh.addFaceByPoints(0, 0, y, 0, 0, ny, 0, hw1, ny)\n        mesh.addFaceByPoints(0, hw1, ny, 0, hw0, y, 0, 0, y)\n        mesh.addFaceByPoints(geo_width, 0, y, geo_width, 0, ny, geo_width, he1, ny)\n        mesh.addFaceByPoints(geo_width, he1, ny, geo_width, he0, y, geo_width, 0, y)\n    mesh.calculateNormals(fast=True)\n    scene_node.setMeshData(mesh.build())\n    return scene_node",
            "def _generateSceneNode(self, file_name, xz_size, height_from_base, base_height, blur_iterations, max_size, lighter_is_higher, use_transparency_model, transmittance_1mm):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    scene_node = SceneNode()\n    mesh = MeshBuilder()\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return None\n    width = max(img.width(), 2)\n    height = max(img.height(), 2)\n    aspect = height / width\n    if img.width() < 2 or img.height() < 2:\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    height_from_base = max(height_from_base, 0)\n    base_height = max(base_height, 0)\n    xz_size = max(xz_size, 1)\n    scale_vector = Vector(xz_size, height_from_base, xz_size)\n    if width > height:\n        scale_vector = scale_vector.set(z=scale_vector.z * aspect)\n    elif height > width:\n        scale_vector = scale_vector.set(x=scale_vector.x / aspect)\n    if width > max_size or height > max_size:\n        scale_factor = max_size / width\n        if height > width:\n            scale_factor = max_size / height\n        width = int(max(round(width * scale_factor), 2))\n        height = int(max(round(height * scale_factor), 2))\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    width_minus_one = width - 1\n    height_minus_one = height - 1\n    Job.yieldThread()\n    texel_width = 1.0 / width_minus_one * scale_vector.x\n    texel_height = 1.0 / height_minus_one * scale_vector.z\n    height_data = numpy.zeros((height, width), dtype=numpy.float32)\n    for x in range(0, width):\n        for y in range(0, height):\n            qrgb = img.pixel(x, y)\n            if use_transparency_model:\n                height_data[y, x] = 0.299 * math.pow(qRed(qrgb) / 255.0, 2.2) + 0.587 * math.pow(qGreen(qrgb) / 255.0, 2.2) + 0.114 * math.pow(qBlue(qrgb) / 255.0, 2.2)\n            else:\n                height_data[y, x] = (0.212655 * qRed(qrgb) + 0.715158 * qGreen(qrgb) + 0.072187 * qBlue(qrgb)) / 255\n    Job.yieldThread()\n    if lighter_is_higher == use_transparency_model:\n        height_data = 1 - height_data\n    for _ in range(0, blur_iterations):\n        copy = numpy.pad(height_data, ((1, 1), (1, 1)), mode='edge')\n        height_data += copy[1:-1, 2:]\n        height_data += copy[1:-1, :-2]\n        height_data += copy[2:, 1:-1]\n        height_data += copy[:-2, 1:-1]\n        height_data += copy[2:, 2:]\n        height_data += copy[:-2, 2:]\n        height_data += copy[2:, :-2]\n        height_data += copy[:-2, :-2]\n        height_data /= 9\n        Job.yieldThread()\n    if use_transparency_model:\n        divisor = 1.0 / math.log(transmittance_1mm / 100.0)\n        min_luminance = (transmittance_1mm / 100.0) ** height_from_base\n        for (y, x) in numpy.ndindex(height_data.shape):\n            mapped_luminance = min_luminance + (1.0 - min_luminance) * height_data[y, x]\n            height_data[y, x] = base_height + divisor * math.log(mapped_luminance)\n    else:\n        height_data *= scale_vector.y\n        height_data += base_height\n    if img.hasAlphaChannel():\n        for x in range(0, width):\n            for y in range(0, height):\n                height_data[y, x] *= qAlpha(img.pixel(x, y)) / 255.0\n    heightmap_face_count = 2 * height_minus_one * width_minus_one\n    total_face_count = heightmap_face_count + width_minus_one * 2 * (height_minus_one * 2) + 2\n    mesh.reserveFaceCount(total_face_count)\n    heightmap_vertices = numpy.zeros((width_minus_one * height_minus_one, 6, 3), dtype=numpy.float32)\n    heightmap_vertices = heightmap_vertices + numpy.array([[[0, base_height, 0], [0, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, 0], [0, base_height, 0]]], dtype=numpy.float32)\n    (offsetsz, offsetsx) = numpy.mgrid[0:height_minus_one, 0:width - 1]\n    offsetsx = numpy.array(offsetsx, numpy.float32).reshape(-1, 1) * texel_width\n    offsetsz = numpy.array(offsetsz, numpy.float32).reshape(-1, 1) * texel_height\n    heightmap_vertex_offsets = numpy.concatenate([offsetsx, numpy.zeros((offsetsx.shape[0], offsetsx.shape[1]), dtype=numpy.float32), offsetsz], 1)\n    heightmap_vertices += heightmap_vertex_offsets.repeat(6, 0).reshape(-1, 6, 3)\n    heightmap_vertices[:, 0, 1] = heightmap_vertices[:, 5, 1] = height_data[:-1, :-1].reshape(-1)\n    heightmap_vertices[:, 1, 1] = height_data[1:, :-1].reshape(-1)\n    heightmap_vertices[:, 2, 1] = heightmap_vertices[:, 3, 1] = height_data[1:, 1:].reshape(-1)\n    heightmap_vertices[:, 4, 1] = height_data[:-1, 1:].reshape(-1)\n    heightmap_indices = numpy.array(numpy.mgrid[0:heightmap_face_count * 3], dtype=numpy.int32).reshape(-1, 3)\n    mesh._vertices[0:heightmap_vertices.size // 3, :] = heightmap_vertices.reshape(-1, 3)\n    mesh._indices[0:heightmap_indices.size // 3, :] = heightmap_indices\n    mesh._vertex_count = heightmap_vertices.size // 3\n    mesh._face_count = heightmap_indices.size // 3\n    geo_width = width_minus_one * texel_width\n    geo_height = height_minus_one * texel_height\n    mesh.addFaceByPoints(0, 0, 0, 0, 0, geo_height, geo_width, 0, geo_height)\n    mesh.addFaceByPoints(geo_width, 0, geo_height, geo_width, 0, 0, 0, 0, 0)\n    for n in range(0, width_minus_one):\n        x = n * texel_width\n        nx = (n + 1) * texel_width\n        hn0 = height_data[0, n]\n        hn1 = height_data[0, n + 1]\n        hs0 = height_data[height_minus_one, n]\n        hs1 = height_data[height_minus_one, n + 1]\n        mesh.addFaceByPoints(x, 0, 0, nx, 0, 0, nx, hn1, 0)\n        mesh.addFaceByPoints(nx, hn1, 0, x, hn0, 0, x, 0, 0)\n        mesh.addFaceByPoints(x, 0, geo_height, nx, 0, geo_height, nx, hs1, geo_height)\n        mesh.addFaceByPoints(nx, hs1, geo_height, x, hs0, geo_height, x, 0, geo_height)\n    for n in range(0, height_minus_one):\n        y = n * texel_height\n        ny = (n + 1) * texel_height\n        hw0 = height_data[n, 0]\n        hw1 = height_data[n + 1, 0]\n        he0 = height_data[n, width_minus_one]\n        he1 = height_data[n + 1, width_minus_one]\n        mesh.addFaceByPoints(0, 0, y, 0, 0, ny, 0, hw1, ny)\n        mesh.addFaceByPoints(0, hw1, ny, 0, hw0, y, 0, 0, y)\n        mesh.addFaceByPoints(geo_width, 0, y, geo_width, 0, ny, geo_width, he1, ny)\n        mesh.addFaceByPoints(geo_width, he1, ny, geo_width, he0, y, geo_width, 0, y)\n    mesh.calculateNormals(fast=True)\n    scene_node.setMeshData(mesh.build())\n    return scene_node",
            "def _generateSceneNode(self, file_name, xz_size, height_from_base, base_height, blur_iterations, max_size, lighter_is_higher, use_transparency_model, transmittance_1mm):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    scene_node = SceneNode()\n    mesh = MeshBuilder()\n    img = QImage(file_name)\n    if img.isNull():\n        Logger.log('e', 'Image is corrupt.')\n        return None\n    width = max(img.width(), 2)\n    height = max(img.height(), 2)\n    aspect = height / width\n    if img.width() < 2 or img.height() < 2:\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    height_from_base = max(height_from_base, 0)\n    base_height = max(base_height, 0)\n    xz_size = max(xz_size, 1)\n    scale_vector = Vector(xz_size, height_from_base, xz_size)\n    if width > height:\n        scale_vector = scale_vector.set(z=scale_vector.z * aspect)\n    elif height > width:\n        scale_vector = scale_vector.set(x=scale_vector.x / aspect)\n    if width > max_size or height > max_size:\n        scale_factor = max_size / width\n        if height > width:\n            scale_factor = max_size / height\n        width = int(max(round(width * scale_factor), 2))\n        height = int(max(round(height * scale_factor), 2))\n        img = img.scaled(width, height, Qt.AspectRatioMode.IgnoreAspectRatio)\n    width_minus_one = width - 1\n    height_minus_one = height - 1\n    Job.yieldThread()\n    texel_width = 1.0 / width_minus_one * scale_vector.x\n    texel_height = 1.0 / height_minus_one * scale_vector.z\n    height_data = numpy.zeros((height, width), dtype=numpy.float32)\n    for x in range(0, width):\n        for y in range(0, height):\n            qrgb = img.pixel(x, y)\n            if use_transparency_model:\n                height_data[y, x] = 0.299 * math.pow(qRed(qrgb) / 255.0, 2.2) + 0.587 * math.pow(qGreen(qrgb) / 255.0, 2.2) + 0.114 * math.pow(qBlue(qrgb) / 255.0, 2.2)\n            else:\n                height_data[y, x] = (0.212655 * qRed(qrgb) + 0.715158 * qGreen(qrgb) + 0.072187 * qBlue(qrgb)) / 255\n    Job.yieldThread()\n    if lighter_is_higher == use_transparency_model:\n        height_data = 1 - height_data\n    for _ in range(0, blur_iterations):\n        copy = numpy.pad(height_data, ((1, 1), (1, 1)), mode='edge')\n        height_data += copy[1:-1, 2:]\n        height_data += copy[1:-1, :-2]\n        height_data += copy[2:, 1:-1]\n        height_data += copy[:-2, 1:-1]\n        height_data += copy[2:, 2:]\n        height_data += copy[:-2, 2:]\n        height_data += copy[2:, :-2]\n        height_data += copy[:-2, :-2]\n        height_data /= 9\n        Job.yieldThread()\n    if use_transparency_model:\n        divisor = 1.0 / math.log(transmittance_1mm / 100.0)\n        min_luminance = (transmittance_1mm / 100.0) ** height_from_base\n        for (y, x) in numpy.ndindex(height_data.shape):\n            mapped_luminance = min_luminance + (1.0 - min_luminance) * height_data[y, x]\n            height_data[y, x] = base_height + divisor * math.log(mapped_luminance)\n    else:\n        height_data *= scale_vector.y\n        height_data += base_height\n    if img.hasAlphaChannel():\n        for x in range(0, width):\n            for y in range(0, height):\n                height_data[y, x] *= qAlpha(img.pixel(x, y)) / 255.0\n    heightmap_face_count = 2 * height_minus_one * width_minus_one\n    total_face_count = heightmap_face_count + width_minus_one * 2 * (height_minus_one * 2) + 2\n    mesh.reserveFaceCount(total_face_count)\n    heightmap_vertices = numpy.zeros((width_minus_one * height_minus_one, 6, 3), dtype=numpy.float32)\n    heightmap_vertices = heightmap_vertices + numpy.array([[[0, base_height, 0], [0, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, texel_height], [texel_width, base_height, 0], [0, base_height, 0]]], dtype=numpy.float32)\n    (offsetsz, offsetsx) = numpy.mgrid[0:height_minus_one, 0:width - 1]\n    offsetsx = numpy.array(offsetsx, numpy.float32).reshape(-1, 1) * texel_width\n    offsetsz = numpy.array(offsetsz, numpy.float32).reshape(-1, 1) * texel_height\n    heightmap_vertex_offsets = numpy.concatenate([offsetsx, numpy.zeros((offsetsx.shape[0], offsetsx.shape[1]), dtype=numpy.float32), offsetsz], 1)\n    heightmap_vertices += heightmap_vertex_offsets.repeat(6, 0).reshape(-1, 6, 3)\n    heightmap_vertices[:, 0, 1] = heightmap_vertices[:, 5, 1] = height_data[:-1, :-1].reshape(-1)\n    heightmap_vertices[:, 1, 1] = height_data[1:, :-1].reshape(-1)\n    heightmap_vertices[:, 2, 1] = heightmap_vertices[:, 3, 1] = height_data[1:, 1:].reshape(-1)\n    heightmap_vertices[:, 4, 1] = height_data[:-1, 1:].reshape(-1)\n    heightmap_indices = numpy.array(numpy.mgrid[0:heightmap_face_count * 3], dtype=numpy.int32).reshape(-1, 3)\n    mesh._vertices[0:heightmap_vertices.size // 3, :] = heightmap_vertices.reshape(-1, 3)\n    mesh._indices[0:heightmap_indices.size // 3, :] = heightmap_indices\n    mesh._vertex_count = heightmap_vertices.size // 3\n    mesh._face_count = heightmap_indices.size // 3\n    geo_width = width_minus_one * texel_width\n    geo_height = height_minus_one * texel_height\n    mesh.addFaceByPoints(0, 0, 0, 0, 0, geo_height, geo_width, 0, geo_height)\n    mesh.addFaceByPoints(geo_width, 0, geo_height, geo_width, 0, 0, 0, 0, 0)\n    for n in range(0, width_minus_one):\n        x = n * texel_width\n        nx = (n + 1) * texel_width\n        hn0 = height_data[0, n]\n        hn1 = height_data[0, n + 1]\n        hs0 = height_data[height_minus_one, n]\n        hs1 = height_data[height_minus_one, n + 1]\n        mesh.addFaceByPoints(x, 0, 0, nx, 0, 0, nx, hn1, 0)\n        mesh.addFaceByPoints(nx, hn1, 0, x, hn0, 0, x, 0, 0)\n        mesh.addFaceByPoints(x, 0, geo_height, nx, 0, geo_height, nx, hs1, geo_height)\n        mesh.addFaceByPoints(nx, hs1, geo_height, x, hs0, geo_height, x, 0, geo_height)\n    for n in range(0, height_minus_one):\n        y = n * texel_height\n        ny = (n + 1) * texel_height\n        hw0 = height_data[n, 0]\n        hw1 = height_data[n + 1, 0]\n        he0 = height_data[n, width_minus_one]\n        he1 = height_data[n + 1, width_minus_one]\n        mesh.addFaceByPoints(0, 0, y, 0, 0, ny, 0, hw1, ny)\n        mesh.addFaceByPoints(0, hw1, ny, 0, hw0, y, 0, 0, y)\n        mesh.addFaceByPoints(geo_width, 0, y, geo_width, 0, ny, geo_width, he1, ny)\n        mesh.addFaceByPoints(geo_width, he1, ny, geo_width, he0, y, geo_width, 0, y)\n    mesh.calculateNormals(fast=True)\n    scene_node.setMeshData(mesh.build())\n    return scene_node"
        ]
    }
]