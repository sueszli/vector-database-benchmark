"""
Checks the legal headers of all files.
"""
from datetime import date
import re
from subprocess import Popen, PIPE
from .util import findfiles, readfile, writefile, has_ext, SHEBANG
OPENAGE_AUTHORS = 'Copyright (?P<crstart>\\d{4})-(?P<crend>\\d{4}) the openage authors\\.'
OPENAGE_AUTHORTEMPLATE = 'Copyright {crstart}-{crend} the openage authors.'
NATIVELEGALHEADER = re.compile('^(' + SHEBANG + ')?(#|//) ' + OPENAGE_AUTHORS + ' See copying\\.md for legal info\\.\n')
THIRDPARTYLEGALHEADER = re.compile('^(#|//) This file (was (taken|adapted)|contains (data|code)) from .*\n(#|//) Copyright \\d{4}-\\d{4} .*\n(#|//) .*license.*\n((#|//) .*\\n)*(#|//) (Modifications|Other (data|code)|Everything else) ' + OPENAGE_AUTHORS + '\n(#|//) See copying\\.md for further legal info\\.\n')
EMPTYFILE = re.compile('^(((#|//) .*)?\n)*$')
CYTHONGENERATED = re.compile('^[^\\n]*(Generated by Cython |failed Cython compilation.)')
EXTENSIONS_REQUIRING_LEGAL_HEADERS = {'.h', '.cpp', '.py', '.pyx', '.pxi', '.cmake', '.h.in', '.cpp.in', '.py.in', '.h.template', '.cpp.template', '.py.template', '.qml'}

def get_git_change_year(filename):
    if False:
        return 10
    " Returns git-log's opinion on when the file was last changed. "
    invocation = ['git', 'log', '-1', '--format=%ad', '--date=short', '--no-merges', '--', filename]
    with Popen(invocation, stdout=PIPE) as proc:
        output = proc.communicate()[0].decode('utf-8', errors='ignore').strip()
        if proc.returncode != 0 or not output:
            return None
    return int(output[:4])

def match_legalheader(data):
    if False:
        for i in range(10):
            print('nop')
    '\n    Tests whether data matches any of the regular expressions,\n    and returns a tuple of (matching header regex, match).\n    '
    for hdr in (NATIVELEGALHEADER, THIRDPARTYLEGALHEADER, EMPTYFILE, CYTHONGENERATED):
        match = re.match(hdr, data)
        if match is not None:
            return (hdr, match)
    raise ValueError('no match found')

def create_year_fix(filename, file_content, expected_end_year, found_start_year, headertype):
    if False:
        i = 10
        return i + 15
    '\n    Create a function that, when called, fixes the copyright header.\n    '
    if headertype not in {NATIVELEGALHEADER, THIRDPARTYLEGALHEADER}:
        return None

    def year_fix_function():
        if False:
            i = 10
            return i + 15
        '\n        Store the file with correct copyright years.\n        '
        (fixed_file, success) = re.subn(OPENAGE_AUTHORS, OPENAGE_AUTHORTEMPLATE.format(crstart=found_start_year, crend=expected_end_year), file_content)
        if not success:
            raise ValueError('copyright year fix did not suceeed')
        writefile(filename, fixed_file)
        return f'Copyright for {filename} was fixed.'
    return year_fix_function

def test_headers(check_files, paths, git_change_years, third_party_files):
    if False:
        for i in range(10):
            print('nop')
    ' Tests all in-sourcefile legal headers. '
    if not git_change_years:
        print("warning: I won't check if the copyright matches the git history.")
        print('         Run with --test-git-change-years to enable the check.')
    with Popen(['git', 'diff', '--name-only', 'HEAD'], stdout=PIPE) as proc:
        uncommited = set(proc.communicate()[0].decode('ascii').strip().split('\n'))
    current_calendar_year = date.today().year
    for filename in findfiles(paths, EXTENSIONS_REQUIRING_LEGAL_HEADERS):
        try:
            file_content = readfile(filename)
            (headertype, match) = match_legalheader(file_content)
        except ValueError:
            yield ('Legal header missing or invalid', filename + '\nSee copying.md for a template', None)
            continue
        if headertype is THIRDPARTYLEGALHEADER:
            third_party_files.add(filename)
        try:
            found_start_year = int(match.group('crstart'))
            found_end_year = int(match.group('crend'))
        except IndexError:
            continue
        expected_end_year = None
        if filename in uncommited:
            expected_end_year = current_calendar_year
        elif git_change_years:
            if check_files is None or filename in check_files:
                expected_end_year = get_git_change_year(filename)
        if expected_end_year is None:
            continue
        if found_end_year != expected_end_year:
            fix = create_year_fix(filename, file_content, expected_end_year, found_start_year, headertype)
            yield ('Bad copyright year', filename + '\n' + f'\tExpected {expected_end_year}\n' + f'\tFound    {found_end_year}', fix)

def find_issues(check_files, paths, git_change_years=False):
    if False:
        while True:
            i = 10
    '\n    Tests all source files for the required legal headers.\n    '
    third_party_files = set()
    yield from test_headers(check_files, paths, git_change_years, third_party_files)
    listed_files = set()
    for line in readfile('copying.md').split('\n'):
        match = re.match('^ - `([^`]+)`.*$', line)
        if not match:
            continue
        filename = match.group(1)
        listed_files.add(filename)
    for filename in sorted(listed_files - third_party_files):
        if has_ext(filename, EXTENSIONS_REQUIRING_LEGAL_HEADERS):
            yield ('third-party file listing issue', f'{filename}\n\tlisted in copying.md, but has no third-party license header.', None)
    for filename in sorted(third_party_files - listed_files):
        yield ('third-party file listing issue', f"{filename}\n\thas a third-party license header, but isn't listed in copying.md", None)