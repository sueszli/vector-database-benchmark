[
    {
        "func_name": "subscribe",
        "original": "def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n    assert subject_factory\n    connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n    assert mapper\n    subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n    return CompositeDisposable(subscription, connectable.connect(scheduler))",
        "mutated": [
            "def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n    if False:\n        i = 10\n    assert subject_factory\n    connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n    assert mapper\n    subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n    return CompositeDisposable(subscription, connectable.connect(scheduler))",
            "def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    assert subject_factory\n    connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n    assert mapper\n    subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n    return CompositeDisposable(subscription, connectable.connect(scheduler))",
            "def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    assert subject_factory\n    connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n    assert mapper\n    subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n    return CompositeDisposable(subscription, connectable.connect(scheduler))",
            "def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    assert subject_factory\n    connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n    assert mapper\n    subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n    return CompositeDisposable(subscription, connectable.connect(scheduler))",
            "def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    assert subject_factory\n    connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n    assert mapper\n    subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n    return CompositeDisposable(subscription, connectable.connect(scheduler))"
        ]
    },
    {
        "func_name": "multicast",
        "original": "def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n    if subject_factory:\n\n        def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n            assert subject_factory\n            connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n            assert mapper\n            subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n            return CompositeDisposable(subscription, connectable.connect(scheduler))\n        return Observable(subscribe)\n    if not subject:\n        raise ValueError('multicast: Subject cannot be None')\n    ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n    return ret",
        "mutated": [
            "def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n    if False:\n        i = 10\n    if subject_factory:\n\n        def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n            assert subject_factory\n            connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n            assert mapper\n            subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n            return CompositeDisposable(subscription, connectable.connect(scheduler))\n        return Observable(subscribe)\n    if not subject:\n        raise ValueError('multicast: Subject cannot be None')\n    ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n    return ret",
            "def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if subject_factory:\n\n        def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n            assert subject_factory\n            connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n            assert mapper\n            subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n            return CompositeDisposable(subscription, connectable.connect(scheduler))\n        return Observable(subscribe)\n    if not subject:\n        raise ValueError('multicast: Subject cannot be None')\n    ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n    return ret",
            "def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if subject_factory:\n\n        def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n            assert subject_factory\n            connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n            assert mapper\n            subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n            return CompositeDisposable(subscription, connectable.connect(scheduler))\n        return Observable(subscribe)\n    if not subject:\n        raise ValueError('multicast: Subject cannot be None')\n    ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n    return ret",
            "def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if subject_factory:\n\n        def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n            assert subject_factory\n            connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n            assert mapper\n            subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n            return CompositeDisposable(subscription, connectable.connect(scheduler))\n        return Observable(subscribe)\n    if not subject:\n        raise ValueError('multicast: Subject cannot be None')\n    ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n    return ret",
            "def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if subject_factory:\n\n        def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n            assert subject_factory\n            connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n            assert mapper\n            subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n            return CompositeDisposable(subscription, connectable.connect(scheduler))\n        return Observable(subscribe)\n    if not subject:\n        raise ValueError('multicast: Subject cannot be None')\n    ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n    return ret"
        ]
    },
    {
        "func_name": "multicast_",
        "original": "def multicast_(subject: Optional[abc.SubjectBase[_TSource]]=None, *, subject_factory: Optional[Callable[[Optional[abc.SchedulerBase]], abc.SubjectBase[_TSource]]]=None, mapper: Optional[Callable[[Observable[_TSource]], Observable[_TResult]]]=None) -> Callable[[Observable[_TSource]], Union[Observable[_TResult], ConnectableObservable[_TSource]]]:\n    \"\"\"Multicasts the source sequence notifications through an\n    instantiated subject into all uses of the sequence within a mapper\n    function. Each subscription to the resulting sequence causes a\n    separate multicast invocation, exposing the sequence resulting from\n    the mapper function's invocation. For specializations with fixed\n    subject types, see Publish, PublishLast, and Replay.\n\n    Examples:\n        >>> res = multicast(observable)\n        >>> res = multicast(\n            subject_factory=lambda scheduler: Subject(),\n            mapper=lambda x: x\n        )\n\n    Args:\n        subject_factory: Factory function to create an intermediate\n            subject through which the source sequence's elements will be\n            multicast to the mapper function.\n        subject: Subject to push source elements into.\n        mapper: [Optional] Mapper function which can use the\n            multicasted source sequence subject to the policies enforced\n            by the created subject. Specified only if subject_factory\"\n            is a factory function.\n\n    Returns:\n        An observable sequence that contains the elements of a sequence\n        produced by multicasting the source sequence within a mapper\n        function.\n    \"\"\"\n\n    def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n        if subject_factory:\n\n            def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n                assert subject_factory\n                connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n                assert mapper\n                subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n                return CompositeDisposable(subscription, connectable.connect(scheduler))\n            return Observable(subscribe)\n        if not subject:\n            raise ValueError('multicast: Subject cannot be None')\n        ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n        return ret\n    return multicast",
        "mutated": [
            "def multicast_(subject: Optional[abc.SubjectBase[_TSource]]=None, *, subject_factory: Optional[Callable[[Optional[abc.SchedulerBase]], abc.SubjectBase[_TSource]]]=None, mapper: Optional[Callable[[Observable[_TSource]], Observable[_TResult]]]=None) -> Callable[[Observable[_TSource]], Union[Observable[_TResult], ConnectableObservable[_TSource]]]:\n    if False:\n        i = 10\n    'Multicasts the source sequence notifications through an\\n    instantiated subject into all uses of the sequence within a mapper\\n    function. Each subscription to the resulting sequence causes a\\n    separate multicast invocation, exposing the sequence resulting from\\n    the mapper function\\'s invocation. For specializations with fixed\\n    subject types, see Publish, PublishLast, and Replay.\\n\\n    Examples:\\n        >>> res = multicast(observable)\\n        >>> res = multicast(\\n            subject_factory=lambda scheduler: Subject(),\\n            mapper=lambda x: x\\n        )\\n\\n    Args:\\n        subject_factory: Factory function to create an intermediate\\n            subject through which the source sequence\\'s elements will be\\n            multicast to the mapper function.\\n        subject: Subject to push source elements into.\\n        mapper: [Optional] Mapper function which can use the\\n            multicasted source sequence subject to the policies enforced\\n            by the created subject. Specified only if subject_factory\"\\n            is a factory function.\\n\\n    Returns:\\n        An observable sequence that contains the elements of a sequence\\n        produced by multicasting the source sequence within a mapper\\n        function.\\n    '\n\n    def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n        if subject_factory:\n\n            def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n                assert subject_factory\n                connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n                assert mapper\n                subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n                return CompositeDisposable(subscription, connectable.connect(scheduler))\n            return Observable(subscribe)\n        if not subject:\n            raise ValueError('multicast: Subject cannot be None')\n        ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n        return ret\n    return multicast",
            "def multicast_(subject: Optional[abc.SubjectBase[_TSource]]=None, *, subject_factory: Optional[Callable[[Optional[abc.SchedulerBase]], abc.SubjectBase[_TSource]]]=None, mapper: Optional[Callable[[Observable[_TSource]], Observable[_TResult]]]=None) -> Callable[[Observable[_TSource]], Union[Observable[_TResult], ConnectableObservable[_TSource]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Multicasts the source sequence notifications through an\\n    instantiated subject into all uses of the sequence within a mapper\\n    function. Each subscription to the resulting sequence causes a\\n    separate multicast invocation, exposing the sequence resulting from\\n    the mapper function\\'s invocation. For specializations with fixed\\n    subject types, see Publish, PublishLast, and Replay.\\n\\n    Examples:\\n        >>> res = multicast(observable)\\n        >>> res = multicast(\\n            subject_factory=lambda scheduler: Subject(),\\n            mapper=lambda x: x\\n        )\\n\\n    Args:\\n        subject_factory: Factory function to create an intermediate\\n            subject through which the source sequence\\'s elements will be\\n            multicast to the mapper function.\\n        subject: Subject to push source elements into.\\n        mapper: [Optional] Mapper function which can use the\\n            multicasted source sequence subject to the policies enforced\\n            by the created subject. Specified only if subject_factory\"\\n            is a factory function.\\n\\n    Returns:\\n        An observable sequence that contains the elements of a sequence\\n        produced by multicasting the source sequence within a mapper\\n        function.\\n    '\n\n    def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n        if subject_factory:\n\n            def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n                assert subject_factory\n                connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n                assert mapper\n                subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n                return CompositeDisposable(subscription, connectable.connect(scheduler))\n            return Observable(subscribe)\n        if not subject:\n            raise ValueError('multicast: Subject cannot be None')\n        ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n        return ret\n    return multicast",
            "def multicast_(subject: Optional[abc.SubjectBase[_TSource]]=None, *, subject_factory: Optional[Callable[[Optional[abc.SchedulerBase]], abc.SubjectBase[_TSource]]]=None, mapper: Optional[Callable[[Observable[_TSource]], Observable[_TResult]]]=None) -> Callable[[Observable[_TSource]], Union[Observable[_TResult], ConnectableObservable[_TSource]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Multicasts the source sequence notifications through an\\n    instantiated subject into all uses of the sequence within a mapper\\n    function. Each subscription to the resulting sequence causes a\\n    separate multicast invocation, exposing the sequence resulting from\\n    the mapper function\\'s invocation. For specializations with fixed\\n    subject types, see Publish, PublishLast, and Replay.\\n\\n    Examples:\\n        >>> res = multicast(observable)\\n        >>> res = multicast(\\n            subject_factory=lambda scheduler: Subject(),\\n            mapper=lambda x: x\\n        )\\n\\n    Args:\\n        subject_factory: Factory function to create an intermediate\\n            subject through which the source sequence\\'s elements will be\\n            multicast to the mapper function.\\n        subject: Subject to push source elements into.\\n        mapper: [Optional] Mapper function which can use the\\n            multicasted source sequence subject to the policies enforced\\n            by the created subject. Specified only if subject_factory\"\\n            is a factory function.\\n\\n    Returns:\\n        An observable sequence that contains the elements of a sequence\\n        produced by multicasting the source sequence within a mapper\\n        function.\\n    '\n\n    def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n        if subject_factory:\n\n            def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n                assert subject_factory\n                connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n                assert mapper\n                subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n                return CompositeDisposable(subscription, connectable.connect(scheduler))\n            return Observable(subscribe)\n        if not subject:\n            raise ValueError('multicast: Subject cannot be None')\n        ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n        return ret\n    return multicast",
            "def multicast_(subject: Optional[abc.SubjectBase[_TSource]]=None, *, subject_factory: Optional[Callable[[Optional[abc.SchedulerBase]], abc.SubjectBase[_TSource]]]=None, mapper: Optional[Callable[[Observable[_TSource]], Observable[_TResult]]]=None) -> Callable[[Observable[_TSource]], Union[Observable[_TResult], ConnectableObservable[_TSource]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Multicasts the source sequence notifications through an\\n    instantiated subject into all uses of the sequence within a mapper\\n    function. Each subscription to the resulting sequence causes a\\n    separate multicast invocation, exposing the sequence resulting from\\n    the mapper function\\'s invocation. For specializations with fixed\\n    subject types, see Publish, PublishLast, and Replay.\\n\\n    Examples:\\n        >>> res = multicast(observable)\\n        >>> res = multicast(\\n            subject_factory=lambda scheduler: Subject(),\\n            mapper=lambda x: x\\n        )\\n\\n    Args:\\n        subject_factory: Factory function to create an intermediate\\n            subject through which the source sequence\\'s elements will be\\n            multicast to the mapper function.\\n        subject: Subject to push source elements into.\\n        mapper: [Optional] Mapper function which can use the\\n            multicasted source sequence subject to the policies enforced\\n            by the created subject. Specified only if subject_factory\"\\n            is a factory function.\\n\\n    Returns:\\n        An observable sequence that contains the elements of a sequence\\n        produced by multicasting the source sequence within a mapper\\n        function.\\n    '\n\n    def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n        if subject_factory:\n\n            def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n                assert subject_factory\n                connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n                assert mapper\n                subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n                return CompositeDisposable(subscription, connectable.connect(scheduler))\n            return Observable(subscribe)\n        if not subject:\n            raise ValueError('multicast: Subject cannot be None')\n        ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n        return ret\n    return multicast",
            "def multicast_(subject: Optional[abc.SubjectBase[_TSource]]=None, *, subject_factory: Optional[Callable[[Optional[abc.SchedulerBase]], abc.SubjectBase[_TSource]]]=None, mapper: Optional[Callable[[Observable[_TSource]], Observable[_TResult]]]=None) -> Callable[[Observable[_TSource]], Union[Observable[_TResult], ConnectableObservable[_TSource]]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Multicasts the source sequence notifications through an\\n    instantiated subject into all uses of the sequence within a mapper\\n    function. Each subscription to the resulting sequence causes a\\n    separate multicast invocation, exposing the sequence resulting from\\n    the mapper function\\'s invocation. For specializations with fixed\\n    subject types, see Publish, PublishLast, and Replay.\\n\\n    Examples:\\n        >>> res = multicast(observable)\\n        >>> res = multicast(\\n            subject_factory=lambda scheduler: Subject(),\\n            mapper=lambda x: x\\n        )\\n\\n    Args:\\n        subject_factory: Factory function to create an intermediate\\n            subject through which the source sequence\\'s elements will be\\n            multicast to the mapper function.\\n        subject: Subject to push source elements into.\\n        mapper: [Optional] Mapper function which can use the\\n            multicasted source sequence subject to the policies enforced\\n            by the created subject. Specified only if subject_factory\"\\n            is a factory function.\\n\\n    Returns:\\n        An observable sequence that contains the elements of a sequence\\n        produced by multicasting the source sequence within a mapper\\n        function.\\n    '\n\n    def multicast(source: Observable[_TSource]) -> Union[Observable[_TResult], ConnectableObservable[_TSource]]:\n        if subject_factory:\n\n            def subscribe(observer: abc.ObserverBase[_TResult], scheduler: Optional[abc.SchedulerBase]=None) -> abc.DisposableBase:\n                assert subject_factory\n                connectable = source.pipe(ops.multicast(subject=subject_factory(scheduler)))\n                assert mapper\n                subscription = mapper(connectable).subscribe(observer, scheduler=scheduler)\n                return CompositeDisposable(subscription, connectable.connect(scheduler))\n            return Observable(subscribe)\n        if not subject:\n            raise ValueError('multicast: Subject cannot be None')\n        ret: ConnectableObservable[_TSource] = ConnectableObservable(source, subject)\n        return ret\n    return multicast"
        ]
    }
]