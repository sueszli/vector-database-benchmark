from typing import Union, Optional, Tuple, Literal, List, Dict, Sequence
from ivy.data_classes.container.base import ContainerBase
import ivy
inf = float('inf')

class _ContainerWithLinearAlgebra(ContainerBase):

    @staticmethod
    def _static_matmul(x1: Union[ivy.Array, ivy.NativeArray, ivy.Container], x2: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, transpose_a: Union[bool, ivy.Container]=False, transpose_b: Union[bool, ivy.Container]=False, adjoint_a: Union[bool, ivy.Container]=False, adjoint_b: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        '\n        ivy.Container static method variant of ivy.matmul. This method simply wraps the\n        function, and so the docstring for ivy.matul also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        x1\n            first input array\n        x2\n            second input array\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to. It must have a shape\n            that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            the matrix multiplication result of x1 and x2\n\n        Examples\n        --------\n        >>> x = ivy.Container(a = ivy.array([[3., -1.], [-1., 3.]]) ,\n        ...                   b = ivy.array([[2., 1.], [1., 1.]]))\n        >>> y = ivy.Container.static_matmul(x, x)\n        >>> print(y)\n        {\n            a: ivy.array([[10., -6.],\n                          [-6., 10.]]),\n            b: ivy.array([[5., 3.],\n                          [3., 2.]])\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('matmul', x1, x2, transpose_a=transpose_a, transpose_b=transpose_b, adjoint_a=adjoint_a, adjoint_b=adjoint_b, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def matmul(self: ivy.Container, x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], /, *, transpose_a: Union[bool, ivy.Container]=False, transpose_b: Union[bool, ivy.Container]=False, adjoint_a: Union[bool, ivy.Container]=False, adjoint_b: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        '\n        ivy.Container instance method variant of ivy.matmul. This method simply wraps\n        the function, and so the docstring for ivy.matmul also applies to this method\n        with minimal changes.\n\n        Parameters\n        ----------\n        self\n            first input array\n        x2\n            second input array\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to. It must have a shape\n            that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            the matrix multiplication result of self and x2\n\n        Examples\n        --------\n        >>> x = ivy.Container(a = ivy.array([[3., -1.], [-1., 3.]]) ,\n        ...                   b = ivy.array([[2., 1.], [1., 1.]]))\n        >>> y = x.matmul(x)\n        >>> print(y)\n        {\n            a: ivy.array([[10., -6.],\n                          [-6., 10.]]),\n            b: ivy.array([[5., 3.],\n                          [3., 2.]])\n        }\n        '
        return self._static_matmul(self, x2, transpose_a=transpose_a, transpose_b=transpose_b, adjoint_a=adjoint_a, adjoint_b=adjoint_b, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_cholesky(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, upper: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        "\n        ivy.Container static method variant of ivy.cholesky. This method simply wraps\n        the function, and so the docstring for ivy.cholesky also applies to this method\n        with minimal changes.\n\n        Parameters\n        ----------\n        x\n            input array or container having shape (..., M, M) and whose innermost two\n            dimensions form square symmetric positive-definite matrices. Should have a\n            floating-point data type.\n        upper\n            If True, the result must be the upper-triangular Cholesky factor U. If\n            False, the result must be the lower-triangular Cholesky factor L.\n            Default: ``False``.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to. It must have a shape\n            that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a container containing the Cholesky factors for each square matrix. If upper\n            is False, the returned container must contain lower-triangular matrices;\n            otherwise, the returned container must contain upper-triangular matrices.\n            The returned container must have a floating-point data type determined by\n            Type Promotion Rules and must have the same shape as self.\n\n        Examples\n        --------\n        With one :class:`ivy.Container` input:\n        >>> x = ivy.Container(a=ivy.array([[3., -1.], [-1., 3.]]),\n        ...                      b=ivy.array([[2., 1.], [1., 1.]]))\n        >>> y = ivy.Container.static_cholesky(x, upper='false')\n        >>> print(y)\n        {\n            a: ivy.array([[1.73, -0.577],\n                            [0., 1.63]]),\n            b: ivy.array([[1.41, 0.707],\n                            [0., 0.707]])\n         }\n        With multiple :class:`ivy.Container` inputs:\n        >>> x = ivy.Container(a=ivy.array([[3., -1], [-1., 3.]]),\n        ...                      b=ivy.array([[2., 1.], [1., 1.]]))\n        >>> upper = ivy.Container(a=1, b=-1)\n        >>> y = ivy.Container.static_roll(x, upper=False)\n        >>> print(y)\n        {\n            a: ivy.array([[3., 3.],\n                         [-1., -1.]]),\n            b: ivy.array([[1., 1.],\n                          [1., 2.]])\n        }\n        "
        return ContainerBase.cont_multi_map_in_function('cholesky', x, upper=upper, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def cholesky(self: ivy.Container, /, *, upper: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        "\n        ivy.Container instance method variant of ivy.cholesky. This method simply wraps\n        the function, and so the docstring for ivy.cholesky also applies to this method\n        with minimal changes.\n\n        Parameters\n        ----------\n        self\n            input container having shape (..., M, M) and whose innermost two dimensions\n            form square symmetric positive-definite matrices. Should have a\n            floating-point data type.\n        upper\n            If True, the result must be the upper-triangular Cholesky factor U. If\n            False, the result must be the lower-triangular Cholesky factor L.\n            Default: ``False``.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to. It must have a shape\n            that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a container containing the Cholesky factors for each square matrix. If upper\n            is False, the returned container must contain lower-triangular matrices;\n            otherwise, the returned container must contain upper-triangular matrices.\n            The returned container must have a floating-point data type determined by\n            Type Promotion Rules and must have the same shape as self.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a=ivy.array([[3., -1],[-1., 3.]]),\n        ...                      b=ivy.array([[2., 1.],[1., 1.]]))\n        >>> y = x.cholesky(upper='false')\n        >>> print(y)\n        {\n            a: ivy.array([[1.73, -0.577],\n                            [0., 1.63]]),\n            b: ivy.array([[1.41, 0.707],\n                            [0., 0.707]])\n        }\n        "
        return self._static_cholesky(self, upper=upper, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_cross(x1: Union[ivy.Array, ivy.NativeArray, ivy.Container], x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], /, *, axis: Union[int, ivy.Container]=-1, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        '\n        ivy.Container static method variant of ivy.cross. This method simply wraps the\n        function, and so the docstring for ivy.cross also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        x1\n            first input array. Should have a numeric data type.\n        x2\n            second input array. Must be compatible with ``self``\n            (see :ref:`broadcasting`). Should have a numeric data type.\n        axis\n            the axis (dimension) of x1 and x2 containing the vectors for which to\n            compute the cross product.vIf set to -1, the function computes the\n            cross product for vectors defined by the last axis (dimension).\n            Default: ``-1``.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to. It must have a shape\n            that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            an array containing the element-wise products. The returned array must have\n            a data type determined by :ref:`type-promotion`.\n\n        Examples\n        --------\n        With one :class:`ivy.Container` input:\n\n        >>> x = ivy.array([9., 0., 3.])\n        >>> y = ivy.Container(a=ivy.array([1., 1., 0.]), b=ivy.array([1., 0., 1.]))\n        >>> z = ivy.Container.static_cross(x, y)\n        >>> print(z)\n        {\n            a: ivy.array([-3., 3., 9.]),\n            b: ivy.array([0., -6., 0.])\n        }\n\n        With multiple :class:`ivy.Container` inputs:\n\n        >>> x = x = ivy.Container(a=ivy.array([5., 0., 0.]), b=ivy.array([0., 0., 2.]))\n        >>> y = ivy.Container(a=ivy.array([0., 7., 0.]), b=ivy.array([3., 0., 0.]))\n        >>> z = ivy.Container.static_cross(x, y)\n        >>> print(z)\n        {\n            a: ivy.array([0., 0., 35.]),\n            b: ivy.array([0., 6., 0.])\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('cross', x1, x2, axis=axis, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def cross(self: ivy.Container, x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], /, *, axis: Union[int, ivy.Container]=-1, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        '\n        ivy.Container instance method variant of ivy.cross. This method simply wraps the\n        function, and so the docstring for ivy.cross also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        self\n            first input array. Should have a numeric data type.\n        x2\n            second input array. Must be compatible with ``self``\n            (see :ref:`broadcasting`). Should have a numeric data type.\n        axis\n            the axis (dimension) of x1 and x2 containing the vectors for which to\n            compute (default: -1) the cross product.vIf set to -1, the function\n            computes the cross product for vectors defined by the last axis (dimension).\n            Default: ``-1``.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to. It must have a shape\n            that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            an array containing the element-wise products. The returned array must have\n            a data type determined by :ref:`type-promotion`.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a=ivy.array([5., 0., 0.]), b=ivy.array([0., 0., 2.]))\n        >>> y = ivy.Container(a=ivy.array([0., 7., 0.]), b=ivy.array([3., 0., 0.]))\n        >>> z = x.cross(y)\n        >>> print(z)\n        {\n            a: ivy.array([0., 0., 35.]),\n            b: ivy.array([0., 6., 0.])\n        }\n        '
        return self._static_cross(self, x2, axis=axis, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_det(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            print('Hello World!')
        return ContainerBase.cont_multi_map_in_function('det', x, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def det(self: ivy.Container, /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            i = 10
            return i + 15
        '\n        Examples\n        --------\n        >>> x = ivy.Container(a = ivy.array([[3., -1.], [-1., 3.]]) ,\n        ...                   b = ivy.array([[2., 1.], [1., 1.]]))\n        >>> y = x.det()\n        >>> print(y)\n        {a:ivy.array(8.),b:ivy.array(1.)}\n        '
        return self._static_det(self, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_diagonal(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, offset: Union[int, ivy.Container]=0, axis1: Union[int, ivy.Container]=-2, axis2: Union[int, ivy.Container]=-1, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            i = 10
            return i + 15
        '\n        ivy.Container static method variant of ivy.diagonal. This method simply wraps\n        the function, and so the docstring for ivy.diagonal also applies to this method\n        with minimal changes.\n\n        Parameters\n        ----------\n        x\n            input Container with leave arrays having shape\n             ``(..., M, N)`` and whose innermost two dimensions form\n            ``MxN`` matrices.\n        offset\n            offset specifying the off-diagonal relative to the main diagonal.\n            - ``offset = 0``: the main diagonal.\n            - ``offset > 0``: off-diagonal above the main diagonal.\n            - ``offset < 0``: off-diagonal below the main diagonal.\n            Default: `0`.\n        axis1\n            axis to be used as the first axis of the 2-D sub-arrays from\n            which the diagonals should be taken. Defaults to first axis (-2).\n        axis2\n            axis to be used as the second axis of the 2-D sub-arrays from which the\n            diagonals should be taken. Defaults to second axis (-1).\n        out\n            optional output array, for writing the result to. It must\n            have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            A container with the diagonals. More details can be found in\n            the docstring for ivy.diagonal.\n\n        Examples\n        --------\n        With :class:`ivy.Container` inputs:\n\n        >>> x = ivy.Container(a=ivy.array([[1., 2.], [3., 4.]],\n        ...                   b=ivy.array([[5., 6.], [7., 8.]])))\n        >>> d = ivy.Container.static_diagonal(x)\n        >>> print(d)\n        {\n            a:ivy.array([1., 4.]),\n            b:ivy.array([5., 8.])\n        }\n\n        >>> a = ivy.array([[0, 1, 2],\n        ...                [3, 4, 5],\n        ...                [6, 7, 8]])\n        >>> b = ivy.array([[-1., -2., -3.],\n        ...                 [-3., 4., 5.],\n        ...                 [5., 6., 7.]])],\n        >>> x = ivy.Container(a=a, b=b)\n        >>> d = ivy.Container.static_diagonal(offset=-1, axis1=0)\n        >>> print(d)\n        {\n            a:ivy.array([3., 7.]),\n            b:ivy.array([-3., 6.])\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('diagonal', x, offset=offset, axis1=axis1, axis2=axis2, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def diagonal(self: ivy.Container, /, *, offset: Union[int, ivy.Container]=0, axis1: Union[int, ivy.Container]=-2, axis2: Union[int, ivy.Container]=-1, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        '\n        ivy.Container instance method variant of ivy.diagonal. This method simply wraps\n        the function, and so the docstring for ivy.diagonal also applies to this method\n        with minimal changes.\n\n        Parameters\n        ----------\n        self\n            input Container with leave arrays having shape\n             ``(..., M, N)`` and whose innermost two dimensions form\n            ``MxN`` matrices.\n        offset\n            offset specifying the off-diagonal relative to the main diagonal.\n            - ``offset = 0``: the main diagonal.\n            - ``offset > 0``: off-diagonal above the main diagonal.\n            - ``offset < 0``: off-diagonal below the main diagonal.\n            Default: `0`.\n        axis1\n            axis to be used as the first axis of the 2-D sub-arrays from\n            which the diagonals should be taken. Defaults to first axis (-2).\n        axis2\n            axis to be used as the second axis of the 2-D sub-arrays from which the\n            diagonals should be taken. Defaults to second axis (-1).\n        out\n            optional output array, for writing the result to. It must\n            have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            A container with the diagonals. More details can be found in\n            the docstring for ivy.diagonal.\n\n        Examples\n        --------\n        With :class:`ivy.Container` inputs:\n\n        >>> x = ivy.Container(a=ivy.array([[1., 2.], [3., 4.]]),\n        ...                   b=ivy.array([[5., 6.], [7., 8.]]))\n        >>> d = x.diagonal()\n        >>> print(d)\n        {\n            a:ivy.array([1., 4.]),\n            b:ivy.array([5., 8.])\n        }\n\n        >>> a = ivy.array([[0, 1, 2],\n        ...                [3, 4, 5],\n        ...                [6, 7, 8]])\n        >>> b = ivy.array([[-1., -2., -3.],\n        ...                 [-3., 4., 5.],\n        ...                 [5., 6., 7.]]),\n        >>> x = ivy.Container(a=a, b=b)\n        >>> d = x.diagonal(offset=-1)\n        >>> print(d)\n        {\n            a: ivy.array([3, 7]),\n            b: ivy.array([[-3., 6.]])\n        }\n        '
        return self._static_diagonal(self, offset=offset, axis1=axis1, axis2=axis2, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_diag(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, k: Union[int, ivy.Container]=0, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        return ContainerBase.cont_multi_map_in_function('diag', x, k=k, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def diag(self: ivy.Container, /, *, k: Union[int, ivy.Container]=0, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            print('Hello World!')
        '\n        ivy.Container instance method variant of ivy.diag. This method simply wraps the\n        function, and so the docstring for ivy.diag also applies to this method with\n        minimal changes.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a=[[0, 1, 2],\n        >>>                      [3, 4, 5],\n        >>>                      [6, 7, 8]])\n        >>> ivy.diag(x, k=1)\n        {\n            a: ivy.array([1, 5])\n        }\n        '
        return self._static_diag(self, k=k, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_eigh(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, UPLO: Union[str, ivy.Container]='L', key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        return ContainerBase.cont_multi_map_in_function('eigh', x, UPLO=UPLO, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def eigh(self: ivy.Container, /, *, UPLO: Union[str, ivy.Container]='L', key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        "\n        ivy.Container instance method variant of ivy.eigh. This method simply wraps the\n        function, and so the docstring for ivy.eigh also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        self : ivy.Container\n            Ivy container having shape `(..., M, M)` and whose\n            innermost two dimensions form square matrices.\n            Should have a floating-point data type.\n        UPLO : str, optional\n            Specifies whether the upper or lower triangular part of the\n            Hermitian matrix should be\n            used for the eigenvalue decomposition. Default is 'L'.\n        key_chains : Union[List[str], Dict[str, str]], optional\n            The key-chains to apply or not apply the method to. Default is `None`.\n        to_apply : bool, optional\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is `True`.\n        prune_unapplied : bool, optional\n            Whether to prune key_chains for which the function was not applied.\n            Default is `False`.\n        map_sequences : bool, optional\n            Whether to also map method to sequences (lists, tuples).\n            Default is `False`.\n        out : ivy.Container, optional\n            Optional output container, for writing the result to.\n            It must have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ivy.Container\n            A container containing the computed eigenvalues.\n            The returned array must have shape `(..., M)` and have the same\n            data type as `self`.\n\n        Examples\n        --------\n        With `ivy.Container` inputs:\n\n        >>> x = ivy.Container(a=ivy.array([[[1.,2.],[2.,1.]]]),\n        ...                   b=ivy.array([[[2.,4.],[4.,2.]]]))\n        >>> y = x.eigh()\n        >>> print(y)\n        {\n            a: ivy.array([[-1., 3.]]),\n            b: ivy.array([[-2., 6.]])\n        }\n        "
        return self._static_eigh(self, UPLO=UPLO, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_eigvalsh(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, UPLO: Union[str, ivy.Container]='L', key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            i = 10
            return i + 15
        '\n        ivy.Container static method variant of ivy.eigvalsh. This method simply wraps\n        the function, and so the docstring for ivy.eigvalsh also applies to this method\n        with minimal changes.\n\n        Parameters\n        ----------\n        x\n            Ivy container having shape ``(..., M, M)`` and whose\n            innermost two dimensions form square matrices.\n            Should have a floating-point data type.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to.\n            It must have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a container containing the computed eigenvalues.\n            The returned array must have shape\n            (..., M) and have the same data type as x.\n\n        Examples\n        --------\n        With :class:`ivy.Container` inputs:\n\n        >>> x = ivy.Container(a=ivy.array([[[1.,2.,3.],[2.,4.,5.],[3.,5.,6.]]]),\n        ...                   b=ivy.array([[[1.,1.,2.],[1.,2.,1.],[2.,1.,1.]]]),\n        ...                   c=ivy.array([[[2.,2.,2.],[2.,3.,3.],[2.,3.,3.]]]))\n        >>> e = ivy.Container.static_eigvalsh(x)\n        >>> print(e)\n        {\n            a: ivy.array([[-0.51572949, 0.17091519, 11.3448143]]),\n            b: ivy.array([[-1., 1., 4.]]),\n            c: ivy.array([[-8.88178420e-16, 5.35898387e-01, 7.46410179e+00]])\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('eigvalsh', x, UPLO=UPLO, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def eigvalsh(self: ivy.Container, /, *, UPLO: Union[str, ivy.Container]='L', key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        '\n        ivy.Container instance method variant of ivy.eigvalsh. This method simply wraps\n        the function, and so the docstring for ivy.eigvalsh also applies to this method\n        with minimal changes.\n\n        Parameters\n        ----------\n        self\n            Ivy container having shape ``(..., M, M)`` and whose\n            innermost two dimensions form square matrices.\n            Should have a floating-point data type.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to.\n            It must have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a container containing the computed eigenvalues.\n            The returned array must have shape\n            (..., M) and have the same data type as x.\n\n        Examples\n        --------\n        With :class:`ivy.Container` inputs:\n\n        >>> x = ivy.Container(a=ivy.array([[[1.,2.],[2.,1.]]]),\n        ...                   b=ivy.array([[[2.,4.],[4.,2.]]]))\n        >>> y = ivy.eigvalsh(x)\n        >>> print(y)\n        {\n            a: ivy.array([[-1., 3.]]),\n            b: ivy.array([[-2., 6.]])\n        }\n        '
        return self._static_eigvalsh(self, UPLO=UPLO, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_inner(x1: Union[ivy.Array, ivy.NativeArray, ivy.Container], x2: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            print('Hello World!')
        '\n        ivy.Container static method variant of ivy.inner. This method simply wraps the\n        function, and so the docstring for ivy.inner also applies to this method with\n        minimal changes.\n\n        Return the inner product of two vectors ``x1`` and ``x2``.\n\n        Parameters\n        ----------\n        x1\n            first one-dimensional input array of size N.\n            Should have a numeric data type.\n            a(N,) array_like\n            First input vector. Input is flattened if not already 1-dimensional.\n        x2\n            second one-dimensional input array of size M.\n            Should have a numeric data type.\n            b(M,) array_like\n            Second input vector. Input is flattened if not already 1-dimensional.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains,\n            otherwise key_chains will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output array, for writing the result to.\n            It must have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a two-dimensional array containing the inner product and whose\n            shape is (N, M).\n            The returned array must have a data type determined by Type Promotion Rules.\n\n        Examples\n        --------\n        >>> x1 = ivy.Container(a=ivy.array([[1, 2], [3, 4]]))\n        >>> x2 = ivy.Container(a=ivy.array([5, 6]))\n        >>> y = ivy.Container.static_inner(x1, x2)\n        >>> print(y)\n        {\n            a: ivy.array([17, 39])\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('inner', x1, x2, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def inner(self: ivy.Container, x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        '\n        ivy.Container instance method variant of ivy.inner. This method simply wraps the\n        function, and so the docstring for ivy.inner also applies to this method with\n        minimal changes.\n\n        Return the inner product of two vectors ``self`` and ``x2``.\n\n        Parameters\n        ----------\n        self\n            input container of size N. Should have a numeric data type.\n            a(N,) array_like\n            First input vector. Input is flattened if not already 1-dimensional.\n        x2\n            one-dimensional input array of size M. Should have a numeric data type.\n            b(M,) array_like\n            Second input vector. Input is flattened if not already 1-dimensional.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains,\n            otherwise key_chains will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output array, for writing the result to.\n            It must have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a new container representing the inner product and whose\n            shape is (N, M).\n            The returned array must have a data type determined by Type Promotion Rules.\n\n        Examples\n        --------\n        >>> x1 = ivy.Container(a=ivy.array([[1, 2], [3, 4]]))\n        >>> x2 = ivy.Container(a=ivy.array([5, 6]))\n        >>> y = ivy.Container.inner(x1, x2)\n        >>> print(y)\n        {\n            a: ivy.array([17, 39])\n        }\n        '
        return self._static_inner(self, x2, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_inv(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, adjoint: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        '\n        ivy.Container static method variant of ivy.inv. This method simply wraps the\n        function, and so the docstring for ivy.inv also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        x\n            Ivy container having shape ``(..., M, M)`` and whose\n            innermost two dimensions form square matrices.\n            Should have a floating-point data type.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to.\n            It must have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            A container containing the multiplicative inverses.\n            The returned array must have a floating-point data type\n            determined by :ref:`type-promotion` and must have the\n            same shape as ``x``.\n\n        Examples\n        --------\n        With :class:`ivy.Container` input:\n\n        >>> x = ivy.Container(a=ivy.array([[0., 1.], [4., 4.]]),\n        ...                      b=ivy.array([[4., 4.], [2., 1.]]))\n        >>> y = ivy.Container.static_inv(x)\n        >>> print(y)\n        {\n            a: ivy.array([[-1, 0.25], [1., 0.]]),\n            b: ivy.array([-0.25, 1.], [0.5, -1.])\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('inv', x, adjoint=adjoint, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def inv(self: ivy.Container, /, *, adjoint: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        '\n        ivy.Container instance method variant of ivy.inv. This method simply wraps the\n        function, and so the docstring for ivy.inv also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        self\n            Ivy container having shape ``(..., M, M)`` and whose\n            innermost two dimensions form square matrices.\n            Should have a floating-point data type.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to.\n            It must have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            A container containing the multiplicative inverses.\n            The returned array must have a floating-point data type\n            determined by :ref:`type-promotion` and must have the\n            same shape as ``x``.\n\n        Examples\n        --------\n        With :class:`ivy.Container` input:\n\n        >>> x = ivy.Container(a=ivy.array([[0., 1.], [4., 4.]]),\n        ...                      b=ivy.array([[4., 4.], [2., 1.]]))\n        >>> y = x.inv()\n        >>> print(y)\n        {\n            a: ivy.array([[-1, 0.25], [1., 0.]]),\n            b: ivy.array([-0.25, 1.], [0.5, -1.])\n        }\n        '
        return self._static_inv(self, adjoint=adjoint, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_pinv(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, rtol: Optional[Union[float, Tuple[float], ivy.Container]]=None, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            print('Hello World!')
        '\n        ivy.Container special method variant of ivy.pinv. This method simply wraps the\n        function, and so the docstring for ivy.pinv also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        x\n            input array having shape ``(..., M, N)`` and whose innermost two\n            dimensions form``MxN`` matrices. Should have a floating-point\n            data type.\n        rtol\n            relative tolerance for small singular values approximately less\n            than or equal to ``rtol * largest_singular_value`` are set to zero.\n        out\n            optional output array, for writing the result to.\n            It must have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            an array containing the pseudo-inverses. The returned array must have a\n            floating-point data type determined by :ref:`type-promotion` and\n            must have shape ``(..., N, M)`` (i.e., must have the same shape as\n            ``x``, except the innermost two dimensions must be transposed).\n\n        Examples\n        --------\n        >>> x = ivy.Container(a= ivy.array([[1., 2.], [3., 4.]]))\n        >>> y = ivy.Container.static_pinv(x)\n        >>> print(y)\n        {\n            a: ivy.array([[-2., 1.],\n                          [1.5, -0.5]])\n        }\n\n        >>> x = ivy.Container(a=ivy.array([[1., 2.], [3., 4.]]))\n        >>> out = ivy.Container(a=ivy.zeros((2, 2)))\n        >>> ivy.Container.static_pinv(x, rtol=1e-1, out=out)\n        >>> print(out)\n        {\n            a: ivy.array([[0.0426, 0.0964],\n                          [0.0605, 0.1368]])\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('pinv', x, rtol=rtol, out=out)

    def pinv(self: ivy.Container, /, *, rtol: Optional[Union[float, Tuple[float], ivy.Container]]=None, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            print('Hello World!')
        '\n        ivy.Container instance method variant of ivy.pinv. This method simply wraps the\n        function, and so the docstring for ivy.pinv also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        x\n            input array having shape ``(..., M, N)`` and whose innermost\n            two dimensions form``MxN`` matrices. Should have a floating-point\n            data type.\n        rtol\n            relative tolerance for small singular values approximately less\n            than or equal to ``rtol * largest_singular_value`` are set to zero.\n        out\n            optional output array, for writing the result to.\n            It must have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            an array containing the pseudo-inverses. The returned array must have a\n            floating-point data type determined by :ref:`type-promotion` and\n            must have shape ``(..., N, M)`` (i.e., must have the same shape as\n            ``x``, except the innermost two dimensions must be transposed).\n\n\n        Examples\n        --------\n        >>> x = ivy.Container(a= ivy.array([[1., 2.], [3., 4.]]))\n        >>> y = x.pinv()\n        >>> print(y)\n        {\n            a: ivy.array([[-1.99999988, 1.],\n                          [1.5, -0.5]])\n        }\n\n        >>> x = ivy.Container(a = ivy.array([[1., 2.], [3., 4.]]))\n        >>> out = ivy.Container(a = ivy.zeros(x["a"].shape))\n        >>> x.pinv(out=out)\n        >>> print(out)\n        {\n            a: ivy.array([[-1.99999988, 1.],\n                          [1.5, -0.5]])\n        }\n        '
        return self._static_pinv(self, rtol=rtol, out=out)

    @staticmethod
    def _static_matrix_norm(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, ord: Union[int, float, Literal[inf, -inf, 'fro', 'nuc'], ivy.Container]='fro', axis: Tuple[int, int, ivy.Container]=(-2, -1), keepdims: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        '\n        ivy.Container static method variant of ivy.matrix_norm. This method simply wraps\n        the function, and so the docstring for ivy.matrix_norm also applies to this\n        method with minimal changes.\n\n        Parameters\n        ----------\n        x\n            Input array having shape (..., M, N) and whose innermost two deimensions\n            form MxN matrices. Should have a floating-point data type.\n        ord\n            Order of the norm. Default is "fro".\n        axis\n            specifies the axes that hold 2-D matrices. Default: (-2, -1).\n        keepdims\n            If this is set to True, the axes which are normed over are left in the\n            result as dimensions with size one. With this option the result will\n            broadcast correctly against the original x. Default is ``False``.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output array, for writing the result to.\n            It must have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            Matrix norm of the array at specified axes.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a=ivy.array([[1.1, 2.2], [1., 2.]]),                               b=ivy.array([[1., 2.], [3., 4.]]))\n        >>> y = ivy.Container.static_matrix_norm(x, ord=1)\n        >>> print(y)\n        {\n            a: ivy.array(4.2),\n            b: ivy.array(6.)\n        }\n\n        >>> x = ivy.Container(a=ivy.arange(12, dtype=float).reshape((3, 2, 2)),                               b=ivy.arange(8, dtype=float).reshape((2, 2, 2)))\n        >>> ord = ivy.Container(a=1, b=float(\'inf\'))\n        >>> axis = ivy.Container(a=(1, 2), b=(2, 1))\n        >>> k = ivy.Container(a=False, b=True)\n        >>> y = ivy.Container.static_matrix_norm(x, ord=ord, axis=axis, keepdims=k)\n        >>> print(y)\n        {\n            a: ivy.array([4.24, 11.4, 19.2]),\n            b: ivy.array([[[3.7]],\n                          [[11.2]]])\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('matrix_norm', x, ord=ord, axis=axis, keepdims=keepdims, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def matrix_norm(self: ivy.Container, /, *, ord: Union[int, float, Literal[inf, -inf, 'fro', 'nuc'], ivy.Container]='fro', axis: Tuple[int, int, ivy.Container]=(-2, -1), keepdims: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        '\n        ivy.Container instance method variant of ivy.matrix_norm. This method simply\n        wraps the function, and so the docstring for ivy.matrix_norm also applies to\n        this method with minimal changes.\n\n        Parameters\n        ----------\n        self\n            Container having shape (..., M, N) and whose innermost two dimensions\n            form MxN matrices. Should have a floating-point data type.\n        ord\n            Order of the norm. Default is "fro".\n        axis\n            specifies the axes that hold 2-D matrices. Default: (-2, -1).\n        keepdims\n            If this is set to True, the axes which are normed over are left in the\n            result as dimensions with size one. With this option the result will\n            broadcast correctly against the original x. Default is ``False``.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output array, for writing the result to. It must have a shape that\n            the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            Matrix norm of the array at specified axes.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a=ivy.array([[1.1, 2.2], [1., 2.]]),                               b=ivy.array([[1., 2.], [3., 4.]]))\n        >>> y = x.matrix_norm(ord=1)\n        >>> print(y)\n        {\n            a: ivy.array(4.2),\n            b: ivy.array(6.)\n        }\n\n        >>> x = ivy.Container(a=ivy.arange(12, dtype=float).reshape((3, 2, 2)),                               b=ivy.arange(8, dtype=float).reshape((2, 2, 2)))\n        >>> ord = ivy.Container(a="nuc", b=ivy.inf)\n        >>> axis = ivy.Container(a=(1, 2), b=(2, 1))\n        >>> k = ivy.Container(a=True, b=False)\n        >>> y = x.matrix_norm(ord=ord, axis=axis, keepdims=k)\n        >>> print(y)\n        {\n            a: ivy.array([[[4.24]],\n                         [[11.4]],\n                         [[19.2]]]),\n            b: ivy.array([4., 12.])\n        }\n        '
        return self._static_matrix_norm(self, ord=ord, axis=axis, keepdims=keepdims, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_matrix_power(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], n: Union[int, ivy.Container], /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            print('Hello World!')
        return ContainerBase.cont_multi_map_in_function('matrix_power', x, n, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def matrix_power(self: ivy.Container, n: Union[int, ivy.Container], /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        return self._static_matrix_power(self, n, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_matrix_rank(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, atol: Optional[Union[float, Tuple[float], ivy.Container]]=None, rtol: Optional[Union[float, Tuple[float], ivy.Container]]=None, hermitian: Optional[Union[bool, ivy.Container]]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        '\n        ivy.Container static method variant of ivy.matrix_rank. This method returns the\n        rank (i.e., number of non-zero singular values) of a matrix (or a stack of\n        matrices).\n\n        Parameters\n        ----------\n        x\n            input array or container having shape ``(..., M, N)`` and whose innermost\n            two dimensions form ``MxN`` matrices. Should have a floating-point data\n            type.\n\n        atol\n            absolute tolerance. When None it’s considered to be zero.\n\n        rtol\n            relative tolerance for small singular values. Singular values\n            approximately less than or equal to ``rtol * largest_singular_value`` are\n            set to zero. If a ``float``, the value is equivalent to a zero-dimensional\n            array having a floating-point data type determined by :ref:`type-promotion`\n            (as applied to ``x``) and must be broadcast against each matrix. If an\n            ``array``, must have a floating-point data type and must be compatible with\n            ``shape(x)[:-2]`` (see:ref:`broadcasting`). If ``None``, the default value\n            is ``max(M, N) * eps``, where ``eps`` must be the machine epsilon associated\n            with the floating-point data type determined by :ref:`type-promotion`\n            (as applied to ``x``).\n            Default: ``None``.\n\n        hermitian\n            indicates whether ``x`` is Hermitian. When ``hermitian=True``, ``x`` is\n            assumed to be Hermitian, enabling a more efficient method for finding\n            eigenvalues, but x is not checked inside the function. Instead, We just use\n            the lower triangular of the matrix to compute.\n            Default: ``False``.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output array, for writing the result to. It must have a shape that\n            the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a container containing the ranks. The returned array must have a\n            floating-point data type determined by :ref:`type-promotion` and must have\n            shape ``(...)`` (i.e., must have a shape equal to ``shape(x)[:-2]``).\n\n        Examples\n        --------\n        With :class:`ivy.Container` input:\n\n        >>> x = ivy.Container(a=ivy.array([[1., 0.], [0., 1.]]),\n        ...                   b=ivy.array([[1., 0.], [0., 0.]]))\n        >>> y = ivy.Container.static_matrix_rank(x)\n        >>> print(y)\n        {\n            a: ivy.array(2.),\n            b: ivy.array(1.)\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('matrix_rank', x, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, atol=atol, rtol=rtol, hermitian=hermitian, out=out)

    def matrix_rank(self: ivy.Container, /, *, atol: Optional[Union[float, Tuple[float], ivy.Container]]=None, rtol: Optional[Union[float, Tuple[float], ivy.Container]]=None, hermitian: Optional[Union[bool, ivy.Container]]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        '\n        ivy.Container instance method variant of ivy.matrix_rank. This method returns\n        the rank (i.e., number of non-zero singular values) of a matrix (or a stack of\n        matrices).\n\n        Parameters\n        ----------\n        self\n            input container having shape ``(..., M, N)`` and whose innermost two\n            dimensions form ``MxN`` matrices. Should have a floating-point data type.\n\n        atol\n            absolute tolerance. When None it’s considered to be zero.\n\n        rtol\n            relative tolerance for small singular values. Singular values approximately\n            less than or equal to ``rtol * largest_singular_value`` are set to zero. If\n            a ``float``, the value is equivalent to a zero-dimensional array having a\n            floating-point data type determined by :ref:`type-promotion` (as applied to\n            ``x``) and must be broadcast against each matrix. If an ``array``, must have\n            a floating-point data type and must be compatible with ``shape(x)[:-2]``\n            (see :ref:`broadcasting`). If ``None``, the default value is\n            ``max(M, N) * eps``, where ``eps`` must be the machine epsilon associated\n            with the floating-point data type determined by :ref:`type-promotion`\n            (as applied to ``x``). Default: ``None``.\n\n        hermitian\n            indicates whether ``x`` is Hermitian. When ``hermitian=True``, ``x`` is\n            assumed to be Hermitian, enabling a more efficient method for finding\n            eigenvalues, but x is not checked inside the function. Instead, We just use\n            the lower triangular of the matrix to compute.\n            Default: ``False``.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output array, for writing the result to. It must have a shape that\n            the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a container containing the ranks. The returned array must have a\n            floating-point data type determined by :ref:`type-promotion` and must have\n            shape ``(...)`` (i.e., must have a shape equal to ``shape(x)[:-2]``).\n\n        Examples\n        --------\n        With :class:`ivy.Container` input:\n        >>> x = ivy.Container(a=ivy.array([[1., 0.], [0., 1.]]),\n        ...                   b=ivy.array([[1., 0.], [0., 0.]]))\n        >>> y = x.matrix_rank()\n        >>> print(y)\n        {\n            a: ivy.array(2),\n            b: ivy.array(1)\n        }\n        '
        return self._static_matrix_rank(self, atol=atol, rtol=rtol, hermitian=hermitian, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_matrix_transpose(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, conjugate: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            print('Hello World!')
        '\n        Transpose a matrix (or a stack of matrices) ``x``.\n\n        Parameters\n        ----------\n        x\n            input Container which will have arrays with shape ``(..., M, N)``\n            and whose innermost two dimensions form ``MxN`` matrices.\n        out\n            optional output array, for writing the result to. It must have a\n            shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            A container with the transposes for each matrix and having shape\n            ``(..., N, M)``. The returned array must have the same data\n            type as ``x``.\n\n\n        Examples\n        --------\n        With :code:`ivy.Container` instance method:\n\n        >>> x = ivy.Container(a=ivy.array([[1., 1.], [0., 3.]]),                         b=ivy.array([[0., 4.], [3., 1.]]))\n        >>> y = ivy.Container.static_matrix_transpose(x)\n        >>> print(y)\n        {\n            a: ivy.array([[1., 0.],\n                          [1., 3.]]),\n            b: ivy.array([[0., 3.],\n                          [4., 1.]])\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('matrix_transpose', x, conjugate=conjugate, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def matrix_transpose(self: ivy.Container, /, *, conjugate: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        '\n        Transpose a matrix (or a stack of matrices) ``x``.\n\n        Parameters\n        ----------\n        self\n            input Container which will have arrays with shape ``(..., M, N)``\n            and whose innermost two dimensions form ``MxN`` matrices.\n        out\n            optional output array, for writing the result to. It must have a\n            shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            A container with the transposes for each matrix and having shape\n            ``(..., N, M)``. The returned array must have the same data\n            type as ``x``.\n\n        Examples\n        --------\n        With :code:`ivy.Container` instance method:\n\n        >>> x = ivy.Container(a=ivy.array([[1., 1.], [0., 3.]]),                       b=ivy.array([[0., 4.], [3., 1.]]))\n        >>> y = x.matrix_transpose()\n        >>> print(y)\n        {\n            a: ivy.array([[1., 0.],\n                          [1., 3.]]),\n            b: ivy.array([[0., 3.],\n                          [4., 1.]])\n        }\n        '
        return self._static_matrix_transpose(self, conjugate=conjugate, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_outer(x1: Union[ivy.Array, ivy.NativeArray, ivy.Container], x2: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        '\n        ivy.Container static method variant of ivy.outer. This method simply wraps the\n        function, and so the docstring for ivy.outer also applies to this method with\n        minimal changes.\n\n        Computes the outer product of two arrays, x1 and x2,\n        by computing the tensor product along the last dimension of both arrays.\n\n        Parameters\n        ----------\n        x1\n            first input array having shape (..., N1)\n        x2\n            second input array having shape (..., N2)\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains,\n            otherwise key_chains will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output container, for writing the result to.\n            The container must have shape (..., N1, N2). The first x1.ndim-1\n            dimensions must have the same size as those of the input array x1\n            and the first x2.ndim-1 dimensions must have the same\n            size as those of the input array x2.\n\n        Returns\n        -------\n        ret\n            an ivy container whose shape is (..., N1, N2).\n            The first x1.ndim-1 dimensions have the same size as those\n            of the input array x1 and the first x2.ndim-1\n            dimensions have the same size as those of the input array x2.\n\n        Example\n        -------\n        >>> x1 =ivy.Container( a=ivy.array([[1, 2, 3], [4, 5, 6]]))\n        >>> x2 = ivy.Container(a=ivy.array([1, 2, 3]))\n        >>> y = ivy.Container.static_outer(x1, x2)\n        >>> print(y)\n        ivy.array([[[ 1.,  2.,  3.],\n                    [ 2.,  4.,  6.],\n                    [ 3.,  6.,  9.]],\n                   [[ 4.,  8., 12.],\n                    [ 5., 10., 15.],\n                    [ 6., 12., 18.]]])\n        '
        return ContainerBase.cont_multi_map_in_function('outer', x1, x2, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def outer(self: ivy.Container, x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        '\n        Return the outer product of two arrays or containers.\n\n        The instance method implementation of the static method static_outer of the\n        ivy.Container class. It calculates the outer product of two input arrays or\n        containers along the last dimension and returns the resulting container. The\n        input arrays should be either ivy.Container, ivy.Array, or ivy.NativeArray. The\n        output container shape is the concatenation of the shapes of the input\n        containers along the last dimension.\n\n        Parameters\n        ----------\n        self : ivy.Container\n            Input container of shape (...,B) where the last dimension\n            represents B elements.\n        x2 : Union[ivy.Container, ivy.Array, ivy.NativeArray]\n            Second input array or container of shape (..., N)\n            where the last dimension represents N elements.\n        key_chains : Optional[Union[List[str], Dict[str, str]]]\n            The key-chains to apply or not apply the method to. Default is None.\n        to_apply : bool\n            If True, the method will be applied to key_chains,\n            otherwise key_chains will be skipped.Default is True.\n        prune_unapplied : bool\n            Whether to prune key_chains for which the function was not applied.\n            Default is False.\n        map_sequences : bool\n            Whether to also map the method to sequences (lists, tuples).\n            Default is False.\n        out : Optional[ivy.Container]\n            Optional output container to write the result to.\n            If not provided, a new container will be created.\n\n        Returns\n        -------\n        ivy.Container\n            A new container of shape (..., M, N) representing\n            the outer product of the input arrays or containers\n            along the last dimension.\n\n        Examples\n        --------\n        >>> x = ivy.array([[1., 2.],[3., 4.]])\n        >>> y = ivy.array([[5., 6.],[7., 8.]])\n        >>> d = ivy.outer(x,y)\n        >>> print(d)\n        ivy.array([[ 5.,  6.,  7.,  8.],\n                    [10., 12., 14., 16.],\n                    [15., 18., 21., 24.],\n                    [20., 24., 28., 32.]])\n        '
        return self._static_outer(self, x2, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_qr(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, mode: Union[str, ivy.Container]='reduced', key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[Tuple[ivy.Container, ivy.Container]]=None) -> Tuple[ivy.Container, ivy.Container]:
        if False:
            return 10
        "\n        ivy.Container static method variant of ivy.qr. This method simply wraps the\n        function, and so the docstring for ivy.qr also applies to this method with\n        minimal changes.\n\n        Returns the qr decomposition x = QR of a full column rank matrix (or a stack of\n        matrices), where Q is an orthonormal matrix (or a stack of matrices) and R is an\n        upper-triangular matrix (or a stack of matrices).\n\n        Parameters\n        ----------\n        x\n            input container having shape (..., M, N) and whose innermost two dimensions\n            form MxN matrices of rank N. Should have a floating-point data type.\n        mode\n            decomposition mode. Should be one of the following modes:\n            - 'reduced': compute only the leading K columns of q, such that q and r have\n            dimensions (..., M, K) and (..., K, N), respectively, and where\n            K = min(M, N).\n            - 'complete': compute q and r with dimensions (..., M, M) and (..., M, N),\n            respectively.\n            Default: 'reduced'.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output tuple of containers, for writing the result to. The arrays\n            must have shapes that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a namedtuple (Q, R) whose\n            - first element must have the field name Q and must be an container whose\n            shape depends on the value of mode and contain matrices with orthonormal\n            columns. If mode is 'complete', the container must have shape (..., M, M).\n            If mode is 'reduced', the container must have shape (..., M, K), where\n            K = min(M, N). The first x.ndim-2 dimensions must have the same size as\n            those of the input container x.\n            - second element must have the field name R and must be an container whose\n            shape depends on the value of mode and contain upper-triangular matrices. If\n            mode is 'complete', the container must have shape (..., M, N). If mode is\n            'reduced', the container must have shape (..., K, N), where K = min(M, N).\n            The first x.ndim-2 dimensions must have the same size as those of the input\n            x.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a = ivy.native_array([[1., 2.], [3., 4.]]),\n        ...                   b = ivy.array([[2., 3.], [4. ,5.]]))\n        >>> q,r = ivy.Container.static_qr(x, mode='complete')\n        >>> print(q)\n        {\n            a: ivy.array([[-0.31622777, -0.9486833],\n                        [-0.9486833, 0.31622777]]),\n            b: ivy.array([[-0.4472136, -0.89442719],\n                        [-0.89442719, 0.4472136]])\n        }\n        >>> print(r)\n        {\n            a: ivy.array([[-3.16227766, -4.42718872],\n                        [0., -0.63245553]]),\n            b: ivy.array([[-4.47213595, -5.81377674],\n                        [0., -0.4472136]])\n        }\n        "
        return ContainerBase.cont_multi_map_in_function('qr', x, mode=mode, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def qr(self: ivy.Container, /, *, mode: Union[str, ivy.Container]='reduced', key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[Tuple[ivy.Container, ivy.Container]]=None) -> Tuple[ivy.Container, ivy.Container]:
        if False:
            while True:
                i = 10
        "\n        ivy.Container instance method variant of ivy.qr. This method simply wraps the\n        function, and so the docstring for ivy.qr also applies to this method with\n        minimal changes.\n\n        Returns the qr decomposition x = QR of a full column rank matrix (or a stack of\n        matrices), where Q is an orthonormal matrix (or a stack of matrices) and R is an\n        upper-triangular matrix (or a stack of matrices).\n\n        Parameters\n        ----------\n        self\n            input container having shape (..., M, N) and whose innermost two dimensions\n            form MxN matrices of rank N. Should have a floating-point data type.\n        mode\n            decomposition mode. Should be one of the following modes:\n            - 'reduced': compute only the leading K columns of q, such that q and r have\n            dimensions (..., M, K) and (..., K, N), respectively, and where\n            K = min(M, N).\n            - 'complete': compute q and r with dimensions (..., M, M) and (..., M, N),\n            respectively.\n            Default: 'reduced'.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output tuple of containers, for writing the result to. The arrays\n            must have shapes that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a namedtuple (Q, R) whose\n            - first element must have the field name Q and must be an container whose\n            shape depends on the value of mode and contain matrices with orthonormal\n            columns. If mode is 'complete', the container must have shape (..., M, M).\n            If mode is 'reduced', the container must have shape (..., M, K), where\n            K = min(M, N). The first x.ndim-2 dimensions must have the same size as\n            those of the input container x.\n            - second element must have the field name R and must be an container whose\n            shape depends on the value of mode and contain upper-triangular matrices. If\n            mode is 'complete', the container must have shape (..., M, N). If mode is\n            'reduced', the container must have shape (..., K, N), where K = min(M, N).\n            The first x.ndim-2 dimensions must have the same size as those of the input\n            x.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a = ivy.native_array([[1., 2.], [3., 4.]]),\n        ...                   b = ivy.array([[2., 3.], [4. ,5.]]))\n        >>> q,r = x.qr(mode='complete')\n        >>> print(q)\n        {\n            a: ivy.array([[-0.31622777, -0.9486833],\n                        [-0.9486833, 0.31622777]]),\n            b: ivy.array([[-0.4472136, -0.89442719],\n                        [-0.89442719, 0.4472136]])\n        }\n        >>> print(r)\n        {\n            a: ivy.array([[-3.16227766, -4.42718872],\n                        [0., -0.63245553]]),\n            b: ivy.array([[-4.47213595, -5.81377674],\n                        [0., -0.4472136]])\n        }\n        "
        return self._static_qr(self, mode=mode, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_slogdet(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False) -> ivy.Container:
        if False:
            print('Hello World!')
        '\n        ivy.Container static method variant of ivy.slogdet. This method simply wraps the\n        function, and so the docstring for ivy.slogdet also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        x\n            input array or container having shape (..., M, M) and whose innermost two\n            dimensions form square matrices. Should have a floating-point data type.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n\n        Returns\n        -------\n        ret\n            This function returns a container containing NamedTuples.\n            Each NamedTuple of output will have -\n                sign:\n                An array containing a number representing the sign of the determinant\n                for each square matrix.\n\n                logabsdet:\n                An array containing natural log of the absolute determinant of each\n                square matrix.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a=ivy.array([[1.0, 2.0],\n        ...                                [3.0, 4.0]]),\n        ...                   b=ivy.array([[1.0, 2.0],\n        ...                                [2.0, 1.0]]))\n        >>> y = ivy.Container.static_slogdet(x)\n        >>> print(y)\n        {\n            a: [\n                sign = ivy.array(-1.),\n                logabsdet = ivy.array(0.6931472)\n            ],\n            b: [\n                sign = ivy.array(-1.),\n                logabsdet = ivy.array(1.0986123)\n            ]\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('slogdet', x, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences)

    def slogdet(self: ivy.Container, /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False) -> ivy.Container:
        if False:
            while True:
                i = 10
        '\n        ivy.Container instance method variant of ivy.slogdet. This method simply wraps\n        the function, and so the docstring for ivy.slogdet also applies to this method\n        with minimal changes.\n\n        Parameters\n        ----------\n        self\n            input container having shape (..., M, M) and whose innermost two dimensions\n            form square matrices. Should have a floating-point data type.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n\n        Returns\n        -------\n        ret\n            This function returns container containing NamedTuples.\n            Each NamedTuple of output will have -\n                sign:\n                An array of a number representing the sign of the determinant of each\n                square.\n\n                logabsdet:\n                An array of the natural log of the absolute value of the determinant of\n                each square.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a=ivy.array([[1.0, 2.0],\n        ...                                [3.0, 4.0]]),\n        ...                   b=ivy.array([[1.0, 2.0],\n        ...                                [2.0, 1.0]]))\n        >>> y = x.slogdet()\n        >>> print(y)\n        [{\n            a: ivy.array(-1.),\n            b: ivy.array(-1.)\n        }, {\n            a: ivy.array(0.69314718),\n            b: ivy.array(1.09861231)\n        }]\n        '
        return self._static_slogdet(self, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences)

    @staticmethod
    def _static_solve(x1: Union[ivy.Array, ivy.NativeArray, ivy.Container], x2: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, adjoint: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        return ContainerBase.cont_multi_map_in_function('solve', x1, x2, adjoint=adjoint, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def solve(self: ivy.Container, x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], /, *, adjoint: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        return self._static_solve(self, x2, adjoint=adjoint, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_svd(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, compute_uv: Union[bool, ivy.Container]=True, full_matrices: Union[bool, ivy.Container]=True, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> Union[ivy.Container, Tuple[ivy.Container, ...]]:
        if False:
            while True:
                i = 10
        '\n        ivy.Container static method variant of ivy.svd. This method simply wraps the\n        function, and so the docstring for ivy.svd also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        x\n            input container with array leaves having shape ``(..., M, N)`` and whose\n            innermost two dimensions form matrices on which to perform singular value\n            decomposition. Should have a floating-point data type.\n        full_matrices\n            If ``True``, compute full-sized ``U`` and ``Vh``, such that ``U`` has\n            shape ``(..., M, M)`` and ``Vh`` has shape ``(..., N, N)``. If ``False``,\n            compute on             the leading ``K`` singular vectors, such that ``U``\n            has shape ``(..., M, K)`` and ``Vh`` has shape ``(..., K, N)`` and where\n            ``K = min(M, N)``. Default: ``True``.\n        compute_uv\n            If ``True`` then left and right singular vectors will be computed and\n            returned in ``U`` and ``Vh``, respectively. Otherwise, only the singular\n            values will be computed, which can be significantly faster.\n        .. note::\n            with backend set as torch, svd with still compute left and right singular\n            vectors irrespective of the value of compute_uv, however Ivy will\n            still only return the\n            singular values.\n\n        Returns\n        -------\n        .. note::\n            once complex numbers are supported, each square matrix must be Hermitian.\n\n        ret\n            A container of a namedtuples ``(U, S, Vh)``. More details in ivy.svd.\n\n\n        Examples\n        --------\n        With :class:`ivy.Container` input:\n\n        >>> x = ivy.random_normal(shape = (9, 6))\n        >>> y = ivy.random_normal(shape = (2, 4))\n        >>> z = ivy.Container(a=x, b=y)\n        >>> ret = ivy.Container.static_svd(z)\n        >>> aU, aS, aVh = ret.a\n        >>> bU, bS, bVh = ret.b\n        >>> print(aU.shape, aS.shape, aVh.shape, bU.shape, bS.shape, bVh.shape)\n        (9, 9) (6,) (6, 6) (2, 2) (2,) (4, 4)\n        '
        return ContainerBase.cont_multi_map_in_function('svd', x, compute_uv=compute_uv, full_matrices=full_matrices, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def svd(self: ivy.Container, /, *, compute_uv: Union[bool, ivy.Container]=True, full_matrices: Union[bool, ivy.Container]=True, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        '\n        ivy.Container instance method variant of ivy.svd. This method simply wraps the\n        function, and so the docstring for ivy.svd also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        self\n            input container with array leaves having shape ``(..., M, N)`` and whose\n            innermost two dimensions form matrices on which to perform singular value\n            decomposition. Should have a floating-point data type.\n        full_matrices\n            If ``True``, compute full-sized ``U`` and ``Vh``, such that ``U`` has\n            shape ``(..., M, M)`` and ``Vh`` has shape ``(..., N, N)``. If ``False``,\n            compute on             the leading ``K`` singular vectors, such that ``U``\n            has shape ``(..., M, K)`` and ``Vh`` has shape ``(..., K, N)`` and where\n            ``K = min(M, N)``. Default: ``True``.\n        compute_uv\n            If ``True`` then left and right singular vectors will be computed and\n            returned in ``U`` and ``Vh``, respectively. Otherwise, only the singular\n            values will be computed, which can be significantly faster.\n        .. note::\n            with backend set as torch, svd with still compute left and right singular\n            vectors irrespective of the value of compute_uv, however Ivy will\n            still only return the\n            singular values.\n\n        Returns\n        -------\n        .. note::\n            once complex numbers are supported, each square matrix must be Hermitian.\n\n        ret\n            A container of a namedtuples ``(U, S, Vh)``. More details in ivy.svd.\n\n        Examples\n        --------\n        With :class:`ivy.Container` input:\n\n        >>> x = ivy.random_normal(shape = (9, 6))\n        >>> y = ivy.random_normal(shape = (2, 4))\n        >>> z = ivy.Container(a=x, b=y)\n        >>> ret = z.svd()\n        >>> print(ret[0], ret[1], ret[2])\n        {\n            a: (<class ivy.data_classes.array.array.Array> shape=[9, 9]),\n            b: ivy.array([[-0.3475602, -0.93765765],\n                          [-0.93765765, 0.3475602]])\n        } {\n            a: ivy.array([3.58776021, 3.10416126, 2.80644298, 1.87024701, 1.48127627,\n                          0.79101127]),\n            b: ivy.array([1.98288572, 0.68917423])\n        } {\n            a: (<class ivy.data_classes.array.array.Array> shape=[6, 6]),\n            b: (<class ivy.data_classes.array.array.Array> shape=[4, 4])\n        }\n        '
        return self._static_svd(self, compute_uv=compute_uv, full_matrices=full_matrices, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_svdvals(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        return ContainerBase.cont_multi_map_in_function('svdvals', x, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def svdvals(self: ivy.Container, /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            i = 10
            return i + 15
        return self._static_svdvals(self, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_tensordot(x1: Union[ivy.Array, ivy.NativeArray, ivy.Container], x2: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, axes: Union[int, Tuple[List[int], List[int]], ivy.Container]=2, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        return ContainerBase.cont_multi_map_in_function('tensordot', x1, x2, axes=axes, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def tensordot(self: ivy.Container, x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], /, *, axes: Union[int, Tuple[List[int], List[int]], ivy.Container]=2, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        return self._static_tensordot(self, x2, axes=axes, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_tensorsolve(x1: Union[ivy.Array, ivy.NativeArray, ivy.Container], x2: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, axes: Optional[Union[int, Tuple[List[int], List[int]], ivy.Container]]=None, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        return ContainerBase.cont_multi_map_in_function('tensorsolve', x1, x2, axes=axes, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def tensorsolve(self: ivy.Container, x2: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, axes: Optional[Union[int, Tuple[List[int], List[int]], ivy.Container]]=None, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            i = 10
            return i + 15
        return self._static_tensorsolve(self, x2, axes=axes, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_trace(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, offset: Union[int, ivy.Container]=0, axis1: Union[int, ivy.Container]=0, axis2: Union[int, ivy.Container]=1, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        '\n        ivy.Container static method variant of ivy.trace. This method Returns the sum\n        along the specified diagonals of a matrix (or a stack of matrices).\n\n        Parameters\n        ----------\n        x\n            input container having shape ``(..., M, N)`` and whose innermost two\n            dimensions form ``MxN`` matrices. Should have a floating-point data type.\n        offset\n            Offset of the diagonal from the main diagonal. Can be both positive and\n            negative. Defaults to 0.\n        axis1\n            axis to be used as the first axis of the 2-D sub-arrays from which the\n            diagonals should be taken.\n            Defaults to ``0.`` .\n        axis2\n            axis to be used as the second axis of the 2-D sub-arrays from which the\n            diagonals should be taken.\n            Defaults to ``1.`` .\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output array, for writing the result to. It must have a shape that\n            the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a container containing the traces and whose shape is determined by removing\n            the last two dimensions and storing the traces in the last array dimension.\n            For example, if ``x`` has rank ``k`` and shape ``(I, J, K, ..., L, M, N)``,\n            then an output array has rank ``k-2`` and shape ``(I, J, K, ..., L)`` where\n\n            ::\n\n            out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])\n\n            The returned array must have the same data type as ``x``.\n\n        Examples\n        --------\n        With :class:`ivy.Container` input:\n        >>> x = ivy.Container(\n        ...    a = ivy.array([[7, 1, 2],\n        ...                   [1, 3, 5],\n        ...                   [0, 7, 4]]),\n        ...    b = ivy.array([[4, 3, 2],\n        ...                   [1, 9, 5],\n        ...                   [7, 0, 6]])\n        )\n        >>> y = x.Container.static_trace(x)\n        >>> print(y)\n        {\n            a: ivy.array(14),\n            b: ivy.array(19)\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('trace', x, offset=offset, axis1=axis1, axis2=axis2, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def trace(self: ivy.Container, /, *, offset: Union[int, ivy.Container]=0, axis1: Union[int, ivy.Container]=0, axis2: Union[int, ivy.Container]=1, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        '\n        ivy.Container instance method variant of ivy.trace. This method Returns the sum\n        along the specified diagonals of a matrix (or a stack of matrices).\n\n        Parameters\n        ----------\n        self\n            input container having shape ``(..., M, N)`` and whose innermost two\n            dimensions form ``MxN`` matrices. Should have a floating-point data type.\n        offset\n            Offset of the diagonal from the main diagonal. Can be both positive and\n            negative. Defaults to 0.\n        axis1\n            axis to be used as the first axis of the 2-D sub-arrays from which the\n            diagonals should be taken.\n            Defaults to ``0.`` .\n        axis2\n            axis to be used as the second axis of the 2-D sub-arrays from which the\n            diagonals should be taken.\n            Defaults to ``1.`` .\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            optional output array, for writing the result to. It must have a shape that\n            the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            a container containing the traces and whose shape is determined by removing\n            the last two dimensions and storing the traces in the last array dimension.\n            For example, if ``x`` has rank ``k`` and shape ``(I, J, K, ..., L, M, N)``,\n            then an output array has rank ``k-2`` and shape ``(I, J, K, ..., L)`` where\n\n            ::\n\n            out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])\n\n            The returned array must have the same data type as ``x``.\n\n        Examples\n        --------\n        With :class:`ivy.Container` input:\n        >>> x = ivy.Container(\n        ...    a = ivy.array([[7, 1, 2],\n        ...                   [1, 3, 5],\n        ...                   [0, 7, 4]]),\n        ...    b = ivy.array([[4, 3, 2],\n        ...                   [1, 9, 5],\n        ...                   [7, 0, 6]]))\n        >>> y = x.trace()\n        >>> print(y)\n        {\n            a: ivy.array(14),\n            b: ivy.array(19)\n        }\n        '
        return self._static_trace(self, offset=offset, axis1=axis1, axis2=axis2, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_vecdot(x1: Union[ivy.Container, ivy.Array, ivy.NativeArray], x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], /, *, axis: Union[int, ivy.Container]=-1, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        return ContainerBase.cont_multi_map_in_function('vecdot', x1, x2, axis=axis, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def vecdot(self: ivy.Container, x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], /, *, axis: Union[int, ivy.Container]=-1, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        return self._static_vecdot(self, x2, axis=axis, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_vector_norm(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, axis: Optional[Union[int, Sequence[int], ivy.Container]]=None, keepdims: Union[bool, ivy.Container]=False, ord: Union[int, float, Literal[inf, -inf], ivy.Container]=2, dtype: Optional[Union[ivy.Dtype, ivy.NativeDtype, ivy.Container]]=None, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            print('Hello World!')
        '\n        ivy.Container static method variant of ivy.vector_norm. This method simply wraps\n        the function, and so the docstring for ivy.vector_norm also applies to this\n        method with minimal changes.\n\n        Parameters\n        ----------\n        x\n            input array. Should have a floating-point data type.\n        axis\n            If an integer, ``axis`` specifies the axis (dimension)\n            along which to compute vector norms. If an n-tuple,\n            ``axis`` specifies the axes (dimensions) along\n            which to compute batched vector norms. If ``None``, the\n             vector norm must be computed over all array values\n             (i.e., equivalent to computing the vector norm of\n            a flattened array). Negative indices must be\n            supported. Default: ``None``.\n        keepdims\n            If ``True``, the axes (dimensions) specified by ``axis``\n            must be included in the result as singleton dimensions,\n            and, accordingly, the result must be compatible\n            with the input array (see :ref:`broadcasting`). Otherwise,\n            if ``False``, the axes (dimensions) specified by ``axis`` must\n            not be included in the result. Default: ``False``.\n        ord\n            order of the norm. The following mathematical norms must be supported:\n\n            +------------------+----------------------------+\n            | ord              | description                |\n            +==================+============================+\n            | 1                | L1-norm (Manhattan)        |\n            +------------------+----------------------------+\n            | 2                | L2-norm (Euclidean)        |\n            +------------------+----------------------------+\n            | inf              | infinity norm              |\n            +------------------+----------------------------+\n            | (int,float >= 1) | p-norm                     |\n            +------------------+----------------------------+\n\n            The following non-mathematical "norms" must be supported:\n\n            +------------------+--------------------------------+\n            | ord              | description                    |\n            +==================+================================+\n            | 0                | sum(a != 0)                    |\n            +------------------+--------------------------------+\n            | -1               | 1./sum(1./abs(a))              |\n            +------------------+--------------------------------+\n            | -2               | 1./sqrt(sum(1./abs(a)/*/*2))   | # noqa\n            +------------------+--------------------------------+\n            | -inf             | min(abs(a))                    |\n            +------------------+--------------------------------+\n            | (int,float < 1)  | sum(abs(a)/*/*ord)/*/*(1./ord) |\n            +------------------+--------------------------------+\n\n            Default: ``2``.\n        dtype\n            data type that may be used to perform the computation more precisely. The\n            input array ``x`` gets cast to ``dtype`` before the function\'s computations.\n        out\n            optional output array, for writing the result to. It must\n            have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            an array containing the vector norms. If ``axis`` is\n            ``None``, the returned array must be a zero-dimensional\n            array containing a vector norm. If ``axis`` is\n            a scalar value (``int`` or ``float``), the returned array\n            must have a rank which is one less than the rank of ``x``.\n            If ``axis`` is a ``n``-tuple, the returned array must have\n             a rank which is ``n`` less than the rank of ``x``. The returned\n            array must have a floating-point data type determined\n            by :ref:`type-promotion`.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a = [1., 2., 3.], b = [-2., 0., 3.2])\n        >>> y = ivy.Container.static_vector_norm(x)\n        >>> print(y)\n        {\n            a: ivy.array([3.7416575]),\n            b: ivy.array([3.77359247])\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('vector_norm', x, axis=axis, keepdims=keepdims, ord=ord, dtype=dtype, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def vector_norm(self: ivy.Container, /, *, axis: Optional[Union[int, Sequence[int], ivy.Container]]=None, keepdims: Union[bool, ivy.Container]=False, ord: Union[int, float, Literal[inf, -inf], ivy.Container]=2, dtype: Optional[Union[ivy.Dtype, ivy.NativeDtype, ivy.Container]]=None, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            while True:
                i = 10
        '\n        ivy.Container instance method variant of ivy.vector_norm. This method simply\n        wraps the function, and so the docstring for ivy.vector_norm also applies to\n        this method with minimal changes.\n\n        Parameters\n        ----------\n        self\n            input array. Should have a floating-point data type.\n        axis\n            If an integer, ``axis`` specifies the axis (dimension)\n            along which to compute vector norms. If an n-tuple, ``axis``\n            specifies the axes (dimensions) along which to compute\n            batched vector norms. If ``None``, the vector norm must be\n            computed over all array values (i.e., equivalent to computing\n            the vector norm of a flattened array). Negative indices must\n            be supported. Default: ``None``.\n        keepdims\n            If ``True``, the axes (dimensions) specified by ``axis`` must\n            be included in the result as singleton dimensions, and, accordingly,\n            the result must be compatible with the input array\n            (see :ref:`broadcasting`).Otherwise, if ``False``, the axes\n            (dimensions) specified by ``axis`` must not be included in\n            the result. Default: ``False``.\n        ord\n            order of the norm. The following mathematical norms must be supported:\n\n            +------------------+----------------------------+\n            | ord              | description                |\n            +==================+============================+\n            | 1                | L1-norm (Manhattan)        |\n            +------------------+----------------------------+\n            | 2                | L2-norm (Euclidean)        |\n            +------------------+----------------------------+\n            | inf              | infinity norm              |\n            +------------------+----------------------------+\n            | (int,float >= 1) | p-norm                     |\n            +------------------+----------------------------+\n\n            The following non-mathematical "norms" must be supported:\n\n            +------------------+--------------------------------+\n            | ord              | description                    |\n            +==================+================================+\n            | 0                | sum(a != 0)                    |\n            +------------------+--------------------------------+\n            | -1               | 1./sum(1./abs(a))              |\n            +------------------+--------------------------------+\n            | -2               | 1./sqrt(sum(1./abs(a)/*/*2))   | # noqa\n            +------------------+--------------------------------+\n            | -inf             | min(abs(a))                    |\n            +------------------+--------------------------------+\n            | (int,float < 1)  | sum(abs(a)/*/*ord)/*/*(1./ord) |\n            +------------------+--------------------------------+\n\n            Default: ``2``.\n        dtype\n            data type that may be used to perform the computation more precisely. The\n            input array ``x`` gets cast to ``dtype`` before the function\'s computations.\n        out\n            optional output array, for writing the result to. It must\n            have a shape that the inputs broadcast to.\n\n        Returns\n        -------\n        ret\n            an array containing the vector norms. If ``axis`` is ``None``,\n            the returned array must be a zero-dimensional array containing\n            a vector norm. If ``axis`` is a scalar value (``int`` or ``float``),\n            the returned array must have a rank which is one less than the\n            rank of ``x``. If ``axis`` is a ``n``-tuple, the returned\n            array must have a rank which is ``n`` less than the rank of\n            ``x``. The returned array must have a floating-point data type\n            determined by :ref:`type-promotion`.\n\n        Examples\n        --------\n        >>> x = ivy.Container(a = [1., 2., 3.], b = [-2., 0., 3.2])\n        >>> y = x.vector_norm()\n        >>> print(y)\n        {\n            a: ivy.array([3.7416575]),\n            b: ivy.array([3.77359247])\n        }\n        '
        return self._static_vector_norm(self, axis=axis, keepdims=keepdims, ord=ord, dtype=dtype, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_vector_to_skew_symmetric_matrix(vector: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        return ContainerBase.cont_multi_map_in_function('vector_to_skew_symmetric_matrix', vector, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def vector_to_skew_symmetric_matrix(self: ivy.Container, /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        return self._static_vector_to_skew_symmetric_matrix(self, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    @staticmethod
    def _static_vander(x: Union[ivy.Array, ivy.NativeArray, ivy.Container], /, *, N: Optional[Union[int, ivy.Container]]=None, increasing: Union[bool, ivy.Container]=False, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        '\n        ivy.Container static method variant of ivy.vander. This method simply wraps the\n        function, and so the docstring for ivy.vander also applies to this method with\n        minimal changes.\n\n        Parameters\n        ----------\n        x\n            ivy container that contains 1-D arrays.\n        N\n            Number of columns in the output. If N is not specified,\n            a square array is returned (N = len(x))\n        increasing\n            Order of the powers of the columns. If True, the powers increase\n            from left to right, if False (the default) they are reversed.\n        out\n            optional output container, for writing the result to.\n\n        Returns\n        -------\n        ret\n            container that contains the Vandermonde matrix of the arrays included\n            in the input container.\n\n        Examples\n        --------\n        With :class:`ivy.Container` inputs:\n\n        >>> x = ivy.Container(\n                a = ivy.array([1, 2, 3, 5])\n                b = ivy.array([6, 7, 8, 9])\n            )\n        >>> ivy.Container.static_vander(x)\n        {\n            a: ivy.array(\n                    [[  1,   1,   1,   1],\n                    [  8,   4,   2,   1],\n                    [ 27,   9,   3,   1],\n                    [125,  25,   5,   1]]\n                    ),\n            b: ivy.array(\n                    [[216,  36,   6,   1],\n                    [343,  49,   7,   1],\n                    [512,  64,   8,   1],\n                    [729,  81,   9,   1]]\n                    )\n        }\n        '
        return ContainerBase.cont_multi_map_in_function('vander', x, N=N, increasing=increasing, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def vander(self: ivy.Container, /, *, N: Optional[Union[int, ivy.Container]]=None, increasing: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            return 10
        '\n        ivy.Container instance method variant of ivy.vander. This method Returns the\n        Vandermonde matrix of the input array.\n\n        Parameters\n        ----------\n        self\n            1-D input array.\n        N\n            Number of columns in the output. If N is not specified,\n            a square array is returned (N = len(x))\n        increasing\n            Order of the powers of the columns. If True, the powers increase\n            from left to right, if False (the default) they are reversed.\n        out\n            optional output container, for writing the result to.\n\n        Returns\n        -------\n        ret\n            an container containing the Vandermonde matrices of the arrays\n            included in the input container.\n\n        Examples\n        --------\n        With :class:`ivy.Container` inputs:\n\n        >>> x = ivy.Container(\n                a = ivy.array([1, 2, 3, 5])\n                b = ivy.array([6, 7, 8, 9])\n            )\n        >>> x.vander()\n        {\n            a: ivy.array(\n                    [[  1,   1,   1,   1],\n                    [  8,   4,   2,   1],\n                    [ 27,   9,   3,   1],\n                    [125,  25,   5,   1]]\n                    ),\n            b: ivy.array(\n                    [[216,  36,   6,   1],\n                    [343,  49,   7,   1],\n                    [512,  64,   8,   1],\n                    [729,  81,   9,   1]]\n                    )\n        }\n        '
        return self._static_vander(self, N=N, increasing=increasing, out=out)

    @staticmethod
    def static_general_inner_product(x1: Union[ivy.Container, ivy.Array, ivy.NativeArray], x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], n_modes: Optional[Union[int, ivy.Container]]=None, /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            for i in range(10):
                print('nop')
        "\n        ivy.Container static method variant of ivy.general_inner_product. This method\n        simply wraps the function, and so the docstring for ivy.general_inner_product\n        also applies to this method with minimal changes.\n\n        Parameters\n        ----------\n        x1\n            First input container containing input array.\n        x2\n            First input container containing input array.\n        n_modes\n            int, default is None. If None, the traditional inner product is returned\n            (i.e. a float) otherwise, the product between the `n_modes` last modes of\n            `x1` and the `n_modes` first modes of `x2` is returned. The resulting\n            tensor's order is `len(x1) - n_modes`.\n        key_chains\n            The key-chains to apply or not apply the method to. Default is ``None``.\n        to_apply\n            If True, the method will be applied to key_chains, otherwise key_chains\n            will be skipped. Default is ``True``.\n        prune_unapplied\n            Whether to prune key_chains for which the function was not applied.\n            Default is ``False``.\n        map_sequences\n            Whether to also map method to sequences (lists, tuples).\n            Default is ``False``.\n        out\n            Alternate output container in which to place the result.\n            The default is None.\n\n        Returns\n        -------\n        ret\n            Container including the inner product tensor.\n\n        Examples\n        --------\n        >>> x = ivy.Container(\n                a=ivy.reshape(ivy.arange(4), (2, 2)),\n                b=ivy.reshape(ivy.arange(8), (2, 4)),\n            )\n        >>> ivy.Container.general_inner_product(x, 1)\n            {\n                a: ivy.array(6),\n                b: ivy.array(28)\n            }\n        "
        return ContainerBase.cont_multi_map_in_function('general_inner_product', x1, x2, n_modes, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)

    def general_inner_product(self: Union[ivy.Container, ivy.Array, ivy.NativeArray], x2: Union[ivy.Container, ivy.Array, ivy.NativeArray], n_modes: Optional[Union[int, ivy.Container]]=None, /, *, key_chains: Optional[Union[List[str], Dict[str, str], ivy.Container]]=None, to_apply: Union[bool, ivy.Container]=True, prune_unapplied: Union[bool, ivy.Container]=False, map_sequences: Union[bool, ivy.Container]=False, out: Optional[ivy.Container]=None) -> ivy.Container:
        if False:
            print('Hello World!')
        '\n        ivy.Container instance method variant of ivy.general_inner_product.\n\n        This method simply wraps the function, and so the docstring for\n        ivy.general_inner_product also applies to this method with\n        minimal changes.\n        '
        return self.static_general_inner_product(self, x2, n_modes, key_chains=key_chains, to_apply=to_apply, prune_unapplied=prune_unapplied, map_sequences=map_sequences, out=out)