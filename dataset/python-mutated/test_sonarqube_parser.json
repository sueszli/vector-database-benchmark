[
    {
        "func_name": "init",
        "original": "def init(self, reportFilename):\n    my_file_handle = open(reportFilename)\n    product = Product()\n    engagement = Engagement()\n    test = Test()\n    engagement.product = product\n    test.engagement = engagement\n    return (my_file_handle, product, engagement, test)",
        "mutated": [
            "def init(self, reportFilename):\n    if False:\n        i = 10\n    my_file_handle = open(reportFilename)\n    product = Product()\n    engagement = Engagement()\n    test = Test()\n    engagement.product = product\n    test.engagement = engagement\n    return (my_file_handle, product, engagement, test)",
            "def init(self, reportFilename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    my_file_handle = open(reportFilename)\n    product = Product()\n    engagement = Engagement()\n    test = Test()\n    engagement.product = product\n    test.engagement = engagement\n    return (my_file_handle, product, engagement, test)",
            "def init(self, reportFilename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    my_file_handle = open(reportFilename)\n    product = Product()\n    engagement = Engagement()\n    test = Test()\n    engagement.product = product\n    test.engagement = engagement\n    return (my_file_handle, product, engagement, test)",
            "def init(self, reportFilename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    my_file_handle = open(reportFilename)\n    product = Product()\n    engagement = Engagement()\n    test = Test()\n    engagement.product = product\n    test.engagement = engagement\n    return (my_file_handle, product, engagement, test)",
            "def init(self, reportFilename):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    my_file_handle = open(reportFilename)\n    product = Product()\n    engagement = Engagement()\n    test = Test()\n    engagement.product = product\n    test.engagement = engagement\n    return (my_file_handle, product, engagement, test)"
        ]
    },
    {
        "func_name": "test_file_name_aggregated_parse_file_with_no_vulnerabilities_has_no_findings",
        "original": "def test_file_name_aggregated_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))",
        "mutated": [
            "def test_file_name_aggregated_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    if False:\n        i = 10\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))",
            "def test_file_name_aggregated_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))",
            "def test_file_name_aggregated_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))",
            "def test_file_name_aggregated_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))",
            "def test_file_name_aggregated_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))"
        ]
    },
    {
        "func_name": "test_detailed_parse_file_with_no_vulnerabilities_has_no_findings",
        "original": "def test_detailed_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))",
        "mutated": [
            "def test_detailed_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    if False:\n        i = 10\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))",
            "def test_detailed_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))",
            "def test_detailed_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))",
            "def test_detailed_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))",
            "def test_detailed_parse_file_with_no_vulnerabilities_has_no_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-no-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(0, len(findings))"
        ]
    },
    {
        "func_name": "test_file_name_aggregated_parse_file_with_single_vulnerability_has_single_finding",
        "original": "def test_file_name_aggregated_parse_file_with_single_vulnerability_has_single_finding(self):\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 66', item.description)\n    self.assertIsNone(item.line)\n    self.assertIsNone(item.unique_id_from_tool)\n    self.assertEqual(int, type(item.nb_occurences))\n    self.assertEqual(1, item.nb_occurences)",
        "mutated": [
            "def test_file_name_aggregated_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 66', item.description)\n    self.assertIsNone(item.line)\n    self.assertIsNone(item.unique_id_from_tool)\n    self.assertEqual(int, type(item.nb_occurences))\n    self.assertEqual(1, item.nb_occurences)",
            "def test_file_name_aggregated_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 66', item.description)\n    self.assertIsNone(item.line)\n    self.assertIsNone(item.unique_id_from_tool)\n    self.assertEqual(int, type(item.nb_occurences))\n    self.assertEqual(1, item.nb_occurences)",
            "def test_file_name_aggregated_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 66', item.description)\n    self.assertIsNone(item.line)\n    self.assertIsNone(item.unique_id_from_tool)\n    self.assertEqual(int, type(item.nb_occurences))\n    self.assertEqual(1, item.nb_occurences)",
            "def test_file_name_aggregated_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 66', item.description)\n    self.assertIsNone(item.line)\n    self.assertIsNone(item.unique_id_from_tool)\n    self.assertEqual(int, type(item.nb_occurences))\n    self.assertEqual(1, item.nb_occurences)",
            "def test_file_name_aggregated_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 66', item.description)\n    self.assertIsNone(item.line)\n    self.assertIsNone(item.unique_id_from_tool)\n    self.assertEqual(int, type(item.nb_occurences))\n    self.assertEqual(1, item.nb_occurences)"
        ]
    },
    {
        "func_name": "test_detailed_parse_file_with_single_vulnerability_has_single_finding",
        "original": "def test_detailed_parse_file_with_single_vulnerability_has_single_finding(self):\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);', item.description)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('66', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)",
        "mutated": [
            "def test_detailed_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);', item.description)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('66', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)",
            "def test_detailed_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);', item.description)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('66', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)",
            "def test_detailed_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);', item.description)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('66', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)",
            "def test_detailed_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);', item.description)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('66', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)",
            "def test_detailed_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-single-finding.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\nIt\\'s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", ...\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);', item.description)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('66', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)"
        ]
    },
    {
        "func_name": "check_parse_file_with_single_vulnerability_has_single_finding",
        "original": "def check_parse_file_with_single_vulnerability_has_single_finding(self):\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('Credentials should not be hard-coded', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(798, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(False, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual(\"'PASSWORD' detected in this expression, review this potentially hardcoded credential.\", item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2068\\nOWASP Top 10 2017 Category A2\\nMITRE, CWE-798\\nMITRE, CWE-259\\nCERT, MSC03-J.\\nSANS Top 25\\nHard Coded Password', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java', item.file_path)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
        "mutated": [
            "def check_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('Credentials should not be hard-coded', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(798, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(False, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual(\"'PASSWORD' detected in this expression, review this potentially hardcoded credential.\", item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2068\\nOWASP Top 10 2017 Category A2\\nMITRE, CWE-798\\nMITRE, CWE-259\\nCERT, MSC03-J.\\nSANS Top 25\\nHard Coded Password', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java', item.file_path)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def check_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('Credentials should not be hard-coded', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(798, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(False, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual(\"'PASSWORD' detected in this expression, review this potentially hardcoded credential.\", item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2068\\nOWASP Top 10 2017 Category A2\\nMITRE, CWE-798\\nMITRE, CWE-259\\nCERT, MSC03-J.\\nSANS Top 25\\nHard Coded Password', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java', item.file_path)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def check_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('Credentials should not be hard-coded', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(798, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(False, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual(\"'PASSWORD' detected in this expression, review this potentially hardcoded credential.\", item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2068\\nOWASP Top 10 2017 Category A2\\nMITRE, CWE-798\\nMITRE, CWE-259\\nCERT, MSC03-J.\\nSANS Top 25\\nHard Coded Password', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java', item.file_path)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def check_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('Credentials should not be hard-coded', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(798, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(False, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual(\"'PASSWORD' detected in this expression, review this potentially hardcoded credential.\", item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2068\\nOWASP Top 10 2017 Category A2\\nMITRE, CWE-798\\nMITRE, CWE-259\\nCERT, MSC03-J.\\nSANS Top 25\\nHard Coded Password', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java', item.file_path)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def check_parse_file_with_single_vulnerability_has_single_finding(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('Credentials should not be hard-coded', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(798, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(False, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual(\"'PASSWORD' detected in this expression, review this potentially hardcoded credential.\", item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2068\\nOWASP Top 10 2017 Category A2\\nMITRE, CWE-798\\nMITRE, CWE-259\\nCERT, MSC03-J.\\nSANS Top 25\\nHard Coded Password', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('modules/jdbc-pool/src/main/java/org/apache/tomcat/jdbc/pool/DataSourceFactory.java', item.file_path)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)"
        ]
    },
    {
        "func_name": "test_detailed_parse_file_with_multiple_vulnerabilities_has_multiple_findings",
        "original": "def test_detailed_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))",
        "mutated": [
            "def test_detailed_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    if False:\n        i = 10\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))",
            "def test_detailed_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))",
            "def test_detailed_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))",
            "def test_detailed_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))",
            "def test_detailed_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))"
        ]
    },
    {
        "func_name": "test_file_name_aggregated_parse_file_with_multiple_vulnerabilities_has_multiple_findings",
        "original": "def test_file_name_aggregated_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))",
        "mutated": [
            "def test_file_name_aggregated_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    if False:\n        i = 10\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))",
            "def test_file_name_aggregated_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))",
            "def test_file_name_aggregated_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))",
            "def test_file_name_aggregated_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))",
            "def test_file_name_aggregated_parse_file_with_multiple_vulnerabilities_has_multiple_findings(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-6-findings.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(6, len(findings))"
        ]
    },
    {
        "func_name": "test_detailed_parse_file_with_table_in_table",
        "original": "def test_detailed_parse_file_with_table_in_table(self):\n    \"\"\"Test parsing when the vulnerability details include a table, with tr and td that should be ignored when looking for list of rules\"\"\"\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-table-in-table.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Many consider clone and Cloneable broken in Java, largely because the rules for overriding clone are tricky\\nand difficult to get right, according to Joshua Bloch:\\n\\n  Object\\'s clone method is very tricky. It\\'s based on field copies, and it\\'s \"extra-linguistic.\" It creates an object without calling a constructor.\\n  There are no guarantees that it preserves the invariants established by the constructors. There have been lots of bugs over the years, both in and\\n  outside Sun, stemming from the fact that if you just call super.clone repeatedly up the chain until you have cloned an object, you have a shallow\\n  copy of the object. The clone generally shares state with the object being cloned. If that state is mutable, you don\\'t have two independent objects.\\n  If you modify one, the other changes as well. And all of a sudden, you get random behavior.\\n\\nA copy constructor or copy factory should be used instead.\\nThis rule raises an issue when clone is overridden, whether or not Cloneable is implemented.\\n**Noncompliant Code Example**\\n\\npublic class MyClass {\\n  // ...\\n\\n  public Object clone() { // Noncompliant\\n    //...\\n  }\\n}\\n\\n**Compliant Solution**\\n\\npublic class MyClass {\\n  // ...\\n\\n  MyClass (MyClass source) {\\n    //...\\n  }\\n}', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2975\\nCopy Constructor versus Cloning\\nS2157\\nS1182', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
        "mutated": [
            "def test_detailed_parse_file_with_table_in_table(self):\n    if False:\n        i = 10\n    'Test parsing when the vulnerability details include a table, with tr and td that should be ignored when looking for list of rules'\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-table-in-table.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Many consider clone and Cloneable broken in Java, largely because the rules for overriding clone are tricky\\nand difficult to get right, according to Joshua Bloch:\\n\\n  Object\\'s clone method is very tricky. It\\'s based on field copies, and it\\'s \"extra-linguistic.\" It creates an object without calling a constructor.\\n  There are no guarantees that it preserves the invariants established by the constructors. There have been lots of bugs over the years, both in and\\n  outside Sun, stemming from the fact that if you just call super.clone repeatedly up the chain until you have cloned an object, you have a shallow\\n  copy of the object. The clone generally shares state with the object being cloned. If that state is mutable, you don\\'t have two independent objects.\\n  If you modify one, the other changes as well. And all of a sudden, you get random behavior.\\n\\nA copy constructor or copy factory should be used instead.\\nThis rule raises an issue when clone is overridden, whether or not Cloneable is implemented.\\n**Noncompliant Code Example**\\n\\npublic class MyClass {\\n  // ...\\n\\n  public Object clone() { // Noncompliant\\n    //...\\n  }\\n}\\n\\n**Compliant Solution**\\n\\npublic class MyClass {\\n  // ...\\n\\n  MyClass (MyClass source) {\\n    //...\\n  }\\n}', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2975\\nCopy Constructor versus Cloning\\nS2157\\nS1182', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def test_detailed_parse_file_with_table_in_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Test parsing when the vulnerability details include a table, with tr and td that should be ignored when looking for list of rules'\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-table-in-table.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Many consider clone and Cloneable broken in Java, largely because the rules for overriding clone are tricky\\nand difficult to get right, according to Joshua Bloch:\\n\\n  Object\\'s clone method is very tricky. It\\'s based on field copies, and it\\'s \"extra-linguistic.\" It creates an object without calling a constructor.\\n  There are no guarantees that it preserves the invariants established by the constructors. There have been lots of bugs over the years, both in and\\n  outside Sun, stemming from the fact that if you just call super.clone repeatedly up the chain until you have cloned an object, you have a shallow\\n  copy of the object. The clone generally shares state with the object being cloned. If that state is mutable, you don\\'t have two independent objects.\\n  If you modify one, the other changes as well. And all of a sudden, you get random behavior.\\n\\nA copy constructor or copy factory should be used instead.\\nThis rule raises an issue when clone is overridden, whether or not Cloneable is implemented.\\n**Noncompliant Code Example**\\n\\npublic class MyClass {\\n  // ...\\n\\n  public Object clone() { // Noncompliant\\n    //...\\n  }\\n}\\n\\n**Compliant Solution**\\n\\npublic class MyClass {\\n  // ...\\n\\n  MyClass (MyClass source) {\\n    //...\\n  }\\n}', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2975\\nCopy Constructor versus Cloning\\nS2157\\nS1182', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def test_detailed_parse_file_with_table_in_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Test parsing when the vulnerability details include a table, with tr and td that should be ignored when looking for list of rules'\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-table-in-table.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Many consider clone and Cloneable broken in Java, largely because the rules for overriding clone are tricky\\nand difficult to get right, according to Joshua Bloch:\\n\\n  Object\\'s clone method is very tricky. It\\'s based on field copies, and it\\'s \"extra-linguistic.\" It creates an object without calling a constructor.\\n  There are no guarantees that it preserves the invariants established by the constructors. There have been lots of bugs over the years, both in and\\n  outside Sun, stemming from the fact that if you just call super.clone repeatedly up the chain until you have cloned an object, you have a shallow\\n  copy of the object. The clone generally shares state with the object being cloned. If that state is mutable, you don\\'t have two independent objects.\\n  If you modify one, the other changes as well. And all of a sudden, you get random behavior.\\n\\nA copy constructor or copy factory should be used instead.\\nThis rule raises an issue when clone is overridden, whether or not Cloneable is implemented.\\n**Noncompliant Code Example**\\n\\npublic class MyClass {\\n  // ...\\n\\n  public Object clone() { // Noncompliant\\n    //...\\n  }\\n}\\n\\n**Compliant Solution**\\n\\npublic class MyClass {\\n  // ...\\n\\n  MyClass (MyClass source) {\\n    //...\\n  }\\n}', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2975\\nCopy Constructor versus Cloning\\nS2157\\nS1182', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def test_detailed_parse_file_with_table_in_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Test parsing when the vulnerability details include a table, with tr and td that should be ignored when looking for list of rules'\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-table-in-table.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Many consider clone and Cloneable broken in Java, largely because the rules for overriding clone are tricky\\nand difficult to get right, according to Joshua Bloch:\\n\\n  Object\\'s clone method is very tricky. It\\'s based on field copies, and it\\'s \"extra-linguistic.\" It creates an object without calling a constructor.\\n  There are no guarantees that it preserves the invariants established by the constructors. There have been lots of bugs over the years, both in and\\n  outside Sun, stemming from the fact that if you just call super.clone repeatedly up the chain until you have cloned an object, you have a shallow\\n  copy of the object. The clone generally shares state with the object being cloned. If that state is mutable, you don\\'t have two independent objects.\\n  If you modify one, the other changes as well. And all of a sudden, you get random behavior.\\n\\nA copy constructor or copy factory should be used instead.\\nThis rule raises an issue when clone is overridden, whether or not Cloneable is implemented.\\n**Noncompliant Code Example**\\n\\npublic class MyClass {\\n  // ...\\n\\n  public Object clone() { // Noncompliant\\n    //...\\n  }\\n}\\n\\n**Compliant Solution**\\n\\npublic class MyClass {\\n  // ...\\n\\n  MyClass (MyClass source) {\\n    //...\\n  }\\n}', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2975\\nCopy Constructor versus Cloning\\nS2157\\nS1182', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def test_detailed_parse_file_with_table_in_table(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Test parsing when the vulnerability details include a table, with tr and td that should be ignored when looking for list of rules'\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-table-in-table.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertMultiLineEqual('Many consider clone and Cloneable broken in Java, largely because the rules for overriding clone are tricky\\nand difficult to get right, according to Joshua Bloch:\\n\\n  Object\\'s clone method is very tricky. It\\'s based on field copies, and it\\'s \"extra-linguistic.\" It creates an object without calling a constructor.\\n  There are no guarantees that it preserves the invariants established by the constructors. There have been lots of bugs over the years, both in and\\n  outside Sun, stemming from the fact that if you just call super.clone repeatedly up the chain until you have cloned an object, you have a shallow\\n  copy of the object. The clone generally shares state with the object being cloned. If that state is mutable, you don\\'t have two independent objects.\\n  If you modify one, the other changes as well. And all of a sudden, you get random behavior.\\n\\nA copy constructor or copy factory should be used instead.\\nThis rule raises an issue when clone is overridden, whether or not Cloneable is implemented.\\n**Noncompliant Code Example**\\n\\npublic class MyClass {\\n  // ...\\n\\n  public Object clone() { // Noncompliant\\n    //...\\n  }\\n}\\n\\n**Compliant Solution**\\n\\npublic class MyClass {\\n  // ...\\n\\n  MyClass (MyClass source) {\\n    //...\\n  }\\n}', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertMultiLineEqual('squid:S2975\\nCopy Constructor versus Cloning\\nS2157\\nS1182', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)"
        ]
    },
    {
        "func_name": "test_detailed_parse_file_with_rule_undefined",
        "original": "def test_detailed_parse_file_with_rule_undefined(self):\n    \"\"\"the vulnerability's rule is not in the list of rules\"\"\"\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-rule-undefined.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertEqual('No description provided', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertEqual('', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
        "mutated": [
            "def test_detailed_parse_file_with_rule_undefined(self):\n    if False:\n        i = 10\n    \"the vulnerability's rule is not in the list of rules\"\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-rule-undefined.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertEqual('No description provided', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertEqual('', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def test_detailed_parse_file_with_rule_undefined(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"the vulnerability's rule is not in the list of rules\"\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-rule-undefined.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertEqual('No description provided', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertEqual('', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def test_detailed_parse_file_with_rule_undefined(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"the vulnerability's rule is not in the list of rules\"\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-rule-undefined.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertEqual('No description provided', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertEqual('', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def test_detailed_parse_file_with_rule_undefined(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"the vulnerability's rule is not in the list of rules\"\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-rule-undefined.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertEqual('No description provided', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertEqual('', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)",
            "def test_detailed_parse_file_with_rule_undefined(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"the vulnerability's rule is not in the list of rules\"\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-rule-undefined.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(1, len(findings))\n    item = findings[0]\n    self.assertEqual(str, type(findings[0].title))\n    self.assertEqual('\"clone\" should not be overridden', item.title)\n    self.assertEqual(int, type(item.cwe))\n    self.assertEqual(0, item.cwe)\n    self.assertEqual(bool, type(item.active))\n    self.assertEqual(True, item.active)\n    self.assertEqual(bool, type(item.verified))\n    self.assertEqual(False, item.verified)\n    self.assertEqual(str, type(item.description))\n    self.assertEqual('No description provided', item.description)\n    self.assertEqual(str, type(item.severity))\n    self.assertEqual('Critical', item.severity)\n    self.assertEqual(str, type(item.mitigation))\n    self.assertEqual('Remove this \"clone\" implementation; use a copy constructor or copy factory instead.', item.mitigation)\n    self.assertEqual(str, type(item.references))\n    self.assertEqual('', item.references)\n    self.assertEqual(str, type(item.file_path))\n    self.assertEqual('java/org/apache/catalina/util/URLEncoder.java', item.file_path)\n    self.assertEqual(str, type(item.line))\n    self.assertEqual('190', item.line)\n    self.assertEqual(str, type(item.unique_id_from_tool))\n    self.assertEqual('AWK40IMu-pl6AHs22MnV', item.unique_id_from_tool)\n    self.assertEqual(bool, type(item.static_finding))\n    self.assertEqual(True, item.static_finding)\n    self.assertEqual(bool, type(item.dynamic_finding))\n    self.assertEqual(False, item.dynamic_finding)"
        ]
    },
    {
        "func_name": "test_file_name_aggregated_parse_file_with_vuln_on_same_filename",
        "original": "def test_file_name_aggregated_parse_file_with_vuln_on_same_filename(self):\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(2, len(findings))\n    item1 = findings[0]\n    item2 = findings[1]\n    if item1.nb_occurences == 3:\n        aggregatedItem = item1\n        self.assertEqual(int, type(item2.nb_occurences))\n        self.assertEqual(1, item2.nb_occurences)\n    elif item2.nb_occurences == 3:\n        aggregatedItem = item2\n        self.assertEqual(int, type(item1.nb_occurences))\n        self.assertEqual(1, item1.nb_occurences)\n    else:\n        self.fail('cannot find aggregated item')\n    self.assertEqual(str, type(aggregatedItem.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 12\\nLine: 13\\nLine: 14', aggregatedItem.description)\n    self.assertIsNone(aggregatedItem.line)\n    self.assertIsNone(aggregatedItem.unique_id_from_tool)\n    self.assertEqual(int, type(aggregatedItem.nb_occurences))",
        "mutated": [
            "def test_file_name_aggregated_parse_file_with_vuln_on_same_filename(self):\n    if False:\n        i = 10\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(2, len(findings))\n    item1 = findings[0]\n    item2 = findings[1]\n    if item1.nb_occurences == 3:\n        aggregatedItem = item1\n        self.assertEqual(int, type(item2.nb_occurences))\n        self.assertEqual(1, item2.nb_occurences)\n    elif item2.nb_occurences == 3:\n        aggregatedItem = item2\n        self.assertEqual(int, type(item1.nb_occurences))\n        self.assertEqual(1, item1.nb_occurences)\n    else:\n        self.fail('cannot find aggregated item')\n    self.assertEqual(str, type(aggregatedItem.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 12\\nLine: 13\\nLine: 14', aggregatedItem.description)\n    self.assertIsNone(aggregatedItem.line)\n    self.assertIsNone(aggregatedItem.unique_id_from_tool)\n    self.assertEqual(int, type(aggregatedItem.nb_occurences))",
            "def test_file_name_aggregated_parse_file_with_vuln_on_same_filename(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(2, len(findings))\n    item1 = findings[0]\n    item2 = findings[1]\n    if item1.nb_occurences == 3:\n        aggregatedItem = item1\n        self.assertEqual(int, type(item2.nb_occurences))\n        self.assertEqual(1, item2.nb_occurences)\n    elif item2.nb_occurences == 3:\n        aggregatedItem = item2\n        self.assertEqual(int, type(item1.nb_occurences))\n        self.assertEqual(1, item1.nb_occurences)\n    else:\n        self.fail('cannot find aggregated item')\n    self.assertEqual(str, type(aggregatedItem.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 12\\nLine: 13\\nLine: 14', aggregatedItem.description)\n    self.assertIsNone(aggregatedItem.line)\n    self.assertIsNone(aggregatedItem.unique_id_from_tool)\n    self.assertEqual(int, type(aggregatedItem.nb_occurences))",
            "def test_file_name_aggregated_parse_file_with_vuln_on_same_filename(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(2, len(findings))\n    item1 = findings[0]\n    item2 = findings[1]\n    if item1.nb_occurences == 3:\n        aggregatedItem = item1\n        self.assertEqual(int, type(item2.nb_occurences))\n        self.assertEqual(1, item2.nb_occurences)\n    elif item2.nb_occurences == 3:\n        aggregatedItem = item2\n        self.assertEqual(int, type(item1.nb_occurences))\n        self.assertEqual(1, item1.nb_occurences)\n    else:\n        self.fail('cannot find aggregated item')\n    self.assertEqual(str, type(aggregatedItem.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 12\\nLine: 13\\nLine: 14', aggregatedItem.description)\n    self.assertIsNone(aggregatedItem.line)\n    self.assertIsNone(aggregatedItem.unique_id_from_tool)\n    self.assertEqual(int, type(aggregatedItem.nb_occurences))",
            "def test_file_name_aggregated_parse_file_with_vuln_on_same_filename(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(2, len(findings))\n    item1 = findings[0]\n    item2 = findings[1]\n    if item1.nb_occurences == 3:\n        aggregatedItem = item1\n        self.assertEqual(int, type(item2.nb_occurences))\n        self.assertEqual(1, item2.nb_occurences)\n    elif item2.nb_occurences == 3:\n        aggregatedItem = item2\n        self.assertEqual(int, type(item1.nb_occurences))\n        self.assertEqual(1, item1.nb_occurences)\n    else:\n        self.fail('cannot find aggregated item')\n    self.assertEqual(str, type(aggregatedItem.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 12\\nLine: 13\\nLine: 14', aggregatedItem.description)\n    self.assertIsNone(aggregatedItem.line)\n    self.assertIsNone(aggregatedItem.unique_id_from_tool)\n    self.assertEqual(int, type(aggregatedItem.nb_occurences))",
            "def test_file_name_aggregated_parse_file_with_vuln_on_same_filename(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(2, len(findings))\n    item1 = findings[0]\n    item2 = findings[1]\n    if item1.nb_occurences == 3:\n        aggregatedItem = item1\n        self.assertEqual(int, type(item2.nb_occurences))\n        self.assertEqual(1, item2.nb_occurences)\n    elif item2.nb_occurences == 3:\n        aggregatedItem = item2\n        self.assertEqual(int, type(item1.nb_occurences))\n        self.assertEqual(1, item1.nb_occurences)\n    else:\n        self.fail('cannot find aggregated item')\n    self.assertEqual(str, type(aggregatedItem.description))\n    self.assertMultiLineEqual('Because it is easy to extract strings from a compiled application, credentials should never be hard-coded. Do so, and they\\'re almost guaranteed to\\nend up in the hands of an attacker. This is particularly true for applications that are distributed.\\nCredentials should be stored outside of the code in a strongly-protected encrypted configuration file or database.\\n**Noncompliant Code Example**\\n\\nConnection conn = null;\\ntry {\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=steve&amp;password=blue\"); // Noncompliant\\n  String uname = \"steve\";\\n  String password = \"blue\";\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password); // Noncompliant\\n\\n  java.net.PasswordAuthentication pa = new java.net.PasswordAuthentication(\"userName\", \"1234\".toCharArray());  // Noncompliant\\n\\n**Compliant Solution**\\n\\nConnection conn = null;\\ntry {\\n  String uname = getEncryptedUser();\\n  String password = getEncryptedPass();\\n  conn = DriverManager.getConnection(\"jdbc:mysql://localhost/test?\" +\\n        \"user=\" + uname + \"&amp;password=\" + password);\\n\\n-----\\nOccurences:\\nLine: 12\\nLine: 13\\nLine: 14', aggregatedItem.description)\n    self.assertIsNone(aggregatedItem.line)\n    self.assertIsNone(aggregatedItem.unique_id_from_tool)\n    self.assertEqual(int, type(aggregatedItem.nb_occurences))"
        ]
    },
    {
        "func_name": "test_detailed_parse_file_with_vuln_on_same_filename",
        "original": "def test_detailed_parse_file_with_vuln_on_same_filename(self):\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(4, len(findings))",
        "mutated": [
            "def test_detailed_parse_file_with_vuln_on_same_filename(self):\n    if False:\n        i = 10\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(4, len(findings))",
            "def test_detailed_parse_file_with_vuln_on_same_filename(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(4, len(findings))",
            "def test_detailed_parse_file_with_vuln_on_same_filename(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(4, len(findings))",
            "def test_detailed_parse_file_with_vuln_on_same_filename(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(4, len(findings))",
            "def test_detailed_parse_file_with_vuln_on_same_filename(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar-4-findings-3-to-aggregate.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(4, len(findings))"
        ]
    },
    {
        "func_name": "test_detailed_parse_file_with_vuln_issue_3725",
        "original": "def test_detailed_parse_file_with_vuln_issue_3725(self):\n    \"\"\"SonarQube Scan detailed - report that crash\n        see: https://github.com/DefectDojo/django-DefectDojo/issues/3725\n        \"\"\"\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(322, len(findings))",
        "mutated": [
            "def test_detailed_parse_file_with_vuln_issue_3725(self):\n    if False:\n        i = 10\n    'SonarQube Scan detailed - report that crash\\n        see: https://github.com/DefectDojo/django-DefectDojo/issues/3725\\n        '\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(322, len(findings))",
            "def test_detailed_parse_file_with_vuln_issue_3725(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'SonarQube Scan detailed - report that crash\\n        see: https://github.com/DefectDojo/django-DefectDojo/issues/3725\\n        '\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(322, len(findings))",
            "def test_detailed_parse_file_with_vuln_issue_3725(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'SonarQube Scan detailed - report that crash\\n        see: https://github.com/DefectDojo/django-DefectDojo/issues/3725\\n        '\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(322, len(findings))",
            "def test_detailed_parse_file_with_vuln_issue_3725(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'SonarQube Scan detailed - report that crash\\n        see: https://github.com/DefectDojo/django-DefectDojo/issues/3725\\n        '\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(322, len(findings))",
            "def test_detailed_parse_file_with_vuln_issue_3725(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'SonarQube Scan detailed - report that crash\\n        see: https://github.com/DefectDojo/django-DefectDojo/issues/3725\\n        '\n    (my_file_handle, product, engagement, test) = self.init(get_unit_tests_path() + '/scans/sonarqube/sonar.html')\n    parser = SonarQubeParser()\n    parser.set_mode('detailed')\n    findings = parser.get_findings(my_file_handle, test)\n    self.assertEqual(322, len(findings))"
        ]
    }
]