[
    {
        "func_name": "opensfm_to_upright",
        "original": "def opensfm_to_upright(coords: np.ndarray, width: int, height: int, orientation: int, new_width: Optional[int]=None, new_height: Optional[int]=None) -> np.ndarray:\n    \"\"\"\n    Transform opensfm coordinates to upright coordinates, correcting for EXIF orientation.\n\n    :param coords: Points in opensfm coordinate system.\n    :param width: Width of original image in pixels unadjusted for orientation.\n    :param height: Height of original image in pixels unadjusted for orientation.\n    :param orientation: Orientation of original image.\n\n    :return: Points in upright coordinate system.\n\n    >>> sfm = np.array([[-0.5, -0.375],\n    ...                 [-0.5,  0.375],\n    ...                 [ 0.5, -0.375],\n    ...                 [ 0.5,  0.375]])\n    >>> opensfm_to_upright(sfm, 320, 240, 1)\n    array([[   0.,    0.],\n           [   0.,  240.],\n           [ 320.,    0.],\n           [ 320.,  240.]])\n    \"\"\"\n    R = {1: np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), 3: np.array([[-1, 0, 1], [0, -1, 1], [0, 0, 1]]), 6: np.array([[0, -1, 1], [1, 0, 0], [0, 0, 1]]), 8: np.array([[0, 1, 0], [-1, 0, 1], [0, 0, 1]])}\n    w = float(width)\n    h = float(height)\n    s = max(w, h)\n    H = np.array([[s / w, 0, 0.5], [0, s / h, 0.5], [0, 0, 1]])\n    T = np.dot(R[orientation], H)\n    p = np.dot(coords, T[:2, :2].T) + T[:2, 2].reshape(1, 2)\n    upright_width = width if orientation < 6 else height\n    upright_height = height if orientation < 6 else width\n    if new_width is not None:\n        upright_width = new_width\n    if new_height is not None:\n        upright_height = new_height\n    p[:, 0] = upright_width * p[:, 0]\n    p[:, 1] = upright_height * p[:, 1]\n    return p",
        "mutated": [
            "def opensfm_to_upright(coords: np.ndarray, width: int, height: int, orientation: int, new_width: Optional[int]=None, new_height: Optional[int]=None) -> np.ndarray:\n    if False:\n        i = 10\n    '\\n    Transform opensfm coordinates to upright coordinates, correcting for EXIF orientation.\\n\\n    :param coords: Points in opensfm coordinate system.\\n    :param width: Width of original image in pixels unadjusted for orientation.\\n    :param height: Height of original image in pixels unadjusted for orientation.\\n    :param orientation: Orientation of original image.\\n\\n    :return: Points in upright coordinate system.\\n\\n    >>> sfm = np.array([[-0.5, -0.375],\\n    ...                 [-0.5,  0.375],\\n    ...                 [ 0.5, -0.375],\\n    ...                 [ 0.5,  0.375]])\\n    >>> opensfm_to_upright(sfm, 320, 240, 1)\\n    array([[   0.,    0.],\\n           [   0.,  240.],\\n           [ 320.,    0.],\\n           [ 320.,  240.]])\\n    '\n    R = {1: np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), 3: np.array([[-1, 0, 1], [0, -1, 1], [0, 0, 1]]), 6: np.array([[0, -1, 1], [1, 0, 0], [0, 0, 1]]), 8: np.array([[0, 1, 0], [-1, 0, 1], [0, 0, 1]])}\n    w = float(width)\n    h = float(height)\n    s = max(w, h)\n    H = np.array([[s / w, 0, 0.5], [0, s / h, 0.5], [0, 0, 1]])\n    T = np.dot(R[orientation], H)\n    p = np.dot(coords, T[:2, :2].T) + T[:2, 2].reshape(1, 2)\n    upright_width = width if orientation < 6 else height\n    upright_height = height if orientation < 6 else width\n    if new_width is not None:\n        upright_width = new_width\n    if new_height is not None:\n        upright_height = new_height\n    p[:, 0] = upright_width * p[:, 0]\n    p[:, 1] = upright_height * p[:, 1]\n    return p",
            "def opensfm_to_upright(coords: np.ndarray, width: int, height: int, orientation: int, new_width: Optional[int]=None, new_height: Optional[int]=None) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Transform opensfm coordinates to upright coordinates, correcting for EXIF orientation.\\n\\n    :param coords: Points in opensfm coordinate system.\\n    :param width: Width of original image in pixels unadjusted for orientation.\\n    :param height: Height of original image in pixels unadjusted for orientation.\\n    :param orientation: Orientation of original image.\\n\\n    :return: Points in upright coordinate system.\\n\\n    >>> sfm = np.array([[-0.5, -0.375],\\n    ...                 [-0.5,  0.375],\\n    ...                 [ 0.5, -0.375],\\n    ...                 [ 0.5,  0.375]])\\n    >>> opensfm_to_upright(sfm, 320, 240, 1)\\n    array([[   0.,    0.],\\n           [   0.,  240.],\\n           [ 320.,    0.],\\n           [ 320.,  240.]])\\n    '\n    R = {1: np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), 3: np.array([[-1, 0, 1], [0, -1, 1], [0, 0, 1]]), 6: np.array([[0, -1, 1], [1, 0, 0], [0, 0, 1]]), 8: np.array([[0, 1, 0], [-1, 0, 1], [0, 0, 1]])}\n    w = float(width)\n    h = float(height)\n    s = max(w, h)\n    H = np.array([[s / w, 0, 0.5], [0, s / h, 0.5], [0, 0, 1]])\n    T = np.dot(R[orientation], H)\n    p = np.dot(coords, T[:2, :2].T) + T[:2, 2].reshape(1, 2)\n    upright_width = width if orientation < 6 else height\n    upright_height = height if orientation < 6 else width\n    if new_width is not None:\n        upright_width = new_width\n    if new_height is not None:\n        upright_height = new_height\n    p[:, 0] = upright_width * p[:, 0]\n    p[:, 1] = upright_height * p[:, 1]\n    return p",
            "def opensfm_to_upright(coords: np.ndarray, width: int, height: int, orientation: int, new_width: Optional[int]=None, new_height: Optional[int]=None) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Transform opensfm coordinates to upright coordinates, correcting for EXIF orientation.\\n\\n    :param coords: Points in opensfm coordinate system.\\n    :param width: Width of original image in pixels unadjusted for orientation.\\n    :param height: Height of original image in pixels unadjusted for orientation.\\n    :param orientation: Orientation of original image.\\n\\n    :return: Points in upright coordinate system.\\n\\n    >>> sfm = np.array([[-0.5, -0.375],\\n    ...                 [-0.5,  0.375],\\n    ...                 [ 0.5, -0.375],\\n    ...                 [ 0.5,  0.375]])\\n    >>> opensfm_to_upright(sfm, 320, 240, 1)\\n    array([[   0.,    0.],\\n           [   0.,  240.],\\n           [ 320.,    0.],\\n           [ 320.,  240.]])\\n    '\n    R = {1: np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), 3: np.array([[-1, 0, 1], [0, -1, 1], [0, 0, 1]]), 6: np.array([[0, -1, 1], [1, 0, 0], [0, 0, 1]]), 8: np.array([[0, 1, 0], [-1, 0, 1], [0, 0, 1]])}\n    w = float(width)\n    h = float(height)\n    s = max(w, h)\n    H = np.array([[s / w, 0, 0.5], [0, s / h, 0.5], [0, 0, 1]])\n    T = np.dot(R[orientation], H)\n    p = np.dot(coords, T[:2, :2].T) + T[:2, 2].reshape(1, 2)\n    upright_width = width if orientation < 6 else height\n    upright_height = height if orientation < 6 else width\n    if new_width is not None:\n        upright_width = new_width\n    if new_height is not None:\n        upright_height = new_height\n    p[:, 0] = upright_width * p[:, 0]\n    p[:, 1] = upright_height * p[:, 1]\n    return p",
            "def opensfm_to_upright(coords: np.ndarray, width: int, height: int, orientation: int, new_width: Optional[int]=None, new_height: Optional[int]=None) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Transform opensfm coordinates to upright coordinates, correcting for EXIF orientation.\\n\\n    :param coords: Points in opensfm coordinate system.\\n    :param width: Width of original image in pixels unadjusted for orientation.\\n    :param height: Height of original image in pixels unadjusted for orientation.\\n    :param orientation: Orientation of original image.\\n\\n    :return: Points in upright coordinate system.\\n\\n    >>> sfm = np.array([[-0.5, -0.375],\\n    ...                 [-0.5,  0.375],\\n    ...                 [ 0.5, -0.375],\\n    ...                 [ 0.5,  0.375]])\\n    >>> opensfm_to_upright(sfm, 320, 240, 1)\\n    array([[   0.,    0.],\\n           [   0.,  240.],\\n           [ 320.,    0.],\\n           [ 320.,  240.]])\\n    '\n    R = {1: np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), 3: np.array([[-1, 0, 1], [0, -1, 1], [0, 0, 1]]), 6: np.array([[0, -1, 1], [1, 0, 0], [0, 0, 1]]), 8: np.array([[0, 1, 0], [-1, 0, 1], [0, 0, 1]])}\n    w = float(width)\n    h = float(height)\n    s = max(w, h)\n    H = np.array([[s / w, 0, 0.5], [0, s / h, 0.5], [0, 0, 1]])\n    T = np.dot(R[orientation], H)\n    p = np.dot(coords, T[:2, :2].T) + T[:2, 2].reshape(1, 2)\n    upright_width = width if orientation < 6 else height\n    upright_height = height if orientation < 6 else width\n    if new_width is not None:\n        upright_width = new_width\n    if new_height is not None:\n        upright_height = new_height\n    p[:, 0] = upright_width * p[:, 0]\n    p[:, 1] = upright_height * p[:, 1]\n    return p",
            "def opensfm_to_upright(coords: np.ndarray, width: int, height: int, orientation: int, new_width: Optional[int]=None, new_height: Optional[int]=None) -> np.ndarray:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Transform opensfm coordinates to upright coordinates, correcting for EXIF orientation.\\n\\n    :param coords: Points in opensfm coordinate system.\\n    :param width: Width of original image in pixels unadjusted for orientation.\\n    :param height: Height of original image in pixels unadjusted for orientation.\\n    :param orientation: Orientation of original image.\\n\\n    :return: Points in upright coordinate system.\\n\\n    >>> sfm = np.array([[-0.5, -0.375],\\n    ...                 [-0.5,  0.375],\\n    ...                 [ 0.5, -0.375],\\n    ...                 [ 0.5,  0.375]])\\n    >>> opensfm_to_upright(sfm, 320, 240, 1)\\n    array([[   0.,    0.],\\n           [   0.,  240.],\\n           [ 320.,    0.],\\n           [ 320.,  240.]])\\n    '\n    R = {1: np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), 3: np.array([[-1, 0, 1], [0, -1, 1], [0, 0, 1]]), 6: np.array([[0, -1, 1], [1, 0, 0], [0, 0, 1]]), 8: np.array([[0, 1, 0], [-1, 0, 1], [0, 0, 1]])}\n    w = float(width)\n    h = float(height)\n    s = max(w, h)\n    H = np.array([[s / w, 0, 0.5], [0, s / h, 0.5], [0, 0, 1]])\n    T = np.dot(R[orientation], H)\n    p = np.dot(coords, T[:2, :2].T) + T[:2, 2].reshape(1, 2)\n    upright_width = width if orientation < 6 else height\n    upright_height = height if orientation < 6 else width\n    if new_width is not None:\n        upright_width = new_width\n    if new_height is not None:\n        upright_height = new_height\n    p[:, 0] = upright_width * p[:, 0]\n    p[:, 1] = upright_height * p[:, 1]\n    return p"
        ]
    }
]