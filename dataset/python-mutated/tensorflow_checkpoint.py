import os
import shutil
import tempfile
from typing import TYPE_CHECKING, Optional
import tensorflow as tf
from tensorflow import keras
from ray.train._internal.framework_checkpoint import FrameworkCheckpoint
from ray.util.annotations import PublicAPI
if TYPE_CHECKING:
    from ray.data.preprocessor import Preprocessor

@PublicAPI(stability='beta')
class TensorflowCheckpoint(FrameworkCheckpoint):
    """A :py:class:`~ray.train.Checkpoint` with TensorFlow-specific functionality."""
    MODEL_FILENAME_KEY = '_model_filename'

    @classmethod
    def from_model(cls, model: keras.Model, *, preprocessor: Optional['Preprocessor']=None) -> 'TensorflowCheckpoint':
        if False:
            print('Hello World!')
        'Create a :py:class:`~ray.train.Checkpoint` that stores a Keras model.\n\n        The checkpoint created with this method needs to be paired with\n        `model` when used.\n\n        Args:\n            model: The Keras model, whose weights are stored in the checkpoint.\n            preprocessor: A fitted preprocessor to be applied before inference.\n\n        Returns:\n            A :py:class:`TensorflowCheckpoint` containing the specified model.\n\n        Examples:\n\n            .. testcode::\n\n                from ray.train.tensorflow import TensorflowCheckpoint\n                import tensorflow as tf\n\n                model = tf.keras.applications.resnet.ResNet101()\n                checkpoint = TensorflowCheckpoint.from_model(model)\n\n            .. testoutput::\n                :options: +MOCK\n                :hide:\n\n                ...  # Model may or may not be downloaded\n\n        '
        tempdir = tempfile.mkdtemp()
        filename = 'model.keras'
        model.save(os.path.join(tempdir, filename))
        checkpoint = cls.from_directory(tempdir)
        if preprocessor:
            checkpoint.set_preprocessor(preprocessor)
        checkpoint.update_metadata({cls.MODEL_FILENAME_KEY: filename})
        return checkpoint

    @classmethod
    def from_h5(cls, file_path: str, *, preprocessor: Optional['Preprocessor']=None) -> 'TensorflowCheckpoint':
        if False:
            i = 10
            return i + 15
        'Create a :py:class:`~ray.train.Checkpoint` that stores a Keras\n        model from H5 format.\n\n        The checkpoint generated by this method contains all the information needed.\n        Thus no `model` is needed to be supplied when using this checkpoint.\n\n        Args:\n            file_path: The path to the .h5 file to load model from. This is the\n                same path that is used for ``model.save(path)``.\n            preprocessor: A fitted preprocessor to be applied before inference.\n\n        Returns:\n            A :py:class:`TensorflowCheckpoint` converted from h5 format.\n\n        '
        if not os.path.isfile(file_path) or not file_path.endswith('.h5'):
            raise ValueError('Please supply a h5 file path to `TensorflowCheckpoint.from_h5()`.')
        tempdir = tempfile.mkdtemp()
        filename = os.path.basename(file_path)
        new_checkpoint_file = os.path.join(tempdir, filename)
        shutil.copy(file_path, new_checkpoint_file)
        checkpoint = cls.from_directory(tempdir)
        if preprocessor:
            checkpoint.set_preprocessor(preprocessor)
        checkpoint.update_metadata({cls.MODEL_FILENAME_KEY: filename})
        return checkpoint

    @classmethod
    def from_saved_model(cls, dir_path: str, *, preprocessor: Optional['Preprocessor']=None) -> 'TensorflowCheckpoint':
        if False:
            print('Hello World!')
        'Create a :py:class:`~ray.train.Checkpoint` that stores a Keras\n        model from SavedModel format.\n\n        The checkpoint generated by this method contains all the information needed.\n        Thus no `model` is needed to be supplied when using this checkpoint.\n\n        Args:\n            dir_path: The directory containing the saved model. This is the same\n                directory as used by ``model.save(dir_path)``.\n            preprocessor: A fitted preprocessor to be applied before inference.\n\n        Returns:\n            A :py:class:`TensorflowCheckpoint` converted from SavedModel format.\n\n        '
        if not os.path.isdir(dir_path):
            raise ValueError('Please supply a directory to `TensorflowCheckpoint.from_saved_model`')
        tempdir = tempfile.mkdtemp()
        os.rmdir(tempdir)
        shutil.copytree(dir_path, tempdir)
        checkpoint = cls.from_directory(tempdir)
        if preprocessor:
            checkpoint.set_preprocessor(preprocessor)
        checkpoint.update_metadata({cls.MODEL_FILENAME_KEY: '.'})
        return checkpoint

    def get_model(self) -> tf.keras.Model:
        if False:
            for i in range(10):
                print('nop')
        'Retrieve the model stored in this checkpoint.\n\n        Returns:\n            The Tensorflow Keras model stored in the checkpoint.\n        '
        metadata = self.get_metadata()
        if self.MODEL_FILENAME_KEY not in metadata:
            raise ValueError('`TensorflowCheckpoint` cannot retrieve the model if you override the checkpoint metadata. Please use `Checkpoint.update_metadata` instead.')
        model_filename = metadata[self.MODEL_FILENAME_KEY]
        with self.as_directory() as checkpoint_dir:
            model_path = os.path.join(checkpoint_dir, model_filename)
            return keras.models.load_model(model_path)