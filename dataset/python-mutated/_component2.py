"""
Implementation of the app Component classes (LocalComponent,
ProxyComponent, StubComponent), which form the basis for the
PyComponent and JsComponent classes (and their proxies).
"""
import sys
from pscript import window, JSString, this_is_js
from .. import event
from ..event import Component, loop, Dict
from ..event._component import with_metaclass, ComponentMeta
from ..event._property import Property
from ..event._emitter import EmitterDescriptor
from ..event._action import ActionDescriptor
from ..event._js import create_js_component_class
from ._asset import get_mod_name
from . import logger
from ._clientcore import serializer, bsdf
manager = None

def make_proxy_action(action):
    if False:
        while True:
            i = 10
    flx_name = action._name

    def flx_proxy_action(self, *args):
        if False:
            return 10
        self._proxy_action(flx_name, *args)
        return self
    flx_proxy_action.__doc__ = action.__doc__
    flx_proxy_action.__qualname__ = 'flx_proxy_action'
    return flx_proxy_action

def make_proxy_emitter(emitter):
    if False:
        for i in range(10):
            print('nop')
    flx_name = emitter._name

    def flx_proxy_emitter(self, *args):
        if False:
            print('Hello World!')
        self._proxy_emitter(flx_name, *args)
    flx_proxy_emitter.__doc__ = emitter.__doc__
    flx_proxy_emitter.__qualname__ = 'flx_proxy_emitter'
    return flx_proxy_emitter

def get_component_classes():
    if False:
        return 10
    ' Get a list of all known PyComponent and JsComponent subclasses.\n    '
    return [c for c in AppComponentMeta.CLASSES]

def meta_repr(cls):
    if False:
        for i in range(10):
            print('nop')
    ' A repr function to provide some context on the purpose of a class.\n    '
    if issubclass(cls, PyComponent):
        prefix = 'PyComponent class'
    elif issubclass(cls, PyComponent.JS):
        prefix = 'proxy PyComponent class for JS '
    elif issubclass(cls, JsComponent):
        prefix = 'proxy JsComponent class'
    elif issubclass(cls, JsComponent.JS):
        prefix = 'JsComponent class for JS'
    else:
        prefix = 'class'
    return "<%s '%s.%s'>" % (prefix, cls.__module__, cls.__name__)

class LocalProperty(Property):
    """ A generic property that is only present at the local side of
    the component, i.e. not at the proxy. Intended for properties that
    the other side should not care about, and/or for wich syncing would be
    problematic, e.g. for performance or because it contains components
    that we want to keep local.
    """

class ComponentMetaJS(ComponentMeta):
    """ Meta class for autogenerated classes intended for JavaScript:
    Proxy PyComponent and local JsComponents.
    """
    __repr__ = meta_repr

    def __init__(cls, name, *args):
        if False:
            print('Hello World!')
        name = name.encode() if sys.version_info[0] == 2 else name
        return super().__init__(name, *args)

class AppComponentMeta(ComponentMeta):
    """ Meta class for PyComponent and JsComponent
    that generate a matching class for JS.
    """
    CLASSES = []
    __repr__ = meta_repr

    def _init_hook1(cls, cls_name, bases, dct):
        if False:
            print('Hello World!')
        CSS = dct.get('CSS', '')
        if issubclass(cls, LocalComponent):
            cls._make_js_proxy_class(cls_name, bases, dct)
        elif issubclass(cls, ProxyComponent):
            cls._make_js_local_class(cls_name, bases, dct)
        else:
            raise TypeError('Expected class to inherit from LocalComponent or ProxyComponent.')
        cls.__jsmodule__ = get_mod_name(sys.modules[cls.__module__])
        cls.JS.__jsmodule__ = cls.__jsmodule__
        cls.JS.__module__ = cls.__module__
        cls.CSS = CSS
        try:
            delattr(cls.JS, 'CSS')
        except AttributeError:
            pass

    def _init_hook2(cls, cls_name, bases, dct):
        if False:
            i = 10
            return i + 15
        if issubclass(cls, LocalComponent):
            cls.__proxy_properties__ = cls.JS.__properties__
            cls.JS.__emitters__ = cls.__emitters__
        else:
            cls.JS.__proxy_properties__ = cls.__properties__
            cls.__emitters__ = cls.JS.__emitters__
        cls.JS.CODE = cls._get_js()
        AppComponentMeta.CLASSES.append(cls)

    def _make_js_proxy_class(cls, cls_name, bases, dct):
        if False:
            for i in range(10):
                print('nop')
        for c in bases:
            assert not issubclass(cls, ProxyComponent)
        jsbases = [b.JS for b in cls.__bases__ if hasattr(b, 'JS')]
        if not jsbases:
            jsbases.append(ProxyComponent)
        jsdict = {}
        for (name, val) in dct.items():
            if name.startswith('__') and name.endswith('__'):
                continue
            elif isinstance(val, LocalProperty):
                pass
            elif isinstance(val, Property):
                jsdict[name] = val
            elif isinstance(val, EmitterDescriptor):
                jsdict[name] = make_proxy_emitter(val)
            elif isinstance(val, ActionDescriptor):
                jsdict[name] = make_proxy_action(val)
            else:
                pass
        cls.JS = ComponentMetaJS(cls_name, tuple(jsbases), jsdict)

    def _make_js_local_class(cls, cls_name, bases, dct):
        if False:
            return 10
        for c in bases:
            assert not issubclass(cls, LocalComponent)
        jsbases = [b.JS for b in cls.__bases__ if hasattr(b, 'JS')]
        if not jsbases:
            jsbases.append(LocalComponent)
        jsdict = {}
        py_only = ['_repr_html_']
        for (name, val) in list(dct.items()):
            if isinstance(val, classmethod):
                continue
            elif name in py_only or (name.startswith('__') and name.endswith('__')):
                if name not in ('__init__', '__linenr__'):
                    continue
            if isinstance(val, Property) or (callable(val) and name.endswith('_validate')):
                jsdict[name] = val
                if isinstance(val, LocalProperty):
                    delattr(cls, name)
                    dct.pop(name, None)
            elif isinstance(val, EmitterDescriptor):
                jsdict[name] = val
                setattr(cls, name, make_proxy_emitter(val))
            elif isinstance(val, ActionDescriptor):
                jsdict[name] = val
                setattr(cls, name, make_proxy_action(val))
            else:
                jsdict[name] = val
                delattr(cls, name)
                dct.pop(name, None)
        cls.JS = ComponentMetaJS(cls_name, tuple(jsbases), jsdict)

    def _get_js(cls):
        if False:
            while True:
                i = 10
        ' Get source code for this class plus the meta info about the code.\n        '
        cls_name = cls.__name__
        base_class = cls.JS.mro()[1]
        base_class_name = '%s.prototype' % base_class.__name__
        code = []
        c = create_js_component_class(cls.JS, cls_name, base_class_name)
        meta = c.meta
        code.append(c)
        if cls.__name__ == 'JsComponent':
            c = cls._get_js_of_base_classes()
            for k in ['vars_unknown', 'vars_global', 'std_functions', 'std_methods']:
                meta[k].update(c.meta[k])
            code.insert(0, c)
        js = JSString('\n'.join(code))
        js.meta = meta
        return js

    def _get_js_of_base_classes(cls):
        if False:
            print('Hello World!')
        ' Get JS for BaseAppComponent, LocalComponent, and ProxyComponent.\n        '
        c1 = create_js_component_class(BaseAppComponent, 'BaseAppComponent', 'Component.prototype')
        c2 = create_js_component_class(LocalComponent, 'LocalComponent', 'BaseAppComponent.prototype')
        c3 = create_js_component_class(ProxyComponent, 'ProxyComponent', 'BaseAppComponent.prototype')
        c4 = create_js_component_class(StubComponent, 'StubComponent', 'BaseAppComponent.prototype')
        meta = c1.meta
        for k in ['vars_unknown', 'vars_global', 'std_functions', 'std_methods']:
            for c in (c2, c3, c4):
                meta[k].update(c.meta[k])
        js = JSString('\n'.join([c1, c2, c3, c4]))
        js.meta = meta
        return js

class BaseAppComponent(Component):
    """ Inherits from :class:`Component <flexx.event.Component>`

    Abstract class for Component classes that can be "shared" between
    Python and JavaScript. The concrete implementations are:

    * The ``PyComponent`` class, which operates in Python, but has a proxy
      object in JavaSript to which properties are synced and from which actions
      can be invoked.
    * The ``JsComponent`` class, which operates in JavaScript, but can have a proxy
      object in Python to which properties are synced and from which actions
      can be invoked.
    * The ``StubComponent`` class, which represents a component class that is
      somewhere else, perhaps in another session. It does not have any
      properties, nor actions. But it can be "moved around".
    """
    session = event.Attribute(doc='\n        The session to which this component belongs. The component id\n        is unique within its session.\n        ')
    root = event.Attribute(doc='\n        The component that represents the root of the application. Alias for\n        session.app.\n        ')
    uid = event.Attribute(doc="\n        A unique identifier for this component; a combination of the\n        session and component id's.\n        ")

    def _comp_init_app_component(self, property_values):
        if False:
            return 10
        property_values.pop('flx_is_app', None)
        custom_id = property_values.pop('flx_id', None)
        self._session = None
        session = property_values.pop('flx_session', None)
        if session is not None:
            self._session = session
        else:
            active = loop.get_active_components()
            active = active[-2] if len(active) > 1 else None
            if active is not None:
                self._session = active._session
            elif not this_is_js():
                self._session = manager.get_default_session()
        if self._session is None:
            raise RuntimeError('%s needs a session!' % (custom_id or self._id))
        self._session._register_component(self, custom_id)
        self._root = self._session.app
        return custom_id is None

class LocalComponent(BaseAppComponent):
    """
    Base class for PyComponent in Python and JsComponent in JavaScript.
    """

    def _comp_init_property_values(self, property_values):
        if False:
            while True:
                i = 10
        self.__event_types_at_proxy = []
        self._comp_init_app_component(property_values)
        self._has_proxy = property_values.pop('flx_has_proxy', False)
        super()._comp_init_property_values(property_values)
        if this_is_js():
            self._event_listeners = []
        else:
            self._ensure_proxy_instance(False)

    def _ensure_proxy_instance(self, include_props=True):
        if False:
            print('Hello World!')
        ' Make the other end instantiate a proxy if necessary. This is e.g.\n        called by the BSDF serializer when a LocalComponent gets serialized.\n\n        A PyComponent always has a Proxy component, and we should not\n        dispose or delete it until the local component is disposed.\n\n        A JsComponent may be instantiated (as its proxy) from Python, in which\n        case we receive the flx_has_proxy kwarg. Still, Python can "loose" the\n        proxy class. To ensure that it exists in Python when needed, the BSDF\n        serializer will ensure it (by calling this method) when it gets\n        serialized.\n\n        In certain cases, it might be that the other end *does* have a proxy\n        while this end\'s _has_proxy is False. In that case the INSTANTIATE\n        command is send, but when handled, will be a no-op.\n\n        In certain cases, it might be that the other end just lost its\n        reference; this end\'s _has_proxy is True, and a new reference to this\n        component will fail to resolve. This is countered by keeping hold\n        of JsComponent proxy classes for at least one roundtrip (upon\n        initialization as well as disposal).\n        '
        if self._has_proxy is False and self._disposed is False:
            if self._session.status > 0:
                props = {}
                if include_props:
                    for name in self.__proxy_properties__:
                        props[name] = getattr(self, name)
                self._session.send_command('INSTANTIATE', self.__jsmodule__, self.__class__.__name__, self._id, [], props)
                self._has_proxy = True

    def emit(self, type, info=None):
        if False:
            while True:
                i = 10
        ev = super().emit(type, info)
        if self._has_proxy is True and self._session.status > 0:
            if type in self.__proxy_properties__:
                self._session.send_command('INVOKE', self._id, '_emit_at_proxy', [ev])
            elif type in self.__event_types_at_proxy:
                self._session.send_command('INVOKE', self._id, '_emit_at_proxy', [ev])

    def _dispose(self):
        if False:
            for i in range(10):
                print('nop')
        was_disposed = self._disposed
        super()._dispose()
        self._has_proxy = False
        if was_disposed is False and self._session is not None:
            self._session._unregister_component(self)
            if self._session.status > 0:
                self._session.send_command('DISPOSE', self._id)

    def _flx_set_has_proxy(self, has_proxy):
        if False:
            for i in range(10):
                print('nop')
        self._has_proxy = has_proxy

    def _flx_set_event_types_at_proxy(self, event_types):
        if False:
            return 10
        self.__event_types_at_proxy = event_types

class ProxyComponent(BaseAppComponent):
    """
    Base class for JSComponent in Python and PyComponent in JavaScript.
    """

    def __init__(self, *init_args, **kwargs):
        if False:
            return 10
        if this_is_js():
            assert len(init_args) == 0
            if 'flx_id' not in kwargs:
                raise RuntimeError('Cannot instantiate a PyComponent from JS.')
            super().__init__(**kwargs)
        else:
            self._flx_init_args = init_args
            super().__init__(**kwargs)

    def _comp_init_property_values(self, property_values):
        if False:
            print('Hello World!')
        local_inst = self._comp_init_app_component(property_values)
        props2set = {} if local_inst else property_values
        for name in list(property_values.keys()):
            if callable(property_values[name]):
                props2set[name] = property_values.pop(name)
        super()._comp_init_property_values(props2set)
        if this_is_js():
            assert len(property_values.keys()) == 0
        else:
            if local_inst is True:
                property_values['flx_has_proxy'] = True
                active_components = [c for c in loop.get_active_components()[:-1] if isinstance(c, (PyComponent, JsComponent))]
                self._session.send_command('INSTANTIATE', self.__jsmodule__, self.__class__.__name__, self._id, self._flx_init_args, property_values, active_components)
            del self._flx_init_args

    def _comp_apply_property_values(self, values):
        if False:
            i = 10
            return i + 15
        for (name, value) in values:
            setattr(self, '_' + name + '_value', value)

    def _proxy_action(self, name, *args, **kwargs):
        if False:
            return 10
        ' To invoke actions on the real object.\n        '
        assert not kwargs
        self._session.send_command('INVOKE', self._id, name, args)

    def _proxy_emitter(self, name, *args, **kwargs):
        if False:
            for i in range(10):
                print('nop')
        ' To handle use of placeholder emitters.\n        '
        if this_is_js():
            logger.error('Cannot use emitters of a PyComponent in JS.')
        else:
            logger.error('Cannot use emitters of a JsComponent in Py.')

    def _mutate(self, *args, **kwargs):
        if False:
            return 10
        ' Disable mutations on the proxy class.\n        '
        raise RuntimeError('Cannot mutate properties from a proxy class.')
        serializer
        BsdfComponentExtension

    def _registered_reactions_hook(self):
        if False:
            return 10
        " Keep the local component informed about what event types this proxy\n        is interested in. This way, the trafic can be minimized, e.g. not send\n        mouse move events if they're not used anyway.\n        "
        event_types = super()._registered_reactions_hook()
        try:
            if self._disposed is False and self._session.status > 0:
                self._session.send_command('INVOKE', self._id, '_flx_set_event_types_at_proxy', [event_types])
        except Exception:
            pass
        return event_types

    @event.action
    def _emit_at_proxy(self, ev):
        if False:
            while True:
                i = 10
        ' Action used by the local component to push an event to the proxy\n        component. If the event represents a property-update, the mutation\n        is applied, otherwise the event is emitted here.\n        '
        if not this_is_js():
            ev = Dict(ev)
        if ev.type in self.__properties__ and hasattr(ev, 'mutation'):
            if ev.mutation == 'set':
                super()._mutate(ev.type, ev.new_value)
            else:
                super()._mutate(ev.type, ev.objects, ev.mutation, ev.index)
        else:
            self.emit(ev.type, ev)

    def dispose(self):
        if False:
            return 10
        if this_is_js():
            raise RuntimeError('Cannot dispose a PyComponent from JS.')
        elif self._session.status > 0:
            self._session.send_command('INVOKE', self._id, 'dispose', [])
        else:
            super().dispose()

    def _dispose(self):
        if False:
            i = 10
            return i + 15
        was_disposed = self._disposed
        super()._dispose()
        if was_disposed is False and self._session is not None:
            self._session._unregister_component(self)
            if self._session.status > 0:
                self._session.send_command('INVOKE', self._id, '_flx_set_has_proxy', [False])

class StubComponent(BaseAppComponent):
    """
    Class to represent stub proxy components to take the place of components
    that do not belong to the current session, or that do not exist
    for whatever reason. These objects cannot really be used, but they can
    be moved around.
    """

    def __init__(self, session, id):
        if False:
            while True:
                i = 10
        super().__init__()
        self._session = session
        self._id = id
        self._uid = session.id + '_' + id

    def __repr__(self):
        if False:
            while True:
                i = 10
        return "<StubComponent for '%s' in session '%s' at 0x%x>" % (self._id, self._session.id, id(self))
LocalComponent.__jsmodule__ = __name__
ProxyComponent.__jsmodule__ = __name__
StubComponent.__jsmodule__ = __name__

class JsComponent(with_metaclass(AppComponentMeta, ProxyComponent)):
    """ Inherits from :class:`BaseAppComponent <flexx.app.BaseAppComponent>`

    Base component class that operates in JavaScript, but is accessible
    in Python, where its properties and events can be observed,
    and actions can be invoked.

    JsComponents can be instantiated from both JavaScript and Python. A
    corresponding proxy component is not necessarily present in Python. It
    is created automatically when needed (e.g. when referenced by a property).
    A JsComponent can be explicitly disposed from both Python and JavaScript.
    When the Python garbage collector collects a JsComponent (or really, the
    proxy thereof), only the Python side proxy is disposed; the JsComponent
    in JS itself will be unaffected. Make sure to call ``dispose()`` when
    needed!

    """

    def __repr__(self):
        if False:
            while True:
                i = 10
        d = ' (disposed)' if self._disposed else ''
        return "<JsComponent '%s'%s at 0x%x>" % (self._id, d, id(self))

    def _addEventListener(self, node, type, callback, capture=False):
        if False:
            for i in range(10):
                print('nop')
        ' Register events with DOM nodes, to be automatically cleaned up\n        when this object is disposed.\n        '
        node.addEventListener(type, callback, capture)
        self._event_listeners.push((node, type, callback, capture))

    def _dispose(self):
        if False:
            while True:
                i = 10
        super()._dispose()
        while len(self._event_listeners) > 0:
            try:
                (node, type, callback, capture) = self._event_listeners.pop()
                node.removeEventListener(type, callback, capture)
            except Exception as err:
                print(err)

class PyComponent(with_metaclass(AppComponentMeta, LocalComponent)):
    """ Inherits from :class:`BaseAppComponent <flexx.app.BaseAppComponent>`

    Base component class that operates in Python, but is accessible
    in JavaScript, where its properties and events can be observed,
    and actions can be invoked.

    PyComponents can only be instantiated in Python, and always have
    a corresponding proxy object in JS. PyComponents can be disposed only
    from Python. Disposal also happens if the Python garbage collector
    collects a PyComponent.

    """

    def __repr__(self):
        if False:
            i = 10
            return i + 15
        d = ' (disposed)' if self._disposed else ''
        return "<PyComponent '%s'%s at 0x%x>" % (self._id, d, id(self))

class BsdfComponentExtension(bsdf.Extension):
    """ A BSDF extension to encode flexx.app Component objects based on their
    session id and component id.
    """
    name = 'flexx.app.component'
    cls = BaseAppComponent

    def match(self, s, c):
        if False:
            for i in range(10):
                print('nop')
        return isinstance(c, self.cls)

    def encode(self, s, c):
        if False:
            for i in range(10):
                print('nop')
        if isinstance(c, PyComponent):
            c._ensure_proxy_instance()
        return dict(session_id=c._session.id, id=c._id)

    def decode(self, s, d):
        if False:
            while True:
                i = 10
        c = None
        session = manager.get_session_by_id(d['session_id'])
        if session is None:
            session = object()
            session.id = d['session_id']
            c = StubComponent(session, d['id'])
        else:
            c = session.get_component_instance(d['id'])
            if c is None:
                logger.warning('Using stub component for %s.' % d['id'])
                c = StubComponent(session, d['id'])
            else:
                session.keep_alive(c)
        return c

    def match_js(self, s, c):
        if False:
            print('Hello World!')
        return isinstance(c, BaseAppComponent)

    def encode_js(self, s, c):
        if False:
            i = 10
            return i + 15
        if isinstance(c, JsComponent):
            c._ensure_proxy_instance()
        return dict(session_id=c._session.id, id=c._id)

    def decode_js(self, s, d):
        if False:
            i = 10
            return i + 15
        c = None
        session = window.flexx.sessions.get(d['session_id'], None)
        if session is None:
            session = dict(id=d['session_id'])
            c = StubComponent(session, d['id'])
        else:
            c = session.get_component_instance(d['id'])
            if c is None:
                logger.warning('Using stub component for %s.' % d['id'])
                c = StubComponent(session, d['id'])
        return c
serializer.add_extension(BsdfComponentExtension)