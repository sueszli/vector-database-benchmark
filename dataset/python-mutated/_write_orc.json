[
    {
        "func_name": "_new_writer",
        "original": "@contextmanager\ndef _new_writer(file_path: str, compression: Optional[str], pyarrow_additional_kwargs: Optional[Dict[str, Any]], s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int]) -> Iterator['ORCWriter']:\n    from pyarrow.orc import ORCWriter\n    writer: Optional['ORCWriter'] = None\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    with open_s3_object(path=file_path, mode='wb', use_threads=use_threads, s3_additional_kwargs=s3_additional_kwargs, s3_client=s3_client) as f:\n        try:\n            writer = ORCWriter(where=f, compression='uncompressed' if compression is None else compression, **pyarrow_additional_kwargs)\n            yield writer\n        finally:\n            if writer is not None and writer.is_open is True:\n                writer.close()",
        "mutated": [
            "@contextmanager\ndef _new_writer(file_path: str, compression: Optional[str], pyarrow_additional_kwargs: Optional[Dict[str, Any]], s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int]) -> Iterator['ORCWriter']:\n    if False:\n        i = 10\n    from pyarrow.orc import ORCWriter\n    writer: Optional['ORCWriter'] = None\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    with open_s3_object(path=file_path, mode='wb', use_threads=use_threads, s3_additional_kwargs=s3_additional_kwargs, s3_client=s3_client) as f:\n        try:\n            writer = ORCWriter(where=f, compression='uncompressed' if compression is None else compression, **pyarrow_additional_kwargs)\n            yield writer\n        finally:\n            if writer is not None and writer.is_open is True:\n                writer.close()",
            "@contextmanager\ndef _new_writer(file_path: str, compression: Optional[str], pyarrow_additional_kwargs: Optional[Dict[str, Any]], s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int]) -> Iterator['ORCWriter']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    from pyarrow.orc import ORCWriter\n    writer: Optional['ORCWriter'] = None\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    with open_s3_object(path=file_path, mode='wb', use_threads=use_threads, s3_additional_kwargs=s3_additional_kwargs, s3_client=s3_client) as f:\n        try:\n            writer = ORCWriter(where=f, compression='uncompressed' if compression is None else compression, **pyarrow_additional_kwargs)\n            yield writer\n        finally:\n            if writer is not None and writer.is_open is True:\n                writer.close()",
            "@contextmanager\ndef _new_writer(file_path: str, compression: Optional[str], pyarrow_additional_kwargs: Optional[Dict[str, Any]], s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int]) -> Iterator['ORCWriter']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    from pyarrow.orc import ORCWriter\n    writer: Optional['ORCWriter'] = None\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    with open_s3_object(path=file_path, mode='wb', use_threads=use_threads, s3_additional_kwargs=s3_additional_kwargs, s3_client=s3_client) as f:\n        try:\n            writer = ORCWriter(where=f, compression='uncompressed' if compression is None else compression, **pyarrow_additional_kwargs)\n            yield writer\n        finally:\n            if writer is not None and writer.is_open is True:\n                writer.close()",
            "@contextmanager\ndef _new_writer(file_path: str, compression: Optional[str], pyarrow_additional_kwargs: Optional[Dict[str, Any]], s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int]) -> Iterator['ORCWriter']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    from pyarrow.orc import ORCWriter\n    writer: Optional['ORCWriter'] = None\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    with open_s3_object(path=file_path, mode='wb', use_threads=use_threads, s3_additional_kwargs=s3_additional_kwargs, s3_client=s3_client) as f:\n        try:\n            writer = ORCWriter(where=f, compression='uncompressed' if compression is None else compression, **pyarrow_additional_kwargs)\n            yield writer\n        finally:\n            if writer is not None and writer.is_open is True:\n                writer.close()",
            "@contextmanager\ndef _new_writer(file_path: str, compression: Optional[str], pyarrow_additional_kwargs: Optional[Dict[str, Any]], s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int]) -> Iterator['ORCWriter']:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    from pyarrow.orc import ORCWriter\n    writer: Optional['ORCWriter'] = None\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    with open_s3_object(path=file_path, mode='wb', use_threads=use_threads, s3_additional_kwargs=s3_additional_kwargs, s3_client=s3_client) as f:\n        try:\n            writer = ORCWriter(where=f, compression='uncompressed' if compression is None else compression, **pyarrow_additional_kwargs)\n            yield writer\n        finally:\n            if writer is not None and writer.is_open is True:\n                writer.close()"
        ]
    },
    {
        "func_name": "_write_chunk",
        "original": "def _write_chunk(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, str], table: pa.Table, offset: int, chunk_size: int, use_threads: Union[bool, int]) -> List[str]:\n    write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n    with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n        writer.write(table.slice(offset, chunk_size), **write_table_args)\n    return [file_path]",
        "mutated": [
            "def _write_chunk(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, str], table: pa.Table, offset: int, chunk_size: int, use_threads: Union[bool, int]) -> List[str]:\n    if False:\n        i = 10\n    write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n    with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n        writer.write(table.slice(offset, chunk_size), **write_table_args)\n    return [file_path]",
            "def _write_chunk(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, str], table: pa.Table, offset: int, chunk_size: int, use_threads: Union[bool, int]) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n    with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n        writer.write(table.slice(offset, chunk_size), **write_table_args)\n    return [file_path]",
            "def _write_chunk(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, str], table: pa.Table, offset: int, chunk_size: int, use_threads: Union[bool, int]) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n    with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n        writer.write(table.slice(offset, chunk_size), **write_table_args)\n    return [file_path]",
            "def _write_chunk(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, str], table: pa.Table, offset: int, chunk_size: int, use_threads: Union[bool, int]) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n    with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n        writer.write(table.slice(offset, chunk_size), **write_table_args)\n    return [file_path]",
            "def _write_chunk(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, str], table: pa.Table, offset: int, chunk_size: int, use_threads: Union[bool, int]) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n    with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n        writer.write(table.slice(offset, chunk_size), **write_table_args)\n    return [file_path]"
        ]
    },
    {
        "func_name": "_to_orc_chunked",
        "original": "def _to_orc_chunked(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, Any], table: pa.Table, max_rows_by_file: int, num_of_rows: int, cpus: int) -> List[str]:\n    chunks: int = math.ceil(num_of_rows / max_rows_by_file)\n    use_threads: Union[bool, int] = cpus > 1\n    proxy: _WriteProxy = _WriteProxy(use_threads=use_threads)\n    for chunk in range(chunks):\n        offset: int = chunk * max_rows_by_file\n        write_path: str = _get_chunk_file_path(chunk, file_path)\n        proxy.write(func=_write_chunk, file_path=write_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, offset=offset, chunk_size=max_rows_by_file, use_threads=use_threads)\n    return proxy.close()",
        "mutated": [
            "def _to_orc_chunked(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, Any], table: pa.Table, max_rows_by_file: int, num_of_rows: int, cpus: int) -> List[str]:\n    if False:\n        i = 10\n    chunks: int = math.ceil(num_of_rows / max_rows_by_file)\n    use_threads: Union[bool, int] = cpus > 1\n    proxy: _WriteProxy = _WriteProxy(use_threads=use_threads)\n    for chunk in range(chunks):\n        offset: int = chunk * max_rows_by_file\n        write_path: str = _get_chunk_file_path(chunk, file_path)\n        proxy.write(func=_write_chunk, file_path=write_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, offset=offset, chunk_size=max_rows_by_file, use_threads=use_threads)\n    return proxy.close()",
            "def _to_orc_chunked(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, Any], table: pa.Table, max_rows_by_file: int, num_of_rows: int, cpus: int) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    chunks: int = math.ceil(num_of_rows / max_rows_by_file)\n    use_threads: Union[bool, int] = cpus > 1\n    proxy: _WriteProxy = _WriteProxy(use_threads=use_threads)\n    for chunk in range(chunks):\n        offset: int = chunk * max_rows_by_file\n        write_path: str = _get_chunk_file_path(chunk, file_path)\n        proxy.write(func=_write_chunk, file_path=write_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, offset=offset, chunk_size=max_rows_by_file, use_threads=use_threads)\n    return proxy.close()",
            "def _to_orc_chunked(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, Any], table: pa.Table, max_rows_by_file: int, num_of_rows: int, cpus: int) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    chunks: int = math.ceil(num_of_rows / max_rows_by_file)\n    use_threads: Union[bool, int] = cpus > 1\n    proxy: _WriteProxy = _WriteProxy(use_threads=use_threads)\n    for chunk in range(chunks):\n        offset: int = chunk * max_rows_by_file\n        write_path: str = _get_chunk_file_path(chunk, file_path)\n        proxy.write(func=_write_chunk, file_path=write_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, offset=offset, chunk_size=max_rows_by_file, use_threads=use_threads)\n    return proxy.close()",
            "def _to_orc_chunked(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, Any], table: pa.Table, max_rows_by_file: int, num_of_rows: int, cpus: int) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    chunks: int = math.ceil(num_of_rows / max_rows_by_file)\n    use_threads: Union[bool, int] = cpus > 1\n    proxy: _WriteProxy = _WriteProxy(use_threads=use_threads)\n    for chunk in range(chunks):\n        offset: int = chunk * max_rows_by_file\n        write_path: str = _get_chunk_file_path(chunk, file_path)\n        proxy.write(func=_write_chunk, file_path=write_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, offset=offset, chunk_size=max_rows_by_file, use_threads=use_threads)\n    return proxy.close()",
            "def _to_orc_chunked(file_path: str, s3_client: 'S3Client', s3_additional_kwargs: Optional[Dict[str, str]], compression: Optional[str], pyarrow_additional_kwargs: Dict[str, Any], table: pa.Table, max_rows_by_file: int, num_of_rows: int, cpus: int) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    chunks: int = math.ceil(num_of_rows / max_rows_by_file)\n    use_threads: Union[bool, int] = cpus > 1\n    proxy: _WriteProxy = _WriteProxy(use_threads=use_threads)\n    for chunk in range(chunks):\n        offset: int = chunk * max_rows_by_file\n        write_path: str = _get_chunk_file_path(chunk, file_path)\n        proxy.write(func=_write_chunk, file_path=write_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, offset=offset, chunk_size=max_rows_by_file, use_threads=use_threads)\n    return proxy.close()"
        ]
    },
    {
        "func_name": "_to_orc",
        "original": "@engine.dispatch_on_engine\ndef _to_orc(df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    s3_client = s3_client if s3_client else _utils.client(service_name='s3')\n    file_path = _get_file_path(path_root=path_root, path=path, filename_prefix=filename_prefix, compression_ext=compression_ext, extension='.orc')\n    table: pa.Table = _df_to_table(df, schema, index, dtype)\n    if max_rows_by_file is not None and max_rows_by_file > 0:\n        paths: List[str] = _to_orc_chunked(file_path=file_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, max_rows_by_file=max_rows_by_file, num_of_rows=df.shape[0], cpus=cpus)\n    else:\n        write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n        with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n            writer.write(table, **write_table_args)\n        paths = [file_path]\n    return paths",
        "mutated": [
            "@engine.dispatch_on_engine\ndef _to_orc(df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    if False:\n        i = 10\n    s3_client = s3_client if s3_client else _utils.client(service_name='s3')\n    file_path = _get_file_path(path_root=path_root, path=path, filename_prefix=filename_prefix, compression_ext=compression_ext, extension='.orc')\n    table: pa.Table = _df_to_table(df, schema, index, dtype)\n    if max_rows_by_file is not None and max_rows_by_file > 0:\n        paths: List[str] = _to_orc_chunked(file_path=file_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, max_rows_by_file=max_rows_by_file, num_of_rows=df.shape[0], cpus=cpus)\n    else:\n        write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n        with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n            writer.write(table, **write_table_args)\n        paths = [file_path]\n    return paths",
            "@engine.dispatch_on_engine\ndef _to_orc(df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s3_client = s3_client if s3_client else _utils.client(service_name='s3')\n    file_path = _get_file_path(path_root=path_root, path=path, filename_prefix=filename_prefix, compression_ext=compression_ext, extension='.orc')\n    table: pa.Table = _df_to_table(df, schema, index, dtype)\n    if max_rows_by_file is not None and max_rows_by_file > 0:\n        paths: List[str] = _to_orc_chunked(file_path=file_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, max_rows_by_file=max_rows_by_file, num_of_rows=df.shape[0], cpus=cpus)\n    else:\n        write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n        with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n            writer.write(table, **write_table_args)\n        paths = [file_path]\n    return paths",
            "@engine.dispatch_on_engine\ndef _to_orc(df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s3_client = s3_client if s3_client else _utils.client(service_name='s3')\n    file_path = _get_file_path(path_root=path_root, path=path, filename_prefix=filename_prefix, compression_ext=compression_ext, extension='.orc')\n    table: pa.Table = _df_to_table(df, schema, index, dtype)\n    if max_rows_by_file is not None and max_rows_by_file > 0:\n        paths: List[str] = _to_orc_chunked(file_path=file_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, max_rows_by_file=max_rows_by_file, num_of_rows=df.shape[0], cpus=cpus)\n    else:\n        write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n        with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n            writer.write(table, **write_table_args)\n        paths = [file_path]\n    return paths",
            "@engine.dispatch_on_engine\ndef _to_orc(df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s3_client = s3_client if s3_client else _utils.client(service_name='s3')\n    file_path = _get_file_path(path_root=path_root, path=path, filename_prefix=filename_prefix, compression_ext=compression_ext, extension='.orc')\n    table: pa.Table = _df_to_table(df, schema, index, dtype)\n    if max_rows_by_file is not None and max_rows_by_file > 0:\n        paths: List[str] = _to_orc_chunked(file_path=file_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, max_rows_by_file=max_rows_by_file, num_of_rows=df.shape[0], cpus=cpus)\n    else:\n        write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n        with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n            writer.write(table, **write_table_args)\n        paths = [file_path]\n    return paths",
            "@engine.dispatch_on_engine\ndef _to_orc(df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s3_client = s3_client if s3_client else _utils.client(service_name='s3')\n    file_path = _get_file_path(path_root=path_root, path=path, filename_prefix=filename_prefix, compression_ext=compression_ext, extension='.orc')\n    table: pa.Table = _df_to_table(df, schema, index, dtype)\n    if max_rows_by_file is not None and max_rows_by_file > 0:\n        paths: List[str] = _to_orc_chunked(file_path=file_path, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, table=table, max_rows_by_file=max_rows_by_file, num_of_rows=df.shape[0], cpus=cpus)\n    else:\n        write_table_args = _get_write_table_args(pyarrow_additional_kwargs)\n        with _new_writer(file_path=file_path, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads) as writer:\n            writer.write(table, **write_table_args)\n        paths = [file_path]\n    return paths"
        ]
    },
    {
        "func_name": "_write_to_s3_func",
        "original": "@property\ndef _write_to_s3_func(self) -> Callable[..., List[str]]:\n    return _to_orc",
        "mutated": [
            "@property\ndef _write_to_s3_func(self) -> Callable[..., List[str]]:\n    if False:\n        i = 10\n    return _to_orc",
            "@property\ndef _write_to_s3_func(self) -> Callable[..., List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return _to_orc",
            "@property\ndef _write_to_s3_func(self) -> Callable[..., List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return _to_orc",
            "@property\ndef _write_to_s3_func(self) -> Callable[..., List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return _to_orc",
            "@property\ndef _write_to_s3_func(self) -> Callable[..., List[str]]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return _to_orc"
        ]
    },
    {
        "func_name": "_write_to_s3",
        "original": "def _write_to_s3(self, df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    return _to_orc(df=df, schema=schema, index=index, compression=compression, compression_ext=compression_ext, pyarrow_additional_kwargs=pyarrow_additional_kwargs, cpus=cpus, dtype=dtype, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads, path=path, path_root=path_root, filename_prefix=filename_prefix, max_rows_by_file=max_rows_by_file, bucketing=bucketing)",
        "mutated": [
            "def _write_to_s3(self, df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    if False:\n        i = 10\n    return _to_orc(df=df, schema=schema, index=index, compression=compression, compression_ext=compression_ext, pyarrow_additional_kwargs=pyarrow_additional_kwargs, cpus=cpus, dtype=dtype, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads, path=path, path_root=path_root, filename_prefix=filename_prefix, max_rows_by_file=max_rows_by_file, bucketing=bucketing)",
            "def _write_to_s3(self, df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return _to_orc(df=df, schema=schema, index=index, compression=compression, compression_ext=compression_ext, pyarrow_additional_kwargs=pyarrow_additional_kwargs, cpus=cpus, dtype=dtype, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads, path=path, path_root=path_root, filename_prefix=filename_prefix, max_rows_by_file=max_rows_by_file, bucketing=bucketing)",
            "def _write_to_s3(self, df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return _to_orc(df=df, schema=schema, index=index, compression=compression, compression_ext=compression_ext, pyarrow_additional_kwargs=pyarrow_additional_kwargs, cpus=cpus, dtype=dtype, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads, path=path, path_root=path_root, filename_prefix=filename_prefix, max_rows_by_file=max_rows_by_file, bucketing=bucketing)",
            "def _write_to_s3(self, df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return _to_orc(df=df, schema=schema, index=index, compression=compression, compression_ext=compression_ext, pyarrow_additional_kwargs=pyarrow_additional_kwargs, cpus=cpus, dtype=dtype, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads, path=path, path_root=path_root, filename_prefix=filename_prefix, max_rows_by_file=max_rows_by_file, bucketing=bucketing)",
            "def _write_to_s3(self, df: pd.DataFrame, schema: pa.Schema, index: bool, compression: Optional[str], compression_ext: str, pyarrow_additional_kwargs: Dict[str, Any], cpus: int, dtype: Dict[str, str], s3_client: Optional['S3Client'], s3_additional_kwargs: Optional[Dict[str, str]], use_threads: Union[bool, int], path: Optional[str]=None, path_root: Optional[str]=None, filename_prefix: Optional[str]=None, max_rows_by_file: Optional[int]=0, bucketing: bool=False) -> List[str]:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return _to_orc(df=df, schema=schema, index=index, compression=compression, compression_ext=compression_ext, pyarrow_additional_kwargs=pyarrow_additional_kwargs, cpus=cpus, dtype=dtype, s3_client=s3_client, s3_additional_kwargs=s3_additional_kwargs, use_threads=use_threads, path=path, path_root=path_root, filename_prefix=filename_prefix, max_rows_by_file=max_rows_by_file, bucketing=bucketing)"
        ]
    },
    {
        "func_name": "_create_glue_table",
        "original": "def _create_glue_table(self, database: str, table: str, path: str, columns_types: Dict[str, str], table_type: Optional[str]=None, partitions_types: Optional[Dict[str, str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, description: Optional[str]=None, parameters: Optional[Dict[str, str]]=None, columns_comments: Optional[Dict[str, str]]=None, mode: str='overwrite', catalog_versioning: bool=False, transaction_id: Optional[str]=None, athena_partition_projection_settings: Optional[AthenaPartitionProjectionSettings]=None, boto3_session: Optional[boto3.Session]=None, catalog_table_input: Optional[Dict[str, Any]]=None) -> None:\n    return _create_orc_table(database=database, table=table, path=path, columns_types=columns_types, table_type=table_type, partitions_types=partitions_types, bucketing_info=bucketing_info, catalog_id=catalog_id, compression=compression, description=description, parameters=parameters, columns_comments=columns_comments, mode=mode, catalog_versioning=catalog_versioning, transaction_id=transaction_id, athena_partition_projection_settings=athena_partition_projection_settings, boto3_session=boto3_session, catalog_table_input=catalog_table_input)",
        "mutated": [
            "def _create_glue_table(self, database: str, table: str, path: str, columns_types: Dict[str, str], table_type: Optional[str]=None, partitions_types: Optional[Dict[str, str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, description: Optional[str]=None, parameters: Optional[Dict[str, str]]=None, columns_comments: Optional[Dict[str, str]]=None, mode: str='overwrite', catalog_versioning: bool=False, transaction_id: Optional[str]=None, athena_partition_projection_settings: Optional[AthenaPartitionProjectionSettings]=None, boto3_session: Optional[boto3.Session]=None, catalog_table_input: Optional[Dict[str, Any]]=None) -> None:\n    if False:\n        i = 10\n    return _create_orc_table(database=database, table=table, path=path, columns_types=columns_types, table_type=table_type, partitions_types=partitions_types, bucketing_info=bucketing_info, catalog_id=catalog_id, compression=compression, description=description, parameters=parameters, columns_comments=columns_comments, mode=mode, catalog_versioning=catalog_versioning, transaction_id=transaction_id, athena_partition_projection_settings=athena_partition_projection_settings, boto3_session=boto3_session, catalog_table_input=catalog_table_input)",
            "def _create_glue_table(self, database: str, table: str, path: str, columns_types: Dict[str, str], table_type: Optional[str]=None, partitions_types: Optional[Dict[str, str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, description: Optional[str]=None, parameters: Optional[Dict[str, str]]=None, columns_comments: Optional[Dict[str, str]]=None, mode: str='overwrite', catalog_versioning: bool=False, transaction_id: Optional[str]=None, athena_partition_projection_settings: Optional[AthenaPartitionProjectionSettings]=None, boto3_session: Optional[boto3.Session]=None, catalog_table_input: Optional[Dict[str, Any]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return _create_orc_table(database=database, table=table, path=path, columns_types=columns_types, table_type=table_type, partitions_types=partitions_types, bucketing_info=bucketing_info, catalog_id=catalog_id, compression=compression, description=description, parameters=parameters, columns_comments=columns_comments, mode=mode, catalog_versioning=catalog_versioning, transaction_id=transaction_id, athena_partition_projection_settings=athena_partition_projection_settings, boto3_session=boto3_session, catalog_table_input=catalog_table_input)",
            "def _create_glue_table(self, database: str, table: str, path: str, columns_types: Dict[str, str], table_type: Optional[str]=None, partitions_types: Optional[Dict[str, str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, description: Optional[str]=None, parameters: Optional[Dict[str, str]]=None, columns_comments: Optional[Dict[str, str]]=None, mode: str='overwrite', catalog_versioning: bool=False, transaction_id: Optional[str]=None, athena_partition_projection_settings: Optional[AthenaPartitionProjectionSettings]=None, boto3_session: Optional[boto3.Session]=None, catalog_table_input: Optional[Dict[str, Any]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return _create_orc_table(database=database, table=table, path=path, columns_types=columns_types, table_type=table_type, partitions_types=partitions_types, bucketing_info=bucketing_info, catalog_id=catalog_id, compression=compression, description=description, parameters=parameters, columns_comments=columns_comments, mode=mode, catalog_versioning=catalog_versioning, transaction_id=transaction_id, athena_partition_projection_settings=athena_partition_projection_settings, boto3_session=boto3_session, catalog_table_input=catalog_table_input)",
            "def _create_glue_table(self, database: str, table: str, path: str, columns_types: Dict[str, str], table_type: Optional[str]=None, partitions_types: Optional[Dict[str, str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, description: Optional[str]=None, parameters: Optional[Dict[str, str]]=None, columns_comments: Optional[Dict[str, str]]=None, mode: str='overwrite', catalog_versioning: bool=False, transaction_id: Optional[str]=None, athena_partition_projection_settings: Optional[AthenaPartitionProjectionSettings]=None, boto3_session: Optional[boto3.Session]=None, catalog_table_input: Optional[Dict[str, Any]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return _create_orc_table(database=database, table=table, path=path, columns_types=columns_types, table_type=table_type, partitions_types=partitions_types, bucketing_info=bucketing_info, catalog_id=catalog_id, compression=compression, description=description, parameters=parameters, columns_comments=columns_comments, mode=mode, catalog_versioning=catalog_versioning, transaction_id=transaction_id, athena_partition_projection_settings=athena_partition_projection_settings, boto3_session=boto3_session, catalog_table_input=catalog_table_input)",
            "def _create_glue_table(self, database: str, table: str, path: str, columns_types: Dict[str, str], table_type: Optional[str]=None, partitions_types: Optional[Dict[str, str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, description: Optional[str]=None, parameters: Optional[Dict[str, str]]=None, columns_comments: Optional[Dict[str, str]]=None, mode: str='overwrite', catalog_versioning: bool=False, transaction_id: Optional[str]=None, athena_partition_projection_settings: Optional[AthenaPartitionProjectionSettings]=None, boto3_session: Optional[boto3.Session]=None, catalog_table_input: Optional[Dict[str, Any]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return _create_orc_table(database=database, table=table, path=path, columns_types=columns_types, table_type=table_type, partitions_types=partitions_types, bucketing_info=bucketing_info, catalog_id=catalog_id, compression=compression, description=description, parameters=parameters, columns_comments=columns_comments, mode=mode, catalog_versioning=catalog_versioning, transaction_id=transaction_id, athena_partition_projection_settings=athena_partition_projection_settings, boto3_session=boto3_session, catalog_table_input=catalog_table_input)"
        ]
    },
    {
        "func_name": "_add_glue_partitions",
        "original": "def _add_glue_partitions(self, database: str, table: str, partitions_values: Dict[str, List[str]], bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, boto3_session: Optional[boto3.Session]=None, columns_types: Optional[Dict[str, str]]=None, partitions_parameters: Optional[Dict[str, str]]=None) -> None:\n    return catalog.add_orc_partitions(database=database, table=table, partitions_values=partitions_values, bucketing_info=bucketing_info, compression=compression, boto3_session=boto3_session, catalog_id=catalog_id, columns_types=columns_types, partitions_parameters=partitions_parameters)",
        "mutated": [
            "def _add_glue_partitions(self, database: str, table: str, partitions_values: Dict[str, List[str]], bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, boto3_session: Optional[boto3.Session]=None, columns_types: Optional[Dict[str, str]]=None, partitions_parameters: Optional[Dict[str, str]]=None) -> None:\n    if False:\n        i = 10\n    return catalog.add_orc_partitions(database=database, table=table, partitions_values=partitions_values, bucketing_info=bucketing_info, compression=compression, boto3_session=boto3_session, catalog_id=catalog_id, columns_types=columns_types, partitions_parameters=partitions_parameters)",
            "def _add_glue_partitions(self, database: str, table: str, partitions_values: Dict[str, List[str]], bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, boto3_session: Optional[boto3.Session]=None, columns_types: Optional[Dict[str, str]]=None, partitions_parameters: Optional[Dict[str, str]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return catalog.add_orc_partitions(database=database, table=table, partitions_values=partitions_values, bucketing_info=bucketing_info, compression=compression, boto3_session=boto3_session, catalog_id=catalog_id, columns_types=columns_types, partitions_parameters=partitions_parameters)",
            "def _add_glue_partitions(self, database: str, table: str, partitions_values: Dict[str, List[str]], bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, boto3_session: Optional[boto3.Session]=None, columns_types: Optional[Dict[str, str]]=None, partitions_parameters: Optional[Dict[str, str]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return catalog.add_orc_partitions(database=database, table=table, partitions_values=partitions_values, bucketing_info=bucketing_info, compression=compression, boto3_session=boto3_session, catalog_id=catalog_id, columns_types=columns_types, partitions_parameters=partitions_parameters)",
            "def _add_glue_partitions(self, database: str, table: str, partitions_values: Dict[str, List[str]], bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, boto3_session: Optional[boto3.Session]=None, columns_types: Optional[Dict[str, str]]=None, partitions_parameters: Optional[Dict[str, str]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return catalog.add_orc_partitions(database=database, table=table, partitions_values=partitions_values, bucketing_info=bucketing_info, compression=compression, boto3_session=boto3_session, catalog_id=catalog_id, columns_types=columns_types, partitions_parameters=partitions_parameters)",
            "def _add_glue_partitions(self, database: str, table: str, partitions_values: Dict[str, List[str]], bucketing_info: Optional[BucketingInfoTuple]=None, catalog_id: Optional[str]=None, compression: Optional[str]=None, boto3_session: Optional[boto3.Session]=None, columns_types: Optional[Dict[str, str]]=None, partitions_parameters: Optional[Dict[str, str]]=None) -> None:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return catalog.add_orc_partitions(database=database, table=table, partitions_values=partitions_values, bucketing_info=bucketing_info, compression=compression, boto3_session=boto3_session, catalog_id=catalog_id, columns_types=columns_types, partitions_parameters=partitions_parameters)"
        ]
    },
    {
        "func_name": "to_orc",
        "original": "@_utils.validate_distributed_kwargs(unsupported_kwargs=['boto3_session', 's3_additional_kwargs'])\n@apply_configs\ndef to_orc(df: pd.DataFrame, path: Optional[str]=None, index: bool=False, compression: Optional[str]=None, pyarrow_additional_kwargs: Optional[Dict[str, Any]]=None, max_rows_by_file: Optional[int]=None, use_threads: Union[bool, int]=True, boto3_session: Optional[boto3.Session]=None, s3_additional_kwargs: Optional[Dict[str, Any]]=None, sanitize_columns: bool=False, dataset: bool=False, filename_prefix: Optional[str]=None, partition_cols: Optional[List[str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, concurrent_partitioning: bool=False, mode: Optional[Literal['append', 'overwrite', 'overwrite_partitions']]=None, catalog_versioning: bool=False, schema_evolution: bool=True, database: Optional[str]=None, table: Optional[str]=None, glue_table_settings: Optional[GlueTableSettings]=None, dtype: Optional[Dict[str, str]]=None, athena_partition_projection_settings: Optional[typing.AthenaPartitionProjectionSettings]=None, catalog_id: Optional[str]=None) -> _S3WriteDataReturnValue:\n    \"\"\"Write ORC file or dataset on Amazon S3.\n\n    The concept of Dataset goes beyond the simple idea of ordinary files and enable more\n    complex features like partitioning and catalog integration (Amazon Athena/AWS Glue Catalog).\n\n    Note\n    ----\n    This operation may mutate the original pandas DataFrame in-place. To avoid this behaviour\n    please pass in a deep copy instead (i.e. `df.copy()`)\n\n    Note\n    ----\n    If `database` and `table` arguments are passed, the table name and all column names\n    will be automatically sanitized using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`.\n    Please, pass `sanitize_columns=True` to enforce this behaviour always.\n\n    Note\n    ----\n    In case of `use_threads=True` the number of threads\n    that will be spawned will be gotten from os.cpu_count().\n\n    Parameters\n    ----------\n    df: pandas.DataFrame\n        Pandas DataFrame https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html\n    path : str, optional\n        S3 path (for file e.g. ``s3://bucket/prefix/filename.orc``) (for dataset e.g. ``s3://bucket/prefix``).\n        Required if dataset=False or when dataset=True and creating a new dataset\n    index : bool\n        True to store the DataFrame index in file, otherwise False to ignore it.\n        Is not supported in conjunction with `max_rows_by_file` when running the library with Ray/Modin.\n    compression: str, optional\n        Compression style (``None``, ``snappy``, ``gzip``, ``zstd``).\n    pyarrow_additional_kwargs : Optional[Dict[str, Any]]\n        Additional parameters forwarded to pyarrow.\n        e.g. pyarrow_additional_kwargs={'coerce_timestamps': 'ns', 'use_deprecated_int96_timestamps': False,\n        'allow_truncated_timestamps'=False}\n    max_rows_by_file : int\n        Max number of rows in each file.\n        Default is None i.e. don't split the files.\n        (e.g. 33554432, 268435456)\n        Is not supported in conjunction with `index=True` when running the library with Ray/Modin.\n    use_threads : bool, int\n        True to enable concurrent requests, False to disable multiple threads.\n        If enabled os.cpu_count() will be used as the max number of threads.\n        If integer is provided, specified number is used.\n    boto3_session : boto3.Session(), optional\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\n    s3_additional_kwargs : Optional[Dict[str, Any]]\n        Forwarded to botocore requests.\n        e.g. s3_additional_kwargs={'ServerSideEncryption': 'aws:kms', 'SSEKMSKeyId': 'YOUR_KMS_KEY_ARN'}\n    sanitize_columns : bool\n        True to sanitize columns names (using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`)\n        or False to keep it as is.\n        True value behaviour is enforced if `database` and `table` arguments are passed.\n    dataset : bool\n        If True store a orc dataset instead of a ordinary file(s)\n        If True, enable all follow arguments:\n        partition_cols, mode, database, table, description, parameters, columns_comments, concurrent_partitioning,\n        catalog_versioning, projection_params, catalog_id, schema_evolution.\n    filename_prefix: str, optional\n        If dataset=True, add a filename prefix to the output files.\n    partition_cols: List[str], optional\n        List of column names that will be used to create partitions. Only takes effect if dataset=True.\n    bucketing_info: Tuple[List[str], int], optional\n        Tuple consisting of the column names used for bucketing as the first element and the number of buckets as the\n        second element.\n        Only `str`, `int` and `bool` are supported as column data types for bucketing.\n    concurrent_partitioning: bool\n        If True will increase the parallelism level during the partitions writing. It will decrease the\n        writing time and increase the memory usage.\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/022%20-%20Writing%20Partitions%20Concurrently.html\n    mode: str, optional\n        ``append`` (Default), ``overwrite``, ``overwrite_partitions``. Only takes effect if dataset=True.\n    catalog_versioning : bool\n        If True and `mode=\"overwrite\"`, creates an archived version of the table catalog before updating it.\n    schema_evolution : bool\n        If True allows schema evolution (new or missing columns), otherwise a exception will be raised. True by default.\n        (Only considered if dataset=True and mode in (\"append\", \"overwrite_partitions\"))\n        Related tutorial:\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/014%20-%20Schema%20Evolution.html\n    database : str, optional\n        Glue/Athena catalog: Database name.\n    table : str, optional\n        Glue/Athena catalog: Table name.\n    glue_table_settings: dict (GlueTableSettings), optional\n        Settings for writing to the Glue table.\n    dtype : Dict[str, str], optional\n        Dictionary of columns names and Athena/Glue types to be casted.\n        Useful when you have columns with undetermined or mixed data types.\n        (e.g. {'col name': 'bigint', 'col2 name': 'int'})\n    athena_partition_projection_settings: typing.AthenaPartitionProjectionSettings, optional\n        Parameters of the Athena Partition Projection (https://docs.aws.amazon.com/athena/latest/ug/partition-projection.html).\n        AthenaPartitionProjectionSettings is a `TypedDict`, meaning the passed parameter can be instantiated either as an\n        instance of AthenaPartitionProjectionSettings or as a regular Python dict.\n\n        Following projection parameters are supported:\n\n        .. list-table:: Projection Parameters\n           :header-rows: 1\n\n           * - Name\n             - Type\n             - Description\n           * - projection_types\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections types.\n               Valid types: \"enum\", \"integer\", \"date\", \"injected\"\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {'col_name': 'enum', 'col2_name': 'integer'})\n           * - projection_ranges\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections ranges.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {'col_name': '0,10', 'col2_name': '-1,8675309'})\n           * - projection_values\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections values.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {'col_name': 'A,B,Unknown', 'col2_name': 'foo,boo,bar'})\n           * - projection_intervals\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections intervals.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {'col_name': '1', 'col2_name': '5'})\n           * - projection_digits\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections digits.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {'col_name': '1', 'col2_name': '2'})\n           * - projection_formats\n             - Optional[Dict[str, str]]\n             - Dictionary of partitions names and Athena projections formats.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\n               (e.g. {'col_date': 'yyyy-MM-dd', 'col2_timestamp': 'yyyy-MM-dd HH:mm:ss'})\n           * - projection_storage_location_template\n             - Optional[str]\n             - Value which is allows Athena to properly map partition values if the S3 file locations do not follow\n               a typical `.../column=value/...` pattern.\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-setting-up.html\n               (e.g. s3://bucket/table_root/a=${a}/${b}/some_static_subdirectory/${c}/)\n    catalog_id : str, optional\n        The ID of the Data Catalog from which to retrieve Databases.\n        If none is provided, the AWS account ID is used by default.\n\n    Returns\n    -------\n    wr.typing._S3WriteDataReturnValue\n        Dictionary with:\n        'paths': List of all stored files paths on S3.\n        'partitions_values': Dictionary of partitions added with keys as S3 path locations\n        and values as a list of partitions values as str.\n\n    Examples\n    --------\n    Writing single file\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_orc(\n    ...     df=pd.DataFrame({'col': [1, 2, 3]}),\n    ...     path='s3://bucket/prefix/my_file.orc',\n    ... )\n    {\n        'paths': ['s3://bucket/prefix/my_file.orc'],\n        'partitions_values': {}\n    }\n\n    Writing single file encrypted with a KMS key\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_orc(\n    ...     df=pd.DataFrame({'col': [1, 2, 3]}),\n    ...     path='s3://bucket/prefix/my_file.orc',\n    ...     s3_additional_kwargs={\n    ...         'ServerSideEncryption': 'aws:kms',\n    ...         'SSEKMSKeyId': 'YOUR_KMS_KEY_ARN'\n    ...     }\n    ... )\n    {\n        'paths': ['s3://bucket/prefix/my_file.orc'],\n        'partitions_values': {}\n    }\n\n    Writing partitioned dataset\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_orc(\n    ...     df=pd.DataFrame({\n    ...         'col': [1, 2, 3],\n    ...         'col2': ['A', 'A', 'B']\n    ...     }),\n    ...     path='s3://bucket/prefix',\n    ...     dataset=True,\n    ...     partition_cols=['col2']\n    ... )\n    {\n        'paths': ['s3://.../col2=A/x.orc', 's3://.../col2=B/y.orc'],\n        'partitions_values: {\n            's3://.../col2=A/': ['A'],\n            's3://.../col2=B/': ['B']\n        }\n    }\n\n    Writing partitioned dataset with partition projection\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> from datetime import datetime\n    >>> dt = lambda x: datetime.strptime(x, \"%Y-%m-%d\").date()\n    >>> wr.s3.to_orc(\n    ...     df=pd.DataFrame({\n    ...         \"id\": [1, 2, 3],\n    ...         \"value\": [1000, 1001, 1002],\n    ...         \"category\": ['A', 'B', 'C'],\n    ...     }),\n    ...     path='s3://bucket/prefix',\n    ...     dataset=True,\n    ...     partition_cols=['value', 'category'],\n    ...     athena_partition_projection_settings={\n    ...        \"projection_types\": {\n    ...             \"value\": \"integer\",\n    ...             \"category\": \"enum\",\n    ...         },\n    ...         \"projection_ranges\": {\n    ...             \"value\": \"1000,2000\",\n    ...             \"category\": \"A,B,C\",\n    ...         },\n    ...     },\n    ... )\n    {\n        'paths': [\n            's3://.../value=1000/category=A/x.snappy.orc', ...\n        ],\n        'partitions_values': {\n            's3://.../value=1000/category=A/': [\n                '1000',\n                'A',\n            ], ...\n        }\n    }\n\n    Writing bucketed dataset\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_orc(\n    ...     df=pd.DataFrame({\n    ...         'col': [1, 2, 3],\n    ...         'col2': ['A', 'A', 'B']\n    ...     }),\n    ...     path='s3://bucket/prefix',\n    ...     dataset=True,\n    ...     bucketing_info=([\"col2\"], 2)\n    ... )\n    {\n        'paths': ['s3://.../x_bucket-00000.csv', 's3://.../col2=B/x_bucket-00001.csv'],\n        'partitions_values: {}\n    }\n\n    Writing dataset to S3 with metadata on Athena/Glue Catalog.\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_orc(\n    ...     df=pd.DataFrame({\n    ...         'col': [1, 2, 3],\n    ...         'col2': ['A', 'A', 'B']\n    ...     }),\n    ...     path='s3://bucket/prefix',\n    ...     dataset=True,\n    ...     partition_cols=['col2'],\n    ...     database='default',  # Athena/Glue database\n    ...     table='my_table'  # Athena/Glue table\n    ... )\n    {\n        'paths': ['s3://.../col2=A/x.orc', 's3://.../col2=B/y.orc'],\n        'partitions_values: {\n            's3://.../col2=A/': ['A'],\n            's3://.../col2=B/': ['B']\n        }\n    }\n\n    Writing dataset to Glue governed table\n\n    >>> import awswrangler as wr\n    >>> import pandas as pd\n    >>> wr.s3.to_orc(\n    ...     df=pd.DataFrame({\n    ...         'col': [1, 2, 3],\n    ...         'col2': ['A', 'A', 'B'],\n    ...     }),\n    ...     dataset=True,\n    ...     mode='append',\n    ...     database='default',  # Athena/Glue database\n    ...     table='my_table',  # Athena/Glue table\n    ...     glue_table_settings=wr.typing.GlueTableSettings(\n    ...         table_type=\"GOVERNED\",\n    ...         transaction_id=\"xxx\",\n    ...     ),\n    ... )\n    {\n        'paths': ['s3://.../x.orc'],\n        'partitions_values: {}\n    }\n\n    \"\"\"\n    glue_table_settings = cast(GlueTableSettings, glue_table_settings if glue_table_settings else {})\n    table_type = glue_table_settings.get('table_type')\n    transaction_id = glue_table_settings.get('transaction_id')\n    description = glue_table_settings.get('description')\n    parameters = glue_table_settings.get('parameters')\n    columns_comments = glue_table_settings.get('columns_comments')\n    regular_partitions = glue_table_settings.get('regular_partitions', True)\n    _validate_args(df=df, table=table, database=database, dataset=dataset, path=path, partition_cols=partition_cols, bucketing_info=bucketing_info, mode=mode, description=description, parameters=parameters, columns_comments=columns_comments, execution_engine=engine.get())\n    if _COMPRESSION_2_EXT.get(compression, None) is None:\n        raise exceptions.InvalidCompression(f\"{compression} is invalid, please use None, 'snappy', 'zlib', 'lz4' or 'zstd'.\")\n    compression_ext: str = _COMPRESSION_2_EXT[compression]\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    strategy = _S3ORCWriteStrategy()\n    return strategy.write(df=df, path=path, index=index, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, max_rows_by_file=max_rows_by_file, use_threads=use_threads, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs, sanitize_columns=sanitize_columns, dataset=dataset, filename_prefix=filename_prefix, partition_cols=partition_cols, bucketing_info=bucketing_info, concurrent_partitioning=concurrent_partitioning, mode=mode, catalog_versioning=catalog_versioning, schema_evolution=schema_evolution, database=database, table=table, description=description, parameters=parameters, columns_comments=columns_comments, table_type=table_type, transaction_id=transaction_id, regular_partitions=regular_partitions, dtype=dtype, athena_partition_projection_settings=athena_partition_projection_settings, catalog_id=catalog_id, compression_ext=compression_ext)",
        "mutated": [
            "@_utils.validate_distributed_kwargs(unsupported_kwargs=['boto3_session', 's3_additional_kwargs'])\n@apply_configs\ndef to_orc(df: pd.DataFrame, path: Optional[str]=None, index: bool=False, compression: Optional[str]=None, pyarrow_additional_kwargs: Optional[Dict[str, Any]]=None, max_rows_by_file: Optional[int]=None, use_threads: Union[bool, int]=True, boto3_session: Optional[boto3.Session]=None, s3_additional_kwargs: Optional[Dict[str, Any]]=None, sanitize_columns: bool=False, dataset: bool=False, filename_prefix: Optional[str]=None, partition_cols: Optional[List[str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, concurrent_partitioning: bool=False, mode: Optional[Literal['append', 'overwrite', 'overwrite_partitions']]=None, catalog_versioning: bool=False, schema_evolution: bool=True, database: Optional[str]=None, table: Optional[str]=None, glue_table_settings: Optional[GlueTableSettings]=None, dtype: Optional[Dict[str, str]]=None, athena_partition_projection_settings: Optional[typing.AthenaPartitionProjectionSettings]=None, catalog_id: Optional[str]=None) -> _S3WriteDataReturnValue:\n    if False:\n        i = 10\n    'Write ORC file or dataset on Amazon S3.\\n\\n    The concept of Dataset goes beyond the simple idea of ordinary files and enable more\\n    complex features like partitioning and catalog integration (Amazon Athena/AWS Glue Catalog).\\n\\n    Note\\n    ----\\n    This operation may mutate the original pandas DataFrame in-place. To avoid this behaviour\\n    please pass in a deep copy instead (i.e. `df.copy()`)\\n\\n    Note\\n    ----\\n    If `database` and `table` arguments are passed, the table name and all column names\\n    will be automatically sanitized using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`.\\n    Please, pass `sanitize_columns=True` to enforce this behaviour always.\\n\\n    Note\\n    ----\\n    In case of `use_threads=True` the number of threads\\n    that will be spawned will be gotten from os.cpu_count().\\n\\n    Parameters\\n    ----------\\n    df: pandas.DataFrame\\n        Pandas DataFrame https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html\\n    path : str, optional\\n        S3 path (for file e.g. ``s3://bucket/prefix/filename.orc``) (for dataset e.g. ``s3://bucket/prefix``).\\n        Required if dataset=False or when dataset=True and creating a new dataset\\n    index : bool\\n        True to store the DataFrame index in file, otherwise False to ignore it.\\n        Is not supported in conjunction with `max_rows_by_file` when running the library with Ray/Modin.\\n    compression: str, optional\\n        Compression style (``None``, ``snappy``, ``gzip``, ``zstd``).\\n    pyarrow_additional_kwargs : Optional[Dict[str, Any]]\\n        Additional parameters forwarded to pyarrow.\\n        e.g. pyarrow_additional_kwargs={\\'coerce_timestamps\\': \\'ns\\', \\'use_deprecated_int96_timestamps\\': False,\\n        \\'allow_truncated_timestamps\\'=False}\\n    max_rows_by_file : int\\n        Max number of rows in each file.\\n        Default is None i.e. don\\'t split the files.\\n        (e.g. 33554432, 268435456)\\n        Is not supported in conjunction with `index=True` when running the library with Ray/Modin.\\n    use_threads : bool, int\\n        True to enable concurrent requests, False to disable multiple threads.\\n        If enabled os.cpu_count() will be used as the max number of threads.\\n        If integer is provided, specified number is used.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n    s3_additional_kwargs : Optional[Dict[str, Any]]\\n        Forwarded to botocore requests.\\n        e.g. s3_additional_kwargs={\\'ServerSideEncryption\\': \\'aws:kms\\', \\'SSEKMSKeyId\\': \\'YOUR_KMS_KEY_ARN\\'}\\n    sanitize_columns : bool\\n        True to sanitize columns names (using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`)\\n        or False to keep it as is.\\n        True value behaviour is enforced if `database` and `table` arguments are passed.\\n    dataset : bool\\n        If True store a orc dataset instead of a ordinary file(s)\\n        If True, enable all follow arguments:\\n        partition_cols, mode, database, table, description, parameters, columns_comments, concurrent_partitioning,\\n        catalog_versioning, projection_params, catalog_id, schema_evolution.\\n    filename_prefix: str, optional\\n        If dataset=True, add a filename prefix to the output files.\\n    partition_cols: List[str], optional\\n        List of column names that will be used to create partitions. Only takes effect if dataset=True.\\n    bucketing_info: Tuple[List[str], int], optional\\n        Tuple consisting of the column names used for bucketing as the first element and the number of buckets as the\\n        second element.\\n        Only `str`, `int` and `bool` are supported as column data types for bucketing.\\n    concurrent_partitioning: bool\\n        If True will increase the parallelism level during the partitions writing. It will decrease the\\n        writing time and increase the memory usage.\\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/022%20-%20Writing%20Partitions%20Concurrently.html\\n    mode: str, optional\\n        ``append`` (Default), ``overwrite``, ``overwrite_partitions``. Only takes effect if dataset=True.\\n    catalog_versioning : bool\\n        If True and `mode=\"overwrite\"`, creates an archived version of the table catalog before updating it.\\n    schema_evolution : bool\\n        If True allows schema evolution (new or missing columns), otherwise a exception will be raised. True by default.\\n        (Only considered if dataset=True and mode in (\"append\", \"overwrite_partitions\"))\\n        Related tutorial:\\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/014%20-%20Schema%20Evolution.html\\n    database : str, optional\\n        Glue/Athena catalog: Database name.\\n    table : str, optional\\n        Glue/Athena catalog: Table name.\\n    glue_table_settings: dict (GlueTableSettings), optional\\n        Settings for writing to the Glue table.\\n    dtype : Dict[str, str], optional\\n        Dictionary of columns names and Athena/Glue types to be casted.\\n        Useful when you have columns with undetermined or mixed data types.\\n        (e.g. {\\'col name\\': \\'bigint\\', \\'col2 name\\': \\'int\\'})\\n    athena_partition_projection_settings: typing.AthenaPartitionProjectionSettings, optional\\n        Parameters of the Athena Partition Projection (https://docs.aws.amazon.com/athena/latest/ug/partition-projection.html).\\n        AthenaPartitionProjectionSettings is a `TypedDict`, meaning the passed parameter can be instantiated either as an\\n        instance of AthenaPartitionProjectionSettings or as a regular Python dict.\\n\\n        Following projection parameters are supported:\\n\\n        .. list-table:: Projection Parameters\\n           :header-rows: 1\\n\\n           * - Name\\n             - Type\\n             - Description\\n           * - projection_types\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections types.\\n               Valid types: \"enum\", \"integer\", \"date\", \"injected\"\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'enum\\', \\'col2_name\\': \\'integer\\'})\\n           * - projection_ranges\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections ranges.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'0,10\\', \\'col2_name\\': \\'-1,8675309\\'})\\n           * - projection_values\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections values.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'A,B,Unknown\\', \\'col2_name\\': \\'foo,boo,bar\\'})\\n           * - projection_intervals\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections intervals.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'1\\', \\'col2_name\\': \\'5\\'})\\n           * - projection_digits\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections digits.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'1\\', \\'col2_name\\': \\'2\\'})\\n           * - projection_formats\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections formats.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_date\\': \\'yyyy-MM-dd\\', \\'col2_timestamp\\': \\'yyyy-MM-dd HH:mm:ss\\'})\\n           * - projection_storage_location_template\\n             - Optional[str]\\n             - Value which is allows Athena to properly map partition values if the S3 file locations do not follow\\n               a typical `.../column=value/...` pattern.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-setting-up.html\\n               (e.g. s3://bucket/table_root/a=${a}/${b}/some_static_subdirectory/${c}/)\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n\\n    Returns\\n    -------\\n    wr.typing._S3WriteDataReturnValue\\n        Dictionary with:\\n        \\'paths\\': List of all stored files paths on S3.\\n        \\'partitions_values\\': Dictionary of partitions added with keys as S3 path locations\\n        and values as a list of partitions values as str.\\n\\n    Examples\\n    --------\\n    Writing single file\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\'col\\': [1, 2, 3]}),\\n    ...     path=\\'s3://bucket/prefix/my_file.orc\\',\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://bucket/prefix/my_file.orc\\'],\\n        \\'partitions_values\\': {}\\n    }\\n\\n    Writing single file encrypted with a KMS key\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\'col\\': [1, 2, 3]}),\\n    ...     path=\\'s3://bucket/prefix/my_file.orc\\',\\n    ...     s3_additional_kwargs={\\n    ...         \\'ServerSideEncryption\\': \\'aws:kms\\',\\n    ...         \\'SSEKMSKeyId\\': \\'YOUR_KMS_KEY_ARN\\'\\n    ...     }\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://bucket/prefix/my_file.orc\\'],\\n        \\'partitions_values\\': {}\\n    }\\n\\n    Writing partitioned dataset\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'col2\\']\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../col2=A/x.orc\\', \\'s3://.../col2=B/y.orc\\'],\\n        \\'partitions_values: {\\n            \\'s3://.../col2=A/\\': [\\'A\\'],\\n            \\'s3://.../col2=B/\\': [\\'B\\']\\n        }\\n    }\\n\\n    Writing partitioned dataset with partition projection\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> from datetime import datetime\\n    >>> dt = lambda x: datetime.strptime(x, \"%Y-%m-%d\").date()\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \"id\": [1, 2, 3],\\n    ...         \"value\": [1000, 1001, 1002],\\n    ...         \"category\": [\\'A\\', \\'B\\', \\'C\\'],\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'value\\', \\'category\\'],\\n    ...     athena_partition_projection_settings={\\n    ...        \"projection_types\": {\\n    ...             \"value\": \"integer\",\\n    ...             \"category\": \"enum\",\\n    ...         },\\n    ...         \"projection_ranges\": {\\n    ...             \"value\": \"1000,2000\",\\n    ...             \"category\": \"A,B,C\",\\n    ...         },\\n    ...     },\\n    ... )\\n    {\\n        \\'paths\\': [\\n            \\'s3://.../value=1000/category=A/x.snappy.orc\\', ...\\n        ],\\n        \\'partitions_values\\': {\\n            \\'s3://.../value=1000/category=A/\\': [\\n                \\'1000\\',\\n                \\'A\\',\\n            ], ...\\n        }\\n    }\\n\\n    Writing bucketed dataset\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     bucketing_info=([\"col2\"], 2)\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../x_bucket-00000.csv\\', \\'s3://.../col2=B/x_bucket-00001.csv\\'],\\n        \\'partitions_values: {}\\n    }\\n\\n    Writing dataset to S3 with metadata on Athena/Glue Catalog.\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'col2\\'],\\n    ...     database=\\'default\\',  # Athena/Glue database\\n    ...     table=\\'my_table\\'  # Athena/Glue table\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../col2=A/x.orc\\', \\'s3://.../col2=B/y.orc\\'],\\n        \\'partitions_values: {\\n            \\'s3://.../col2=A/\\': [\\'A\\'],\\n            \\'s3://.../col2=B/\\': [\\'B\\']\\n        }\\n    }\\n\\n    Writing dataset to Glue governed table\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\'],\\n    ...     }),\\n    ...     dataset=True,\\n    ...     mode=\\'append\\',\\n    ...     database=\\'default\\',  # Athena/Glue database\\n    ...     table=\\'my_table\\',  # Athena/Glue table\\n    ...     glue_table_settings=wr.typing.GlueTableSettings(\\n    ...         table_type=\"GOVERNED\",\\n    ...         transaction_id=\"xxx\",\\n    ...     ),\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../x.orc\\'],\\n        \\'partitions_values: {}\\n    }\\n\\n    '\n    glue_table_settings = cast(GlueTableSettings, glue_table_settings if glue_table_settings else {})\n    table_type = glue_table_settings.get('table_type')\n    transaction_id = glue_table_settings.get('transaction_id')\n    description = glue_table_settings.get('description')\n    parameters = glue_table_settings.get('parameters')\n    columns_comments = glue_table_settings.get('columns_comments')\n    regular_partitions = glue_table_settings.get('regular_partitions', True)\n    _validate_args(df=df, table=table, database=database, dataset=dataset, path=path, partition_cols=partition_cols, bucketing_info=bucketing_info, mode=mode, description=description, parameters=parameters, columns_comments=columns_comments, execution_engine=engine.get())\n    if _COMPRESSION_2_EXT.get(compression, None) is None:\n        raise exceptions.InvalidCompression(f\"{compression} is invalid, please use None, 'snappy', 'zlib', 'lz4' or 'zstd'.\")\n    compression_ext: str = _COMPRESSION_2_EXT[compression]\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    strategy = _S3ORCWriteStrategy()\n    return strategy.write(df=df, path=path, index=index, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, max_rows_by_file=max_rows_by_file, use_threads=use_threads, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs, sanitize_columns=sanitize_columns, dataset=dataset, filename_prefix=filename_prefix, partition_cols=partition_cols, bucketing_info=bucketing_info, concurrent_partitioning=concurrent_partitioning, mode=mode, catalog_versioning=catalog_versioning, schema_evolution=schema_evolution, database=database, table=table, description=description, parameters=parameters, columns_comments=columns_comments, table_type=table_type, transaction_id=transaction_id, regular_partitions=regular_partitions, dtype=dtype, athena_partition_projection_settings=athena_partition_projection_settings, catalog_id=catalog_id, compression_ext=compression_ext)",
            "@_utils.validate_distributed_kwargs(unsupported_kwargs=['boto3_session', 's3_additional_kwargs'])\n@apply_configs\ndef to_orc(df: pd.DataFrame, path: Optional[str]=None, index: bool=False, compression: Optional[str]=None, pyarrow_additional_kwargs: Optional[Dict[str, Any]]=None, max_rows_by_file: Optional[int]=None, use_threads: Union[bool, int]=True, boto3_session: Optional[boto3.Session]=None, s3_additional_kwargs: Optional[Dict[str, Any]]=None, sanitize_columns: bool=False, dataset: bool=False, filename_prefix: Optional[str]=None, partition_cols: Optional[List[str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, concurrent_partitioning: bool=False, mode: Optional[Literal['append', 'overwrite', 'overwrite_partitions']]=None, catalog_versioning: bool=False, schema_evolution: bool=True, database: Optional[str]=None, table: Optional[str]=None, glue_table_settings: Optional[GlueTableSettings]=None, dtype: Optional[Dict[str, str]]=None, athena_partition_projection_settings: Optional[typing.AthenaPartitionProjectionSettings]=None, catalog_id: Optional[str]=None) -> _S3WriteDataReturnValue:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Write ORC file or dataset on Amazon S3.\\n\\n    The concept of Dataset goes beyond the simple idea of ordinary files and enable more\\n    complex features like partitioning and catalog integration (Amazon Athena/AWS Glue Catalog).\\n\\n    Note\\n    ----\\n    This operation may mutate the original pandas DataFrame in-place. To avoid this behaviour\\n    please pass in a deep copy instead (i.e. `df.copy()`)\\n\\n    Note\\n    ----\\n    If `database` and `table` arguments are passed, the table name and all column names\\n    will be automatically sanitized using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`.\\n    Please, pass `sanitize_columns=True` to enforce this behaviour always.\\n\\n    Note\\n    ----\\n    In case of `use_threads=True` the number of threads\\n    that will be spawned will be gotten from os.cpu_count().\\n\\n    Parameters\\n    ----------\\n    df: pandas.DataFrame\\n        Pandas DataFrame https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html\\n    path : str, optional\\n        S3 path (for file e.g. ``s3://bucket/prefix/filename.orc``) (for dataset e.g. ``s3://bucket/prefix``).\\n        Required if dataset=False or when dataset=True and creating a new dataset\\n    index : bool\\n        True to store the DataFrame index in file, otherwise False to ignore it.\\n        Is not supported in conjunction with `max_rows_by_file` when running the library with Ray/Modin.\\n    compression: str, optional\\n        Compression style (``None``, ``snappy``, ``gzip``, ``zstd``).\\n    pyarrow_additional_kwargs : Optional[Dict[str, Any]]\\n        Additional parameters forwarded to pyarrow.\\n        e.g. pyarrow_additional_kwargs={\\'coerce_timestamps\\': \\'ns\\', \\'use_deprecated_int96_timestamps\\': False,\\n        \\'allow_truncated_timestamps\\'=False}\\n    max_rows_by_file : int\\n        Max number of rows in each file.\\n        Default is None i.e. don\\'t split the files.\\n        (e.g. 33554432, 268435456)\\n        Is not supported in conjunction with `index=True` when running the library with Ray/Modin.\\n    use_threads : bool, int\\n        True to enable concurrent requests, False to disable multiple threads.\\n        If enabled os.cpu_count() will be used as the max number of threads.\\n        If integer is provided, specified number is used.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n    s3_additional_kwargs : Optional[Dict[str, Any]]\\n        Forwarded to botocore requests.\\n        e.g. s3_additional_kwargs={\\'ServerSideEncryption\\': \\'aws:kms\\', \\'SSEKMSKeyId\\': \\'YOUR_KMS_KEY_ARN\\'}\\n    sanitize_columns : bool\\n        True to sanitize columns names (using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`)\\n        or False to keep it as is.\\n        True value behaviour is enforced if `database` and `table` arguments are passed.\\n    dataset : bool\\n        If True store a orc dataset instead of a ordinary file(s)\\n        If True, enable all follow arguments:\\n        partition_cols, mode, database, table, description, parameters, columns_comments, concurrent_partitioning,\\n        catalog_versioning, projection_params, catalog_id, schema_evolution.\\n    filename_prefix: str, optional\\n        If dataset=True, add a filename prefix to the output files.\\n    partition_cols: List[str], optional\\n        List of column names that will be used to create partitions. Only takes effect if dataset=True.\\n    bucketing_info: Tuple[List[str], int], optional\\n        Tuple consisting of the column names used for bucketing as the first element and the number of buckets as the\\n        second element.\\n        Only `str`, `int` and `bool` are supported as column data types for bucketing.\\n    concurrent_partitioning: bool\\n        If True will increase the parallelism level during the partitions writing. It will decrease the\\n        writing time and increase the memory usage.\\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/022%20-%20Writing%20Partitions%20Concurrently.html\\n    mode: str, optional\\n        ``append`` (Default), ``overwrite``, ``overwrite_partitions``. Only takes effect if dataset=True.\\n    catalog_versioning : bool\\n        If True and `mode=\"overwrite\"`, creates an archived version of the table catalog before updating it.\\n    schema_evolution : bool\\n        If True allows schema evolution (new or missing columns), otherwise a exception will be raised. True by default.\\n        (Only considered if dataset=True and mode in (\"append\", \"overwrite_partitions\"))\\n        Related tutorial:\\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/014%20-%20Schema%20Evolution.html\\n    database : str, optional\\n        Glue/Athena catalog: Database name.\\n    table : str, optional\\n        Glue/Athena catalog: Table name.\\n    glue_table_settings: dict (GlueTableSettings), optional\\n        Settings for writing to the Glue table.\\n    dtype : Dict[str, str], optional\\n        Dictionary of columns names and Athena/Glue types to be casted.\\n        Useful when you have columns with undetermined or mixed data types.\\n        (e.g. {\\'col name\\': \\'bigint\\', \\'col2 name\\': \\'int\\'})\\n    athena_partition_projection_settings: typing.AthenaPartitionProjectionSettings, optional\\n        Parameters of the Athena Partition Projection (https://docs.aws.amazon.com/athena/latest/ug/partition-projection.html).\\n        AthenaPartitionProjectionSettings is a `TypedDict`, meaning the passed parameter can be instantiated either as an\\n        instance of AthenaPartitionProjectionSettings or as a regular Python dict.\\n\\n        Following projection parameters are supported:\\n\\n        .. list-table:: Projection Parameters\\n           :header-rows: 1\\n\\n           * - Name\\n             - Type\\n             - Description\\n           * - projection_types\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections types.\\n               Valid types: \"enum\", \"integer\", \"date\", \"injected\"\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'enum\\', \\'col2_name\\': \\'integer\\'})\\n           * - projection_ranges\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections ranges.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'0,10\\', \\'col2_name\\': \\'-1,8675309\\'})\\n           * - projection_values\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections values.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'A,B,Unknown\\', \\'col2_name\\': \\'foo,boo,bar\\'})\\n           * - projection_intervals\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections intervals.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'1\\', \\'col2_name\\': \\'5\\'})\\n           * - projection_digits\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections digits.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'1\\', \\'col2_name\\': \\'2\\'})\\n           * - projection_formats\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections formats.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_date\\': \\'yyyy-MM-dd\\', \\'col2_timestamp\\': \\'yyyy-MM-dd HH:mm:ss\\'})\\n           * - projection_storage_location_template\\n             - Optional[str]\\n             - Value which is allows Athena to properly map partition values if the S3 file locations do not follow\\n               a typical `.../column=value/...` pattern.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-setting-up.html\\n               (e.g. s3://bucket/table_root/a=${a}/${b}/some_static_subdirectory/${c}/)\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n\\n    Returns\\n    -------\\n    wr.typing._S3WriteDataReturnValue\\n        Dictionary with:\\n        \\'paths\\': List of all stored files paths on S3.\\n        \\'partitions_values\\': Dictionary of partitions added with keys as S3 path locations\\n        and values as a list of partitions values as str.\\n\\n    Examples\\n    --------\\n    Writing single file\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\'col\\': [1, 2, 3]}),\\n    ...     path=\\'s3://bucket/prefix/my_file.orc\\',\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://bucket/prefix/my_file.orc\\'],\\n        \\'partitions_values\\': {}\\n    }\\n\\n    Writing single file encrypted with a KMS key\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\'col\\': [1, 2, 3]}),\\n    ...     path=\\'s3://bucket/prefix/my_file.orc\\',\\n    ...     s3_additional_kwargs={\\n    ...         \\'ServerSideEncryption\\': \\'aws:kms\\',\\n    ...         \\'SSEKMSKeyId\\': \\'YOUR_KMS_KEY_ARN\\'\\n    ...     }\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://bucket/prefix/my_file.orc\\'],\\n        \\'partitions_values\\': {}\\n    }\\n\\n    Writing partitioned dataset\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'col2\\']\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../col2=A/x.orc\\', \\'s3://.../col2=B/y.orc\\'],\\n        \\'partitions_values: {\\n            \\'s3://.../col2=A/\\': [\\'A\\'],\\n            \\'s3://.../col2=B/\\': [\\'B\\']\\n        }\\n    }\\n\\n    Writing partitioned dataset with partition projection\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> from datetime import datetime\\n    >>> dt = lambda x: datetime.strptime(x, \"%Y-%m-%d\").date()\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \"id\": [1, 2, 3],\\n    ...         \"value\": [1000, 1001, 1002],\\n    ...         \"category\": [\\'A\\', \\'B\\', \\'C\\'],\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'value\\', \\'category\\'],\\n    ...     athena_partition_projection_settings={\\n    ...        \"projection_types\": {\\n    ...             \"value\": \"integer\",\\n    ...             \"category\": \"enum\",\\n    ...         },\\n    ...         \"projection_ranges\": {\\n    ...             \"value\": \"1000,2000\",\\n    ...             \"category\": \"A,B,C\",\\n    ...         },\\n    ...     },\\n    ... )\\n    {\\n        \\'paths\\': [\\n            \\'s3://.../value=1000/category=A/x.snappy.orc\\', ...\\n        ],\\n        \\'partitions_values\\': {\\n            \\'s3://.../value=1000/category=A/\\': [\\n                \\'1000\\',\\n                \\'A\\',\\n            ], ...\\n        }\\n    }\\n\\n    Writing bucketed dataset\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     bucketing_info=([\"col2\"], 2)\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../x_bucket-00000.csv\\', \\'s3://.../col2=B/x_bucket-00001.csv\\'],\\n        \\'partitions_values: {}\\n    }\\n\\n    Writing dataset to S3 with metadata on Athena/Glue Catalog.\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'col2\\'],\\n    ...     database=\\'default\\',  # Athena/Glue database\\n    ...     table=\\'my_table\\'  # Athena/Glue table\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../col2=A/x.orc\\', \\'s3://.../col2=B/y.orc\\'],\\n        \\'partitions_values: {\\n            \\'s3://.../col2=A/\\': [\\'A\\'],\\n            \\'s3://.../col2=B/\\': [\\'B\\']\\n        }\\n    }\\n\\n    Writing dataset to Glue governed table\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\'],\\n    ...     }),\\n    ...     dataset=True,\\n    ...     mode=\\'append\\',\\n    ...     database=\\'default\\',  # Athena/Glue database\\n    ...     table=\\'my_table\\',  # Athena/Glue table\\n    ...     glue_table_settings=wr.typing.GlueTableSettings(\\n    ...         table_type=\"GOVERNED\",\\n    ...         transaction_id=\"xxx\",\\n    ...     ),\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../x.orc\\'],\\n        \\'partitions_values: {}\\n    }\\n\\n    '\n    glue_table_settings = cast(GlueTableSettings, glue_table_settings if glue_table_settings else {})\n    table_type = glue_table_settings.get('table_type')\n    transaction_id = glue_table_settings.get('transaction_id')\n    description = glue_table_settings.get('description')\n    parameters = glue_table_settings.get('parameters')\n    columns_comments = glue_table_settings.get('columns_comments')\n    regular_partitions = glue_table_settings.get('regular_partitions', True)\n    _validate_args(df=df, table=table, database=database, dataset=dataset, path=path, partition_cols=partition_cols, bucketing_info=bucketing_info, mode=mode, description=description, parameters=parameters, columns_comments=columns_comments, execution_engine=engine.get())\n    if _COMPRESSION_2_EXT.get(compression, None) is None:\n        raise exceptions.InvalidCompression(f\"{compression} is invalid, please use None, 'snappy', 'zlib', 'lz4' or 'zstd'.\")\n    compression_ext: str = _COMPRESSION_2_EXT[compression]\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    strategy = _S3ORCWriteStrategy()\n    return strategy.write(df=df, path=path, index=index, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, max_rows_by_file=max_rows_by_file, use_threads=use_threads, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs, sanitize_columns=sanitize_columns, dataset=dataset, filename_prefix=filename_prefix, partition_cols=partition_cols, bucketing_info=bucketing_info, concurrent_partitioning=concurrent_partitioning, mode=mode, catalog_versioning=catalog_versioning, schema_evolution=schema_evolution, database=database, table=table, description=description, parameters=parameters, columns_comments=columns_comments, table_type=table_type, transaction_id=transaction_id, regular_partitions=regular_partitions, dtype=dtype, athena_partition_projection_settings=athena_partition_projection_settings, catalog_id=catalog_id, compression_ext=compression_ext)",
            "@_utils.validate_distributed_kwargs(unsupported_kwargs=['boto3_session', 's3_additional_kwargs'])\n@apply_configs\ndef to_orc(df: pd.DataFrame, path: Optional[str]=None, index: bool=False, compression: Optional[str]=None, pyarrow_additional_kwargs: Optional[Dict[str, Any]]=None, max_rows_by_file: Optional[int]=None, use_threads: Union[bool, int]=True, boto3_session: Optional[boto3.Session]=None, s3_additional_kwargs: Optional[Dict[str, Any]]=None, sanitize_columns: bool=False, dataset: bool=False, filename_prefix: Optional[str]=None, partition_cols: Optional[List[str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, concurrent_partitioning: bool=False, mode: Optional[Literal['append', 'overwrite', 'overwrite_partitions']]=None, catalog_versioning: bool=False, schema_evolution: bool=True, database: Optional[str]=None, table: Optional[str]=None, glue_table_settings: Optional[GlueTableSettings]=None, dtype: Optional[Dict[str, str]]=None, athena_partition_projection_settings: Optional[typing.AthenaPartitionProjectionSettings]=None, catalog_id: Optional[str]=None) -> _S3WriteDataReturnValue:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Write ORC file or dataset on Amazon S3.\\n\\n    The concept of Dataset goes beyond the simple idea of ordinary files and enable more\\n    complex features like partitioning and catalog integration (Amazon Athena/AWS Glue Catalog).\\n\\n    Note\\n    ----\\n    This operation may mutate the original pandas DataFrame in-place. To avoid this behaviour\\n    please pass in a deep copy instead (i.e. `df.copy()`)\\n\\n    Note\\n    ----\\n    If `database` and `table` arguments are passed, the table name and all column names\\n    will be automatically sanitized using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`.\\n    Please, pass `sanitize_columns=True` to enforce this behaviour always.\\n\\n    Note\\n    ----\\n    In case of `use_threads=True` the number of threads\\n    that will be spawned will be gotten from os.cpu_count().\\n\\n    Parameters\\n    ----------\\n    df: pandas.DataFrame\\n        Pandas DataFrame https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html\\n    path : str, optional\\n        S3 path (for file e.g. ``s3://bucket/prefix/filename.orc``) (for dataset e.g. ``s3://bucket/prefix``).\\n        Required if dataset=False or when dataset=True and creating a new dataset\\n    index : bool\\n        True to store the DataFrame index in file, otherwise False to ignore it.\\n        Is not supported in conjunction with `max_rows_by_file` when running the library with Ray/Modin.\\n    compression: str, optional\\n        Compression style (``None``, ``snappy``, ``gzip``, ``zstd``).\\n    pyarrow_additional_kwargs : Optional[Dict[str, Any]]\\n        Additional parameters forwarded to pyarrow.\\n        e.g. pyarrow_additional_kwargs={\\'coerce_timestamps\\': \\'ns\\', \\'use_deprecated_int96_timestamps\\': False,\\n        \\'allow_truncated_timestamps\\'=False}\\n    max_rows_by_file : int\\n        Max number of rows in each file.\\n        Default is None i.e. don\\'t split the files.\\n        (e.g. 33554432, 268435456)\\n        Is not supported in conjunction with `index=True` when running the library with Ray/Modin.\\n    use_threads : bool, int\\n        True to enable concurrent requests, False to disable multiple threads.\\n        If enabled os.cpu_count() will be used as the max number of threads.\\n        If integer is provided, specified number is used.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n    s3_additional_kwargs : Optional[Dict[str, Any]]\\n        Forwarded to botocore requests.\\n        e.g. s3_additional_kwargs={\\'ServerSideEncryption\\': \\'aws:kms\\', \\'SSEKMSKeyId\\': \\'YOUR_KMS_KEY_ARN\\'}\\n    sanitize_columns : bool\\n        True to sanitize columns names (using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`)\\n        or False to keep it as is.\\n        True value behaviour is enforced if `database` and `table` arguments are passed.\\n    dataset : bool\\n        If True store a orc dataset instead of a ordinary file(s)\\n        If True, enable all follow arguments:\\n        partition_cols, mode, database, table, description, parameters, columns_comments, concurrent_partitioning,\\n        catalog_versioning, projection_params, catalog_id, schema_evolution.\\n    filename_prefix: str, optional\\n        If dataset=True, add a filename prefix to the output files.\\n    partition_cols: List[str], optional\\n        List of column names that will be used to create partitions. Only takes effect if dataset=True.\\n    bucketing_info: Tuple[List[str], int], optional\\n        Tuple consisting of the column names used for bucketing as the first element and the number of buckets as the\\n        second element.\\n        Only `str`, `int` and `bool` are supported as column data types for bucketing.\\n    concurrent_partitioning: bool\\n        If True will increase the parallelism level during the partitions writing. It will decrease the\\n        writing time and increase the memory usage.\\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/022%20-%20Writing%20Partitions%20Concurrently.html\\n    mode: str, optional\\n        ``append`` (Default), ``overwrite``, ``overwrite_partitions``. Only takes effect if dataset=True.\\n    catalog_versioning : bool\\n        If True and `mode=\"overwrite\"`, creates an archived version of the table catalog before updating it.\\n    schema_evolution : bool\\n        If True allows schema evolution (new or missing columns), otherwise a exception will be raised. True by default.\\n        (Only considered if dataset=True and mode in (\"append\", \"overwrite_partitions\"))\\n        Related tutorial:\\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/014%20-%20Schema%20Evolution.html\\n    database : str, optional\\n        Glue/Athena catalog: Database name.\\n    table : str, optional\\n        Glue/Athena catalog: Table name.\\n    glue_table_settings: dict (GlueTableSettings), optional\\n        Settings for writing to the Glue table.\\n    dtype : Dict[str, str], optional\\n        Dictionary of columns names and Athena/Glue types to be casted.\\n        Useful when you have columns with undetermined or mixed data types.\\n        (e.g. {\\'col name\\': \\'bigint\\', \\'col2 name\\': \\'int\\'})\\n    athena_partition_projection_settings: typing.AthenaPartitionProjectionSettings, optional\\n        Parameters of the Athena Partition Projection (https://docs.aws.amazon.com/athena/latest/ug/partition-projection.html).\\n        AthenaPartitionProjectionSettings is a `TypedDict`, meaning the passed parameter can be instantiated either as an\\n        instance of AthenaPartitionProjectionSettings or as a regular Python dict.\\n\\n        Following projection parameters are supported:\\n\\n        .. list-table:: Projection Parameters\\n           :header-rows: 1\\n\\n           * - Name\\n             - Type\\n             - Description\\n           * - projection_types\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections types.\\n               Valid types: \"enum\", \"integer\", \"date\", \"injected\"\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'enum\\', \\'col2_name\\': \\'integer\\'})\\n           * - projection_ranges\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections ranges.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'0,10\\', \\'col2_name\\': \\'-1,8675309\\'})\\n           * - projection_values\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections values.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'A,B,Unknown\\', \\'col2_name\\': \\'foo,boo,bar\\'})\\n           * - projection_intervals\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections intervals.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'1\\', \\'col2_name\\': \\'5\\'})\\n           * - projection_digits\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections digits.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'1\\', \\'col2_name\\': \\'2\\'})\\n           * - projection_formats\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections formats.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_date\\': \\'yyyy-MM-dd\\', \\'col2_timestamp\\': \\'yyyy-MM-dd HH:mm:ss\\'})\\n           * - projection_storage_location_template\\n             - Optional[str]\\n             - Value which is allows Athena to properly map partition values if the S3 file locations do not follow\\n               a typical `.../column=value/...` pattern.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-setting-up.html\\n               (e.g. s3://bucket/table_root/a=${a}/${b}/some_static_subdirectory/${c}/)\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n\\n    Returns\\n    -------\\n    wr.typing._S3WriteDataReturnValue\\n        Dictionary with:\\n        \\'paths\\': List of all stored files paths on S3.\\n        \\'partitions_values\\': Dictionary of partitions added with keys as S3 path locations\\n        and values as a list of partitions values as str.\\n\\n    Examples\\n    --------\\n    Writing single file\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\'col\\': [1, 2, 3]}),\\n    ...     path=\\'s3://bucket/prefix/my_file.orc\\',\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://bucket/prefix/my_file.orc\\'],\\n        \\'partitions_values\\': {}\\n    }\\n\\n    Writing single file encrypted with a KMS key\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\'col\\': [1, 2, 3]}),\\n    ...     path=\\'s3://bucket/prefix/my_file.orc\\',\\n    ...     s3_additional_kwargs={\\n    ...         \\'ServerSideEncryption\\': \\'aws:kms\\',\\n    ...         \\'SSEKMSKeyId\\': \\'YOUR_KMS_KEY_ARN\\'\\n    ...     }\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://bucket/prefix/my_file.orc\\'],\\n        \\'partitions_values\\': {}\\n    }\\n\\n    Writing partitioned dataset\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'col2\\']\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../col2=A/x.orc\\', \\'s3://.../col2=B/y.orc\\'],\\n        \\'partitions_values: {\\n            \\'s3://.../col2=A/\\': [\\'A\\'],\\n            \\'s3://.../col2=B/\\': [\\'B\\']\\n        }\\n    }\\n\\n    Writing partitioned dataset with partition projection\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> from datetime import datetime\\n    >>> dt = lambda x: datetime.strptime(x, \"%Y-%m-%d\").date()\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \"id\": [1, 2, 3],\\n    ...         \"value\": [1000, 1001, 1002],\\n    ...         \"category\": [\\'A\\', \\'B\\', \\'C\\'],\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'value\\', \\'category\\'],\\n    ...     athena_partition_projection_settings={\\n    ...        \"projection_types\": {\\n    ...             \"value\": \"integer\",\\n    ...             \"category\": \"enum\",\\n    ...         },\\n    ...         \"projection_ranges\": {\\n    ...             \"value\": \"1000,2000\",\\n    ...             \"category\": \"A,B,C\",\\n    ...         },\\n    ...     },\\n    ... )\\n    {\\n        \\'paths\\': [\\n            \\'s3://.../value=1000/category=A/x.snappy.orc\\', ...\\n        ],\\n        \\'partitions_values\\': {\\n            \\'s3://.../value=1000/category=A/\\': [\\n                \\'1000\\',\\n                \\'A\\',\\n            ], ...\\n        }\\n    }\\n\\n    Writing bucketed dataset\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     bucketing_info=([\"col2\"], 2)\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../x_bucket-00000.csv\\', \\'s3://.../col2=B/x_bucket-00001.csv\\'],\\n        \\'partitions_values: {}\\n    }\\n\\n    Writing dataset to S3 with metadata on Athena/Glue Catalog.\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'col2\\'],\\n    ...     database=\\'default\\',  # Athena/Glue database\\n    ...     table=\\'my_table\\'  # Athena/Glue table\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../col2=A/x.orc\\', \\'s3://.../col2=B/y.orc\\'],\\n        \\'partitions_values: {\\n            \\'s3://.../col2=A/\\': [\\'A\\'],\\n            \\'s3://.../col2=B/\\': [\\'B\\']\\n        }\\n    }\\n\\n    Writing dataset to Glue governed table\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\'],\\n    ...     }),\\n    ...     dataset=True,\\n    ...     mode=\\'append\\',\\n    ...     database=\\'default\\',  # Athena/Glue database\\n    ...     table=\\'my_table\\',  # Athena/Glue table\\n    ...     glue_table_settings=wr.typing.GlueTableSettings(\\n    ...         table_type=\"GOVERNED\",\\n    ...         transaction_id=\"xxx\",\\n    ...     ),\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../x.orc\\'],\\n        \\'partitions_values: {}\\n    }\\n\\n    '\n    glue_table_settings = cast(GlueTableSettings, glue_table_settings if glue_table_settings else {})\n    table_type = glue_table_settings.get('table_type')\n    transaction_id = glue_table_settings.get('transaction_id')\n    description = glue_table_settings.get('description')\n    parameters = glue_table_settings.get('parameters')\n    columns_comments = glue_table_settings.get('columns_comments')\n    regular_partitions = glue_table_settings.get('regular_partitions', True)\n    _validate_args(df=df, table=table, database=database, dataset=dataset, path=path, partition_cols=partition_cols, bucketing_info=bucketing_info, mode=mode, description=description, parameters=parameters, columns_comments=columns_comments, execution_engine=engine.get())\n    if _COMPRESSION_2_EXT.get(compression, None) is None:\n        raise exceptions.InvalidCompression(f\"{compression} is invalid, please use None, 'snappy', 'zlib', 'lz4' or 'zstd'.\")\n    compression_ext: str = _COMPRESSION_2_EXT[compression]\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    strategy = _S3ORCWriteStrategy()\n    return strategy.write(df=df, path=path, index=index, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, max_rows_by_file=max_rows_by_file, use_threads=use_threads, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs, sanitize_columns=sanitize_columns, dataset=dataset, filename_prefix=filename_prefix, partition_cols=partition_cols, bucketing_info=bucketing_info, concurrent_partitioning=concurrent_partitioning, mode=mode, catalog_versioning=catalog_versioning, schema_evolution=schema_evolution, database=database, table=table, description=description, parameters=parameters, columns_comments=columns_comments, table_type=table_type, transaction_id=transaction_id, regular_partitions=regular_partitions, dtype=dtype, athena_partition_projection_settings=athena_partition_projection_settings, catalog_id=catalog_id, compression_ext=compression_ext)",
            "@_utils.validate_distributed_kwargs(unsupported_kwargs=['boto3_session', 's3_additional_kwargs'])\n@apply_configs\ndef to_orc(df: pd.DataFrame, path: Optional[str]=None, index: bool=False, compression: Optional[str]=None, pyarrow_additional_kwargs: Optional[Dict[str, Any]]=None, max_rows_by_file: Optional[int]=None, use_threads: Union[bool, int]=True, boto3_session: Optional[boto3.Session]=None, s3_additional_kwargs: Optional[Dict[str, Any]]=None, sanitize_columns: bool=False, dataset: bool=False, filename_prefix: Optional[str]=None, partition_cols: Optional[List[str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, concurrent_partitioning: bool=False, mode: Optional[Literal['append', 'overwrite', 'overwrite_partitions']]=None, catalog_versioning: bool=False, schema_evolution: bool=True, database: Optional[str]=None, table: Optional[str]=None, glue_table_settings: Optional[GlueTableSettings]=None, dtype: Optional[Dict[str, str]]=None, athena_partition_projection_settings: Optional[typing.AthenaPartitionProjectionSettings]=None, catalog_id: Optional[str]=None) -> _S3WriteDataReturnValue:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Write ORC file or dataset on Amazon S3.\\n\\n    The concept of Dataset goes beyond the simple idea of ordinary files and enable more\\n    complex features like partitioning and catalog integration (Amazon Athena/AWS Glue Catalog).\\n\\n    Note\\n    ----\\n    This operation may mutate the original pandas DataFrame in-place. To avoid this behaviour\\n    please pass in a deep copy instead (i.e. `df.copy()`)\\n\\n    Note\\n    ----\\n    If `database` and `table` arguments are passed, the table name and all column names\\n    will be automatically sanitized using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`.\\n    Please, pass `sanitize_columns=True` to enforce this behaviour always.\\n\\n    Note\\n    ----\\n    In case of `use_threads=True` the number of threads\\n    that will be spawned will be gotten from os.cpu_count().\\n\\n    Parameters\\n    ----------\\n    df: pandas.DataFrame\\n        Pandas DataFrame https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html\\n    path : str, optional\\n        S3 path (for file e.g. ``s3://bucket/prefix/filename.orc``) (for dataset e.g. ``s3://bucket/prefix``).\\n        Required if dataset=False or when dataset=True and creating a new dataset\\n    index : bool\\n        True to store the DataFrame index in file, otherwise False to ignore it.\\n        Is not supported in conjunction with `max_rows_by_file` when running the library with Ray/Modin.\\n    compression: str, optional\\n        Compression style (``None``, ``snappy``, ``gzip``, ``zstd``).\\n    pyarrow_additional_kwargs : Optional[Dict[str, Any]]\\n        Additional parameters forwarded to pyarrow.\\n        e.g. pyarrow_additional_kwargs={\\'coerce_timestamps\\': \\'ns\\', \\'use_deprecated_int96_timestamps\\': False,\\n        \\'allow_truncated_timestamps\\'=False}\\n    max_rows_by_file : int\\n        Max number of rows in each file.\\n        Default is None i.e. don\\'t split the files.\\n        (e.g. 33554432, 268435456)\\n        Is not supported in conjunction with `index=True` when running the library with Ray/Modin.\\n    use_threads : bool, int\\n        True to enable concurrent requests, False to disable multiple threads.\\n        If enabled os.cpu_count() will be used as the max number of threads.\\n        If integer is provided, specified number is used.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n    s3_additional_kwargs : Optional[Dict[str, Any]]\\n        Forwarded to botocore requests.\\n        e.g. s3_additional_kwargs={\\'ServerSideEncryption\\': \\'aws:kms\\', \\'SSEKMSKeyId\\': \\'YOUR_KMS_KEY_ARN\\'}\\n    sanitize_columns : bool\\n        True to sanitize columns names (using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`)\\n        or False to keep it as is.\\n        True value behaviour is enforced if `database` and `table` arguments are passed.\\n    dataset : bool\\n        If True store a orc dataset instead of a ordinary file(s)\\n        If True, enable all follow arguments:\\n        partition_cols, mode, database, table, description, parameters, columns_comments, concurrent_partitioning,\\n        catalog_versioning, projection_params, catalog_id, schema_evolution.\\n    filename_prefix: str, optional\\n        If dataset=True, add a filename prefix to the output files.\\n    partition_cols: List[str], optional\\n        List of column names that will be used to create partitions. Only takes effect if dataset=True.\\n    bucketing_info: Tuple[List[str], int], optional\\n        Tuple consisting of the column names used for bucketing as the first element and the number of buckets as the\\n        second element.\\n        Only `str`, `int` and `bool` are supported as column data types for bucketing.\\n    concurrent_partitioning: bool\\n        If True will increase the parallelism level during the partitions writing. It will decrease the\\n        writing time and increase the memory usage.\\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/022%20-%20Writing%20Partitions%20Concurrently.html\\n    mode: str, optional\\n        ``append`` (Default), ``overwrite``, ``overwrite_partitions``. Only takes effect if dataset=True.\\n    catalog_versioning : bool\\n        If True and `mode=\"overwrite\"`, creates an archived version of the table catalog before updating it.\\n    schema_evolution : bool\\n        If True allows schema evolution (new or missing columns), otherwise a exception will be raised. True by default.\\n        (Only considered if dataset=True and mode in (\"append\", \"overwrite_partitions\"))\\n        Related tutorial:\\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/014%20-%20Schema%20Evolution.html\\n    database : str, optional\\n        Glue/Athena catalog: Database name.\\n    table : str, optional\\n        Glue/Athena catalog: Table name.\\n    glue_table_settings: dict (GlueTableSettings), optional\\n        Settings for writing to the Glue table.\\n    dtype : Dict[str, str], optional\\n        Dictionary of columns names and Athena/Glue types to be casted.\\n        Useful when you have columns with undetermined or mixed data types.\\n        (e.g. {\\'col name\\': \\'bigint\\', \\'col2 name\\': \\'int\\'})\\n    athena_partition_projection_settings: typing.AthenaPartitionProjectionSettings, optional\\n        Parameters of the Athena Partition Projection (https://docs.aws.amazon.com/athena/latest/ug/partition-projection.html).\\n        AthenaPartitionProjectionSettings is a `TypedDict`, meaning the passed parameter can be instantiated either as an\\n        instance of AthenaPartitionProjectionSettings or as a regular Python dict.\\n\\n        Following projection parameters are supported:\\n\\n        .. list-table:: Projection Parameters\\n           :header-rows: 1\\n\\n           * - Name\\n             - Type\\n             - Description\\n           * - projection_types\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections types.\\n               Valid types: \"enum\", \"integer\", \"date\", \"injected\"\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'enum\\', \\'col2_name\\': \\'integer\\'})\\n           * - projection_ranges\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections ranges.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'0,10\\', \\'col2_name\\': \\'-1,8675309\\'})\\n           * - projection_values\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections values.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'A,B,Unknown\\', \\'col2_name\\': \\'foo,boo,bar\\'})\\n           * - projection_intervals\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections intervals.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'1\\', \\'col2_name\\': \\'5\\'})\\n           * - projection_digits\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections digits.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'1\\', \\'col2_name\\': \\'2\\'})\\n           * - projection_formats\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections formats.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_date\\': \\'yyyy-MM-dd\\', \\'col2_timestamp\\': \\'yyyy-MM-dd HH:mm:ss\\'})\\n           * - projection_storage_location_template\\n             - Optional[str]\\n             - Value which is allows Athena to properly map partition values if the S3 file locations do not follow\\n               a typical `.../column=value/...` pattern.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-setting-up.html\\n               (e.g. s3://bucket/table_root/a=${a}/${b}/some_static_subdirectory/${c}/)\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n\\n    Returns\\n    -------\\n    wr.typing._S3WriteDataReturnValue\\n        Dictionary with:\\n        \\'paths\\': List of all stored files paths on S3.\\n        \\'partitions_values\\': Dictionary of partitions added with keys as S3 path locations\\n        and values as a list of partitions values as str.\\n\\n    Examples\\n    --------\\n    Writing single file\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\'col\\': [1, 2, 3]}),\\n    ...     path=\\'s3://bucket/prefix/my_file.orc\\',\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://bucket/prefix/my_file.orc\\'],\\n        \\'partitions_values\\': {}\\n    }\\n\\n    Writing single file encrypted with a KMS key\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\'col\\': [1, 2, 3]}),\\n    ...     path=\\'s3://bucket/prefix/my_file.orc\\',\\n    ...     s3_additional_kwargs={\\n    ...         \\'ServerSideEncryption\\': \\'aws:kms\\',\\n    ...         \\'SSEKMSKeyId\\': \\'YOUR_KMS_KEY_ARN\\'\\n    ...     }\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://bucket/prefix/my_file.orc\\'],\\n        \\'partitions_values\\': {}\\n    }\\n\\n    Writing partitioned dataset\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'col2\\']\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../col2=A/x.orc\\', \\'s3://.../col2=B/y.orc\\'],\\n        \\'partitions_values: {\\n            \\'s3://.../col2=A/\\': [\\'A\\'],\\n            \\'s3://.../col2=B/\\': [\\'B\\']\\n        }\\n    }\\n\\n    Writing partitioned dataset with partition projection\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> from datetime import datetime\\n    >>> dt = lambda x: datetime.strptime(x, \"%Y-%m-%d\").date()\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \"id\": [1, 2, 3],\\n    ...         \"value\": [1000, 1001, 1002],\\n    ...         \"category\": [\\'A\\', \\'B\\', \\'C\\'],\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'value\\', \\'category\\'],\\n    ...     athena_partition_projection_settings={\\n    ...        \"projection_types\": {\\n    ...             \"value\": \"integer\",\\n    ...             \"category\": \"enum\",\\n    ...         },\\n    ...         \"projection_ranges\": {\\n    ...             \"value\": \"1000,2000\",\\n    ...             \"category\": \"A,B,C\",\\n    ...         },\\n    ...     },\\n    ... )\\n    {\\n        \\'paths\\': [\\n            \\'s3://.../value=1000/category=A/x.snappy.orc\\', ...\\n        ],\\n        \\'partitions_values\\': {\\n            \\'s3://.../value=1000/category=A/\\': [\\n                \\'1000\\',\\n                \\'A\\',\\n            ], ...\\n        }\\n    }\\n\\n    Writing bucketed dataset\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     bucketing_info=([\"col2\"], 2)\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../x_bucket-00000.csv\\', \\'s3://.../col2=B/x_bucket-00001.csv\\'],\\n        \\'partitions_values: {}\\n    }\\n\\n    Writing dataset to S3 with metadata on Athena/Glue Catalog.\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'col2\\'],\\n    ...     database=\\'default\\',  # Athena/Glue database\\n    ...     table=\\'my_table\\'  # Athena/Glue table\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../col2=A/x.orc\\', \\'s3://.../col2=B/y.orc\\'],\\n        \\'partitions_values: {\\n            \\'s3://.../col2=A/\\': [\\'A\\'],\\n            \\'s3://.../col2=B/\\': [\\'B\\']\\n        }\\n    }\\n\\n    Writing dataset to Glue governed table\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\'],\\n    ...     }),\\n    ...     dataset=True,\\n    ...     mode=\\'append\\',\\n    ...     database=\\'default\\',  # Athena/Glue database\\n    ...     table=\\'my_table\\',  # Athena/Glue table\\n    ...     glue_table_settings=wr.typing.GlueTableSettings(\\n    ...         table_type=\"GOVERNED\",\\n    ...         transaction_id=\"xxx\",\\n    ...     ),\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../x.orc\\'],\\n        \\'partitions_values: {}\\n    }\\n\\n    '\n    glue_table_settings = cast(GlueTableSettings, glue_table_settings if glue_table_settings else {})\n    table_type = glue_table_settings.get('table_type')\n    transaction_id = glue_table_settings.get('transaction_id')\n    description = glue_table_settings.get('description')\n    parameters = glue_table_settings.get('parameters')\n    columns_comments = glue_table_settings.get('columns_comments')\n    regular_partitions = glue_table_settings.get('regular_partitions', True)\n    _validate_args(df=df, table=table, database=database, dataset=dataset, path=path, partition_cols=partition_cols, bucketing_info=bucketing_info, mode=mode, description=description, parameters=parameters, columns_comments=columns_comments, execution_engine=engine.get())\n    if _COMPRESSION_2_EXT.get(compression, None) is None:\n        raise exceptions.InvalidCompression(f\"{compression} is invalid, please use None, 'snappy', 'zlib', 'lz4' or 'zstd'.\")\n    compression_ext: str = _COMPRESSION_2_EXT[compression]\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    strategy = _S3ORCWriteStrategy()\n    return strategy.write(df=df, path=path, index=index, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, max_rows_by_file=max_rows_by_file, use_threads=use_threads, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs, sanitize_columns=sanitize_columns, dataset=dataset, filename_prefix=filename_prefix, partition_cols=partition_cols, bucketing_info=bucketing_info, concurrent_partitioning=concurrent_partitioning, mode=mode, catalog_versioning=catalog_versioning, schema_evolution=schema_evolution, database=database, table=table, description=description, parameters=parameters, columns_comments=columns_comments, table_type=table_type, transaction_id=transaction_id, regular_partitions=regular_partitions, dtype=dtype, athena_partition_projection_settings=athena_partition_projection_settings, catalog_id=catalog_id, compression_ext=compression_ext)",
            "@_utils.validate_distributed_kwargs(unsupported_kwargs=['boto3_session', 's3_additional_kwargs'])\n@apply_configs\ndef to_orc(df: pd.DataFrame, path: Optional[str]=None, index: bool=False, compression: Optional[str]=None, pyarrow_additional_kwargs: Optional[Dict[str, Any]]=None, max_rows_by_file: Optional[int]=None, use_threads: Union[bool, int]=True, boto3_session: Optional[boto3.Session]=None, s3_additional_kwargs: Optional[Dict[str, Any]]=None, sanitize_columns: bool=False, dataset: bool=False, filename_prefix: Optional[str]=None, partition_cols: Optional[List[str]]=None, bucketing_info: Optional[BucketingInfoTuple]=None, concurrent_partitioning: bool=False, mode: Optional[Literal['append', 'overwrite', 'overwrite_partitions']]=None, catalog_versioning: bool=False, schema_evolution: bool=True, database: Optional[str]=None, table: Optional[str]=None, glue_table_settings: Optional[GlueTableSettings]=None, dtype: Optional[Dict[str, str]]=None, athena_partition_projection_settings: Optional[typing.AthenaPartitionProjectionSettings]=None, catalog_id: Optional[str]=None) -> _S3WriteDataReturnValue:\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Write ORC file or dataset on Amazon S3.\\n\\n    The concept of Dataset goes beyond the simple idea of ordinary files and enable more\\n    complex features like partitioning and catalog integration (Amazon Athena/AWS Glue Catalog).\\n\\n    Note\\n    ----\\n    This operation may mutate the original pandas DataFrame in-place. To avoid this behaviour\\n    please pass in a deep copy instead (i.e. `df.copy()`)\\n\\n    Note\\n    ----\\n    If `database` and `table` arguments are passed, the table name and all column names\\n    will be automatically sanitized using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`.\\n    Please, pass `sanitize_columns=True` to enforce this behaviour always.\\n\\n    Note\\n    ----\\n    In case of `use_threads=True` the number of threads\\n    that will be spawned will be gotten from os.cpu_count().\\n\\n    Parameters\\n    ----------\\n    df: pandas.DataFrame\\n        Pandas DataFrame https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html\\n    path : str, optional\\n        S3 path (for file e.g. ``s3://bucket/prefix/filename.orc``) (for dataset e.g. ``s3://bucket/prefix``).\\n        Required if dataset=False or when dataset=True and creating a new dataset\\n    index : bool\\n        True to store the DataFrame index in file, otherwise False to ignore it.\\n        Is not supported in conjunction with `max_rows_by_file` when running the library with Ray/Modin.\\n    compression: str, optional\\n        Compression style (``None``, ``snappy``, ``gzip``, ``zstd``).\\n    pyarrow_additional_kwargs : Optional[Dict[str, Any]]\\n        Additional parameters forwarded to pyarrow.\\n        e.g. pyarrow_additional_kwargs={\\'coerce_timestamps\\': \\'ns\\', \\'use_deprecated_int96_timestamps\\': False,\\n        \\'allow_truncated_timestamps\\'=False}\\n    max_rows_by_file : int\\n        Max number of rows in each file.\\n        Default is None i.e. don\\'t split the files.\\n        (e.g. 33554432, 268435456)\\n        Is not supported in conjunction with `index=True` when running the library with Ray/Modin.\\n    use_threads : bool, int\\n        True to enable concurrent requests, False to disable multiple threads.\\n        If enabled os.cpu_count() will be used as the max number of threads.\\n        If integer is provided, specified number is used.\\n    boto3_session : boto3.Session(), optional\\n        Boto3 Session. The default boto3 session will be used if boto3_session receive None.\\n    s3_additional_kwargs : Optional[Dict[str, Any]]\\n        Forwarded to botocore requests.\\n        e.g. s3_additional_kwargs={\\'ServerSideEncryption\\': \\'aws:kms\\', \\'SSEKMSKeyId\\': \\'YOUR_KMS_KEY_ARN\\'}\\n    sanitize_columns : bool\\n        True to sanitize columns names (using `wr.catalog.sanitize_table_name` and `wr.catalog.sanitize_column_name`)\\n        or False to keep it as is.\\n        True value behaviour is enforced if `database` and `table` arguments are passed.\\n    dataset : bool\\n        If True store a orc dataset instead of a ordinary file(s)\\n        If True, enable all follow arguments:\\n        partition_cols, mode, database, table, description, parameters, columns_comments, concurrent_partitioning,\\n        catalog_versioning, projection_params, catalog_id, schema_evolution.\\n    filename_prefix: str, optional\\n        If dataset=True, add a filename prefix to the output files.\\n    partition_cols: List[str], optional\\n        List of column names that will be used to create partitions. Only takes effect if dataset=True.\\n    bucketing_info: Tuple[List[str], int], optional\\n        Tuple consisting of the column names used for bucketing as the first element and the number of buckets as the\\n        second element.\\n        Only `str`, `int` and `bool` are supported as column data types for bucketing.\\n    concurrent_partitioning: bool\\n        If True will increase the parallelism level during the partitions writing. It will decrease the\\n        writing time and increase the memory usage.\\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/022%20-%20Writing%20Partitions%20Concurrently.html\\n    mode: str, optional\\n        ``append`` (Default), ``overwrite``, ``overwrite_partitions``. Only takes effect if dataset=True.\\n    catalog_versioning : bool\\n        If True and `mode=\"overwrite\"`, creates an archived version of the table catalog before updating it.\\n    schema_evolution : bool\\n        If True allows schema evolution (new or missing columns), otherwise a exception will be raised. True by default.\\n        (Only considered if dataset=True and mode in (\"append\", \"overwrite_partitions\"))\\n        Related tutorial:\\n        https://aws-sdk-pandas.readthedocs.io/en/3.1.1/tutorials/014%20-%20Schema%20Evolution.html\\n    database : str, optional\\n        Glue/Athena catalog: Database name.\\n    table : str, optional\\n        Glue/Athena catalog: Table name.\\n    glue_table_settings: dict (GlueTableSettings), optional\\n        Settings for writing to the Glue table.\\n    dtype : Dict[str, str], optional\\n        Dictionary of columns names and Athena/Glue types to be casted.\\n        Useful when you have columns with undetermined or mixed data types.\\n        (e.g. {\\'col name\\': \\'bigint\\', \\'col2 name\\': \\'int\\'})\\n    athena_partition_projection_settings: typing.AthenaPartitionProjectionSettings, optional\\n        Parameters of the Athena Partition Projection (https://docs.aws.amazon.com/athena/latest/ug/partition-projection.html).\\n        AthenaPartitionProjectionSettings is a `TypedDict`, meaning the passed parameter can be instantiated either as an\\n        instance of AthenaPartitionProjectionSettings or as a regular Python dict.\\n\\n        Following projection parameters are supported:\\n\\n        .. list-table:: Projection Parameters\\n           :header-rows: 1\\n\\n           * - Name\\n             - Type\\n             - Description\\n           * - projection_types\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections types.\\n               Valid types: \"enum\", \"integer\", \"date\", \"injected\"\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'enum\\', \\'col2_name\\': \\'integer\\'})\\n           * - projection_ranges\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections ranges.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'0,10\\', \\'col2_name\\': \\'-1,8675309\\'})\\n           * - projection_values\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections values.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'A,B,Unknown\\', \\'col2_name\\': \\'foo,boo,bar\\'})\\n           * - projection_intervals\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections intervals.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'1\\', \\'col2_name\\': \\'5\\'})\\n           * - projection_digits\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections digits.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_name\\': \\'1\\', \\'col2_name\\': \\'2\\'})\\n           * - projection_formats\\n             - Optional[Dict[str, str]]\\n             - Dictionary of partitions names and Athena projections formats.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-supported-types.html\\n               (e.g. {\\'col_date\\': \\'yyyy-MM-dd\\', \\'col2_timestamp\\': \\'yyyy-MM-dd HH:mm:ss\\'})\\n           * - projection_storage_location_template\\n             - Optional[str]\\n             - Value which is allows Athena to properly map partition values if the S3 file locations do not follow\\n               a typical `.../column=value/...` pattern.\\n               https://docs.aws.amazon.com/athena/latest/ug/partition-projection-setting-up.html\\n               (e.g. s3://bucket/table_root/a=${a}/${b}/some_static_subdirectory/${c}/)\\n    catalog_id : str, optional\\n        The ID of the Data Catalog from which to retrieve Databases.\\n        If none is provided, the AWS account ID is used by default.\\n\\n    Returns\\n    -------\\n    wr.typing._S3WriteDataReturnValue\\n        Dictionary with:\\n        \\'paths\\': List of all stored files paths on S3.\\n        \\'partitions_values\\': Dictionary of partitions added with keys as S3 path locations\\n        and values as a list of partitions values as str.\\n\\n    Examples\\n    --------\\n    Writing single file\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\'col\\': [1, 2, 3]}),\\n    ...     path=\\'s3://bucket/prefix/my_file.orc\\',\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://bucket/prefix/my_file.orc\\'],\\n        \\'partitions_values\\': {}\\n    }\\n\\n    Writing single file encrypted with a KMS key\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\'col\\': [1, 2, 3]}),\\n    ...     path=\\'s3://bucket/prefix/my_file.orc\\',\\n    ...     s3_additional_kwargs={\\n    ...         \\'ServerSideEncryption\\': \\'aws:kms\\',\\n    ...         \\'SSEKMSKeyId\\': \\'YOUR_KMS_KEY_ARN\\'\\n    ...     }\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://bucket/prefix/my_file.orc\\'],\\n        \\'partitions_values\\': {}\\n    }\\n\\n    Writing partitioned dataset\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'col2\\']\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../col2=A/x.orc\\', \\'s3://.../col2=B/y.orc\\'],\\n        \\'partitions_values: {\\n            \\'s3://.../col2=A/\\': [\\'A\\'],\\n            \\'s3://.../col2=B/\\': [\\'B\\']\\n        }\\n    }\\n\\n    Writing partitioned dataset with partition projection\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> from datetime import datetime\\n    >>> dt = lambda x: datetime.strptime(x, \"%Y-%m-%d\").date()\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \"id\": [1, 2, 3],\\n    ...         \"value\": [1000, 1001, 1002],\\n    ...         \"category\": [\\'A\\', \\'B\\', \\'C\\'],\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'value\\', \\'category\\'],\\n    ...     athena_partition_projection_settings={\\n    ...        \"projection_types\": {\\n    ...             \"value\": \"integer\",\\n    ...             \"category\": \"enum\",\\n    ...         },\\n    ...         \"projection_ranges\": {\\n    ...             \"value\": \"1000,2000\",\\n    ...             \"category\": \"A,B,C\",\\n    ...         },\\n    ...     },\\n    ... )\\n    {\\n        \\'paths\\': [\\n            \\'s3://.../value=1000/category=A/x.snappy.orc\\', ...\\n        ],\\n        \\'partitions_values\\': {\\n            \\'s3://.../value=1000/category=A/\\': [\\n                \\'1000\\',\\n                \\'A\\',\\n            ], ...\\n        }\\n    }\\n\\n    Writing bucketed dataset\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     bucketing_info=([\"col2\"], 2)\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../x_bucket-00000.csv\\', \\'s3://.../col2=B/x_bucket-00001.csv\\'],\\n        \\'partitions_values: {}\\n    }\\n\\n    Writing dataset to S3 with metadata on Athena/Glue Catalog.\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\']\\n    ...     }),\\n    ...     path=\\'s3://bucket/prefix\\',\\n    ...     dataset=True,\\n    ...     partition_cols=[\\'col2\\'],\\n    ...     database=\\'default\\',  # Athena/Glue database\\n    ...     table=\\'my_table\\'  # Athena/Glue table\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../col2=A/x.orc\\', \\'s3://.../col2=B/y.orc\\'],\\n        \\'partitions_values: {\\n            \\'s3://.../col2=A/\\': [\\'A\\'],\\n            \\'s3://.../col2=B/\\': [\\'B\\']\\n        }\\n    }\\n\\n    Writing dataset to Glue governed table\\n\\n    >>> import awswrangler as wr\\n    >>> import pandas as pd\\n    >>> wr.s3.to_orc(\\n    ...     df=pd.DataFrame({\\n    ...         \\'col\\': [1, 2, 3],\\n    ...         \\'col2\\': [\\'A\\', \\'A\\', \\'B\\'],\\n    ...     }),\\n    ...     dataset=True,\\n    ...     mode=\\'append\\',\\n    ...     database=\\'default\\',  # Athena/Glue database\\n    ...     table=\\'my_table\\',  # Athena/Glue table\\n    ...     glue_table_settings=wr.typing.GlueTableSettings(\\n    ...         table_type=\"GOVERNED\",\\n    ...         transaction_id=\"xxx\",\\n    ...     ),\\n    ... )\\n    {\\n        \\'paths\\': [\\'s3://.../x.orc\\'],\\n        \\'partitions_values: {}\\n    }\\n\\n    '\n    glue_table_settings = cast(GlueTableSettings, glue_table_settings if glue_table_settings else {})\n    table_type = glue_table_settings.get('table_type')\n    transaction_id = glue_table_settings.get('transaction_id')\n    description = glue_table_settings.get('description')\n    parameters = glue_table_settings.get('parameters')\n    columns_comments = glue_table_settings.get('columns_comments')\n    regular_partitions = glue_table_settings.get('regular_partitions', True)\n    _validate_args(df=df, table=table, database=database, dataset=dataset, path=path, partition_cols=partition_cols, bucketing_info=bucketing_info, mode=mode, description=description, parameters=parameters, columns_comments=columns_comments, execution_engine=engine.get())\n    if _COMPRESSION_2_EXT.get(compression, None) is None:\n        raise exceptions.InvalidCompression(f\"{compression} is invalid, please use None, 'snappy', 'zlib', 'lz4' or 'zstd'.\")\n    compression_ext: str = _COMPRESSION_2_EXT[compression]\n    if not pyarrow_additional_kwargs:\n        pyarrow_additional_kwargs = {}\n    strategy = _S3ORCWriteStrategy()\n    return strategy.write(df=df, path=path, index=index, compression=compression, pyarrow_additional_kwargs=pyarrow_additional_kwargs, max_rows_by_file=max_rows_by_file, use_threads=use_threads, boto3_session=boto3_session, s3_additional_kwargs=s3_additional_kwargs, sanitize_columns=sanitize_columns, dataset=dataset, filename_prefix=filename_prefix, partition_cols=partition_cols, bucketing_info=bucketing_info, concurrent_partitioning=concurrent_partitioning, mode=mode, catalog_versioning=catalog_versioning, schema_evolution=schema_evolution, database=database, table=table, description=description, parameters=parameters, columns_comments=columns_comments, table_type=table_type, transaction_id=transaction_id, regular_partitions=regular_partitions, dtype=dtype, athena_partition_projection_settings=athena_partition_projection_settings, catalog_id=catalog_id, compression_ext=compression_ext)"
        ]
    }
]