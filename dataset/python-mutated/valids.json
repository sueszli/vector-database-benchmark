[
    {
        "func_name": "extract_metric",
        "original": "def extract_metric(s, metric):\n    try:\n        j = json.loads(s)\n    except:\n        return None\n    if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n        return None\n    return j[metric] if metric in j else None",
        "mutated": [
            "def extract_metric(s, metric):\n    if False:\n        i = 10\n    try:\n        j = json.loads(s)\n    except:\n        return None\n    if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n        return None\n    return j[metric] if metric in j else None",
            "def extract_metric(s, metric):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        j = json.loads(s)\n    except:\n        return None\n    if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n        return None\n    return j[metric] if metric in j else None",
            "def extract_metric(s, metric):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        j = json.loads(s)\n    except:\n        return None\n    if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n        return None\n    return j[metric] if metric in j else None",
            "def extract_metric(s, metric):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        j = json.loads(s)\n    except:\n        return None\n    if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n        return None\n    return j[metric] if metric in j else None",
            "def extract_metric(s, metric):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        j = json.loads(s)\n    except:\n        return None\n    if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n        return None\n    return j[metric] if metric in j else None"
        ]
    },
    {
        "func_name": "extract_params",
        "original": "def extract_params(s):\n    s = s.replace(args.base, '', 1)\n    if args.path_contains is not None:\n        s = s.replace(args.path_contains, '', 1)\n    if args.hydra:\n        num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n        str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n        lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n        task_matches = re.findall('.*/(\\\\d+)$', s)\n    else:\n        num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n        str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n        lr_matches = []\n        task_matches = []\n    cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n    items = OrderedDict()\n    for m in str_matches:\n        if isinstance(m, tuple):\n            if 'checkpoint' not in m[0]:\n                items[m[0]] = m[1]\n        else:\n            items[m] = ''\n    for m in num_matches:\n        items[m[0]] = m[1]\n    for m in lr_matches:\n        items[m[0]] = m[1]\n    for m in task_matches:\n        items['hydra_task'] = m\n    for m in cp_matches:\n        items['checkpoint'] = m\n    return items",
        "mutated": [
            "def extract_params(s):\n    if False:\n        i = 10\n    s = s.replace(args.base, '', 1)\n    if args.path_contains is not None:\n        s = s.replace(args.path_contains, '', 1)\n    if args.hydra:\n        num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n        str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n        lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n        task_matches = re.findall('.*/(\\\\d+)$', s)\n    else:\n        num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n        str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n        lr_matches = []\n        task_matches = []\n    cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n    items = OrderedDict()\n    for m in str_matches:\n        if isinstance(m, tuple):\n            if 'checkpoint' not in m[0]:\n                items[m[0]] = m[1]\n        else:\n            items[m] = ''\n    for m in num_matches:\n        items[m[0]] = m[1]\n    for m in lr_matches:\n        items[m[0]] = m[1]\n    for m in task_matches:\n        items['hydra_task'] = m\n    for m in cp_matches:\n        items['checkpoint'] = m\n    return items",
            "def extract_params(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    s = s.replace(args.base, '', 1)\n    if args.path_contains is not None:\n        s = s.replace(args.path_contains, '', 1)\n    if args.hydra:\n        num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n        str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n        lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n        task_matches = re.findall('.*/(\\\\d+)$', s)\n    else:\n        num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n        str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n        lr_matches = []\n        task_matches = []\n    cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n    items = OrderedDict()\n    for m in str_matches:\n        if isinstance(m, tuple):\n            if 'checkpoint' not in m[0]:\n                items[m[0]] = m[1]\n        else:\n            items[m] = ''\n    for m in num_matches:\n        items[m[0]] = m[1]\n    for m in lr_matches:\n        items[m[0]] = m[1]\n    for m in task_matches:\n        items['hydra_task'] = m\n    for m in cp_matches:\n        items['checkpoint'] = m\n    return items",
            "def extract_params(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    s = s.replace(args.base, '', 1)\n    if args.path_contains is not None:\n        s = s.replace(args.path_contains, '', 1)\n    if args.hydra:\n        num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n        str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n        lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n        task_matches = re.findall('.*/(\\\\d+)$', s)\n    else:\n        num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n        str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n        lr_matches = []\n        task_matches = []\n    cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n    items = OrderedDict()\n    for m in str_matches:\n        if isinstance(m, tuple):\n            if 'checkpoint' not in m[0]:\n                items[m[0]] = m[1]\n        else:\n            items[m] = ''\n    for m in num_matches:\n        items[m[0]] = m[1]\n    for m in lr_matches:\n        items[m[0]] = m[1]\n    for m in task_matches:\n        items['hydra_task'] = m\n    for m in cp_matches:\n        items['checkpoint'] = m\n    return items",
            "def extract_params(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    s = s.replace(args.base, '', 1)\n    if args.path_contains is not None:\n        s = s.replace(args.path_contains, '', 1)\n    if args.hydra:\n        num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n        str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n        lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n        task_matches = re.findall('.*/(\\\\d+)$', s)\n    else:\n        num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n        str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n        lr_matches = []\n        task_matches = []\n    cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n    items = OrderedDict()\n    for m in str_matches:\n        if isinstance(m, tuple):\n            if 'checkpoint' not in m[0]:\n                items[m[0]] = m[1]\n        else:\n            items[m] = ''\n    for m in num_matches:\n        items[m[0]] = m[1]\n    for m in lr_matches:\n        items[m[0]] = m[1]\n    for m in task_matches:\n        items['hydra_task'] = m\n    for m in cp_matches:\n        items['checkpoint'] = m\n    return items",
            "def extract_params(s):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    s = s.replace(args.base, '', 1)\n    if args.path_contains is not None:\n        s = s.replace(args.path_contains, '', 1)\n    if args.hydra:\n        num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n        str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n        lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n        task_matches = re.findall('.*/(\\\\d+)$', s)\n    else:\n        num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n        str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n        lr_matches = []\n        task_matches = []\n    cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n    items = OrderedDict()\n    for m in str_matches:\n        if isinstance(m, tuple):\n            if 'checkpoint' not in m[0]:\n                items[m[0]] = m[1]\n        else:\n            items[m] = ''\n    for m in num_matches:\n        items[m[0]] = m[1]\n    for m in lr_matches:\n        items[m[0]] = m[1]\n    for m in task_matches:\n        items['hydra_task'] = m\n    for m in cp_matches:\n        items['checkpoint'] = m\n    return items"
        ]
    },
    {
        "func_name": "cmp",
        "original": "def cmp(a, b):\n    a = float(a)\n    b = float(b)\n    if args.best_biggest:\n        return a > b\n    return a < b",
        "mutated": [
            "def cmp(a, b):\n    if False:\n        i = 10\n    a = float(a)\n    b = float(b)\n    if args.best_biggest:\n        return a > b\n    return a < b",
            "def cmp(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    a = float(a)\n    b = float(b)\n    if args.best_biggest:\n        return a > b\n    return a < b",
            "def cmp(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    a = float(a)\n    b = float(b)\n    if args.best_biggest:\n        return a > b\n    return a < b",
            "def cmp(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    a = float(a)\n    b = float(b)\n    if args.best_biggest:\n        return a > b\n    return a < b",
            "def cmp(a, b):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    a = float(a)\n    b = float(b)\n    if args.best_biggest:\n        return a > b\n    return a < b"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(args, print_output):\n    ret = {}\n    entries = []\n\n    def extract_metric(s, metric):\n        try:\n            j = json.loads(s)\n        except:\n            return None\n        if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n            return None\n        return j[metric] if metric in j else None\n\n    def extract_params(s):\n        s = s.replace(args.base, '', 1)\n        if args.path_contains is not None:\n            s = s.replace(args.path_contains, '', 1)\n        if args.hydra:\n            num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n            str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n            lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n            task_matches = re.findall('.*/(\\\\d+)$', s)\n        else:\n            num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n            str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n            lr_matches = []\n            task_matches = []\n        cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n        items = OrderedDict()\n        for m in str_matches:\n            if isinstance(m, tuple):\n                if 'checkpoint' not in m[0]:\n                    items[m[0]] = m[1]\n            else:\n                items[m] = ''\n        for m in num_matches:\n            items[m[0]] = m[1]\n        for m in lr_matches:\n            items[m[0]] = m[1]\n        for m in task_matches:\n            items['hydra_task'] = m\n        for m in cp_matches:\n            items['checkpoint'] = m\n        return items\n    abs_best = None\n    sources = []\n    for (root, _, files) in os.walk(args.base):\n        if args.path_contains is not None and (not args.path_contains in root):\n            continue\n        for f in files:\n            if f.endswith(args.file_name):\n                sources.append((root, f))\n    if args.last_files is not None:\n        sources = sources[-args.last_files:]\n    for (root, file) in sources:\n        with open(os.path.join(root, file), 'r') as fin:\n            found = []\n            avg = {}\n            prev = None\n            for line in fin:\n                line = line.rstrip()\n                if line.find(args.target) != -1 and (args.skip_containing is None or line.find(args.skip_containing) == -1):\n                    try:\n                        idx = line.index('{')\n                        line = line[idx:]\n                        line_json = json.loads(line)\n                    except:\n                        continue\n                    if prev is not None:\n                        try:\n                            prev.update(line_json)\n                            line_json = prev\n                        except:\n                            pass\n                    if args.target in line_json:\n                        found.append(line_json)\n                if args.avg_params:\n                    avg_params = args.avg_params.split(',')\n                    for p in avg_params:\n                        m = extract_metric(line, p)\n                        if m is not None:\n                            (prev_v, prev_c) = avg.get(p, (0, 0))\n                            avg[p] = (prev_v + float(m), prev_c + 1)\n                if args.extract_prev:\n                    try:\n                        prev = json.loads(line)\n                    except:\n                        pass\n            best = None\n            if args.best:\n                curr_best = None\n                for i in range(len(found)):\n                    cand_best = found[i][args.target] if args.target in found[i] else None\n\n                    def cmp(a, b):\n                        a = float(a)\n                        b = float(b)\n                        if args.best_biggest:\n                            return a > b\n                        return a < b\n                    if cand_best is not None and (not math.isnan(float(cand_best))) and (curr_best is None or cmp(cand_best, curr_best)):\n                        curr_best = cand_best\n                        if abs_best is None or cmp(curr_best, abs_best):\n                            abs_best = curr_best\n                        best = found[i]\n            if args.unique_epochs or args.epoch:\n                last_found = []\n                last_epoch = None\n                for i in reversed(range(len(found))):\n                    epoch = found[i]['epoch']\n                    if args.epoch and args.epoch != epoch:\n                        continue\n                    if epoch != last_epoch:\n                        last_epoch = epoch\n                        last_found.append(found[i])\n                found = list(reversed(last_found))\n            if len(found) == 0:\n                if print_output and (args.last_files is not None or not args.skip_empty):\n                    print(root[len(args.base):])\n                    print('Nothing')\n            else:\n                if not print_output:\n                    ret[root[len(args.base):]] = best\n                    continue\n                if args.compact:\n                    print('{}\\t{}'.format(root[len(args.base) + 1:], curr_best))\n                    continue\n                if args.group_on is None and (not args.best_only):\n                    print(root[len(args.base):])\n                if not args.everything:\n                    if best is not None and args.group_on is None and (not args.best_only) and (not args.flat):\n                        print(best, '(best)')\n                    if args.group_on is None and args.last and (not args.best_only) and (not args.flat):\n                        for f in found[-args.last:]:\n                            if args.extract_prev is not None:\n                                try:\n                                    print('{}\\t{}'.format(f[args.extract_prev], f[args.target]))\n                                except Exception as e:\n                                    print('Exception!', e)\n                            else:\n                                print(f)\n                    try:\n                        metric = found[-1][args.target] if not args.best or best is None else best[args.target]\n                    except:\n                        print(found[-1])\n                        raise\n                    if metric is not None:\n                        entries.append((extract_params(root), metric))\n                else:\n                    for f in found:\n                        print(f)\n                if not args.group_on and print_output:\n                    print()\n            if len(avg) > 0:\n                for (k, (v, c)) in avg.items():\n                    print(f'{k}: {v / c}')\n    if args.best_only:\n        print(abs_best)\n    if args.flat:\n        print('\\t'.join((m for (_, m) in entries)))\n    if args.group_on is not None:\n        by_val = OrderedDict()\n        for (e, m) in entries:\n            k = args.group_on\n            if k not in e:\n                m_keys = [x for x in e.keys() if x.startswith(k)]\n                if len(m_keys) == 0:\n                    val = 'False'\n                else:\n                    assert len(m_keys) == 1\n                    k = m_keys[0]\n                    val = m_keys[0]\n            else:\n                val = e[args.group_on]\n                if val == '':\n                    val = 'True'\n            scrubbed_entry = copy.deepcopy(e)\n            if k in scrubbed_entry:\n                del scrubbed_entry[k]\n            if args.remove_metric and args.remove_metric in scrubbed_entry:\n                val += '_' + scrubbed_entry[args.remove_metric]\n                del scrubbed_entry[args.remove_metric]\n            by_val.setdefault(tuple(scrubbed_entry.items()), dict())[val] = m\n        distinct_vals = set()\n        for v in by_val.values():\n            distinct_vals.update(v.keys())\n        try:\n            distinct_vals = {int(d) for d in distinct_vals}\n        except:\n            print(distinct_vals)\n            print()\n            print('by_val', len(by_val))\n            for (k, v) in by_val.items():\n                print(k, '=>', v)\n            print()\n            raise\n        from natsort import natsorted\n        svals = list(map(str, natsorted(distinct_vals)))\n        print('{}\\t{}'.format(args.group_on, '\\t'.join(svals)))\n        sums = OrderedDict({n: [] for n in svals})\n        for (k, v) in by_val.items():\n            kstr = '.'.join((':'.join(x) for x in k))\n            vstr = ''\n            for mv in svals:\n                x = v[mv] if mv in v else ''\n                vstr += '\\t{}'.format(round(x, 5) if isinstance(x, float) else x)\n                try:\n                    sums[mv].append(float(x))\n                except:\n                    pass\n            print('{}{}'.format(kstr[:args.key_len], vstr))\n        if any((len(x) > 0 for x in sums.values())):\n            print('min:', end='')\n            for v in sums.values():\n                min = np.min(v)\n                print(f'\\t{round(min, 5)}', end='')\n            print()\n            print('max:', end='')\n            for v in sums.values():\n                max = np.max(v)\n                print(f'\\t{round(max, 5)}', end='')\n            print()\n            print('avg:', end='')\n            for v in sums.values():\n                mean = np.mean(v)\n                print(f'\\t{round(mean, 5)}', end='')\n            print()\n            print('median:', end='')\n            for v in sums.values():\n                median = np.median(v)\n                print(f'\\t{round(median, 5)}', end='')\n            print()\n    return ret",
        "mutated": [
            "def main(args, print_output):\n    if False:\n        i = 10\n    ret = {}\n    entries = []\n\n    def extract_metric(s, metric):\n        try:\n            j = json.loads(s)\n        except:\n            return None\n        if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n            return None\n        return j[metric] if metric in j else None\n\n    def extract_params(s):\n        s = s.replace(args.base, '', 1)\n        if args.path_contains is not None:\n            s = s.replace(args.path_contains, '', 1)\n        if args.hydra:\n            num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n            str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n            lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n            task_matches = re.findall('.*/(\\\\d+)$', s)\n        else:\n            num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n            str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n            lr_matches = []\n            task_matches = []\n        cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n        items = OrderedDict()\n        for m in str_matches:\n            if isinstance(m, tuple):\n                if 'checkpoint' not in m[0]:\n                    items[m[0]] = m[1]\n            else:\n                items[m] = ''\n        for m in num_matches:\n            items[m[0]] = m[1]\n        for m in lr_matches:\n            items[m[0]] = m[1]\n        for m in task_matches:\n            items['hydra_task'] = m\n        for m in cp_matches:\n            items['checkpoint'] = m\n        return items\n    abs_best = None\n    sources = []\n    for (root, _, files) in os.walk(args.base):\n        if args.path_contains is not None and (not args.path_contains in root):\n            continue\n        for f in files:\n            if f.endswith(args.file_name):\n                sources.append((root, f))\n    if args.last_files is not None:\n        sources = sources[-args.last_files:]\n    for (root, file) in sources:\n        with open(os.path.join(root, file), 'r') as fin:\n            found = []\n            avg = {}\n            prev = None\n            for line in fin:\n                line = line.rstrip()\n                if line.find(args.target) != -1 and (args.skip_containing is None or line.find(args.skip_containing) == -1):\n                    try:\n                        idx = line.index('{')\n                        line = line[idx:]\n                        line_json = json.loads(line)\n                    except:\n                        continue\n                    if prev is not None:\n                        try:\n                            prev.update(line_json)\n                            line_json = prev\n                        except:\n                            pass\n                    if args.target in line_json:\n                        found.append(line_json)\n                if args.avg_params:\n                    avg_params = args.avg_params.split(',')\n                    for p in avg_params:\n                        m = extract_metric(line, p)\n                        if m is not None:\n                            (prev_v, prev_c) = avg.get(p, (0, 0))\n                            avg[p] = (prev_v + float(m), prev_c + 1)\n                if args.extract_prev:\n                    try:\n                        prev = json.loads(line)\n                    except:\n                        pass\n            best = None\n            if args.best:\n                curr_best = None\n                for i in range(len(found)):\n                    cand_best = found[i][args.target] if args.target in found[i] else None\n\n                    def cmp(a, b):\n                        a = float(a)\n                        b = float(b)\n                        if args.best_biggest:\n                            return a > b\n                        return a < b\n                    if cand_best is not None and (not math.isnan(float(cand_best))) and (curr_best is None or cmp(cand_best, curr_best)):\n                        curr_best = cand_best\n                        if abs_best is None or cmp(curr_best, abs_best):\n                            abs_best = curr_best\n                        best = found[i]\n            if args.unique_epochs or args.epoch:\n                last_found = []\n                last_epoch = None\n                for i in reversed(range(len(found))):\n                    epoch = found[i]['epoch']\n                    if args.epoch and args.epoch != epoch:\n                        continue\n                    if epoch != last_epoch:\n                        last_epoch = epoch\n                        last_found.append(found[i])\n                found = list(reversed(last_found))\n            if len(found) == 0:\n                if print_output and (args.last_files is not None or not args.skip_empty):\n                    print(root[len(args.base):])\n                    print('Nothing')\n            else:\n                if not print_output:\n                    ret[root[len(args.base):]] = best\n                    continue\n                if args.compact:\n                    print('{}\\t{}'.format(root[len(args.base) + 1:], curr_best))\n                    continue\n                if args.group_on is None and (not args.best_only):\n                    print(root[len(args.base):])\n                if not args.everything:\n                    if best is not None and args.group_on is None and (not args.best_only) and (not args.flat):\n                        print(best, '(best)')\n                    if args.group_on is None and args.last and (not args.best_only) and (not args.flat):\n                        for f in found[-args.last:]:\n                            if args.extract_prev is not None:\n                                try:\n                                    print('{}\\t{}'.format(f[args.extract_prev], f[args.target]))\n                                except Exception as e:\n                                    print('Exception!', e)\n                            else:\n                                print(f)\n                    try:\n                        metric = found[-1][args.target] if not args.best or best is None else best[args.target]\n                    except:\n                        print(found[-1])\n                        raise\n                    if metric is not None:\n                        entries.append((extract_params(root), metric))\n                else:\n                    for f in found:\n                        print(f)\n                if not args.group_on and print_output:\n                    print()\n            if len(avg) > 0:\n                for (k, (v, c)) in avg.items():\n                    print(f'{k}: {v / c}')\n    if args.best_only:\n        print(abs_best)\n    if args.flat:\n        print('\\t'.join((m for (_, m) in entries)))\n    if args.group_on is not None:\n        by_val = OrderedDict()\n        for (e, m) in entries:\n            k = args.group_on\n            if k not in e:\n                m_keys = [x for x in e.keys() if x.startswith(k)]\n                if len(m_keys) == 0:\n                    val = 'False'\n                else:\n                    assert len(m_keys) == 1\n                    k = m_keys[0]\n                    val = m_keys[0]\n            else:\n                val = e[args.group_on]\n                if val == '':\n                    val = 'True'\n            scrubbed_entry = copy.deepcopy(e)\n            if k in scrubbed_entry:\n                del scrubbed_entry[k]\n            if args.remove_metric and args.remove_metric in scrubbed_entry:\n                val += '_' + scrubbed_entry[args.remove_metric]\n                del scrubbed_entry[args.remove_metric]\n            by_val.setdefault(tuple(scrubbed_entry.items()), dict())[val] = m\n        distinct_vals = set()\n        for v in by_val.values():\n            distinct_vals.update(v.keys())\n        try:\n            distinct_vals = {int(d) for d in distinct_vals}\n        except:\n            print(distinct_vals)\n            print()\n            print('by_val', len(by_val))\n            for (k, v) in by_val.items():\n                print(k, '=>', v)\n            print()\n            raise\n        from natsort import natsorted\n        svals = list(map(str, natsorted(distinct_vals)))\n        print('{}\\t{}'.format(args.group_on, '\\t'.join(svals)))\n        sums = OrderedDict({n: [] for n in svals})\n        for (k, v) in by_val.items():\n            kstr = '.'.join((':'.join(x) for x in k))\n            vstr = ''\n            for mv in svals:\n                x = v[mv] if mv in v else ''\n                vstr += '\\t{}'.format(round(x, 5) if isinstance(x, float) else x)\n                try:\n                    sums[mv].append(float(x))\n                except:\n                    pass\n            print('{}{}'.format(kstr[:args.key_len], vstr))\n        if any((len(x) > 0 for x in sums.values())):\n            print('min:', end='')\n            for v in sums.values():\n                min = np.min(v)\n                print(f'\\t{round(min, 5)}', end='')\n            print()\n            print('max:', end='')\n            for v in sums.values():\n                max = np.max(v)\n                print(f'\\t{round(max, 5)}', end='')\n            print()\n            print('avg:', end='')\n            for v in sums.values():\n                mean = np.mean(v)\n                print(f'\\t{round(mean, 5)}', end='')\n            print()\n            print('median:', end='')\n            for v in sums.values():\n                median = np.median(v)\n                print(f'\\t{round(median, 5)}', end='')\n            print()\n    return ret",
            "def main(args, print_output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    ret = {}\n    entries = []\n\n    def extract_metric(s, metric):\n        try:\n            j = json.loads(s)\n        except:\n            return None\n        if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n            return None\n        return j[metric] if metric in j else None\n\n    def extract_params(s):\n        s = s.replace(args.base, '', 1)\n        if args.path_contains is not None:\n            s = s.replace(args.path_contains, '', 1)\n        if args.hydra:\n            num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n            str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n            lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n            task_matches = re.findall('.*/(\\\\d+)$', s)\n        else:\n            num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n            str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n            lr_matches = []\n            task_matches = []\n        cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n        items = OrderedDict()\n        for m in str_matches:\n            if isinstance(m, tuple):\n                if 'checkpoint' not in m[0]:\n                    items[m[0]] = m[1]\n            else:\n                items[m] = ''\n        for m in num_matches:\n            items[m[0]] = m[1]\n        for m in lr_matches:\n            items[m[0]] = m[1]\n        for m in task_matches:\n            items['hydra_task'] = m\n        for m in cp_matches:\n            items['checkpoint'] = m\n        return items\n    abs_best = None\n    sources = []\n    for (root, _, files) in os.walk(args.base):\n        if args.path_contains is not None and (not args.path_contains in root):\n            continue\n        for f in files:\n            if f.endswith(args.file_name):\n                sources.append((root, f))\n    if args.last_files is not None:\n        sources = sources[-args.last_files:]\n    for (root, file) in sources:\n        with open(os.path.join(root, file), 'r') as fin:\n            found = []\n            avg = {}\n            prev = None\n            for line in fin:\n                line = line.rstrip()\n                if line.find(args.target) != -1 and (args.skip_containing is None or line.find(args.skip_containing) == -1):\n                    try:\n                        idx = line.index('{')\n                        line = line[idx:]\n                        line_json = json.loads(line)\n                    except:\n                        continue\n                    if prev is not None:\n                        try:\n                            prev.update(line_json)\n                            line_json = prev\n                        except:\n                            pass\n                    if args.target in line_json:\n                        found.append(line_json)\n                if args.avg_params:\n                    avg_params = args.avg_params.split(',')\n                    for p in avg_params:\n                        m = extract_metric(line, p)\n                        if m is not None:\n                            (prev_v, prev_c) = avg.get(p, (0, 0))\n                            avg[p] = (prev_v + float(m), prev_c + 1)\n                if args.extract_prev:\n                    try:\n                        prev = json.loads(line)\n                    except:\n                        pass\n            best = None\n            if args.best:\n                curr_best = None\n                for i in range(len(found)):\n                    cand_best = found[i][args.target] if args.target in found[i] else None\n\n                    def cmp(a, b):\n                        a = float(a)\n                        b = float(b)\n                        if args.best_biggest:\n                            return a > b\n                        return a < b\n                    if cand_best is not None and (not math.isnan(float(cand_best))) and (curr_best is None or cmp(cand_best, curr_best)):\n                        curr_best = cand_best\n                        if abs_best is None or cmp(curr_best, abs_best):\n                            abs_best = curr_best\n                        best = found[i]\n            if args.unique_epochs or args.epoch:\n                last_found = []\n                last_epoch = None\n                for i in reversed(range(len(found))):\n                    epoch = found[i]['epoch']\n                    if args.epoch and args.epoch != epoch:\n                        continue\n                    if epoch != last_epoch:\n                        last_epoch = epoch\n                        last_found.append(found[i])\n                found = list(reversed(last_found))\n            if len(found) == 0:\n                if print_output and (args.last_files is not None or not args.skip_empty):\n                    print(root[len(args.base):])\n                    print('Nothing')\n            else:\n                if not print_output:\n                    ret[root[len(args.base):]] = best\n                    continue\n                if args.compact:\n                    print('{}\\t{}'.format(root[len(args.base) + 1:], curr_best))\n                    continue\n                if args.group_on is None and (not args.best_only):\n                    print(root[len(args.base):])\n                if not args.everything:\n                    if best is not None and args.group_on is None and (not args.best_only) and (not args.flat):\n                        print(best, '(best)')\n                    if args.group_on is None and args.last and (not args.best_only) and (not args.flat):\n                        for f in found[-args.last:]:\n                            if args.extract_prev is not None:\n                                try:\n                                    print('{}\\t{}'.format(f[args.extract_prev], f[args.target]))\n                                except Exception as e:\n                                    print('Exception!', e)\n                            else:\n                                print(f)\n                    try:\n                        metric = found[-1][args.target] if not args.best or best is None else best[args.target]\n                    except:\n                        print(found[-1])\n                        raise\n                    if metric is not None:\n                        entries.append((extract_params(root), metric))\n                else:\n                    for f in found:\n                        print(f)\n                if not args.group_on and print_output:\n                    print()\n            if len(avg) > 0:\n                for (k, (v, c)) in avg.items():\n                    print(f'{k}: {v / c}')\n    if args.best_only:\n        print(abs_best)\n    if args.flat:\n        print('\\t'.join((m for (_, m) in entries)))\n    if args.group_on is not None:\n        by_val = OrderedDict()\n        for (e, m) in entries:\n            k = args.group_on\n            if k not in e:\n                m_keys = [x for x in e.keys() if x.startswith(k)]\n                if len(m_keys) == 0:\n                    val = 'False'\n                else:\n                    assert len(m_keys) == 1\n                    k = m_keys[0]\n                    val = m_keys[0]\n            else:\n                val = e[args.group_on]\n                if val == '':\n                    val = 'True'\n            scrubbed_entry = copy.deepcopy(e)\n            if k in scrubbed_entry:\n                del scrubbed_entry[k]\n            if args.remove_metric and args.remove_metric in scrubbed_entry:\n                val += '_' + scrubbed_entry[args.remove_metric]\n                del scrubbed_entry[args.remove_metric]\n            by_val.setdefault(tuple(scrubbed_entry.items()), dict())[val] = m\n        distinct_vals = set()\n        for v in by_val.values():\n            distinct_vals.update(v.keys())\n        try:\n            distinct_vals = {int(d) for d in distinct_vals}\n        except:\n            print(distinct_vals)\n            print()\n            print('by_val', len(by_val))\n            for (k, v) in by_val.items():\n                print(k, '=>', v)\n            print()\n            raise\n        from natsort import natsorted\n        svals = list(map(str, natsorted(distinct_vals)))\n        print('{}\\t{}'.format(args.group_on, '\\t'.join(svals)))\n        sums = OrderedDict({n: [] for n in svals})\n        for (k, v) in by_val.items():\n            kstr = '.'.join((':'.join(x) for x in k))\n            vstr = ''\n            for mv in svals:\n                x = v[mv] if mv in v else ''\n                vstr += '\\t{}'.format(round(x, 5) if isinstance(x, float) else x)\n                try:\n                    sums[mv].append(float(x))\n                except:\n                    pass\n            print('{}{}'.format(kstr[:args.key_len], vstr))\n        if any((len(x) > 0 for x in sums.values())):\n            print('min:', end='')\n            for v in sums.values():\n                min = np.min(v)\n                print(f'\\t{round(min, 5)}', end='')\n            print()\n            print('max:', end='')\n            for v in sums.values():\n                max = np.max(v)\n                print(f'\\t{round(max, 5)}', end='')\n            print()\n            print('avg:', end='')\n            for v in sums.values():\n                mean = np.mean(v)\n                print(f'\\t{round(mean, 5)}', end='')\n            print()\n            print('median:', end='')\n            for v in sums.values():\n                median = np.median(v)\n                print(f'\\t{round(median, 5)}', end='')\n            print()\n    return ret",
            "def main(args, print_output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    ret = {}\n    entries = []\n\n    def extract_metric(s, metric):\n        try:\n            j = json.loads(s)\n        except:\n            return None\n        if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n            return None\n        return j[metric] if metric in j else None\n\n    def extract_params(s):\n        s = s.replace(args.base, '', 1)\n        if args.path_contains is not None:\n            s = s.replace(args.path_contains, '', 1)\n        if args.hydra:\n            num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n            str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n            lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n            task_matches = re.findall('.*/(\\\\d+)$', s)\n        else:\n            num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n            str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n            lr_matches = []\n            task_matches = []\n        cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n        items = OrderedDict()\n        for m in str_matches:\n            if isinstance(m, tuple):\n                if 'checkpoint' not in m[0]:\n                    items[m[0]] = m[1]\n            else:\n                items[m] = ''\n        for m in num_matches:\n            items[m[0]] = m[1]\n        for m in lr_matches:\n            items[m[0]] = m[1]\n        for m in task_matches:\n            items['hydra_task'] = m\n        for m in cp_matches:\n            items['checkpoint'] = m\n        return items\n    abs_best = None\n    sources = []\n    for (root, _, files) in os.walk(args.base):\n        if args.path_contains is not None and (not args.path_contains in root):\n            continue\n        for f in files:\n            if f.endswith(args.file_name):\n                sources.append((root, f))\n    if args.last_files is not None:\n        sources = sources[-args.last_files:]\n    for (root, file) in sources:\n        with open(os.path.join(root, file), 'r') as fin:\n            found = []\n            avg = {}\n            prev = None\n            for line in fin:\n                line = line.rstrip()\n                if line.find(args.target) != -1 and (args.skip_containing is None or line.find(args.skip_containing) == -1):\n                    try:\n                        idx = line.index('{')\n                        line = line[idx:]\n                        line_json = json.loads(line)\n                    except:\n                        continue\n                    if prev is not None:\n                        try:\n                            prev.update(line_json)\n                            line_json = prev\n                        except:\n                            pass\n                    if args.target in line_json:\n                        found.append(line_json)\n                if args.avg_params:\n                    avg_params = args.avg_params.split(',')\n                    for p in avg_params:\n                        m = extract_metric(line, p)\n                        if m is not None:\n                            (prev_v, prev_c) = avg.get(p, (0, 0))\n                            avg[p] = (prev_v + float(m), prev_c + 1)\n                if args.extract_prev:\n                    try:\n                        prev = json.loads(line)\n                    except:\n                        pass\n            best = None\n            if args.best:\n                curr_best = None\n                for i in range(len(found)):\n                    cand_best = found[i][args.target] if args.target in found[i] else None\n\n                    def cmp(a, b):\n                        a = float(a)\n                        b = float(b)\n                        if args.best_biggest:\n                            return a > b\n                        return a < b\n                    if cand_best is not None and (not math.isnan(float(cand_best))) and (curr_best is None or cmp(cand_best, curr_best)):\n                        curr_best = cand_best\n                        if abs_best is None or cmp(curr_best, abs_best):\n                            abs_best = curr_best\n                        best = found[i]\n            if args.unique_epochs or args.epoch:\n                last_found = []\n                last_epoch = None\n                for i in reversed(range(len(found))):\n                    epoch = found[i]['epoch']\n                    if args.epoch and args.epoch != epoch:\n                        continue\n                    if epoch != last_epoch:\n                        last_epoch = epoch\n                        last_found.append(found[i])\n                found = list(reversed(last_found))\n            if len(found) == 0:\n                if print_output and (args.last_files is not None or not args.skip_empty):\n                    print(root[len(args.base):])\n                    print('Nothing')\n            else:\n                if not print_output:\n                    ret[root[len(args.base):]] = best\n                    continue\n                if args.compact:\n                    print('{}\\t{}'.format(root[len(args.base) + 1:], curr_best))\n                    continue\n                if args.group_on is None and (not args.best_only):\n                    print(root[len(args.base):])\n                if not args.everything:\n                    if best is not None and args.group_on is None and (not args.best_only) and (not args.flat):\n                        print(best, '(best)')\n                    if args.group_on is None and args.last and (not args.best_only) and (not args.flat):\n                        for f in found[-args.last:]:\n                            if args.extract_prev is not None:\n                                try:\n                                    print('{}\\t{}'.format(f[args.extract_prev], f[args.target]))\n                                except Exception as e:\n                                    print('Exception!', e)\n                            else:\n                                print(f)\n                    try:\n                        metric = found[-1][args.target] if not args.best or best is None else best[args.target]\n                    except:\n                        print(found[-1])\n                        raise\n                    if metric is not None:\n                        entries.append((extract_params(root), metric))\n                else:\n                    for f in found:\n                        print(f)\n                if not args.group_on and print_output:\n                    print()\n            if len(avg) > 0:\n                for (k, (v, c)) in avg.items():\n                    print(f'{k}: {v / c}')\n    if args.best_only:\n        print(abs_best)\n    if args.flat:\n        print('\\t'.join((m for (_, m) in entries)))\n    if args.group_on is not None:\n        by_val = OrderedDict()\n        for (e, m) in entries:\n            k = args.group_on\n            if k not in e:\n                m_keys = [x for x in e.keys() if x.startswith(k)]\n                if len(m_keys) == 0:\n                    val = 'False'\n                else:\n                    assert len(m_keys) == 1\n                    k = m_keys[0]\n                    val = m_keys[0]\n            else:\n                val = e[args.group_on]\n                if val == '':\n                    val = 'True'\n            scrubbed_entry = copy.deepcopy(e)\n            if k in scrubbed_entry:\n                del scrubbed_entry[k]\n            if args.remove_metric and args.remove_metric in scrubbed_entry:\n                val += '_' + scrubbed_entry[args.remove_metric]\n                del scrubbed_entry[args.remove_metric]\n            by_val.setdefault(tuple(scrubbed_entry.items()), dict())[val] = m\n        distinct_vals = set()\n        for v in by_val.values():\n            distinct_vals.update(v.keys())\n        try:\n            distinct_vals = {int(d) for d in distinct_vals}\n        except:\n            print(distinct_vals)\n            print()\n            print('by_val', len(by_val))\n            for (k, v) in by_val.items():\n                print(k, '=>', v)\n            print()\n            raise\n        from natsort import natsorted\n        svals = list(map(str, natsorted(distinct_vals)))\n        print('{}\\t{}'.format(args.group_on, '\\t'.join(svals)))\n        sums = OrderedDict({n: [] for n in svals})\n        for (k, v) in by_val.items():\n            kstr = '.'.join((':'.join(x) for x in k))\n            vstr = ''\n            for mv in svals:\n                x = v[mv] if mv in v else ''\n                vstr += '\\t{}'.format(round(x, 5) if isinstance(x, float) else x)\n                try:\n                    sums[mv].append(float(x))\n                except:\n                    pass\n            print('{}{}'.format(kstr[:args.key_len], vstr))\n        if any((len(x) > 0 for x in sums.values())):\n            print('min:', end='')\n            for v in sums.values():\n                min = np.min(v)\n                print(f'\\t{round(min, 5)}', end='')\n            print()\n            print('max:', end='')\n            for v in sums.values():\n                max = np.max(v)\n                print(f'\\t{round(max, 5)}', end='')\n            print()\n            print('avg:', end='')\n            for v in sums.values():\n                mean = np.mean(v)\n                print(f'\\t{round(mean, 5)}', end='')\n            print()\n            print('median:', end='')\n            for v in sums.values():\n                median = np.median(v)\n                print(f'\\t{round(median, 5)}', end='')\n            print()\n    return ret",
            "def main(args, print_output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    ret = {}\n    entries = []\n\n    def extract_metric(s, metric):\n        try:\n            j = json.loads(s)\n        except:\n            return None\n        if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n            return None\n        return j[metric] if metric in j else None\n\n    def extract_params(s):\n        s = s.replace(args.base, '', 1)\n        if args.path_contains is not None:\n            s = s.replace(args.path_contains, '', 1)\n        if args.hydra:\n            num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n            str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n            lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n            task_matches = re.findall('.*/(\\\\d+)$', s)\n        else:\n            num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n            str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n            lr_matches = []\n            task_matches = []\n        cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n        items = OrderedDict()\n        for m in str_matches:\n            if isinstance(m, tuple):\n                if 'checkpoint' not in m[0]:\n                    items[m[0]] = m[1]\n            else:\n                items[m] = ''\n        for m in num_matches:\n            items[m[0]] = m[1]\n        for m in lr_matches:\n            items[m[0]] = m[1]\n        for m in task_matches:\n            items['hydra_task'] = m\n        for m in cp_matches:\n            items['checkpoint'] = m\n        return items\n    abs_best = None\n    sources = []\n    for (root, _, files) in os.walk(args.base):\n        if args.path_contains is not None and (not args.path_contains in root):\n            continue\n        for f in files:\n            if f.endswith(args.file_name):\n                sources.append((root, f))\n    if args.last_files is not None:\n        sources = sources[-args.last_files:]\n    for (root, file) in sources:\n        with open(os.path.join(root, file), 'r') as fin:\n            found = []\n            avg = {}\n            prev = None\n            for line in fin:\n                line = line.rstrip()\n                if line.find(args.target) != -1 and (args.skip_containing is None or line.find(args.skip_containing) == -1):\n                    try:\n                        idx = line.index('{')\n                        line = line[idx:]\n                        line_json = json.loads(line)\n                    except:\n                        continue\n                    if prev is not None:\n                        try:\n                            prev.update(line_json)\n                            line_json = prev\n                        except:\n                            pass\n                    if args.target in line_json:\n                        found.append(line_json)\n                if args.avg_params:\n                    avg_params = args.avg_params.split(',')\n                    for p in avg_params:\n                        m = extract_metric(line, p)\n                        if m is not None:\n                            (prev_v, prev_c) = avg.get(p, (0, 0))\n                            avg[p] = (prev_v + float(m), prev_c + 1)\n                if args.extract_prev:\n                    try:\n                        prev = json.loads(line)\n                    except:\n                        pass\n            best = None\n            if args.best:\n                curr_best = None\n                for i in range(len(found)):\n                    cand_best = found[i][args.target] if args.target in found[i] else None\n\n                    def cmp(a, b):\n                        a = float(a)\n                        b = float(b)\n                        if args.best_biggest:\n                            return a > b\n                        return a < b\n                    if cand_best is not None and (not math.isnan(float(cand_best))) and (curr_best is None or cmp(cand_best, curr_best)):\n                        curr_best = cand_best\n                        if abs_best is None or cmp(curr_best, abs_best):\n                            abs_best = curr_best\n                        best = found[i]\n            if args.unique_epochs or args.epoch:\n                last_found = []\n                last_epoch = None\n                for i in reversed(range(len(found))):\n                    epoch = found[i]['epoch']\n                    if args.epoch and args.epoch != epoch:\n                        continue\n                    if epoch != last_epoch:\n                        last_epoch = epoch\n                        last_found.append(found[i])\n                found = list(reversed(last_found))\n            if len(found) == 0:\n                if print_output and (args.last_files is not None or not args.skip_empty):\n                    print(root[len(args.base):])\n                    print('Nothing')\n            else:\n                if not print_output:\n                    ret[root[len(args.base):]] = best\n                    continue\n                if args.compact:\n                    print('{}\\t{}'.format(root[len(args.base) + 1:], curr_best))\n                    continue\n                if args.group_on is None and (not args.best_only):\n                    print(root[len(args.base):])\n                if not args.everything:\n                    if best is not None and args.group_on is None and (not args.best_only) and (not args.flat):\n                        print(best, '(best)')\n                    if args.group_on is None and args.last and (not args.best_only) and (not args.flat):\n                        for f in found[-args.last:]:\n                            if args.extract_prev is not None:\n                                try:\n                                    print('{}\\t{}'.format(f[args.extract_prev], f[args.target]))\n                                except Exception as e:\n                                    print('Exception!', e)\n                            else:\n                                print(f)\n                    try:\n                        metric = found[-1][args.target] if not args.best or best is None else best[args.target]\n                    except:\n                        print(found[-1])\n                        raise\n                    if metric is not None:\n                        entries.append((extract_params(root), metric))\n                else:\n                    for f in found:\n                        print(f)\n                if not args.group_on and print_output:\n                    print()\n            if len(avg) > 0:\n                for (k, (v, c)) in avg.items():\n                    print(f'{k}: {v / c}')\n    if args.best_only:\n        print(abs_best)\n    if args.flat:\n        print('\\t'.join((m for (_, m) in entries)))\n    if args.group_on is not None:\n        by_val = OrderedDict()\n        for (e, m) in entries:\n            k = args.group_on\n            if k not in e:\n                m_keys = [x for x in e.keys() if x.startswith(k)]\n                if len(m_keys) == 0:\n                    val = 'False'\n                else:\n                    assert len(m_keys) == 1\n                    k = m_keys[0]\n                    val = m_keys[0]\n            else:\n                val = e[args.group_on]\n                if val == '':\n                    val = 'True'\n            scrubbed_entry = copy.deepcopy(e)\n            if k in scrubbed_entry:\n                del scrubbed_entry[k]\n            if args.remove_metric and args.remove_metric in scrubbed_entry:\n                val += '_' + scrubbed_entry[args.remove_metric]\n                del scrubbed_entry[args.remove_metric]\n            by_val.setdefault(tuple(scrubbed_entry.items()), dict())[val] = m\n        distinct_vals = set()\n        for v in by_val.values():\n            distinct_vals.update(v.keys())\n        try:\n            distinct_vals = {int(d) for d in distinct_vals}\n        except:\n            print(distinct_vals)\n            print()\n            print('by_val', len(by_val))\n            for (k, v) in by_val.items():\n                print(k, '=>', v)\n            print()\n            raise\n        from natsort import natsorted\n        svals = list(map(str, natsorted(distinct_vals)))\n        print('{}\\t{}'.format(args.group_on, '\\t'.join(svals)))\n        sums = OrderedDict({n: [] for n in svals})\n        for (k, v) in by_val.items():\n            kstr = '.'.join((':'.join(x) for x in k))\n            vstr = ''\n            for mv in svals:\n                x = v[mv] if mv in v else ''\n                vstr += '\\t{}'.format(round(x, 5) if isinstance(x, float) else x)\n                try:\n                    sums[mv].append(float(x))\n                except:\n                    pass\n            print('{}{}'.format(kstr[:args.key_len], vstr))\n        if any((len(x) > 0 for x in sums.values())):\n            print('min:', end='')\n            for v in sums.values():\n                min = np.min(v)\n                print(f'\\t{round(min, 5)}', end='')\n            print()\n            print('max:', end='')\n            for v in sums.values():\n                max = np.max(v)\n                print(f'\\t{round(max, 5)}', end='')\n            print()\n            print('avg:', end='')\n            for v in sums.values():\n                mean = np.mean(v)\n                print(f'\\t{round(mean, 5)}', end='')\n            print()\n            print('median:', end='')\n            for v in sums.values():\n                median = np.median(v)\n                print(f'\\t{round(median, 5)}', end='')\n            print()\n    return ret",
            "def main(args, print_output):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    ret = {}\n    entries = []\n\n    def extract_metric(s, metric):\n        try:\n            j = json.loads(s)\n        except:\n            return None\n        if args.epoch is not None and ('epoch' not in j or j['epoch'] != args.epoch):\n            return None\n        return j[metric] if metric in j else None\n\n    def extract_params(s):\n        s = s.replace(args.base, '', 1)\n        if args.path_contains is not None:\n            s = s.replace(args.path_contains, '', 1)\n        if args.hydra:\n            num_matches = re.findall('(?:/|__)([^/:]+):(\\\\d+\\\\.?\\\\d*)', s)\n            str_matches = re.findall('(?:/|__)?((?:(?!(?:\\\\:|__)).)+):([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?:/|__)', s)\n            lr_matches = re.findall('optimization.(lr):\\\\[([\\\\d\\\\.,]+)\\\\]', s)\n            task_matches = re.findall('.*/(\\\\d+)$', s)\n        else:\n            num_matches = re.findall('\\\\.?([^\\\\.]+?)(\\\\d+(e\\\\-\\\\d+)?(?:\\\\.\\\\d+)?)(\\\\.|$)', s)\n            str_matches = re.findall('[/\\\\.]([^\\\\.]*[^\\\\d\\\\.]+\\\\d*)(?=\\\\.)', s)\n            lr_matches = []\n            task_matches = []\n        cp_matches = re.findall('checkpoint(?:_\\\\d+)?_(\\\\d+).pt', s)\n        items = OrderedDict()\n        for m in str_matches:\n            if isinstance(m, tuple):\n                if 'checkpoint' not in m[0]:\n                    items[m[0]] = m[1]\n            else:\n                items[m] = ''\n        for m in num_matches:\n            items[m[0]] = m[1]\n        for m in lr_matches:\n            items[m[0]] = m[1]\n        for m in task_matches:\n            items['hydra_task'] = m\n        for m in cp_matches:\n            items['checkpoint'] = m\n        return items\n    abs_best = None\n    sources = []\n    for (root, _, files) in os.walk(args.base):\n        if args.path_contains is not None and (not args.path_contains in root):\n            continue\n        for f in files:\n            if f.endswith(args.file_name):\n                sources.append((root, f))\n    if args.last_files is not None:\n        sources = sources[-args.last_files:]\n    for (root, file) in sources:\n        with open(os.path.join(root, file), 'r') as fin:\n            found = []\n            avg = {}\n            prev = None\n            for line in fin:\n                line = line.rstrip()\n                if line.find(args.target) != -1 and (args.skip_containing is None or line.find(args.skip_containing) == -1):\n                    try:\n                        idx = line.index('{')\n                        line = line[idx:]\n                        line_json = json.loads(line)\n                    except:\n                        continue\n                    if prev is not None:\n                        try:\n                            prev.update(line_json)\n                            line_json = prev\n                        except:\n                            pass\n                    if args.target in line_json:\n                        found.append(line_json)\n                if args.avg_params:\n                    avg_params = args.avg_params.split(',')\n                    for p in avg_params:\n                        m = extract_metric(line, p)\n                        if m is not None:\n                            (prev_v, prev_c) = avg.get(p, (0, 0))\n                            avg[p] = (prev_v + float(m), prev_c + 1)\n                if args.extract_prev:\n                    try:\n                        prev = json.loads(line)\n                    except:\n                        pass\n            best = None\n            if args.best:\n                curr_best = None\n                for i in range(len(found)):\n                    cand_best = found[i][args.target] if args.target in found[i] else None\n\n                    def cmp(a, b):\n                        a = float(a)\n                        b = float(b)\n                        if args.best_biggest:\n                            return a > b\n                        return a < b\n                    if cand_best is not None and (not math.isnan(float(cand_best))) and (curr_best is None or cmp(cand_best, curr_best)):\n                        curr_best = cand_best\n                        if abs_best is None or cmp(curr_best, abs_best):\n                            abs_best = curr_best\n                        best = found[i]\n            if args.unique_epochs or args.epoch:\n                last_found = []\n                last_epoch = None\n                for i in reversed(range(len(found))):\n                    epoch = found[i]['epoch']\n                    if args.epoch and args.epoch != epoch:\n                        continue\n                    if epoch != last_epoch:\n                        last_epoch = epoch\n                        last_found.append(found[i])\n                found = list(reversed(last_found))\n            if len(found) == 0:\n                if print_output and (args.last_files is not None or not args.skip_empty):\n                    print(root[len(args.base):])\n                    print('Nothing')\n            else:\n                if not print_output:\n                    ret[root[len(args.base):]] = best\n                    continue\n                if args.compact:\n                    print('{}\\t{}'.format(root[len(args.base) + 1:], curr_best))\n                    continue\n                if args.group_on is None and (not args.best_only):\n                    print(root[len(args.base):])\n                if not args.everything:\n                    if best is not None and args.group_on is None and (not args.best_only) and (not args.flat):\n                        print(best, '(best)')\n                    if args.group_on is None and args.last and (not args.best_only) and (not args.flat):\n                        for f in found[-args.last:]:\n                            if args.extract_prev is not None:\n                                try:\n                                    print('{}\\t{}'.format(f[args.extract_prev], f[args.target]))\n                                except Exception as e:\n                                    print('Exception!', e)\n                            else:\n                                print(f)\n                    try:\n                        metric = found[-1][args.target] if not args.best or best is None else best[args.target]\n                    except:\n                        print(found[-1])\n                        raise\n                    if metric is not None:\n                        entries.append((extract_params(root), metric))\n                else:\n                    for f in found:\n                        print(f)\n                if not args.group_on and print_output:\n                    print()\n            if len(avg) > 0:\n                for (k, (v, c)) in avg.items():\n                    print(f'{k}: {v / c}')\n    if args.best_only:\n        print(abs_best)\n    if args.flat:\n        print('\\t'.join((m for (_, m) in entries)))\n    if args.group_on is not None:\n        by_val = OrderedDict()\n        for (e, m) in entries:\n            k = args.group_on\n            if k not in e:\n                m_keys = [x for x in e.keys() if x.startswith(k)]\n                if len(m_keys) == 0:\n                    val = 'False'\n                else:\n                    assert len(m_keys) == 1\n                    k = m_keys[0]\n                    val = m_keys[0]\n            else:\n                val = e[args.group_on]\n                if val == '':\n                    val = 'True'\n            scrubbed_entry = copy.deepcopy(e)\n            if k in scrubbed_entry:\n                del scrubbed_entry[k]\n            if args.remove_metric and args.remove_metric in scrubbed_entry:\n                val += '_' + scrubbed_entry[args.remove_metric]\n                del scrubbed_entry[args.remove_metric]\n            by_val.setdefault(tuple(scrubbed_entry.items()), dict())[val] = m\n        distinct_vals = set()\n        for v in by_val.values():\n            distinct_vals.update(v.keys())\n        try:\n            distinct_vals = {int(d) for d in distinct_vals}\n        except:\n            print(distinct_vals)\n            print()\n            print('by_val', len(by_val))\n            for (k, v) in by_val.items():\n                print(k, '=>', v)\n            print()\n            raise\n        from natsort import natsorted\n        svals = list(map(str, natsorted(distinct_vals)))\n        print('{}\\t{}'.format(args.group_on, '\\t'.join(svals)))\n        sums = OrderedDict({n: [] for n in svals})\n        for (k, v) in by_val.items():\n            kstr = '.'.join((':'.join(x) for x in k))\n            vstr = ''\n            for mv in svals:\n                x = v[mv] if mv in v else ''\n                vstr += '\\t{}'.format(round(x, 5) if isinstance(x, float) else x)\n                try:\n                    sums[mv].append(float(x))\n                except:\n                    pass\n            print('{}{}'.format(kstr[:args.key_len], vstr))\n        if any((len(x) > 0 for x in sums.values())):\n            print('min:', end='')\n            for v in sums.values():\n                min = np.min(v)\n                print(f'\\t{round(min, 5)}', end='')\n            print()\n            print('max:', end='')\n            for v in sums.values():\n                max = np.max(v)\n                print(f'\\t{round(max, 5)}', end='')\n            print()\n            print('avg:', end='')\n            for v in sums.values():\n                mean = np.mean(v)\n                print(f'\\t{round(mean, 5)}', end='')\n            print()\n            print('median:', end='')\n            for v in sums.values():\n                median = np.median(v)\n                print(f'\\t{round(median, 5)}', end='')\n            print()\n    return ret"
        ]
    }
]