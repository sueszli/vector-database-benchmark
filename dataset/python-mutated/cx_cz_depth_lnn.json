[
    {
        "func_name": "_initialize_phase_schedule",
        "original": "def _initialize_phase_schedule(mat_z):\n    \"\"\"\n    Given a CZ layer (represented as an n*n CZ matrix Mz)\n    Return a scheudle of phase gates implementing Mz in a SWAP-only netwrok\n    (c.f. Alg 1, [2])\n    \"\"\"\n    n = len(mat_z)\n    phase_schedule = np.zeros((n, n), dtype=int)\n    for (i, j) in zip(*np.where(mat_z)):\n        if i >= j:\n            continue\n        phase_schedule[i, j] = 3\n        phase_schedule[i, i] += 1\n        phase_schedule[j, j] += 1\n    return phase_schedule",
        "mutated": [
            "def _initialize_phase_schedule(mat_z):\n    if False:\n        i = 10\n    '\\n    Given a CZ layer (represented as an n*n CZ matrix Mz)\\n    Return a scheudle of phase gates implementing Mz in a SWAP-only netwrok\\n    (c.f. Alg 1, [2])\\n    '\n    n = len(mat_z)\n    phase_schedule = np.zeros((n, n), dtype=int)\n    for (i, j) in zip(*np.where(mat_z)):\n        if i >= j:\n            continue\n        phase_schedule[i, j] = 3\n        phase_schedule[i, i] += 1\n        phase_schedule[j, j] += 1\n    return phase_schedule",
            "def _initialize_phase_schedule(mat_z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given a CZ layer (represented as an n*n CZ matrix Mz)\\n    Return a scheudle of phase gates implementing Mz in a SWAP-only netwrok\\n    (c.f. Alg 1, [2])\\n    '\n    n = len(mat_z)\n    phase_schedule = np.zeros((n, n), dtype=int)\n    for (i, j) in zip(*np.where(mat_z)):\n        if i >= j:\n            continue\n        phase_schedule[i, j] = 3\n        phase_schedule[i, i] += 1\n        phase_schedule[j, j] += 1\n    return phase_schedule",
            "def _initialize_phase_schedule(mat_z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given a CZ layer (represented as an n*n CZ matrix Mz)\\n    Return a scheudle of phase gates implementing Mz in a SWAP-only netwrok\\n    (c.f. Alg 1, [2])\\n    '\n    n = len(mat_z)\n    phase_schedule = np.zeros((n, n), dtype=int)\n    for (i, j) in zip(*np.where(mat_z)):\n        if i >= j:\n            continue\n        phase_schedule[i, j] = 3\n        phase_schedule[i, i] += 1\n        phase_schedule[j, j] += 1\n    return phase_schedule",
            "def _initialize_phase_schedule(mat_z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given a CZ layer (represented as an n*n CZ matrix Mz)\\n    Return a scheudle of phase gates implementing Mz in a SWAP-only netwrok\\n    (c.f. Alg 1, [2])\\n    '\n    n = len(mat_z)\n    phase_schedule = np.zeros((n, n), dtype=int)\n    for (i, j) in zip(*np.where(mat_z)):\n        if i >= j:\n            continue\n        phase_schedule[i, j] = 3\n        phase_schedule[i, i] += 1\n        phase_schedule[j, j] += 1\n    return phase_schedule",
            "def _initialize_phase_schedule(mat_z):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given a CZ layer (represented as an n*n CZ matrix Mz)\\n    Return a scheudle of phase gates implementing Mz in a SWAP-only netwrok\\n    (c.f. Alg 1, [2])\\n    '\n    n = len(mat_z)\n    phase_schedule = np.zeros((n, n), dtype=int)\n    for (i, j) in zip(*np.where(mat_z)):\n        if i >= j:\n            continue\n        phase_schedule[i, j] = 3\n        phase_schedule[i, i] += 1\n        phase_schedule[j, j] += 1\n    return phase_schedule"
        ]
    },
    {
        "func_name": "_shuffle",
        "original": "def _shuffle(labels, odd):\n    \"\"\"\n    Args:\n        labels : a list of indices\n        odd : a boolean indicating whether this layer is odd or even,\n    Shuffle the indices in labels by swapping adjacent elements\n    (c.f. Fig.2, [2])\n    \"\"\"\n    swapped = [v for p in zip(labels[1::2], labels[::2]) for v in p]\n    return swapped + labels[-1:] if odd else swapped",
        "mutated": [
            "def _shuffle(labels, odd):\n    if False:\n        i = 10\n    '\\n    Args:\\n        labels : a list of indices\\n        odd : a boolean indicating whether this layer is odd or even,\\n    Shuffle the indices in labels by swapping adjacent elements\\n    (c.f. Fig.2, [2])\\n    '\n    swapped = [v for p in zip(labels[1::2], labels[::2]) for v in p]\n    return swapped + labels[-1:] if odd else swapped",
            "def _shuffle(labels, odd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Args:\\n        labels : a list of indices\\n        odd : a boolean indicating whether this layer is odd or even,\\n    Shuffle the indices in labels by swapping adjacent elements\\n    (c.f. Fig.2, [2])\\n    '\n    swapped = [v for p in zip(labels[1::2], labels[::2]) for v in p]\n    return swapped + labels[-1:] if odd else swapped",
            "def _shuffle(labels, odd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Args:\\n        labels : a list of indices\\n        odd : a boolean indicating whether this layer is odd or even,\\n    Shuffle the indices in labels by swapping adjacent elements\\n    (c.f. Fig.2, [2])\\n    '\n    swapped = [v for p in zip(labels[1::2], labels[::2]) for v in p]\n    return swapped + labels[-1:] if odd else swapped",
            "def _shuffle(labels, odd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Args:\\n        labels : a list of indices\\n        odd : a boolean indicating whether this layer is odd or even,\\n    Shuffle the indices in labels by swapping adjacent elements\\n    (c.f. Fig.2, [2])\\n    '\n    swapped = [v for p in zip(labels[1::2], labels[::2]) for v in p]\n    return swapped + labels[-1:] if odd else swapped",
            "def _shuffle(labels, odd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Args:\\n        labels : a list of indices\\n        odd : a boolean indicating whether this layer is odd or even,\\n    Shuffle the indices in labels by swapping adjacent elements\\n    (c.f. Fig.2, [2])\\n    '\n    swapped = [v for p in zip(labels[1::2], labels[::2]) for v in p]\n    return swapped + labels[-1:] if odd else swapped"
        ]
    },
    {
        "func_name": "_make_seq",
        "original": "def _make_seq(n):\n    \"\"\"\n    Given the width of the circuit n,\n    Return the labels of the boxes in order from left to right, top to bottom\n    (c.f. Fig.2, [2])\n    \"\"\"\n    seq = []\n    wire_labels = list(range(n - 1, -1, -1))\n    for i in range(n):\n        wire_labels_new = _shuffle(wire_labels, n % 2) if i % 2 == 0 else wire_labels[0:1] + _shuffle(wire_labels[1:], (n + 1) % 2)\n        seq += [(min(i), max(i)) for i in zip(wire_labels[::2], wire_labels_new[::2]) if i[0] != i[1]]\n        wire_labels = wire_labels_new\n    return seq",
        "mutated": [
            "def _make_seq(n):\n    if False:\n        i = 10\n    '\\n    Given the width of the circuit n,\\n    Return the labels of the boxes in order from left to right, top to bottom\\n    (c.f. Fig.2, [2])\\n    '\n    seq = []\n    wire_labels = list(range(n - 1, -1, -1))\n    for i in range(n):\n        wire_labels_new = _shuffle(wire_labels, n % 2) if i % 2 == 0 else wire_labels[0:1] + _shuffle(wire_labels[1:], (n + 1) % 2)\n        seq += [(min(i), max(i)) for i in zip(wire_labels[::2], wire_labels_new[::2]) if i[0] != i[1]]\n        wire_labels = wire_labels_new\n    return seq",
            "def _make_seq(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given the width of the circuit n,\\n    Return the labels of the boxes in order from left to right, top to bottom\\n    (c.f. Fig.2, [2])\\n    '\n    seq = []\n    wire_labels = list(range(n - 1, -1, -1))\n    for i in range(n):\n        wire_labels_new = _shuffle(wire_labels, n % 2) if i % 2 == 0 else wire_labels[0:1] + _shuffle(wire_labels[1:], (n + 1) % 2)\n        seq += [(min(i), max(i)) for i in zip(wire_labels[::2], wire_labels_new[::2]) if i[0] != i[1]]\n        wire_labels = wire_labels_new\n    return seq",
            "def _make_seq(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given the width of the circuit n,\\n    Return the labels of the boxes in order from left to right, top to bottom\\n    (c.f. Fig.2, [2])\\n    '\n    seq = []\n    wire_labels = list(range(n - 1, -1, -1))\n    for i in range(n):\n        wire_labels_new = _shuffle(wire_labels, n % 2) if i % 2 == 0 else wire_labels[0:1] + _shuffle(wire_labels[1:], (n + 1) % 2)\n        seq += [(min(i), max(i)) for i in zip(wire_labels[::2], wire_labels_new[::2]) if i[0] != i[1]]\n        wire_labels = wire_labels_new\n    return seq",
            "def _make_seq(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given the width of the circuit n,\\n    Return the labels of the boxes in order from left to right, top to bottom\\n    (c.f. Fig.2, [2])\\n    '\n    seq = []\n    wire_labels = list(range(n - 1, -1, -1))\n    for i in range(n):\n        wire_labels_new = _shuffle(wire_labels, n % 2) if i % 2 == 0 else wire_labels[0:1] + _shuffle(wire_labels[1:], (n + 1) % 2)\n        seq += [(min(i), max(i)) for i in zip(wire_labels[::2], wire_labels_new[::2]) if i[0] != i[1]]\n        wire_labels = wire_labels_new\n    return seq",
            "def _make_seq(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given the width of the circuit n,\\n    Return the labels of the boxes in order from left to right, top to bottom\\n    (c.f. Fig.2, [2])\\n    '\n    seq = []\n    wire_labels = list(range(n - 1, -1, -1))\n    for i in range(n):\n        wire_labels_new = _shuffle(wire_labels, n % 2) if i % 2 == 0 else wire_labels[0:1] + _shuffle(wire_labels[1:], (n + 1) % 2)\n        seq += [(min(i), max(i)) for i in zip(wire_labels[::2], wire_labels_new[::2]) if i[0] != i[1]]\n        wire_labels = wire_labels_new\n    return seq"
        ]
    },
    {
        "func_name": "_swap_plus",
        "original": "def _swap_plus(instructions, seq):\n    \"\"\"\n    Given CX instructions (c.f. Thm 7.1, [1]) and the labels of all boxes,\n    Return a list of labels of the boxes that is SWAP+ in descending order\n        * Assumes the instruction gives gates in the order from top to bottom,\n          from left to right\n        * SWAP+ is defined in section 3.A. of [2]. Note the northwest\n          diagonalization procedure of [1] consists exactly n layers of boxes,\n          each being either a SWAP or a SWAP+. That is, each northwest\n          diagonalization circuit can be uniquely represented by which of its\n          n(n-1)/2 boxes are SWAP+ and which are SWAP.\n    \"\"\"\n    instr = deepcopy(instructions)\n    swap_plus = set()\n    for (i, j) in reversed(seq):\n        cnot_1 = instr.pop()\n        instr.pop()\n        if instr == [] or instr[-1] != cnot_1:\n            swap_plus.add((i, j))\n        else:\n            instr.pop()\n    return swap_plus",
        "mutated": [
            "def _swap_plus(instructions, seq):\n    if False:\n        i = 10\n    '\\n    Given CX instructions (c.f. Thm 7.1, [1]) and the labels of all boxes,\\n    Return a list of labels of the boxes that is SWAP+ in descending order\\n        * Assumes the instruction gives gates in the order from top to bottom,\\n          from left to right\\n        * SWAP+ is defined in section 3.A. of [2]. Note the northwest\\n          diagonalization procedure of [1] consists exactly n layers of boxes,\\n          each being either a SWAP or a SWAP+. That is, each northwest\\n          diagonalization circuit can be uniquely represented by which of its\\n          n(n-1)/2 boxes are SWAP+ and which are SWAP.\\n    '\n    instr = deepcopy(instructions)\n    swap_plus = set()\n    for (i, j) in reversed(seq):\n        cnot_1 = instr.pop()\n        instr.pop()\n        if instr == [] or instr[-1] != cnot_1:\n            swap_plus.add((i, j))\n        else:\n            instr.pop()\n    return swap_plus",
            "def _swap_plus(instructions, seq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given CX instructions (c.f. Thm 7.1, [1]) and the labels of all boxes,\\n    Return a list of labels of the boxes that is SWAP+ in descending order\\n        * Assumes the instruction gives gates in the order from top to bottom,\\n          from left to right\\n        * SWAP+ is defined in section 3.A. of [2]. Note the northwest\\n          diagonalization procedure of [1] consists exactly n layers of boxes,\\n          each being either a SWAP or a SWAP+. That is, each northwest\\n          diagonalization circuit can be uniquely represented by which of its\\n          n(n-1)/2 boxes are SWAP+ and which are SWAP.\\n    '\n    instr = deepcopy(instructions)\n    swap_plus = set()\n    for (i, j) in reversed(seq):\n        cnot_1 = instr.pop()\n        instr.pop()\n        if instr == [] or instr[-1] != cnot_1:\n            swap_plus.add((i, j))\n        else:\n            instr.pop()\n    return swap_plus",
            "def _swap_plus(instructions, seq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given CX instructions (c.f. Thm 7.1, [1]) and the labels of all boxes,\\n    Return a list of labels of the boxes that is SWAP+ in descending order\\n        * Assumes the instruction gives gates in the order from top to bottom,\\n          from left to right\\n        * SWAP+ is defined in section 3.A. of [2]. Note the northwest\\n          diagonalization procedure of [1] consists exactly n layers of boxes,\\n          each being either a SWAP or a SWAP+. That is, each northwest\\n          diagonalization circuit can be uniquely represented by which of its\\n          n(n-1)/2 boxes are SWAP+ and which are SWAP.\\n    '\n    instr = deepcopy(instructions)\n    swap_plus = set()\n    for (i, j) in reversed(seq):\n        cnot_1 = instr.pop()\n        instr.pop()\n        if instr == [] or instr[-1] != cnot_1:\n            swap_plus.add((i, j))\n        else:\n            instr.pop()\n    return swap_plus",
            "def _swap_plus(instructions, seq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given CX instructions (c.f. Thm 7.1, [1]) and the labels of all boxes,\\n    Return a list of labels of the boxes that is SWAP+ in descending order\\n        * Assumes the instruction gives gates in the order from top to bottom,\\n          from left to right\\n        * SWAP+ is defined in section 3.A. of [2]. Note the northwest\\n          diagonalization procedure of [1] consists exactly n layers of boxes,\\n          each being either a SWAP or a SWAP+. That is, each northwest\\n          diagonalization circuit can be uniquely represented by which of its\\n          n(n-1)/2 boxes are SWAP+ and which are SWAP.\\n    '\n    instr = deepcopy(instructions)\n    swap_plus = set()\n    for (i, j) in reversed(seq):\n        cnot_1 = instr.pop()\n        instr.pop()\n        if instr == [] or instr[-1] != cnot_1:\n            swap_plus.add((i, j))\n        else:\n            instr.pop()\n    return swap_plus",
            "def _swap_plus(instructions, seq):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given CX instructions (c.f. Thm 7.1, [1]) and the labels of all boxes,\\n    Return a list of labels of the boxes that is SWAP+ in descending order\\n        * Assumes the instruction gives gates in the order from top to bottom,\\n          from left to right\\n        * SWAP+ is defined in section 3.A. of [2]. Note the northwest\\n          diagonalization procedure of [1] consists exactly n layers of boxes,\\n          each being either a SWAP or a SWAP+. That is, each northwest\\n          diagonalization circuit can be uniquely represented by which of its\\n          n(n-1)/2 boxes are SWAP+ and which are SWAP.\\n    '\n    instr = deepcopy(instructions)\n    swap_plus = set()\n    for (i, j) in reversed(seq):\n        cnot_1 = instr.pop()\n        instr.pop()\n        if instr == [] or instr[-1] != cnot_1:\n            swap_plus.add((i, j))\n        else:\n            instr.pop()\n    return swap_plus"
        ]
    },
    {
        "func_name": "_update_phase_schedule",
        "original": "def _update_phase_schedule(n, phase_schedule, swap_plus):\n    \"\"\"\n    Given phase_schedule initialized to induce a CZ circuit in SWAP-only network and list of SWAP+ boxes\n    Update phase_schedule for each SWAP+ according to Algorithm 2, [2]\n    \"\"\"\n    layer_order = list(range(n))[-3::-2] + list(range(n))[-2::-2][::-1]\n    order_comp = np.argsort(layer_order[::-1])\n    for i in layer_order:\n        for j in range(i + 1, n):\n            if (i, j) not in swap_plus:\n                continue\n            (phase_schedule[j, j], phase_schedule[i, j]) = (phase_schedule[i, j], phase_schedule[j, j])\n            for k in range(n):\n                if k in (i, j):\n                    continue\n                if order_comp[min(k, j)] < order_comp[i] and phase_schedule[min(k, j), max(k, j)] % 4 != 0:\n                    phase = phase_schedule[min(k, j), max(k, j)]\n                    phase_schedule[min(k, j), max(k, j)] = 0\n                    for l_s in (i, j, k):\n                        phase_schedule[l_s, l_s] = (phase_schedule[l_s, l_s] + phase * 3) % 4\n                    for (l1, l2) in [(i, j), (i, k), (j, k)]:\n                        ls = min(l1, l2)\n                        lb = max(l1, l2)\n                        phase_schedule[ls, lb] = (phase_schedule[ls, lb] + phase * 3) % 4\n    return phase_schedule",
        "mutated": [
            "def _update_phase_schedule(n, phase_schedule, swap_plus):\n    if False:\n        i = 10\n    '\\n    Given phase_schedule initialized to induce a CZ circuit in SWAP-only network and list of SWAP+ boxes\\n    Update phase_schedule for each SWAP+ according to Algorithm 2, [2]\\n    '\n    layer_order = list(range(n))[-3::-2] + list(range(n))[-2::-2][::-1]\n    order_comp = np.argsort(layer_order[::-1])\n    for i in layer_order:\n        for j in range(i + 1, n):\n            if (i, j) not in swap_plus:\n                continue\n            (phase_schedule[j, j], phase_schedule[i, j]) = (phase_schedule[i, j], phase_schedule[j, j])\n            for k in range(n):\n                if k in (i, j):\n                    continue\n                if order_comp[min(k, j)] < order_comp[i] and phase_schedule[min(k, j), max(k, j)] % 4 != 0:\n                    phase = phase_schedule[min(k, j), max(k, j)]\n                    phase_schedule[min(k, j), max(k, j)] = 0\n                    for l_s in (i, j, k):\n                        phase_schedule[l_s, l_s] = (phase_schedule[l_s, l_s] + phase * 3) % 4\n                    for (l1, l2) in [(i, j), (i, k), (j, k)]:\n                        ls = min(l1, l2)\n                        lb = max(l1, l2)\n                        phase_schedule[ls, lb] = (phase_schedule[ls, lb] + phase * 3) % 4\n    return phase_schedule",
            "def _update_phase_schedule(n, phase_schedule, swap_plus):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given phase_schedule initialized to induce a CZ circuit in SWAP-only network and list of SWAP+ boxes\\n    Update phase_schedule for each SWAP+ according to Algorithm 2, [2]\\n    '\n    layer_order = list(range(n))[-3::-2] + list(range(n))[-2::-2][::-1]\n    order_comp = np.argsort(layer_order[::-1])\n    for i in layer_order:\n        for j in range(i + 1, n):\n            if (i, j) not in swap_plus:\n                continue\n            (phase_schedule[j, j], phase_schedule[i, j]) = (phase_schedule[i, j], phase_schedule[j, j])\n            for k in range(n):\n                if k in (i, j):\n                    continue\n                if order_comp[min(k, j)] < order_comp[i] and phase_schedule[min(k, j), max(k, j)] % 4 != 0:\n                    phase = phase_schedule[min(k, j), max(k, j)]\n                    phase_schedule[min(k, j), max(k, j)] = 0\n                    for l_s in (i, j, k):\n                        phase_schedule[l_s, l_s] = (phase_schedule[l_s, l_s] + phase * 3) % 4\n                    for (l1, l2) in [(i, j), (i, k), (j, k)]:\n                        ls = min(l1, l2)\n                        lb = max(l1, l2)\n                        phase_schedule[ls, lb] = (phase_schedule[ls, lb] + phase * 3) % 4\n    return phase_schedule",
            "def _update_phase_schedule(n, phase_schedule, swap_plus):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given phase_schedule initialized to induce a CZ circuit in SWAP-only network and list of SWAP+ boxes\\n    Update phase_schedule for each SWAP+ according to Algorithm 2, [2]\\n    '\n    layer_order = list(range(n))[-3::-2] + list(range(n))[-2::-2][::-1]\n    order_comp = np.argsort(layer_order[::-1])\n    for i in layer_order:\n        for j in range(i + 1, n):\n            if (i, j) not in swap_plus:\n                continue\n            (phase_schedule[j, j], phase_schedule[i, j]) = (phase_schedule[i, j], phase_schedule[j, j])\n            for k in range(n):\n                if k in (i, j):\n                    continue\n                if order_comp[min(k, j)] < order_comp[i] and phase_schedule[min(k, j), max(k, j)] % 4 != 0:\n                    phase = phase_schedule[min(k, j), max(k, j)]\n                    phase_schedule[min(k, j), max(k, j)] = 0\n                    for l_s in (i, j, k):\n                        phase_schedule[l_s, l_s] = (phase_schedule[l_s, l_s] + phase * 3) % 4\n                    for (l1, l2) in [(i, j), (i, k), (j, k)]:\n                        ls = min(l1, l2)\n                        lb = max(l1, l2)\n                        phase_schedule[ls, lb] = (phase_schedule[ls, lb] + phase * 3) % 4\n    return phase_schedule",
            "def _update_phase_schedule(n, phase_schedule, swap_plus):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given phase_schedule initialized to induce a CZ circuit in SWAP-only network and list of SWAP+ boxes\\n    Update phase_schedule for each SWAP+ according to Algorithm 2, [2]\\n    '\n    layer_order = list(range(n))[-3::-2] + list(range(n))[-2::-2][::-1]\n    order_comp = np.argsort(layer_order[::-1])\n    for i in layer_order:\n        for j in range(i + 1, n):\n            if (i, j) not in swap_plus:\n                continue\n            (phase_schedule[j, j], phase_schedule[i, j]) = (phase_schedule[i, j], phase_schedule[j, j])\n            for k in range(n):\n                if k in (i, j):\n                    continue\n                if order_comp[min(k, j)] < order_comp[i] and phase_schedule[min(k, j), max(k, j)] % 4 != 0:\n                    phase = phase_schedule[min(k, j), max(k, j)]\n                    phase_schedule[min(k, j), max(k, j)] = 0\n                    for l_s in (i, j, k):\n                        phase_schedule[l_s, l_s] = (phase_schedule[l_s, l_s] + phase * 3) % 4\n                    for (l1, l2) in [(i, j), (i, k), (j, k)]:\n                        ls = min(l1, l2)\n                        lb = max(l1, l2)\n                        phase_schedule[ls, lb] = (phase_schedule[ls, lb] + phase * 3) % 4\n    return phase_schedule",
            "def _update_phase_schedule(n, phase_schedule, swap_plus):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given phase_schedule initialized to induce a CZ circuit in SWAP-only network and list of SWAP+ boxes\\n    Update phase_schedule for each SWAP+ according to Algorithm 2, [2]\\n    '\n    layer_order = list(range(n))[-3::-2] + list(range(n))[-2::-2][::-1]\n    order_comp = np.argsort(layer_order[::-1])\n    for i in layer_order:\n        for j in range(i + 1, n):\n            if (i, j) not in swap_plus:\n                continue\n            (phase_schedule[j, j], phase_schedule[i, j]) = (phase_schedule[i, j], phase_schedule[j, j])\n            for k in range(n):\n                if k in (i, j):\n                    continue\n                if order_comp[min(k, j)] < order_comp[i] and phase_schedule[min(k, j), max(k, j)] % 4 != 0:\n                    phase = phase_schedule[min(k, j), max(k, j)]\n                    phase_schedule[min(k, j), max(k, j)] = 0\n                    for l_s in (i, j, k):\n                        phase_schedule[l_s, l_s] = (phase_schedule[l_s, l_s] + phase * 3) % 4\n                    for (l1, l2) in [(i, j), (i, k), (j, k)]:\n                        ls = min(l1, l2)\n                        lb = max(l1, l2)\n                        phase_schedule[ls, lb] = (phase_schedule[ls, lb] + phase * 3) % 4\n    return phase_schedule"
        ]
    },
    {
        "func_name": "_apply_phase_to_nw_circuit",
        "original": "def _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus):\n    \"\"\"\n    Given\n        Width of the circuit (int n)\n        A CZ circuit, represented by the n*n phase schedule phase_schedule\n        A CX circuit, represented by box-labels (seq) and whether the box is SWAP+ (swap_plus)\n            *   This circuit corresponds to the CX tranformation that tranforms a matrix to\n                a NW matrix (c.f. Prop.7.4, [1])\n            *   SWAP+ is defined in section 3.A. of [2].\n            *   As previously noted, the northwest diagonalization procedure of [1] consists\n                of exactly n layers of boxes, each being either a SWAP or a SWAP+. That is,\n                each northwest diagonalization circuit can be uniquely represented by which\n                of its n(n-1)/2 boxes are SWAP+ and which are SWAP.\n    Return a QuantumCircuit that computes the phase scheudle S inside CX\n    \"\"\"\n    cir = QuantumCircuit(n)\n    wires = list(zip(range(n), range(1, n)))\n    wires = wires[::2] + wires[1::2]\n    for (i, (j, k)) in zip(range(len(seq) - 1, -1, -1), reversed(seq)):\n        (w1, w2) = wires[i % (n - 1)]\n        p = phase_schedule[j, k]\n        if (j, k) not in swap_plus:\n            cir.cx(w1, w2)\n        cir.cx(w2, w1)\n        if p % 4 == 0:\n            pass\n        elif p % 4 == 1:\n            cir.sdg(w2)\n        elif p % 4 == 2:\n            cir.z(w2)\n        else:\n            cir.s(w2)\n        cir.cx(w1, w2)\n    for i in range(n):\n        p = phase_schedule[n - 1 - i, n - 1 - i]\n        if p % 4 == 0:\n            continue\n        if p % 4 == 1:\n            cir.sdg(i)\n        elif p % 4 == 2:\n            cir.z(i)\n        else:\n            cir.s(i)\n    return cir",
        "mutated": [
            "def _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus):\n    if False:\n        i = 10\n    '\\n    Given\\n        Width of the circuit (int n)\\n        A CZ circuit, represented by the n*n phase schedule phase_schedule\\n        A CX circuit, represented by box-labels (seq) and whether the box is SWAP+ (swap_plus)\\n            *   This circuit corresponds to the CX tranformation that tranforms a matrix to\\n                a NW matrix (c.f. Prop.7.4, [1])\\n            *   SWAP+ is defined in section 3.A. of [2].\\n            *   As previously noted, the northwest diagonalization procedure of [1] consists\\n                of exactly n layers of boxes, each being either a SWAP or a SWAP+. That is,\\n                each northwest diagonalization circuit can be uniquely represented by which\\n                of its n(n-1)/2 boxes are SWAP+ and which are SWAP.\\n    Return a QuantumCircuit that computes the phase scheudle S inside CX\\n    '\n    cir = QuantumCircuit(n)\n    wires = list(zip(range(n), range(1, n)))\n    wires = wires[::2] + wires[1::2]\n    for (i, (j, k)) in zip(range(len(seq) - 1, -1, -1), reversed(seq)):\n        (w1, w2) = wires[i % (n - 1)]\n        p = phase_schedule[j, k]\n        if (j, k) not in swap_plus:\n            cir.cx(w1, w2)\n        cir.cx(w2, w1)\n        if p % 4 == 0:\n            pass\n        elif p % 4 == 1:\n            cir.sdg(w2)\n        elif p % 4 == 2:\n            cir.z(w2)\n        else:\n            cir.s(w2)\n        cir.cx(w1, w2)\n    for i in range(n):\n        p = phase_schedule[n - 1 - i, n - 1 - i]\n        if p % 4 == 0:\n            continue\n        if p % 4 == 1:\n            cir.sdg(i)\n        elif p % 4 == 2:\n            cir.z(i)\n        else:\n            cir.s(i)\n    return cir",
            "def _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given\\n        Width of the circuit (int n)\\n        A CZ circuit, represented by the n*n phase schedule phase_schedule\\n        A CX circuit, represented by box-labels (seq) and whether the box is SWAP+ (swap_plus)\\n            *   This circuit corresponds to the CX tranformation that tranforms a matrix to\\n                a NW matrix (c.f. Prop.7.4, [1])\\n            *   SWAP+ is defined in section 3.A. of [2].\\n            *   As previously noted, the northwest diagonalization procedure of [1] consists\\n                of exactly n layers of boxes, each being either a SWAP or a SWAP+. That is,\\n                each northwest diagonalization circuit can be uniquely represented by which\\n                of its n(n-1)/2 boxes are SWAP+ and which are SWAP.\\n    Return a QuantumCircuit that computes the phase scheudle S inside CX\\n    '\n    cir = QuantumCircuit(n)\n    wires = list(zip(range(n), range(1, n)))\n    wires = wires[::2] + wires[1::2]\n    for (i, (j, k)) in zip(range(len(seq) - 1, -1, -1), reversed(seq)):\n        (w1, w2) = wires[i % (n - 1)]\n        p = phase_schedule[j, k]\n        if (j, k) not in swap_plus:\n            cir.cx(w1, w2)\n        cir.cx(w2, w1)\n        if p % 4 == 0:\n            pass\n        elif p % 4 == 1:\n            cir.sdg(w2)\n        elif p % 4 == 2:\n            cir.z(w2)\n        else:\n            cir.s(w2)\n        cir.cx(w1, w2)\n    for i in range(n):\n        p = phase_schedule[n - 1 - i, n - 1 - i]\n        if p % 4 == 0:\n            continue\n        if p % 4 == 1:\n            cir.sdg(i)\n        elif p % 4 == 2:\n            cir.z(i)\n        else:\n            cir.s(i)\n    return cir",
            "def _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given\\n        Width of the circuit (int n)\\n        A CZ circuit, represented by the n*n phase schedule phase_schedule\\n        A CX circuit, represented by box-labels (seq) and whether the box is SWAP+ (swap_plus)\\n            *   This circuit corresponds to the CX tranformation that tranforms a matrix to\\n                a NW matrix (c.f. Prop.7.4, [1])\\n            *   SWAP+ is defined in section 3.A. of [2].\\n            *   As previously noted, the northwest diagonalization procedure of [1] consists\\n                of exactly n layers of boxes, each being either a SWAP or a SWAP+. That is,\\n                each northwest diagonalization circuit can be uniquely represented by which\\n                of its n(n-1)/2 boxes are SWAP+ and which are SWAP.\\n    Return a QuantumCircuit that computes the phase scheudle S inside CX\\n    '\n    cir = QuantumCircuit(n)\n    wires = list(zip(range(n), range(1, n)))\n    wires = wires[::2] + wires[1::2]\n    for (i, (j, k)) in zip(range(len(seq) - 1, -1, -1), reversed(seq)):\n        (w1, w2) = wires[i % (n - 1)]\n        p = phase_schedule[j, k]\n        if (j, k) not in swap_plus:\n            cir.cx(w1, w2)\n        cir.cx(w2, w1)\n        if p % 4 == 0:\n            pass\n        elif p % 4 == 1:\n            cir.sdg(w2)\n        elif p % 4 == 2:\n            cir.z(w2)\n        else:\n            cir.s(w2)\n        cir.cx(w1, w2)\n    for i in range(n):\n        p = phase_schedule[n - 1 - i, n - 1 - i]\n        if p % 4 == 0:\n            continue\n        if p % 4 == 1:\n            cir.sdg(i)\n        elif p % 4 == 2:\n            cir.z(i)\n        else:\n            cir.s(i)\n    return cir",
            "def _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given\\n        Width of the circuit (int n)\\n        A CZ circuit, represented by the n*n phase schedule phase_schedule\\n        A CX circuit, represented by box-labels (seq) and whether the box is SWAP+ (swap_plus)\\n            *   This circuit corresponds to the CX tranformation that tranforms a matrix to\\n                a NW matrix (c.f. Prop.7.4, [1])\\n            *   SWAP+ is defined in section 3.A. of [2].\\n            *   As previously noted, the northwest diagonalization procedure of [1] consists\\n                of exactly n layers of boxes, each being either a SWAP or a SWAP+. That is,\\n                each northwest diagonalization circuit can be uniquely represented by which\\n                of its n(n-1)/2 boxes are SWAP+ and which are SWAP.\\n    Return a QuantumCircuit that computes the phase scheudle S inside CX\\n    '\n    cir = QuantumCircuit(n)\n    wires = list(zip(range(n), range(1, n)))\n    wires = wires[::2] + wires[1::2]\n    for (i, (j, k)) in zip(range(len(seq) - 1, -1, -1), reversed(seq)):\n        (w1, w2) = wires[i % (n - 1)]\n        p = phase_schedule[j, k]\n        if (j, k) not in swap_plus:\n            cir.cx(w1, w2)\n        cir.cx(w2, w1)\n        if p % 4 == 0:\n            pass\n        elif p % 4 == 1:\n            cir.sdg(w2)\n        elif p % 4 == 2:\n            cir.z(w2)\n        else:\n            cir.s(w2)\n        cir.cx(w1, w2)\n    for i in range(n):\n        p = phase_schedule[n - 1 - i, n - 1 - i]\n        if p % 4 == 0:\n            continue\n        if p % 4 == 1:\n            cir.sdg(i)\n        elif p % 4 == 2:\n            cir.z(i)\n        else:\n            cir.s(i)\n    return cir",
            "def _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given\\n        Width of the circuit (int n)\\n        A CZ circuit, represented by the n*n phase schedule phase_schedule\\n        A CX circuit, represented by box-labels (seq) and whether the box is SWAP+ (swap_plus)\\n            *   This circuit corresponds to the CX tranformation that tranforms a matrix to\\n                a NW matrix (c.f. Prop.7.4, [1])\\n            *   SWAP+ is defined in section 3.A. of [2].\\n            *   As previously noted, the northwest diagonalization procedure of [1] consists\\n                of exactly n layers of boxes, each being either a SWAP or a SWAP+. That is,\\n                each northwest diagonalization circuit can be uniquely represented by which\\n                of its n(n-1)/2 boxes are SWAP+ and which are SWAP.\\n    Return a QuantumCircuit that computes the phase scheudle S inside CX\\n    '\n    cir = QuantumCircuit(n)\n    wires = list(zip(range(n), range(1, n)))\n    wires = wires[::2] + wires[1::2]\n    for (i, (j, k)) in zip(range(len(seq) - 1, -1, -1), reversed(seq)):\n        (w1, w2) = wires[i % (n - 1)]\n        p = phase_schedule[j, k]\n        if (j, k) not in swap_plus:\n            cir.cx(w1, w2)\n        cir.cx(w2, w1)\n        if p % 4 == 0:\n            pass\n        elif p % 4 == 1:\n            cir.sdg(w2)\n        elif p % 4 == 2:\n            cir.z(w2)\n        else:\n            cir.s(w2)\n        cir.cx(w1, w2)\n    for i in range(n):\n        p = phase_schedule[n - 1 - i, n - 1 - i]\n        if p % 4 == 0:\n            continue\n        if p % 4 == 1:\n            cir.sdg(i)\n        elif p % 4 == 2:\n            cir.z(i)\n        else:\n            cir.s(i)\n    return cir"
        ]
    },
    {
        "func_name": "synth_cx_cz_depth_line_my",
        "original": "def synth_cx_cz_depth_line_my(mat_x: np.ndarray, mat_z: np.ndarray):\n    \"\"\"\n    Joint synthesis of a -CZ-CX- circuit for linear nearest neighbour (LNN) connectivity,\n    with 2-qubit depth at most 5n, based on Maslov and Yang.\n    This method computes the CZ circuit inside the CX circuit via phase gate insertions.\n\n    Args:\n        mat_z : a boolean symmetric matrix representing a CZ circuit.\n            Mz[i][j]=1 represents a CZ(i,j) gate\n\n        mat_x : a boolean invertible matrix representing a CX circuit.\n\n    Return:\n        QuantumCircuit : a circuit implementation of a CX circuit following a CZ circuit,\n        denoted as a -CZ-CX- circuit,in two-qubit depth at most 5n, for LNN connectivity.\n\n    Reference:\n        1. Kutin, S., Moulton, D. P., Smithline, L.,\n           *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\n           `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_\n        2. Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary\n           Hadamard-free Clifford transformations they generate*,\n           `arXiv:2210.16195 <https://arxiv.org/abs/2210.16195>`_.\n    \"\"\"\n    n = len(mat_x)\n    mat_x = calc_inverse_matrix(mat_x)\n    (cx_instructions_rows_m2nw, cx_instructions_rows_nw2id) = _optimize_cx_circ_depth_5n_line(mat_x)\n    phase_schedule = _initialize_phase_schedule(mat_z)\n    seq = _make_seq(n)\n    swap_plus = _swap_plus(cx_instructions_rows_nw2id, seq)\n    _update_phase_schedule(n, phase_schedule, swap_plus)\n    qc = _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus)\n    for (i, j) in reversed(cx_instructions_rows_m2nw):\n        qc.cx(i, j)\n    return qc",
        "mutated": [
            "def synth_cx_cz_depth_line_my(mat_x: np.ndarray, mat_z: np.ndarray):\n    if False:\n        i = 10\n    '\\n    Joint synthesis of a -CZ-CX- circuit for linear nearest neighbour (LNN) connectivity,\\n    with 2-qubit depth at most 5n, based on Maslov and Yang.\\n    This method computes the CZ circuit inside the CX circuit via phase gate insertions.\\n\\n    Args:\\n        mat_z : a boolean symmetric matrix representing a CZ circuit.\\n            Mz[i][j]=1 represents a CZ(i,j) gate\\n\\n        mat_x : a boolean invertible matrix representing a CX circuit.\\n\\n    Return:\\n        QuantumCircuit : a circuit implementation of a CX circuit following a CZ circuit,\\n        denoted as a -CZ-CX- circuit,in two-qubit depth at most 5n, for LNN connectivity.\\n\\n    Reference:\\n        1. Kutin, S., Moulton, D. P., Smithline, L.,\\n           *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\\n           `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_\\n        2. Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary\\n           Hadamard-free Clifford transformations they generate*,\\n           `arXiv:2210.16195 <https://arxiv.org/abs/2210.16195>`_.\\n    '\n    n = len(mat_x)\n    mat_x = calc_inverse_matrix(mat_x)\n    (cx_instructions_rows_m2nw, cx_instructions_rows_nw2id) = _optimize_cx_circ_depth_5n_line(mat_x)\n    phase_schedule = _initialize_phase_schedule(mat_z)\n    seq = _make_seq(n)\n    swap_plus = _swap_plus(cx_instructions_rows_nw2id, seq)\n    _update_phase_schedule(n, phase_schedule, swap_plus)\n    qc = _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus)\n    for (i, j) in reversed(cx_instructions_rows_m2nw):\n        qc.cx(i, j)\n    return qc",
            "def synth_cx_cz_depth_line_my(mat_x: np.ndarray, mat_z: np.ndarray):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Joint synthesis of a -CZ-CX- circuit for linear nearest neighbour (LNN) connectivity,\\n    with 2-qubit depth at most 5n, based on Maslov and Yang.\\n    This method computes the CZ circuit inside the CX circuit via phase gate insertions.\\n\\n    Args:\\n        mat_z : a boolean symmetric matrix representing a CZ circuit.\\n            Mz[i][j]=1 represents a CZ(i,j) gate\\n\\n        mat_x : a boolean invertible matrix representing a CX circuit.\\n\\n    Return:\\n        QuantumCircuit : a circuit implementation of a CX circuit following a CZ circuit,\\n        denoted as a -CZ-CX- circuit,in two-qubit depth at most 5n, for LNN connectivity.\\n\\n    Reference:\\n        1. Kutin, S., Moulton, D. P., Smithline, L.,\\n           *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\\n           `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_\\n        2. Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary\\n           Hadamard-free Clifford transformations they generate*,\\n           `arXiv:2210.16195 <https://arxiv.org/abs/2210.16195>`_.\\n    '\n    n = len(mat_x)\n    mat_x = calc_inverse_matrix(mat_x)\n    (cx_instructions_rows_m2nw, cx_instructions_rows_nw2id) = _optimize_cx_circ_depth_5n_line(mat_x)\n    phase_schedule = _initialize_phase_schedule(mat_z)\n    seq = _make_seq(n)\n    swap_plus = _swap_plus(cx_instructions_rows_nw2id, seq)\n    _update_phase_schedule(n, phase_schedule, swap_plus)\n    qc = _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus)\n    for (i, j) in reversed(cx_instructions_rows_m2nw):\n        qc.cx(i, j)\n    return qc",
            "def synth_cx_cz_depth_line_my(mat_x: np.ndarray, mat_z: np.ndarray):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Joint synthesis of a -CZ-CX- circuit for linear nearest neighbour (LNN) connectivity,\\n    with 2-qubit depth at most 5n, based on Maslov and Yang.\\n    This method computes the CZ circuit inside the CX circuit via phase gate insertions.\\n\\n    Args:\\n        mat_z : a boolean symmetric matrix representing a CZ circuit.\\n            Mz[i][j]=1 represents a CZ(i,j) gate\\n\\n        mat_x : a boolean invertible matrix representing a CX circuit.\\n\\n    Return:\\n        QuantumCircuit : a circuit implementation of a CX circuit following a CZ circuit,\\n        denoted as a -CZ-CX- circuit,in two-qubit depth at most 5n, for LNN connectivity.\\n\\n    Reference:\\n        1. Kutin, S., Moulton, D. P., Smithline, L.,\\n           *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\\n           `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_\\n        2. Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary\\n           Hadamard-free Clifford transformations they generate*,\\n           `arXiv:2210.16195 <https://arxiv.org/abs/2210.16195>`_.\\n    '\n    n = len(mat_x)\n    mat_x = calc_inverse_matrix(mat_x)\n    (cx_instructions_rows_m2nw, cx_instructions_rows_nw2id) = _optimize_cx_circ_depth_5n_line(mat_x)\n    phase_schedule = _initialize_phase_schedule(mat_z)\n    seq = _make_seq(n)\n    swap_plus = _swap_plus(cx_instructions_rows_nw2id, seq)\n    _update_phase_schedule(n, phase_schedule, swap_plus)\n    qc = _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus)\n    for (i, j) in reversed(cx_instructions_rows_m2nw):\n        qc.cx(i, j)\n    return qc",
            "def synth_cx_cz_depth_line_my(mat_x: np.ndarray, mat_z: np.ndarray):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Joint synthesis of a -CZ-CX- circuit for linear nearest neighbour (LNN) connectivity,\\n    with 2-qubit depth at most 5n, based on Maslov and Yang.\\n    This method computes the CZ circuit inside the CX circuit via phase gate insertions.\\n\\n    Args:\\n        mat_z : a boolean symmetric matrix representing a CZ circuit.\\n            Mz[i][j]=1 represents a CZ(i,j) gate\\n\\n        mat_x : a boolean invertible matrix representing a CX circuit.\\n\\n    Return:\\n        QuantumCircuit : a circuit implementation of a CX circuit following a CZ circuit,\\n        denoted as a -CZ-CX- circuit,in two-qubit depth at most 5n, for LNN connectivity.\\n\\n    Reference:\\n        1. Kutin, S., Moulton, D. P., Smithline, L.,\\n           *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\\n           `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_\\n        2. Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary\\n           Hadamard-free Clifford transformations they generate*,\\n           `arXiv:2210.16195 <https://arxiv.org/abs/2210.16195>`_.\\n    '\n    n = len(mat_x)\n    mat_x = calc_inverse_matrix(mat_x)\n    (cx_instructions_rows_m2nw, cx_instructions_rows_nw2id) = _optimize_cx_circ_depth_5n_line(mat_x)\n    phase_schedule = _initialize_phase_schedule(mat_z)\n    seq = _make_seq(n)\n    swap_plus = _swap_plus(cx_instructions_rows_nw2id, seq)\n    _update_phase_schedule(n, phase_schedule, swap_plus)\n    qc = _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus)\n    for (i, j) in reversed(cx_instructions_rows_m2nw):\n        qc.cx(i, j)\n    return qc",
            "def synth_cx_cz_depth_line_my(mat_x: np.ndarray, mat_z: np.ndarray):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Joint synthesis of a -CZ-CX- circuit for linear nearest neighbour (LNN) connectivity,\\n    with 2-qubit depth at most 5n, based on Maslov and Yang.\\n    This method computes the CZ circuit inside the CX circuit via phase gate insertions.\\n\\n    Args:\\n        mat_z : a boolean symmetric matrix representing a CZ circuit.\\n            Mz[i][j]=1 represents a CZ(i,j) gate\\n\\n        mat_x : a boolean invertible matrix representing a CX circuit.\\n\\n    Return:\\n        QuantumCircuit : a circuit implementation of a CX circuit following a CZ circuit,\\n        denoted as a -CZ-CX- circuit,in two-qubit depth at most 5n, for LNN connectivity.\\n\\n    Reference:\\n        1. Kutin, S., Moulton, D. P., Smithline, L.,\\n           *Computation at a distance*, Chicago J. Theor. Comput. Sci., vol. 2007, (2007),\\n           `arXiv:quant-ph/0701194 <https://arxiv.org/abs/quant-ph/0701194>`_\\n        2. Dmitri Maslov, Willers Yang, *CNOT circuits need little help to implement arbitrary\\n           Hadamard-free Clifford transformations they generate*,\\n           `arXiv:2210.16195 <https://arxiv.org/abs/2210.16195>`_.\\n    '\n    n = len(mat_x)\n    mat_x = calc_inverse_matrix(mat_x)\n    (cx_instructions_rows_m2nw, cx_instructions_rows_nw2id) = _optimize_cx_circ_depth_5n_line(mat_x)\n    phase_schedule = _initialize_phase_schedule(mat_z)\n    seq = _make_seq(n)\n    swap_plus = _swap_plus(cx_instructions_rows_nw2id, seq)\n    _update_phase_schedule(n, phase_schedule, swap_plus)\n    qc = _apply_phase_to_nw_circuit(n, phase_schedule, seq, swap_plus)\n    for (i, j) in reversed(cx_instructions_rows_m2nw):\n        qc.cx(i, j)\n    return qc"
        ]
    }
]