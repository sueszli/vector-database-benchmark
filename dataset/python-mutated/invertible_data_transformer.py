"""
Invertible Data Transformer Base Class
--------------------------------------
"""
from abc import abstractmethod
from typing import Any, List, Mapping, Optional, Sequence, Union
import numpy as np
from darts import TimeSeries
from darts.logging import get_logger, raise_if_not
from darts.utils import _build_tqdm_iterator, _parallel_apply
from .base_data_transformer import BaseDataTransformer
logger = get_logger(__name__)

class InvertibleDataTransformer(BaseDataTransformer):

    def __init__(self, name: str='InvertibleDataTransformer', n_jobs: int=1, verbose: bool=False, parallel_params: Union[bool, Sequence[str]]=False, mask_components: bool=True):
        if False:
            return 10
        "Abstract class for invertible transformers.\n\n        All the deriving classes have to implement the static methods :func:`ts_transform()` and\n        :func:`ts_inverse_transform()`. For information on how to implement the :func:`ts_transform` method,\n        please refer to the :class:`.BaseDataTransformer` documentation.\n\n        The :func:`ts_inverse_transform()` method should be implemented in a virtually identical way to the\n        :func:`ts_transform()` method: it should accept a ``TimeSeries`` as a first argument, and a dictionary\n        of fixed parameters (as well as fitted parameters if the transformation also inherits from\n        `FittableDataTransformer`) as a second argument. Additionally, :func:`ts_inverse_transform()` should\n        also accept `*args` and `**kwargs` if additional positional/keyword arguments are expected to be\n        passed. The only difference between :func:`ts_inverse_transform()` and :func:`ts_transform()`\n        is that the former should 'undo' the transformation made to a `TimeSeries` by the latter. Please\n        refer to the :func:`ts_inverse_transform()` documentation for further information.\n\n        This class takes care of parallelizing the transformation on multiple ``TimeSeries`` when possible.\n\n        Parameters\n        ----------\n        name\n            The data transformer's name\n        n_jobs\n            The number of jobs to run in parallel. Parallel jobs are created only when a Sequence[TimeSeries] is passed\n            as input to a method, parallelising operations regarding different TimeSeries. Defaults to `1` (sequential).\n            Setting the parameter to `-1` means using all the available processors.\n            Note: for a small amount of data, the parallelisation overhead could end up increasing the total\n            required amount of time.\n        verbose\n            Optionally, whether to print operations progress\n        parallel_params\n            Optionally, specifies which fixed parameters (i.e. the attributes initialized in the child-most\n            class's `__init__`) take on different values for different parallel jobs. Fixed parameters specified\n            by `parallel_params` are assumed to be a `Sequence` of values that should be used for that parameter\n            in each parallel job; the length of this `Sequence` should equal the number of parallel jobs. If\n            `parallel_params=True`, every fixed parameter will take on a different value for each\n            parallel job. If `parallel_params=False`, every fixed parameter will take on the same value for\n            each parallel job. If `parallel_params` is a `Sequence` of fixed attribute names, only those\n            attribute names specified will take on different values between different parallel jobs.\n        mask_components\n            Optionally, whether or not to automatically apply any provided `component_mask`s to the\n            `TimeSeries` inputs passed to `transform`, `fit`, `inverse_transform`, or `fit_transform`.\n            If `True`, any specified `component_mask` will be applied to each input timeseries\n            before passing them to the called method; the masked components will also be automatically\n            'unmasked' in the returned `TimeSeries`. If `False`, then `component_mask` (if provided) will\n            be passed as a keyword argument, but won't automatically be applied to the input timeseries.\n            See `apply_component_mask` method of `BaseDataTransformer` for further details.\n\n        Notes\n        -----\n        Note: the :func:`ts_transform()` and :func:`ts_inverse_transform()` methods are designed to be\n        static methods instead of instance methods to allow an efficient parallelisation also when the\n        scaler instance is storing a non-negligible amount of data. Using instance methods would imply\n        copying the instance's data through multiple processes, which can easily introduce a bottleneck\n        and nullify parallelisation benefits.\n\n        Example\n        --------\n        >>> from darts.dataprocessing.transformers import InvertibleDataTransformer\n        >>> from darts.utils.timeseries_generation import linear_timeseries\n        >>>\n        >>> class SimpleTransform(InvertibleDataTransformer):\n        >>>\n        >>>         def __init__(self, a):\n        >>>             self._a = a\n        >>>             super().__init__()\n        >>>\n        >>>         @staticmethod\n        >>>         def ts_transform(series, params, **kwargs):\n        >>>             a = params['fixed']['_a']\n        >>>             b = kwargs.pop('b')\n        >>>             return a*series + b\n        >>>\n        >>>         @staticmethod\n        >>>         def ts_inverse_transform(series, params, **kwargs):\n        >>>             a = params['fixed']['_a']\n        >>>             b = kwargs.pop('b')\n        >>>             return (series - b) / a\n        >>>\n        >>> series = linear_timeseries(length=5)\n        >>> print(series)\n        <TimeSeries (DataArray) (time: 5, component: 1, sample: 1)>\n        array([[[0.  ]],\n\n            [[0.25]],\n\n            [[0.5 ]],\n\n            [[0.75]],\n\n            [[1.  ]]])\n        Coordinates:\n        * time       (time) datetime64[ns] 2000-01-01 2000-01-02 ... 2000-01-05\n        * component  (component) object 'linear'\n        Dimensions without coordinates: sample\n        Attributes:\n            static_covariates:  None\n            hierarchy:          None\n        >>> transform = SimpleTransform(a=2)\n        >>> series = transform.transform(series, b=3)\n        >>> print(series)\n        <TimeSeries (DataArray) (time: 5, component: 1, sample: 1)>\n        array([[[3. ]],\n\n            [[3.5]],\n\n            [[4. ]],\n\n            [[4.5]],\n\n            [[5. ]]])\n        Coordinates:\n        * time       (time) datetime64[ns] 2000-01-01 2000-01-02 ... 2000-01-05\n        * component  (component) object 'linear'\n        Dimensions without coordinates: sample\n        Attributes:\n            static_covariates:  None\n            hierarchy:          None\n        >>> series = transform.inverse_transform(series, b=3)\n        >>> print(series)\n        <TimeSeries (DataArray) (time: 5, component: 1, sample: 1)>\n        array([[[0.  ]],\n\n            [[0.25]],\n\n            [[0.5 ]],\n\n            [[0.75]],\n\n            [[1.  ]]])\n        Coordinates:\n        * time       (time) datetime64[ns] 2000-01-01 2000-01-02 ... 2000-01-05\n        * component  (component) object 'linear'\n        Dimensions without coordinates: sample\n        Attributes:\n            static_covariates:  None\n            hierarchy:          None\n        "
        super().__init__(name=name, n_jobs=n_jobs, verbose=verbose, parallel_params=parallel_params, mask_components=mask_components)

    @staticmethod
    @abstractmethod
    def ts_inverse_transform(series: TimeSeries, params: Mapping[str, Any]) -> TimeSeries:
        if False:
            i = 10
            return i + 15
        "The function that will be applied to each series when :func:`inverse_transform` is called.\n\n        The function must take as first argument a ``TimeSeries`` object and, as a second argument, a\n        dictionary containing the fixed and/or fitted parameters of the transformation; this function\n        should then return an inverse transformed ``TimeSeries`` object (i.e. `ts_inverse_transform` should\n        'undo' the transformation performed by `ts_transform`).\n\n        The `params` dictionary *can* contain up to two keys:\n            1. `params['fixed']` stores the fixed parameters of the transformation (i.e. attributed\n            defined in the `__init__` method of the child-most class *before* `super().__init__` is called);\n            `params['fixed']` is a dictionary itself, whose keys are the names of the fixed parameter\n            attributes. For example, if `_my_fixed_param` is defined as an attribute in the child-most\n            class, then this fixed parameter value can be accessed through `params['fixed']['_my_fixed_param']`.\n            2. If the transform inherits from the :class:`.FittableDataTransformer` class, then `params['fitted']`\n            will store the fitted parameters of the transformation; the fitted parameters are simply the output(s)\n            returned by the `ts_fit` function, whatever those output(s) may be. See :class:`.FittableDataTransformer`\n            for further details about fitted parameters.\n\n        Any positional/keyword argument supplied to the `transform` method are passed as positional/keyword arguments\n        to `ts_inverse_transform`; hence, `ts_inverse_transform` should also accept `*args` and/or `**kwargs` if\n        positional/keyword arguments are passed to `transform`. Note that if the `mask_components` attribute of\n        `InvertibleDataTransformer` is set to `False`, then the `component_mask` provided to `transform` will be passed\n        as an additional keyword argument to `ts_inverse_transform`.\n\n        The `BaseDataTransformer` class, from which `InvertibleDataTransformer` inherits, includes some helper methods\n        which may prove useful when implementing a `ts_inverse_transform` function:\n            1. The `apply_component_mask` and `unapply_component_mask` methods, which apply and 'unapply'\n            `component_mask`s to a `TimeSeries` respectively; these methods are automatically called in `transform` if\n            the `mask_component` attribute of `InvertibleDataTransformer` is set to `True`, but you may want to manually\n            call them if you set `mask_components` to `False` and wish to manually specify how `component_mask`s are\n            applied to a `TimeSeries`.\n            2. The `stack_samples` method, which stacks all the samples in a `TimeSeries` along\n            the component axis, so that the `TimeSeries` goes from shape `(n_timesteps, n_components, n_samples)` to\n            shape `(n_timesteps, n_components * n_samples)`. This stacking is useful if a pointwise inverse transform\n            is being implemented (i.e. transforming the value at time `t` depends only on the value of the series at\n            that time `t`). Once transformed, the stacked `TimeSeries` can be 'unstacked' using the `unstack_samples`\n            method.\n\n        This method is not implemented in the base class and must be implemented in the deriving classes.\n\n        Parameters\n        ----------\n        series\n            series to be transformed.\n        params\n            Dictionary containing the parameters of the transformation function. Fixed parameters\n            (i.e. attributes defined in the child-most class of the transformation prior to\n            calling `super.__init__()`) are stored under the `'fixed'` key. If the transformation\n            inherits from the `FittableDataTransformer` class, then the fitted parameters of the\n            transformation (i.e. the values returned by `ts_fit`) are stored under the\n            `'fitted'` key.\n        args\n            Any additional keyword arguments provided to `inverse_transform`.\n        kwargs\n            Any additional keyword arguments provided to `inverse_transform`. Note that if the `mask_component`\n            attribute of `InvertibleDataTransformer` is set to `False`, then `component_mask` will\n            be passed as a keyword argument.\n\n        Notes\n        -----\n        This method is designed to be a static method instead of instance methods to allow an efficient\n        parallelisation also when the scaler instance is storing a non-negligible amount of data. Using instance\n        methods would imply copying the instance's data through multiple processes, which can easily introduce a\n        bottleneck and nullify parallelisation benefits.\n        "
        pass

    def inverse_transform(self, series: Union[TimeSeries, Sequence[TimeSeries]], *args, component_mask: Optional[np.array]=None, **kwargs) -> Union[TimeSeries, List[TimeSeries]]:
        if False:
            while True:
                i = 10
        "Inverse transforms a (sequence of) series by calling the user-implemented `ts_inverse_transform` method.\n\n        In case a sequence is passed as input data, this function takes care of parallelising the\n        transformation of multiple series in the sequence at the same time. Additionally,\n        if the `mask_components` attribute was set to `True` when instantiating `InvertibleDataTransformer`,\n        then any provided `component_mask`s will be automatically applied to each input `TimeSeries`;\n        please refer to 'Notes' for further details on component masking.\n\n        Any additionally specified `*args` and `**kwargs` are automatically passed to `ts_inverse_transform`.\n\n        Parameters\n        ----------\n        series\n            the (sequence of) series be inverse-transformed.\n        args\n            Additional positional arguments for the :func:`ts_inverse_transform()` method\n        component_mask : Optional[np.ndarray] = None\n            Optionally, a 1-D boolean np.ndarray of length ``series.n_components`` that specifies\n            which components of the underlying `series` the inverse transform should consider.\n        kwargs\n            Additional keyword arguments for the :func:`ts_inverse_transform()` method\n\n        Returns\n        -------\n        Union[TimeSeries, List[TimeSeries]]\n            Inverse transformed data.\n\n        Notes\n        -----\n        If the `mask_components` attribute was set to `True` when instantiating `InvertibleDataTransformer`,\n        then any provided `component_mask`s will be automatically applied to each `TimeSeries` input to\n        transform; `component_mask`s are simply boolean arrays of shape `(series.n_components,)` that\n        specify which components of each `series` should be transformed using `ts_inverse_transform` and which\n        components should not. If `component_mask[i]` is `True`, then the `i`th component of each\n        `series` will be transformed by `ts_inverse_transform`. Conversely, if `component_mask[i]` is `False`,\n        the `i`th component will be removed from each `series` before being passed to `ts_inverse_transform`;\n        after transforming this masked series, the untransformed `i`th component will be 'added back'\n        to the output. Note that automatic `component_mask`ing can only be performed if the `ts_inverse_transform`\n        does *not* change the number of timesteps in each series; if this were to happen, then the transformed\n        and untransformed components are unable to be concatenated back together along the component axis.\n\n        If `mask_components` was set to `False` when instantiating `InvertibleDataTransformer`, then any provided\n        `component_masks` will be passed as a keyword argument `ts_inverse_transform`; the user can then manually\n        specify how the `component_mask` should be applied to each series.\n        "
        if hasattr(self, '_fit_called'):
            raise_if_not(self._fit_called, 'fit() must have been called before inverse_transform()', logger)
        desc = f'Inverse ({self._name})'
        if isinstance(series, TimeSeries):
            input_series = [series]
            data = [series]
        else:
            input_series = series
            data = series
        if self._mask_components:
            data = [self.apply_component_mask(ts, component_mask, return_ts=True) for ts in data]
        else:
            kwargs['component_mask'] = component_mask
        input_iterator = _build_tqdm_iterator(zip(data, self._get_params(n_timeseries=len(data))), verbose=self._verbose, desc=desc, total=len(data))
        transformed_data = _parallel_apply(input_iterator, self.__class__.ts_inverse_transform, self._n_jobs, args, kwargs)
        if self._mask_components:
            unmasked = []
            for (ts, transformed_ts) in zip(input_series, transformed_data):
                unmasked.append(self.unapply_component_mask(ts, transformed_ts, component_mask))
            transformed_data = unmasked
        return transformed_data[0] if isinstance(series, TimeSeries) else transformed_data