[
    {
        "func_name": "svar_ckerr",
        "original": "def svar_ckerr(svar_type, A, B):\n    if A is None and (svar_type == 'A' or svar_type == 'AB'):\n        raise ValueError('SVAR of type A or AB but A array not given.')\n    if B is None and (svar_type == 'B' or svar_type == 'AB'):\n        raise ValueError('SVAR of type B or AB but B array not given.')",
        "mutated": [
            "def svar_ckerr(svar_type, A, B):\n    if False:\n        i = 10\n    if A is None and (svar_type == 'A' or svar_type == 'AB'):\n        raise ValueError('SVAR of type A or AB but A array not given.')\n    if B is None and (svar_type == 'B' or svar_type == 'AB'):\n        raise ValueError('SVAR of type B or AB but B array not given.')",
            "def svar_ckerr(svar_type, A, B):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if A is None and (svar_type == 'A' or svar_type == 'AB'):\n        raise ValueError('SVAR of type A or AB but A array not given.')\n    if B is None and (svar_type == 'B' or svar_type == 'AB'):\n        raise ValueError('SVAR of type B or AB but B array not given.')",
            "def svar_ckerr(svar_type, A, B):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if A is None and (svar_type == 'A' or svar_type == 'AB'):\n        raise ValueError('SVAR of type A or AB but A array not given.')\n    if B is None and (svar_type == 'B' or svar_type == 'AB'):\n        raise ValueError('SVAR of type B or AB but B array not given.')",
            "def svar_ckerr(svar_type, A, B):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if A is None and (svar_type == 'A' or svar_type == 'AB'):\n        raise ValueError('SVAR of type A or AB but A array not given.')\n    if B is None and (svar_type == 'B' or svar_type == 'AB'):\n        raise ValueError('SVAR of type B or AB but B array not given.')",
            "def svar_ckerr(svar_type, A, B):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if A is None and (svar_type == 'A' or svar_type == 'AB'):\n        raise ValueError('SVAR of type A or AB but A array not given.')\n    if B is None and (svar_type == 'B' or svar_type == 'AB'):\n        raise ValueError('SVAR of type B or AB but B array not given.')"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, endog, svar_type, dates=None, freq=None, A=None, B=None, missing='none'):\n    super().__init__(endog, None, dates, freq, missing=missing)\n    self.neqs = self.endog.shape[1]\n    types = ['A', 'B', 'AB']\n    if svar_type not in types:\n        raise ValueError('SVAR type not recognized, must be in ' + str(types))\n    self.svar_type = svar_type\n    svar_ckerr(svar_type, A, B)\n    self.A_original = A\n    self.B_original = B\n    if A is None:\n        A = np.identity(self.neqs)\n        self.A_mask = A_mask = np.zeros(A.shape, dtype=bool)\n    else:\n        A_mask = np.logical_or(A == 'E', A == 'e')\n        self.A_mask = A_mask\n    if B is None:\n        B = np.identity(self.neqs)\n        self.B_mask = B_mask = np.zeros(B.shape, dtype=bool)\n    else:\n        B_mask = np.logical_or(B == 'E', B == 'e')\n        self.B_mask = B_mask\n    Anum = np.zeros(A.shape, dtype=float)\n    Anum[~A_mask] = A[~A_mask]\n    Anum[A_mask] = np.nan\n    self.A = Anum\n    Bnum = np.zeros(B.shape, dtype=float)\n    Bnum[~B_mask] = B[~B_mask]\n    Bnum[B_mask] = np.nan\n    self.B = Bnum",
        "mutated": [
            "def __init__(self, endog, svar_type, dates=None, freq=None, A=None, B=None, missing='none'):\n    if False:\n        i = 10\n    super().__init__(endog, None, dates, freq, missing=missing)\n    self.neqs = self.endog.shape[1]\n    types = ['A', 'B', 'AB']\n    if svar_type not in types:\n        raise ValueError('SVAR type not recognized, must be in ' + str(types))\n    self.svar_type = svar_type\n    svar_ckerr(svar_type, A, B)\n    self.A_original = A\n    self.B_original = B\n    if A is None:\n        A = np.identity(self.neqs)\n        self.A_mask = A_mask = np.zeros(A.shape, dtype=bool)\n    else:\n        A_mask = np.logical_or(A == 'E', A == 'e')\n        self.A_mask = A_mask\n    if B is None:\n        B = np.identity(self.neqs)\n        self.B_mask = B_mask = np.zeros(B.shape, dtype=bool)\n    else:\n        B_mask = np.logical_or(B == 'E', B == 'e')\n        self.B_mask = B_mask\n    Anum = np.zeros(A.shape, dtype=float)\n    Anum[~A_mask] = A[~A_mask]\n    Anum[A_mask] = np.nan\n    self.A = Anum\n    Bnum = np.zeros(B.shape, dtype=float)\n    Bnum[~B_mask] = B[~B_mask]\n    Bnum[B_mask] = np.nan\n    self.B = Bnum",
            "def __init__(self, endog, svar_type, dates=None, freq=None, A=None, B=None, missing='none'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__(endog, None, dates, freq, missing=missing)\n    self.neqs = self.endog.shape[1]\n    types = ['A', 'B', 'AB']\n    if svar_type not in types:\n        raise ValueError('SVAR type not recognized, must be in ' + str(types))\n    self.svar_type = svar_type\n    svar_ckerr(svar_type, A, B)\n    self.A_original = A\n    self.B_original = B\n    if A is None:\n        A = np.identity(self.neqs)\n        self.A_mask = A_mask = np.zeros(A.shape, dtype=bool)\n    else:\n        A_mask = np.logical_or(A == 'E', A == 'e')\n        self.A_mask = A_mask\n    if B is None:\n        B = np.identity(self.neqs)\n        self.B_mask = B_mask = np.zeros(B.shape, dtype=bool)\n    else:\n        B_mask = np.logical_or(B == 'E', B == 'e')\n        self.B_mask = B_mask\n    Anum = np.zeros(A.shape, dtype=float)\n    Anum[~A_mask] = A[~A_mask]\n    Anum[A_mask] = np.nan\n    self.A = Anum\n    Bnum = np.zeros(B.shape, dtype=float)\n    Bnum[~B_mask] = B[~B_mask]\n    Bnum[B_mask] = np.nan\n    self.B = Bnum",
            "def __init__(self, endog, svar_type, dates=None, freq=None, A=None, B=None, missing='none'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__(endog, None, dates, freq, missing=missing)\n    self.neqs = self.endog.shape[1]\n    types = ['A', 'B', 'AB']\n    if svar_type not in types:\n        raise ValueError('SVAR type not recognized, must be in ' + str(types))\n    self.svar_type = svar_type\n    svar_ckerr(svar_type, A, B)\n    self.A_original = A\n    self.B_original = B\n    if A is None:\n        A = np.identity(self.neqs)\n        self.A_mask = A_mask = np.zeros(A.shape, dtype=bool)\n    else:\n        A_mask = np.logical_or(A == 'E', A == 'e')\n        self.A_mask = A_mask\n    if B is None:\n        B = np.identity(self.neqs)\n        self.B_mask = B_mask = np.zeros(B.shape, dtype=bool)\n    else:\n        B_mask = np.logical_or(B == 'E', B == 'e')\n        self.B_mask = B_mask\n    Anum = np.zeros(A.shape, dtype=float)\n    Anum[~A_mask] = A[~A_mask]\n    Anum[A_mask] = np.nan\n    self.A = Anum\n    Bnum = np.zeros(B.shape, dtype=float)\n    Bnum[~B_mask] = B[~B_mask]\n    Bnum[B_mask] = np.nan\n    self.B = Bnum",
            "def __init__(self, endog, svar_type, dates=None, freq=None, A=None, B=None, missing='none'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__(endog, None, dates, freq, missing=missing)\n    self.neqs = self.endog.shape[1]\n    types = ['A', 'B', 'AB']\n    if svar_type not in types:\n        raise ValueError('SVAR type not recognized, must be in ' + str(types))\n    self.svar_type = svar_type\n    svar_ckerr(svar_type, A, B)\n    self.A_original = A\n    self.B_original = B\n    if A is None:\n        A = np.identity(self.neqs)\n        self.A_mask = A_mask = np.zeros(A.shape, dtype=bool)\n    else:\n        A_mask = np.logical_or(A == 'E', A == 'e')\n        self.A_mask = A_mask\n    if B is None:\n        B = np.identity(self.neqs)\n        self.B_mask = B_mask = np.zeros(B.shape, dtype=bool)\n    else:\n        B_mask = np.logical_or(B == 'E', B == 'e')\n        self.B_mask = B_mask\n    Anum = np.zeros(A.shape, dtype=float)\n    Anum[~A_mask] = A[~A_mask]\n    Anum[A_mask] = np.nan\n    self.A = Anum\n    Bnum = np.zeros(B.shape, dtype=float)\n    Bnum[~B_mask] = B[~B_mask]\n    Bnum[B_mask] = np.nan\n    self.B = Bnum",
            "def __init__(self, endog, svar_type, dates=None, freq=None, A=None, B=None, missing='none'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__(endog, None, dates, freq, missing=missing)\n    self.neqs = self.endog.shape[1]\n    types = ['A', 'B', 'AB']\n    if svar_type not in types:\n        raise ValueError('SVAR type not recognized, must be in ' + str(types))\n    self.svar_type = svar_type\n    svar_ckerr(svar_type, A, B)\n    self.A_original = A\n    self.B_original = B\n    if A is None:\n        A = np.identity(self.neqs)\n        self.A_mask = A_mask = np.zeros(A.shape, dtype=bool)\n    else:\n        A_mask = np.logical_or(A == 'E', A == 'e')\n        self.A_mask = A_mask\n    if B is None:\n        B = np.identity(self.neqs)\n        self.B_mask = B_mask = np.zeros(B.shape, dtype=bool)\n    else:\n        B_mask = np.logical_or(B == 'E', B == 'e')\n        self.B_mask = B_mask\n    Anum = np.zeros(A.shape, dtype=float)\n    Anum[~A_mask] = A[~A_mask]\n    Anum[A_mask] = np.nan\n    self.A = Anum\n    Bnum = np.zeros(B.shape, dtype=float)\n    Bnum[~B_mask] = B[~B_mask]\n    Bnum[B_mask] = np.nan\n    self.B = Bnum"
        ]
    },
    {
        "func_name": "fit",
        "original": "def fit(self, A_guess=None, B_guess=None, maxlags=None, method='ols', ic=None, trend='c', verbose=False, s_method='mle', solver='bfgs', override=False, maxiter=500, maxfun=500):\n    \"\"\"\n        Fit the SVAR model and solve for structural parameters\n\n        Parameters\n        ----------\n        A_guess : array_like, optional\n            A vector of starting values for all parameters to be estimated\n            in A.\n        B_guess : array_like, optional\n            A vector of starting values for all parameters to be estimated\n            in B.\n        maxlags : int\n            Maximum number of lags to check for order selection, defaults to\n            12 * (nobs/100.)**(1./4), see select_order function\n        method : {'ols'}\n            Estimation method to use\n        ic : {'aic', 'fpe', 'hqic', 'bic', None}\n            Information criterion to use for VAR order selection.\n            aic : Akaike\n            fpe : Final prediction error\n            hqic : Hannan-Quinn\n            bic : Bayesian a.k.a. Schwarz\n        verbose : bool, default False\n            Print order selection output to the screen\n        trend, str {\"c\", \"ct\", \"ctt\", \"n\"}\n            \"c\" - add constant\n            \"ct\" - constant and trend\n            \"ctt\" - constant, linear and quadratic trend\n            \"n\" - co constant, no trend\n            Note that these are prepended to the columns of the dataset.\n        s_method : {'mle'}\n            Estimation method for structural parameters\n        solver : {'nm', 'newton', 'bfgs', 'cg', 'ncg', 'powell'}\n            Solution method\n            See statsmodels.base for details\n        override : bool, default False\n            If True, returns estimates of A and B without checking\n            order or rank condition\n        maxiter : int, default 500\n            Number of iterations to perform in solution method\n        maxfun : int\n            Number of function evaluations to perform\n\n        Notes\n        -----\n        L\u00fctkepohl pp. 146-153\n        Hamilton pp. 324-336\n\n        Returns\n        -------\n        est : SVARResults\n        \"\"\"\n    lags = maxlags\n    if ic is not None:\n        selections = self.select_order(maxlags=maxlags, verbose=verbose)\n        if ic not in selections:\n            raise ValueError('%s not recognized, must be among %s' % (ic, sorted(selections)))\n        lags = selections[ic]\n        if verbose:\n            print('Using %d based on %s criterion' % (lags, ic))\n    elif lags is None:\n        lags = 1\n    self.nobs = len(self.endog) - lags\n    start_params = self._get_init_params(A_guess, B_guess)\n    return self._estimate_svar(start_params, lags, trend=trend, solver=solver, override=override, maxiter=maxiter, maxfun=maxfun)",
        "mutated": [
            "def fit(self, A_guess=None, B_guess=None, maxlags=None, method='ols', ic=None, trend='c', verbose=False, s_method='mle', solver='bfgs', override=False, maxiter=500, maxfun=500):\n    if False:\n        i = 10\n    '\\n        Fit the SVAR model and solve for structural parameters\\n\\n        Parameters\\n        ----------\\n        A_guess : array_like, optional\\n            A vector of starting values for all parameters to be estimated\\n            in A.\\n        B_guess : array_like, optional\\n            A vector of starting values for all parameters to be estimated\\n            in B.\\n        maxlags : int\\n            Maximum number of lags to check for order selection, defaults to\\n            12 * (nobs/100.)**(1./4), see select_order function\\n        method : {\\'ols\\'}\\n            Estimation method to use\\n        ic : {\\'aic\\', \\'fpe\\', \\'hqic\\', \\'bic\\', None}\\n            Information criterion to use for VAR order selection.\\n            aic : Akaike\\n            fpe : Final prediction error\\n            hqic : Hannan-Quinn\\n            bic : Bayesian a.k.a. Schwarz\\n        verbose : bool, default False\\n            Print order selection output to the screen\\n        trend, str {\"c\", \"ct\", \"ctt\", \"n\"}\\n            \"c\" - add constant\\n            \"ct\" - constant and trend\\n            \"ctt\" - constant, linear and quadratic trend\\n            \"n\" - co constant, no trend\\n            Note that these are prepended to the columns of the dataset.\\n        s_method : {\\'mle\\'}\\n            Estimation method for structural parameters\\n        solver : {\\'nm\\', \\'newton\\', \\'bfgs\\', \\'cg\\', \\'ncg\\', \\'powell\\'}\\n            Solution method\\n            See statsmodels.base for details\\n        override : bool, default False\\n            If True, returns estimates of A and B without checking\\n            order or rank condition\\n        maxiter : int, default 500\\n            Number of iterations to perform in solution method\\n        maxfun : int\\n            Number of function evaluations to perform\\n\\n        Notes\\n        -----\\n        L\u00fctkepohl pp. 146-153\\n        Hamilton pp. 324-336\\n\\n        Returns\\n        -------\\n        est : SVARResults\\n        '\n    lags = maxlags\n    if ic is not None:\n        selections = self.select_order(maxlags=maxlags, verbose=verbose)\n        if ic not in selections:\n            raise ValueError('%s not recognized, must be among %s' % (ic, sorted(selections)))\n        lags = selections[ic]\n        if verbose:\n            print('Using %d based on %s criterion' % (lags, ic))\n    elif lags is None:\n        lags = 1\n    self.nobs = len(self.endog) - lags\n    start_params = self._get_init_params(A_guess, B_guess)\n    return self._estimate_svar(start_params, lags, trend=trend, solver=solver, override=override, maxiter=maxiter, maxfun=maxfun)",
            "def fit(self, A_guess=None, B_guess=None, maxlags=None, method='ols', ic=None, trend='c', verbose=False, s_method='mle', solver='bfgs', override=False, maxiter=500, maxfun=500):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Fit the SVAR model and solve for structural parameters\\n\\n        Parameters\\n        ----------\\n        A_guess : array_like, optional\\n            A vector of starting values for all parameters to be estimated\\n            in A.\\n        B_guess : array_like, optional\\n            A vector of starting values for all parameters to be estimated\\n            in B.\\n        maxlags : int\\n            Maximum number of lags to check for order selection, defaults to\\n            12 * (nobs/100.)**(1./4), see select_order function\\n        method : {\\'ols\\'}\\n            Estimation method to use\\n        ic : {\\'aic\\', \\'fpe\\', \\'hqic\\', \\'bic\\', None}\\n            Information criterion to use for VAR order selection.\\n            aic : Akaike\\n            fpe : Final prediction error\\n            hqic : Hannan-Quinn\\n            bic : Bayesian a.k.a. Schwarz\\n        verbose : bool, default False\\n            Print order selection output to the screen\\n        trend, str {\"c\", \"ct\", \"ctt\", \"n\"}\\n            \"c\" - add constant\\n            \"ct\" - constant and trend\\n            \"ctt\" - constant, linear and quadratic trend\\n            \"n\" - co constant, no trend\\n            Note that these are prepended to the columns of the dataset.\\n        s_method : {\\'mle\\'}\\n            Estimation method for structural parameters\\n        solver : {\\'nm\\', \\'newton\\', \\'bfgs\\', \\'cg\\', \\'ncg\\', \\'powell\\'}\\n            Solution method\\n            See statsmodels.base for details\\n        override : bool, default False\\n            If True, returns estimates of A and B without checking\\n            order or rank condition\\n        maxiter : int, default 500\\n            Number of iterations to perform in solution method\\n        maxfun : int\\n            Number of function evaluations to perform\\n\\n        Notes\\n        -----\\n        L\u00fctkepohl pp. 146-153\\n        Hamilton pp. 324-336\\n\\n        Returns\\n        -------\\n        est : SVARResults\\n        '\n    lags = maxlags\n    if ic is not None:\n        selections = self.select_order(maxlags=maxlags, verbose=verbose)\n        if ic not in selections:\n            raise ValueError('%s not recognized, must be among %s' % (ic, sorted(selections)))\n        lags = selections[ic]\n        if verbose:\n            print('Using %d based on %s criterion' % (lags, ic))\n    elif lags is None:\n        lags = 1\n    self.nobs = len(self.endog) - lags\n    start_params = self._get_init_params(A_guess, B_guess)\n    return self._estimate_svar(start_params, lags, trend=trend, solver=solver, override=override, maxiter=maxiter, maxfun=maxfun)",
            "def fit(self, A_guess=None, B_guess=None, maxlags=None, method='ols', ic=None, trend='c', verbose=False, s_method='mle', solver='bfgs', override=False, maxiter=500, maxfun=500):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Fit the SVAR model and solve for structural parameters\\n\\n        Parameters\\n        ----------\\n        A_guess : array_like, optional\\n            A vector of starting values for all parameters to be estimated\\n            in A.\\n        B_guess : array_like, optional\\n            A vector of starting values for all parameters to be estimated\\n            in B.\\n        maxlags : int\\n            Maximum number of lags to check for order selection, defaults to\\n            12 * (nobs/100.)**(1./4), see select_order function\\n        method : {\\'ols\\'}\\n            Estimation method to use\\n        ic : {\\'aic\\', \\'fpe\\', \\'hqic\\', \\'bic\\', None}\\n            Information criterion to use for VAR order selection.\\n            aic : Akaike\\n            fpe : Final prediction error\\n            hqic : Hannan-Quinn\\n            bic : Bayesian a.k.a. Schwarz\\n        verbose : bool, default False\\n            Print order selection output to the screen\\n        trend, str {\"c\", \"ct\", \"ctt\", \"n\"}\\n            \"c\" - add constant\\n            \"ct\" - constant and trend\\n            \"ctt\" - constant, linear and quadratic trend\\n            \"n\" - co constant, no trend\\n            Note that these are prepended to the columns of the dataset.\\n        s_method : {\\'mle\\'}\\n            Estimation method for structural parameters\\n        solver : {\\'nm\\', \\'newton\\', \\'bfgs\\', \\'cg\\', \\'ncg\\', \\'powell\\'}\\n            Solution method\\n            See statsmodels.base for details\\n        override : bool, default False\\n            If True, returns estimates of A and B without checking\\n            order or rank condition\\n        maxiter : int, default 500\\n            Number of iterations to perform in solution method\\n        maxfun : int\\n            Number of function evaluations to perform\\n\\n        Notes\\n        -----\\n        L\u00fctkepohl pp. 146-153\\n        Hamilton pp. 324-336\\n\\n        Returns\\n        -------\\n        est : SVARResults\\n        '\n    lags = maxlags\n    if ic is not None:\n        selections = self.select_order(maxlags=maxlags, verbose=verbose)\n        if ic not in selections:\n            raise ValueError('%s not recognized, must be among %s' % (ic, sorted(selections)))\n        lags = selections[ic]\n        if verbose:\n            print('Using %d based on %s criterion' % (lags, ic))\n    elif lags is None:\n        lags = 1\n    self.nobs = len(self.endog) - lags\n    start_params = self._get_init_params(A_guess, B_guess)\n    return self._estimate_svar(start_params, lags, trend=trend, solver=solver, override=override, maxiter=maxiter, maxfun=maxfun)",
            "def fit(self, A_guess=None, B_guess=None, maxlags=None, method='ols', ic=None, trend='c', verbose=False, s_method='mle', solver='bfgs', override=False, maxiter=500, maxfun=500):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Fit the SVAR model and solve for structural parameters\\n\\n        Parameters\\n        ----------\\n        A_guess : array_like, optional\\n            A vector of starting values for all parameters to be estimated\\n            in A.\\n        B_guess : array_like, optional\\n            A vector of starting values for all parameters to be estimated\\n            in B.\\n        maxlags : int\\n            Maximum number of lags to check for order selection, defaults to\\n            12 * (nobs/100.)**(1./4), see select_order function\\n        method : {\\'ols\\'}\\n            Estimation method to use\\n        ic : {\\'aic\\', \\'fpe\\', \\'hqic\\', \\'bic\\', None}\\n            Information criterion to use for VAR order selection.\\n            aic : Akaike\\n            fpe : Final prediction error\\n            hqic : Hannan-Quinn\\n            bic : Bayesian a.k.a. Schwarz\\n        verbose : bool, default False\\n            Print order selection output to the screen\\n        trend, str {\"c\", \"ct\", \"ctt\", \"n\"}\\n            \"c\" - add constant\\n            \"ct\" - constant and trend\\n            \"ctt\" - constant, linear and quadratic trend\\n            \"n\" - co constant, no trend\\n            Note that these are prepended to the columns of the dataset.\\n        s_method : {\\'mle\\'}\\n            Estimation method for structural parameters\\n        solver : {\\'nm\\', \\'newton\\', \\'bfgs\\', \\'cg\\', \\'ncg\\', \\'powell\\'}\\n            Solution method\\n            See statsmodels.base for details\\n        override : bool, default False\\n            If True, returns estimates of A and B without checking\\n            order or rank condition\\n        maxiter : int, default 500\\n            Number of iterations to perform in solution method\\n        maxfun : int\\n            Number of function evaluations to perform\\n\\n        Notes\\n        -----\\n        L\u00fctkepohl pp. 146-153\\n        Hamilton pp. 324-336\\n\\n        Returns\\n        -------\\n        est : SVARResults\\n        '\n    lags = maxlags\n    if ic is not None:\n        selections = self.select_order(maxlags=maxlags, verbose=verbose)\n        if ic not in selections:\n            raise ValueError('%s not recognized, must be among %s' % (ic, sorted(selections)))\n        lags = selections[ic]\n        if verbose:\n            print('Using %d based on %s criterion' % (lags, ic))\n    elif lags is None:\n        lags = 1\n    self.nobs = len(self.endog) - lags\n    start_params = self._get_init_params(A_guess, B_guess)\n    return self._estimate_svar(start_params, lags, trend=trend, solver=solver, override=override, maxiter=maxiter, maxfun=maxfun)",
            "def fit(self, A_guess=None, B_guess=None, maxlags=None, method='ols', ic=None, trend='c', verbose=False, s_method='mle', solver='bfgs', override=False, maxiter=500, maxfun=500):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Fit the SVAR model and solve for structural parameters\\n\\n        Parameters\\n        ----------\\n        A_guess : array_like, optional\\n            A vector of starting values for all parameters to be estimated\\n            in A.\\n        B_guess : array_like, optional\\n            A vector of starting values for all parameters to be estimated\\n            in B.\\n        maxlags : int\\n            Maximum number of lags to check for order selection, defaults to\\n            12 * (nobs/100.)**(1./4), see select_order function\\n        method : {\\'ols\\'}\\n            Estimation method to use\\n        ic : {\\'aic\\', \\'fpe\\', \\'hqic\\', \\'bic\\', None}\\n            Information criterion to use for VAR order selection.\\n            aic : Akaike\\n            fpe : Final prediction error\\n            hqic : Hannan-Quinn\\n            bic : Bayesian a.k.a. Schwarz\\n        verbose : bool, default False\\n            Print order selection output to the screen\\n        trend, str {\"c\", \"ct\", \"ctt\", \"n\"}\\n            \"c\" - add constant\\n            \"ct\" - constant and trend\\n            \"ctt\" - constant, linear and quadratic trend\\n            \"n\" - co constant, no trend\\n            Note that these are prepended to the columns of the dataset.\\n        s_method : {\\'mle\\'}\\n            Estimation method for structural parameters\\n        solver : {\\'nm\\', \\'newton\\', \\'bfgs\\', \\'cg\\', \\'ncg\\', \\'powell\\'}\\n            Solution method\\n            See statsmodels.base for details\\n        override : bool, default False\\n            If True, returns estimates of A and B without checking\\n            order or rank condition\\n        maxiter : int, default 500\\n            Number of iterations to perform in solution method\\n        maxfun : int\\n            Number of function evaluations to perform\\n\\n        Notes\\n        -----\\n        L\u00fctkepohl pp. 146-153\\n        Hamilton pp. 324-336\\n\\n        Returns\\n        -------\\n        est : SVARResults\\n        '\n    lags = maxlags\n    if ic is not None:\n        selections = self.select_order(maxlags=maxlags, verbose=verbose)\n        if ic not in selections:\n            raise ValueError('%s not recognized, must be among %s' % (ic, sorted(selections)))\n        lags = selections[ic]\n        if verbose:\n            print('Using %d based on %s criterion' % (lags, ic))\n    elif lags is None:\n        lags = 1\n    self.nobs = len(self.endog) - lags\n    start_params = self._get_init_params(A_guess, B_guess)\n    return self._estimate_svar(start_params, lags, trend=trend, solver=solver, override=override, maxiter=maxiter, maxfun=maxfun)"
        ]
    },
    {
        "func_name": "_get_init_params",
        "original": "def _get_init_params(self, A_guess, B_guess):\n    \"\"\"\n        Returns either the given starting or .1 if none are given.\n        \"\"\"\n    var_type = self.svar_type.lower()\n    n_masked_a = self.A_mask.sum()\n    if var_type in ['ab', 'a']:\n        if A_guess is None:\n            A_guess = np.array([0.1] * n_masked_a)\n        elif len(A_guess) != n_masked_a:\n            msg = 'len(A_guess) = %s, there are %s parameters in A'\n            raise ValueError(msg % (len(A_guess), n_masked_a))\n    else:\n        A_guess = []\n    n_masked_b = self.B_mask.sum()\n    if var_type in ['ab', 'b']:\n        if B_guess is None:\n            B_guess = np.array([0.1] * n_masked_b)\n        elif len(B_guess) != n_masked_b:\n            msg = 'len(B_guess) = %s, there are %s parameters in B'\n            raise ValueError(msg % (len(B_guess), n_masked_b))\n    else:\n        B_guess = []\n    return np.r_[A_guess, B_guess]",
        "mutated": [
            "def _get_init_params(self, A_guess, B_guess):\n    if False:\n        i = 10\n    '\\n        Returns either the given starting or .1 if none are given.\\n        '\n    var_type = self.svar_type.lower()\n    n_masked_a = self.A_mask.sum()\n    if var_type in ['ab', 'a']:\n        if A_guess is None:\n            A_guess = np.array([0.1] * n_masked_a)\n        elif len(A_guess) != n_masked_a:\n            msg = 'len(A_guess) = %s, there are %s parameters in A'\n            raise ValueError(msg % (len(A_guess), n_masked_a))\n    else:\n        A_guess = []\n    n_masked_b = self.B_mask.sum()\n    if var_type in ['ab', 'b']:\n        if B_guess is None:\n            B_guess = np.array([0.1] * n_masked_b)\n        elif len(B_guess) != n_masked_b:\n            msg = 'len(B_guess) = %s, there are %s parameters in B'\n            raise ValueError(msg % (len(B_guess), n_masked_b))\n    else:\n        B_guess = []\n    return np.r_[A_guess, B_guess]",
            "def _get_init_params(self, A_guess, B_guess):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns either the given starting or .1 if none are given.\\n        '\n    var_type = self.svar_type.lower()\n    n_masked_a = self.A_mask.sum()\n    if var_type in ['ab', 'a']:\n        if A_guess is None:\n            A_guess = np.array([0.1] * n_masked_a)\n        elif len(A_guess) != n_masked_a:\n            msg = 'len(A_guess) = %s, there are %s parameters in A'\n            raise ValueError(msg % (len(A_guess), n_masked_a))\n    else:\n        A_guess = []\n    n_masked_b = self.B_mask.sum()\n    if var_type in ['ab', 'b']:\n        if B_guess is None:\n            B_guess = np.array([0.1] * n_masked_b)\n        elif len(B_guess) != n_masked_b:\n            msg = 'len(B_guess) = %s, there are %s parameters in B'\n            raise ValueError(msg % (len(B_guess), n_masked_b))\n    else:\n        B_guess = []\n    return np.r_[A_guess, B_guess]",
            "def _get_init_params(self, A_guess, B_guess):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns either the given starting or .1 if none are given.\\n        '\n    var_type = self.svar_type.lower()\n    n_masked_a = self.A_mask.sum()\n    if var_type in ['ab', 'a']:\n        if A_guess is None:\n            A_guess = np.array([0.1] * n_masked_a)\n        elif len(A_guess) != n_masked_a:\n            msg = 'len(A_guess) = %s, there are %s parameters in A'\n            raise ValueError(msg % (len(A_guess), n_masked_a))\n    else:\n        A_guess = []\n    n_masked_b = self.B_mask.sum()\n    if var_type in ['ab', 'b']:\n        if B_guess is None:\n            B_guess = np.array([0.1] * n_masked_b)\n        elif len(B_guess) != n_masked_b:\n            msg = 'len(B_guess) = %s, there are %s parameters in B'\n            raise ValueError(msg % (len(B_guess), n_masked_b))\n    else:\n        B_guess = []\n    return np.r_[A_guess, B_guess]",
            "def _get_init_params(self, A_guess, B_guess):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns either the given starting or .1 if none are given.\\n        '\n    var_type = self.svar_type.lower()\n    n_masked_a = self.A_mask.sum()\n    if var_type in ['ab', 'a']:\n        if A_guess is None:\n            A_guess = np.array([0.1] * n_masked_a)\n        elif len(A_guess) != n_masked_a:\n            msg = 'len(A_guess) = %s, there are %s parameters in A'\n            raise ValueError(msg % (len(A_guess), n_masked_a))\n    else:\n        A_guess = []\n    n_masked_b = self.B_mask.sum()\n    if var_type in ['ab', 'b']:\n        if B_guess is None:\n            B_guess = np.array([0.1] * n_masked_b)\n        elif len(B_guess) != n_masked_b:\n            msg = 'len(B_guess) = %s, there are %s parameters in B'\n            raise ValueError(msg % (len(B_guess), n_masked_b))\n    else:\n        B_guess = []\n    return np.r_[A_guess, B_guess]",
            "def _get_init_params(self, A_guess, B_guess):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns either the given starting or .1 if none are given.\\n        '\n    var_type = self.svar_type.lower()\n    n_masked_a = self.A_mask.sum()\n    if var_type in ['ab', 'a']:\n        if A_guess is None:\n            A_guess = np.array([0.1] * n_masked_a)\n        elif len(A_guess) != n_masked_a:\n            msg = 'len(A_guess) = %s, there are %s parameters in A'\n            raise ValueError(msg % (len(A_guess), n_masked_a))\n    else:\n        A_guess = []\n    n_masked_b = self.B_mask.sum()\n    if var_type in ['ab', 'b']:\n        if B_guess is None:\n            B_guess = np.array([0.1] * n_masked_b)\n        elif len(B_guess) != n_masked_b:\n            msg = 'len(B_guess) = %s, there are %s parameters in B'\n            raise ValueError(msg % (len(B_guess), n_masked_b))\n    else:\n        B_guess = []\n    return np.r_[A_guess, B_guess]"
        ]
    },
    {
        "func_name": "_estimate_svar",
        "original": "def _estimate_svar(self, start_params, lags, maxiter, maxfun, trend='c', solver='nm', override=False):\n    \"\"\"\n        lags : int\n        trend : {str, None}\n            As per above\n        \"\"\"\n    k_trend = util.get_trendorder(trend)\n    y = self.endog\n    z = util.get_var_endog(y, lags, trend=trend, has_constant='raise')\n    y_sample = y[lags:]\n    var_params = np.linalg.lstsq(z, y_sample, rcond=-1)[0]\n    resid = y_sample - np.dot(z, var_params)\n    avobs = len(y_sample)\n    df_resid = avobs - (self.neqs * lags + k_trend)\n    sse = np.dot(resid.T, resid)\n    omega = sse / df_resid\n    self.sigma_u = omega\n    (A, B) = self._solve_AB(start_params, override=override, solver=solver, maxiter=maxiter)\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    return SVARResults(y, z, var_params, omega, lags, names=self.endog_names, trend=trend, dates=self.data.dates, model=self, A=A, B=B, A_mask=A_mask, B_mask=B_mask)",
        "mutated": [
            "def _estimate_svar(self, start_params, lags, maxiter, maxfun, trend='c', solver='nm', override=False):\n    if False:\n        i = 10\n    '\\n        lags : int\\n        trend : {str, None}\\n            As per above\\n        '\n    k_trend = util.get_trendorder(trend)\n    y = self.endog\n    z = util.get_var_endog(y, lags, trend=trend, has_constant='raise')\n    y_sample = y[lags:]\n    var_params = np.linalg.lstsq(z, y_sample, rcond=-1)[0]\n    resid = y_sample - np.dot(z, var_params)\n    avobs = len(y_sample)\n    df_resid = avobs - (self.neqs * lags + k_trend)\n    sse = np.dot(resid.T, resid)\n    omega = sse / df_resid\n    self.sigma_u = omega\n    (A, B) = self._solve_AB(start_params, override=override, solver=solver, maxiter=maxiter)\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    return SVARResults(y, z, var_params, omega, lags, names=self.endog_names, trend=trend, dates=self.data.dates, model=self, A=A, B=B, A_mask=A_mask, B_mask=B_mask)",
            "def _estimate_svar(self, start_params, lags, maxiter, maxfun, trend='c', solver='nm', override=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        lags : int\\n        trend : {str, None}\\n            As per above\\n        '\n    k_trend = util.get_trendorder(trend)\n    y = self.endog\n    z = util.get_var_endog(y, lags, trend=trend, has_constant='raise')\n    y_sample = y[lags:]\n    var_params = np.linalg.lstsq(z, y_sample, rcond=-1)[0]\n    resid = y_sample - np.dot(z, var_params)\n    avobs = len(y_sample)\n    df_resid = avobs - (self.neqs * lags + k_trend)\n    sse = np.dot(resid.T, resid)\n    omega = sse / df_resid\n    self.sigma_u = omega\n    (A, B) = self._solve_AB(start_params, override=override, solver=solver, maxiter=maxiter)\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    return SVARResults(y, z, var_params, omega, lags, names=self.endog_names, trend=trend, dates=self.data.dates, model=self, A=A, B=B, A_mask=A_mask, B_mask=B_mask)",
            "def _estimate_svar(self, start_params, lags, maxiter, maxfun, trend='c', solver='nm', override=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        lags : int\\n        trend : {str, None}\\n            As per above\\n        '\n    k_trend = util.get_trendorder(trend)\n    y = self.endog\n    z = util.get_var_endog(y, lags, trend=trend, has_constant='raise')\n    y_sample = y[lags:]\n    var_params = np.linalg.lstsq(z, y_sample, rcond=-1)[0]\n    resid = y_sample - np.dot(z, var_params)\n    avobs = len(y_sample)\n    df_resid = avobs - (self.neqs * lags + k_trend)\n    sse = np.dot(resid.T, resid)\n    omega = sse / df_resid\n    self.sigma_u = omega\n    (A, B) = self._solve_AB(start_params, override=override, solver=solver, maxiter=maxiter)\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    return SVARResults(y, z, var_params, omega, lags, names=self.endog_names, trend=trend, dates=self.data.dates, model=self, A=A, B=B, A_mask=A_mask, B_mask=B_mask)",
            "def _estimate_svar(self, start_params, lags, maxiter, maxfun, trend='c', solver='nm', override=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        lags : int\\n        trend : {str, None}\\n            As per above\\n        '\n    k_trend = util.get_trendorder(trend)\n    y = self.endog\n    z = util.get_var_endog(y, lags, trend=trend, has_constant='raise')\n    y_sample = y[lags:]\n    var_params = np.linalg.lstsq(z, y_sample, rcond=-1)[0]\n    resid = y_sample - np.dot(z, var_params)\n    avobs = len(y_sample)\n    df_resid = avobs - (self.neqs * lags + k_trend)\n    sse = np.dot(resid.T, resid)\n    omega = sse / df_resid\n    self.sigma_u = omega\n    (A, B) = self._solve_AB(start_params, override=override, solver=solver, maxiter=maxiter)\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    return SVARResults(y, z, var_params, omega, lags, names=self.endog_names, trend=trend, dates=self.data.dates, model=self, A=A, B=B, A_mask=A_mask, B_mask=B_mask)",
            "def _estimate_svar(self, start_params, lags, maxiter, maxfun, trend='c', solver='nm', override=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        lags : int\\n        trend : {str, None}\\n            As per above\\n        '\n    k_trend = util.get_trendorder(trend)\n    y = self.endog\n    z = util.get_var_endog(y, lags, trend=trend, has_constant='raise')\n    y_sample = y[lags:]\n    var_params = np.linalg.lstsq(z, y_sample, rcond=-1)[0]\n    resid = y_sample - np.dot(z, var_params)\n    avobs = len(y_sample)\n    df_resid = avobs - (self.neqs * lags + k_trend)\n    sse = np.dot(resid.T, resid)\n    omega = sse / df_resid\n    self.sigma_u = omega\n    (A, B) = self._solve_AB(start_params, override=override, solver=solver, maxiter=maxiter)\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    return SVARResults(y, z, var_params, omega, lags, names=self.endog_names, trend=trend, dates=self.data.dates, model=self, A=A, B=B, A_mask=A_mask, B_mask=B_mask)"
        ]
    },
    {
        "func_name": "loglike",
        "original": "def loglike(self, params):\n    \"\"\"\n        Loglikelihood for SVAR model\n\n        Notes\n        -----\n        This method assumes that the autoregressive parameters are\n        first estimated, then likelihood with structural parameters\n        is estimated\n        \"\"\"\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_len = len(A[A_mask])\n    B_len = len(B[B_mask])\n    if A is not None:\n        A[A_mask] = params[:A_len]\n    if B is not None:\n        B[B_mask] = params[A_len:A_len + B_len]\n    nobs = self.nobs\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    W = np.dot(npl.inv(B), A)\n    trc_in = np.dot(np.dot(W.T, W), sigma_u)\n    (sign, b_logdet) = slogdet(B ** 2)\n    b_slogdet = sign * b_logdet\n    likl = -nobs / 2.0 * (neqs * np.log(2 * np.pi) - np.log(npl.det(A) ** 2) + b_slogdet + np.trace(trc_in))\n    return likl",
        "mutated": [
            "def loglike(self, params):\n    if False:\n        i = 10\n    '\\n        Loglikelihood for SVAR model\\n\\n        Notes\\n        -----\\n        This method assumes that the autoregressive parameters are\\n        first estimated, then likelihood with structural parameters\\n        is estimated\\n        '\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_len = len(A[A_mask])\n    B_len = len(B[B_mask])\n    if A is not None:\n        A[A_mask] = params[:A_len]\n    if B is not None:\n        B[B_mask] = params[A_len:A_len + B_len]\n    nobs = self.nobs\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    W = np.dot(npl.inv(B), A)\n    trc_in = np.dot(np.dot(W.T, W), sigma_u)\n    (sign, b_logdet) = slogdet(B ** 2)\n    b_slogdet = sign * b_logdet\n    likl = -nobs / 2.0 * (neqs * np.log(2 * np.pi) - np.log(npl.det(A) ** 2) + b_slogdet + np.trace(trc_in))\n    return likl",
            "def loglike(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Loglikelihood for SVAR model\\n\\n        Notes\\n        -----\\n        This method assumes that the autoregressive parameters are\\n        first estimated, then likelihood with structural parameters\\n        is estimated\\n        '\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_len = len(A[A_mask])\n    B_len = len(B[B_mask])\n    if A is not None:\n        A[A_mask] = params[:A_len]\n    if B is not None:\n        B[B_mask] = params[A_len:A_len + B_len]\n    nobs = self.nobs\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    W = np.dot(npl.inv(B), A)\n    trc_in = np.dot(np.dot(W.T, W), sigma_u)\n    (sign, b_logdet) = slogdet(B ** 2)\n    b_slogdet = sign * b_logdet\n    likl = -nobs / 2.0 * (neqs * np.log(2 * np.pi) - np.log(npl.det(A) ** 2) + b_slogdet + np.trace(trc_in))\n    return likl",
            "def loglike(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Loglikelihood for SVAR model\\n\\n        Notes\\n        -----\\n        This method assumes that the autoregressive parameters are\\n        first estimated, then likelihood with structural parameters\\n        is estimated\\n        '\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_len = len(A[A_mask])\n    B_len = len(B[B_mask])\n    if A is not None:\n        A[A_mask] = params[:A_len]\n    if B is not None:\n        B[B_mask] = params[A_len:A_len + B_len]\n    nobs = self.nobs\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    W = np.dot(npl.inv(B), A)\n    trc_in = np.dot(np.dot(W.T, W), sigma_u)\n    (sign, b_logdet) = slogdet(B ** 2)\n    b_slogdet = sign * b_logdet\n    likl = -nobs / 2.0 * (neqs * np.log(2 * np.pi) - np.log(npl.det(A) ** 2) + b_slogdet + np.trace(trc_in))\n    return likl",
            "def loglike(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Loglikelihood for SVAR model\\n\\n        Notes\\n        -----\\n        This method assumes that the autoregressive parameters are\\n        first estimated, then likelihood with structural parameters\\n        is estimated\\n        '\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_len = len(A[A_mask])\n    B_len = len(B[B_mask])\n    if A is not None:\n        A[A_mask] = params[:A_len]\n    if B is not None:\n        B[B_mask] = params[A_len:A_len + B_len]\n    nobs = self.nobs\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    W = np.dot(npl.inv(B), A)\n    trc_in = np.dot(np.dot(W.T, W), sigma_u)\n    (sign, b_logdet) = slogdet(B ** 2)\n    b_slogdet = sign * b_logdet\n    likl = -nobs / 2.0 * (neqs * np.log(2 * np.pi) - np.log(npl.det(A) ** 2) + b_slogdet + np.trace(trc_in))\n    return likl",
            "def loglike(self, params):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Loglikelihood for SVAR model\\n\\n        Notes\\n        -----\\n        This method assumes that the autoregressive parameters are\\n        first estimated, then likelihood with structural parameters\\n        is estimated\\n        '\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_len = len(A[A_mask])\n    B_len = len(B[B_mask])\n    if A is not None:\n        A[A_mask] = params[:A_len]\n    if B is not None:\n        B[B_mask] = params[A_len:A_len + B_len]\n    nobs = self.nobs\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    W = np.dot(npl.inv(B), A)\n    trc_in = np.dot(np.dot(W.T, W), sigma_u)\n    (sign, b_logdet) = slogdet(B ** 2)\n    b_slogdet = sign * b_logdet\n    likl = -nobs / 2.0 * (neqs * np.log(2 * np.pi) - np.log(npl.det(A) ** 2) + b_slogdet + np.trace(trc_in))\n    return likl"
        ]
    },
    {
        "func_name": "score",
        "original": "def score(self, AB_mask):\n    \"\"\"\n        Return the gradient of the loglike at AB_mask.\n\n        Parameters\n        ----------\n        AB_mask : unknown values of A and B matrix concatenated\n\n        Notes\n        -----\n        Return numerical gradient\n        \"\"\"\n    loglike = self.loglike\n    return approx_fprime(AB_mask, loglike, epsilon=1e-08)",
        "mutated": [
            "def score(self, AB_mask):\n    if False:\n        i = 10\n    '\\n        Return the gradient of the loglike at AB_mask.\\n\\n        Parameters\\n        ----------\\n        AB_mask : unknown values of A and B matrix concatenated\\n\\n        Notes\\n        -----\\n        Return numerical gradient\\n        '\n    loglike = self.loglike\n    return approx_fprime(AB_mask, loglike, epsilon=1e-08)",
            "def score(self, AB_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Return the gradient of the loglike at AB_mask.\\n\\n        Parameters\\n        ----------\\n        AB_mask : unknown values of A and B matrix concatenated\\n\\n        Notes\\n        -----\\n        Return numerical gradient\\n        '\n    loglike = self.loglike\n    return approx_fprime(AB_mask, loglike, epsilon=1e-08)",
            "def score(self, AB_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Return the gradient of the loglike at AB_mask.\\n\\n        Parameters\\n        ----------\\n        AB_mask : unknown values of A and B matrix concatenated\\n\\n        Notes\\n        -----\\n        Return numerical gradient\\n        '\n    loglike = self.loglike\n    return approx_fprime(AB_mask, loglike, epsilon=1e-08)",
            "def score(self, AB_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Return the gradient of the loglike at AB_mask.\\n\\n        Parameters\\n        ----------\\n        AB_mask : unknown values of A and B matrix concatenated\\n\\n        Notes\\n        -----\\n        Return numerical gradient\\n        '\n    loglike = self.loglike\n    return approx_fprime(AB_mask, loglike, epsilon=1e-08)",
            "def score(self, AB_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Return the gradient of the loglike at AB_mask.\\n\\n        Parameters\\n        ----------\\n        AB_mask : unknown values of A and B matrix concatenated\\n\\n        Notes\\n        -----\\n        Return numerical gradient\\n        '\n    loglike = self.loglike\n    return approx_fprime(AB_mask, loglike, epsilon=1e-08)"
        ]
    },
    {
        "func_name": "hessian",
        "original": "def hessian(self, AB_mask):\n    \"\"\"\n        Returns numerical hessian.\n        \"\"\"\n    loglike = self.loglike\n    return approx_hess(AB_mask, loglike)",
        "mutated": [
            "def hessian(self, AB_mask):\n    if False:\n        i = 10\n    '\\n        Returns numerical hessian.\\n        '\n    loglike = self.loglike\n    return approx_hess(AB_mask, loglike)",
            "def hessian(self, AB_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Returns numerical hessian.\\n        '\n    loglike = self.loglike\n    return approx_hess(AB_mask, loglike)",
            "def hessian(self, AB_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Returns numerical hessian.\\n        '\n    loglike = self.loglike\n    return approx_hess(AB_mask, loglike)",
            "def hessian(self, AB_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Returns numerical hessian.\\n        '\n    loglike = self.loglike\n    return approx_hess(AB_mask, loglike)",
            "def hessian(self, AB_mask):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Returns numerical hessian.\\n        '\n    loglike = self.loglike\n    return approx_hess(AB_mask, loglike)"
        ]
    },
    {
        "func_name": "_solve_AB",
        "original": "def _solve_AB(self, start_params, maxiter, override=False, solver='bfgs'):\n    \"\"\"\n        Solves for MLE estimate of structural parameters\n\n        Parameters\n        ----------\n\n        override : bool, default False\n            If True, returns estimates of A and B without checking\n            order or rank condition\n        solver : str or None, optional\n            Solver to be used. The default is 'nm' (Nelder-Mead). Other\n            choices are 'bfgs', 'newton' (Newton-Raphson), 'cg'\n            conjugate, 'ncg' (non-conjugate gradient), and 'powell'.\n        maxiter : int, optional\n            The maximum number of iterations. Default is 500.\n\n        Returns\n        -------\n        A_solve, B_solve: ML solutions for A, B matrices\n        \"\"\"\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A = self.A\n    B = self.B\n    A_len = len(A[A_mask])\n    A[A_mask] = start_params[:A_len]\n    B[B_mask] = start_params[A_len:]\n    if not override:\n        J = self._compute_J(A, B)\n        self.check_order(J)\n        self.check_rank(J)\n    else:\n        print('Order/rank conditions have not been checked')\n    retvals = super().fit(start_params=start_params, method=solver, maxiter=maxiter, gtol=1e-20, disp=False).params\n    A[A_mask] = retvals[:A_len]\n    B[B_mask] = retvals[A_len:]\n    return (A, B)",
        "mutated": [
            "def _solve_AB(self, start_params, maxiter, override=False, solver='bfgs'):\n    if False:\n        i = 10\n    \"\\n        Solves for MLE estimate of structural parameters\\n\\n        Parameters\\n        ----------\\n\\n        override : bool, default False\\n            If True, returns estimates of A and B without checking\\n            order or rank condition\\n        solver : str or None, optional\\n            Solver to be used. The default is 'nm' (Nelder-Mead). Other\\n            choices are 'bfgs', 'newton' (Newton-Raphson), 'cg'\\n            conjugate, 'ncg' (non-conjugate gradient), and 'powell'.\\n        maxiter : int, optional\\n            The maximum number of iterations. Default is 500.\\n\\n        Returns\\n        -------\\n        A_solve, B_solve: ML solutions for A, B matrices\\n        \"\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A = self.A\n    B = self.B\n    A_len = len(A[A_mask])\n    A[A_mask] = start_params[:A_len]\n    B[B_mask] = start_params[A_len:]\n    if not override:\n        J = self._compute_J(A, B)\n        self.check_order(J)\n        self.check_rank(J)\n    else:\n        print('Order/rank conditions have not been checked')\n    retvals = super().fit(start_params=start_params, method=solver, maxiter=maxiter, gtol=1e-20, disp=False).params\n    A[A_mask] = retvals[:A_len]\n    B[B_mask] = retvals[A_len:]\n    return (A, B)",
            "def _solve_AB(self, start_params, maxiter, override=False, solver='bfgs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n        Solves for MLE estimate of structural parameters\\n\\n        Parameters\\n        ----------\\n\\n        override : bool, default False\\n            If True, returns estimates of A and B without checking\\n            order or rank condition\\n        solver : str or None, optional\\n            Solver to be used. The default is 'nm' (Nelder-Mead). Other\\n            choices are 'bfgs', 'newton' (Newton-Raphson), 'cg'\\n            conjugate, 'ncg' (non-conjugate gradient), and 'powell'.\\n        maxiter : int, optional\\n            The maximum number of iterations. Default is 500.\\n\\n        Returns\\n        -------\\n        A_solve, B_solve: ML solutions for A, B matrices\\n        \"\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A = self.A\n    B = self.B\n    A_len = len(A[A_mask])\n    A[A_mask] = start_params[:A_len]\n    B[B_mask] = start_params[A_len:]\n    if not override:\n        J = self._compute_J(A, B)\n        self.check_order(J)\n        self.check_rank(J)\n    else:\n        print('Order/rank conditions have not been checked')\n    retvals = super().fit(start_params=start_params, method=solver, maxiter=maxiter, gtol=1e-20, disp=False).params\n    A[A_mask] = retvals[:A_len]\n    B[B_mask] = retvals[A_len:]\n    return (A, B)",
            "def _solve_AB(self, start_params, maxiter, override=False, solver='bfgs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n        Solves for MLE estimate of structural parameters\\n\\n        Parameters\\n        ----------\\n\\n        override : bool, default False\\n            If True, returns estimates of A and B without checking\\n            order or rank condition\\n        solver : str or None, optional\\n            Solver to be used. The default is 'nm' (Nelder-Mead). Other\\n            choices are 'bfgs', 'newton' (Newton-Raphson), 'cg'\\n            conjugate, 'ncg' (non-conjugate gradient), and 'powell'.\\n        maxiter : int, optional\\n            The maximum number of iterations. Default is 500.\\n\\n        Returns\\n        -------\\n        A_solve, B_solve: ML solutions for A, B matrices\\n        \"\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A = self.A\n    B = self.B\n    A_len = len(A[A_mask])\n    A[A_mask] = start_params[:A_len]\n    B[B_mask] = start_params[A_len:]\n    if not override:\n        J = self._compute_J(A, B)\n        self.check_order(J)\n        self.check_rank(J)\n    else:\n        print('Order/rank conditions have not been checked')\n    retvals = super().fit(start_params=start_params, method=solver, maxiter=maxiter, gtol=1e-20, disp=False).params\n    A[A_mask] = retvals[:A_len]\n    B[B_mask] = retvals[A_len:]\n    return (A, B)",
            "def _solve_AB(self, start_params, maxiter, override=False, solver='bfgs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n        Solves for MLE estimate of structural parameters\\n\\n        Parameters\\n        ----------\\n\\n        override : bool, default False\\n            If True, returns estimates of A and B without checking\\n            order or rank condition\\n        solver : str or None, optional\\n            Solver to be used. The default is 'nm' (Nelder-Mead). Other\\n            choices are 'bfgs', 'newton' (Newton-Raphson), 'cg'\\n            conjugate, 'ncg' (non-conjugate gradient), and 'powell'.\\n        maxiter : int, optional\\n            The maximum number of iterations. Default is 500.\\n\\n        Returns\\n        -------\\n        A_solve, B_solve: ML solutions for A, B matrices\\n        \"\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A = self.A\n    B = self.B\n    A_len = len(A[A_mask])\n    A[A_mask] = start_params[:A_len]\n    B[B_mask] = start_params[A_len:]\n    if not override:\n        J = self._compute_J(A, B)\n        self.check_order(J)\n        self.check_rank(J)\n    else:\n        print('Order/rank conditions have not been checked')\n    retvals = super().fit(start_params=start_params, method=solver, maxiter=maxiter, gtol=1e-20, disp=False).params\n    A[A_mask] = retvals[:A_len]\n    B[B_mask] = retvals[A_len:]\n    return (A, B)",
            "def _solve_AB(self, start_params, maxiter, override=False, solver='bfgs'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n        Solves for MLE estimate of structural parameters\\n\\n        Parameters\\n        ----------\\n\\n        override : bool, default False\\n            If True, returns estimates of A and B without checking\\n            order or rank condition\\n        solver : str or None, optional\\n            Solver to be used. The default is 'nm' (Nelder-Mead). Other\\n            choices are 'bfgs', 'newton' (Newton-Raphson), 'cg'\\n            conjugate, 'ncg' (non-conjugate gradient), and 'powell'.\\n        maxiter : int, optional\\n            The maximum number of iterations. Default is 500.\\n\\n        Returns\\n        -------\\n        A_solve, B_solve: ML solutions for A, B matrices\\n        \"\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A = self.A\n    B = self.B\n    A_len = len(A[A_mask])\n    A[A_mask] = start_params[:A_len]\n    B[B_mask] = start_params[A_len:]\n    if not override:\n        J = self._compute_J(A, B)\n        self.check_order(J)\n        self.check_rank(J)\n    else:\n        print('Order/rank conditions have not been checked')\n    retvals = super().fit(start_params=start_params, method=solver, maxiter=maxiter, gtol=1e-20, disp=False).params\n    A[A_mask] = retvals[:A_len]\n    B[B_mask] = retvals[A_len:]\n    return (A, B)"
        ]
    },
    {
        "func_name": "_compute_J",
        "original": "def _compute_J(self, A_solve, B_solve):\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    D_nT = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), neqs ** 2])\n    for j in range(neqs):\n        i = j\n        while j <= i < neqs:\n            u = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), 1])\n            u[int(j * neqs + (i + 1) - 1.0 / 2 * (j + 1) * j - 1)] = 1\n            Tij = np.zeros([neqs, neqs])\n            Tij[i, j] = 1\n            Tij[j, i] = 1\n            D_nT = D_nT + np.dot(u, Tij.ravel('F')[:, None].T)\n            i = i + 1\n    D_n = D_nT.T\n    D_pl = npl.pinv(D_n)\n    S_B = np.zeros((neqs ** 2, len(A_solve[A_mask])))\n    S_D = np.zeros((neqs ** 2, len(B_solve[B_mask])))\n    j = 0\n    j_d = 0\n    if len(A_solve[A_mask]) != 0:\n        A_vec = np.ravel(A_mask, order='F')\n        for k in range(neqs ** 2):\n            if A_vec[k]:\n                S_B[k, j] = -1\n                j += 1\n    if len(B_solve[B_mask]) != 0:\n        B_vec = np.ravel(B_mask, order='F')\n        for k in range(neqs ** 2):\n            if B_vec[k]:\n                S_D[k, j_d] = 1\n                j_d += 1\n    invA = npl.inv(A_solve)\n    J_p1i = np.dot(np.dot(D_pl, np.kron(sigma_u, invA)), S_B)\n    J_p1 = -2.0 * J_p1i\n    J_p2 = np.dot(np.dot(D_pl, np.kron(invA, invA)), S_D)\n    J = np.append(J_p1, J_p2, axis=1)\n    return J",
        "mutated": [
            "def _compute_J(self, A_solve, B_solve):\n    if False:\n        i = 10\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    D_nT = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), neqs ** 2])\n    for j in range(neqs):\n        i = j\n        while j <= i < neqs:\n            u = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), 1])\n            u[int(j * neqs + (i + 1) - 1.0 / 2 * (j + 1) * j - 1)] = 1\n            Tij = np.zeros([neqs, neqs])\n            Tij[i, j] = 1\n            Tij[j, i] = 1\n            D_nT = D_nT + np.dot(u, Tij.ravel('F')[:, None].T)\n            i = i + 1\n    D_n = D_nT.T\n    D_pl = npl.pinv(D_n)\n    S_B = np.zeros((neqs ** 2, len(A_solve[A_mask])))\n    S_D = np.zeros((neqs ** 2, len(B_solve[B_mask])))\n    j = 0\n    j_d = 0\n    if len(A_solve[A_mask]) != 0:\n        A_vec = np.ravel(A_mask, order='F')\n        for k in range(neqs ** 2):\n            if A_vec[k]:\n                S_B[k, j] = -1\n                j += 1\n    if len(B_solve[B_mask]) != 0:\n        B_vec = np.ravel(B_mask, order='F')\n        for k in range(neqs ** 2):\n            if B_vec[k]:\n                S_D[k, j_d] = 1\n                j_d += 1\n    invA = npl.inv(A_solve)\n    J_p1i = np.dot(np.dot(D_pl, np.kron(sigma_u, invA)), S_B)\n    J_p1 = -2.0 * J_p1i\n    J_p2 = np.dot(np.dot(D_pl, np.kron(invA, invA)), S_D)\n    J = np.append(J_p1, J_p2, axis=1)\n    return J",
            "def _compute_J(self, A_solve, B_solve):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    D_nT = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), neqs ** 2])\n    for j in range(neqs):\n        i = j\n        while j <= i < neqs:\n            u = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), 1])\n            u[int(j * neqs + (i + 1) - 1.0 / 2 * (j + 1) * j - 1)] = 1\n            Tij = np.zeros([neqs, neqs])\n            Tij[i, j] = 1\n            Tij[j, i] = 1\n            D_nT = D_nT + np.dot(u, Tij.ravel('F')[:, None].T)\n            i = i + 1\n    D_n = D_nT.T\n    D_pl = npl.pinv(D_n)\n    S_B = np.zeros((neqs ** 2, len(A_solve[A_mask])))\n    S_D = np.zeros((neqs ** 2, len(B_solve[B_mask])))\n    j = 0\n    j_d = 0\n    if len(A_solve[A_mask]) != 0:\n        A_vec = np.ravel(A_mask, order='F')\n        for k in range(neqs ** 2):\n            if A_vec[k]:\n                S_B[k, j] = -1\n                j += 1\n    if len(B_solve[B_mask]) != 0:\n        B_vec = np.ravel(B_mask, order='F')\n        for k in range(neqs ** 2):\n            if B_vec[k]:\n                S_D[k, j_d] = 1\n                j_d += 1\n    invA = npl.inv(A_solve)\n    J_p1i = np.dot(np.dot(D_pl, np.kron(sigma_u, invA)), S_B)\n    J_p1 = -2.0 * J_p1i\n    J_p2 = np.dot(np.dot(D_pl, np.kron(invA, invA)), S_D)\n    J = np.append(J_p1, J_p2, axis=1)\n    return J",
            "def _compute_J(self, A_solve, B_solve):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    D_nT = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), neqs ** 2])\n    for j in range(neqs):\n        i = j\n        while j <= i < neqs:\n            u = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), 1])\n            u[int(j * neqs + (i + 1) - 1.0 / 2 * (j + 1) * j - 1)] = 1\n            Tij = np.zeros([neqs, neqs])\n            Tij[i, j] = 1\n            Tij[j, i] = 1\n            D_nT = D_nT + np.dot(u, Tij.ravel('F')[:, None].T)\n            i = i + 1\n    D_n = D_nT.T\n    D_pl = npl.pinv(D_n)\n    S_B = np.zeros((neqs ** 2, len(A_solve[A_mask])))\n    S_D = np.zeros((neqs ** 2, len(B_solve[B_mask])))\n    j = 0\n    j_d = 0\n    if len(A_solve[A_mask]) != 0:\n        A_vec = np.ravel(A_mask, order='F')\n        for k in range(neqs ** 2):\n            if A_vec[k]:\n                S_B[k, j] = -1\n                j += 1\n    if len(B_solve[B_mask]) != 0:\n        B_vec = np.ravel(B_mask, order='F')\n        for k in range(neqs ** 2):\n            if B_vec[k]:\n                S_D[k, j_d] = 1\n                j_d += 1\n    invA = npl.inv(A_solve)\n    J_p1i = np.dot(np.dot(D_pl, np.kron(sigma_u, invA)), S_B)\n    J_p1 = -2.0 * J_p1i\n    J_p2 = np.dot(np.dot(D_pl, np.kron(invA, invA)), S_D)\n    J = np.append(J_p1, J_p2, axis=1)\n    return J",
            "def _compute_J(self, A_solve, B_solve):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    D_nT = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), neqs ** 2])\n    for j in range(neqs):\n        i = j\n        while j <= i < neqs:\n            u = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), 1])\n            u[int(j * neqs + (i + 1) - 1.0 / 2 * (j + 1) * j - 1)] = 1\n            Tij = np.zeros([neqs, neqs])\n            Tij[i, j] = 1\n            Tij[j, i] = 1\n            D_nT = D_nT + np.dot(u, Tij.ravel('F')[:, None].T)\n            i = i + 1\n    D_n = D_nT.T\n    D_pl = npl.pinv(D_n)\n    S_B = np.zeros((neqs ** 2, len(A_solve[A_mask])))\n    S_D = np.zeros((neqs ** 2, len(B_solve[B_mask])))\n    j = 0\n    j_d = 0\n    if len(A_solve[A_mask]) != 0:\n        A_vec = np.ravel(A_mask, order='F')\n        for k in range(neqs ** 2):\n            if A_vec[k]:\n                S_B[k, j] = -1\n                j += 1\n    if len(B_solve[B_mask]) != 0:\n        B_vec = np.ravel(B_mask, order='F')\n        for k in range(neqs ** 2):\n            if B_vec[k]:\n                S_D[k, j_d] = 1\n                j_d += 1\n    invA = npl.inv(A_solve)\n    J_p1i = np.dot(np.dot(D_pl, np.kron(sigma_u, invA)), S_B)\n    J_p1 = -2.0 * J_p1i\n    J_p2 = np.dot(np.dot(D_pl, np.kron(invA, invA)), S_D)\n    J = np.append(J_p1, J_p2, axis=1)\n    return J",
            "def _compute_J(self, A_solve, B_solve):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    neqs = self.neqs\n    sigma_u = self.sigma_u\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    D_nT = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), neqs ** 2])\n    for j in range(neqs):\n        i = j\n        while j <= i < neqs:\n            u = np.zeros([int(1.0 / 2 * neqs * (neqs + 1)), 1])\n            u[int(j * neqs + (i + 1) - 1.0 / 2 * (j + 1) * j - 1)] = 1\n            Tij = np.zeros([neqs, neqs])\n            Tij[i, j] = 1\n            Tij[j, i] = 1\n            D_nT = D_nT + np.dot(u, Tij.ravel('F')[:, None].T)\n            i = i + 1\n    D_n = D_nT.T\n    D_pl = npl.pinv(D_n)\n    S_B = np.zeros((neqs ** 2, len(A_solve[A_mask])))\n    S_D = np.zeros((neqs ** 2, len(B_solve[B_mask])))\n    j = 0\n    j_d = 0\n    if len(A_solve[A_mask]) != 0:\n        A_vec = np.ravel(A_mask, order='F')\n        for k in range(neqs ** 2):\n            if A_vec[k]:\n                S_B[k, j] = -1\n                j += 1\n    if len(B_solve[B_mask]) != 0:\n        B_vec = np.ravel(B_mask, order='F')\n        for k in range(neqs ** 2):\n            if B_vec[k]:\n                S_D[k, j_d] = 1\n                j_d += 1\n    invA = npl.inv(A_solve)\n    J_p1i = np.dot(np.dot(D_pl, np.kron(sigma_u, invA)), S_B)\n    J_p1 = -2.0 * J_p1i\n    J_p2 = np.dot(np.dot(D_pl, np.kron(invA, invA)), S_D)\n    J = np.append(J_p1, J_p2, axis=1)\n    return J"
        ]
    },
    {
        "func_name": "check_order",
        "original": "def check_order(self, J):\n    if np.size(J, axis=0) < np.size(J, axis=1):\n        raise ValueError('Order condition not met: solution may not be unique')",
        "mutated": [
            "def check_order(self, J):\n    if False:\n        i = 10\n    if np.size(J, axis=0) < np.size(J, axis=1):\n        raise ValueError('Order condition not met: solution may not be unique')",
            "def check_order(self, J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if np.size(J, axis=0) < np.size(J, axis=1):\n        raise ValueError('Order condition not met: solution may not be unique')",
            "def check_order(self, J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if np.size(J, axis=0) < np.size(J, axis=1):\n        raise ValueError('Order condition not met: solution may not be unique')",
            "def check_order(self, J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if np.size(J, axis=0) < np.size(J, axis=1):\n        raise ValueError('Order condition not met: solution may not be unique')",
            "def check_order(self, J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if np.size(J, axis=0) < np.size(J, axis=1):\n        raise ValueError('Order condition not met: solution may not be unique')"
        ]
    },
    {
        "func_name": "check_rank",
        "original": "def check_rank(self, J):\n    rank = np.linalg.matrix_rank(J)\n    if rank < np.size(J, axis=1):\n        raise ValueError('Rank condition not met: solution may not be unique.')",
        "mutated": [
            "def check_rank(self, J):\n    if False:\n        i = 10\n    rank = np.linalg.matrix_rank(J)\n    if rank < np.size(J, axis=1):\n        raise ValueError('Rank condition not met: solution may not be unique.')",
            "def check_rank(self, J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rank = np.linalg.matrix_rank(J)\n    if rank < np.size(J, axis=1):\n        raise ValueError('Rank condition not met: solution may not be unique.')",
            "def check_rank(self, J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rank = np.linalg.matrix_rank(J)\n    if rank < np.size(J, axis=1):\n        raise ValueError('Rank condition not met: solution may not be unique.')",
            "def check_rank(self, J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rank = np.linalg.matrix_rank(J)\n    if rank < np.size(J, axis=1):\n        raise ValueError('Rank condition not met: solution may not be unique.')",
            "def check_rank(self, J):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rank = np.linalg.matrix_rank(J)\n    if rank < np.size(J, axis=1):\n        raise ValueError('Rank condition not met: solution may not be unique.')"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, coefs, intercept, sigma_u, A_solve, B_solve, names=None):\n    self.k_ar = len(coefs)\n    self.neqs = coefs.shape[1]\n    self.coefs = coefs\n    self.intercept = intercept\n    self.sigma_u = sigma_u\n    self.A_solve = A_solve\n    self.B_solve = B_solve\n    self.names = names",
        "mutated": [
            "def __init__(self, coefs, intercept, sigma_u, A_solve, B_solve, names=None):\n    if False:\n        i = 10\n    self.k_ar = len(coefs)\n    self.neqs = coefs.shape[1]\n    self.coefs = coefs\n    self.intercept = intercept\n    self.sigma_u = sigma_u\n    self.A_solve = A_solve\n    self.B_solve = B_solve\n    self.names = names",
            "def __init__(self, coefs, intercept, sigma_u, A_solve, B_solve, names=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.k_ar = len(coefs)\n    self.neqs = coefs.shape[1]\n    self.coefs = coefs\n    self.intercept = intercept\n    self.sigma_u = sigma_u\n    self.A_solve = A_solve\n    self.B_solve = B_solve\n    self.names = names",
            "def __init__(self, coefs, intercept, sigma_u, A_solve, B_solve, names=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.k_ar = len(coefs)\n    self.neqs = coefs.shape[1]\n    self.coefs = coefs\n    self.intercept = intercept\n    self.sigma_u = sigma_u\n    self.A_solve = A_solve\n    self.B_solve = B_solve\n    self.names = names",
            "def __init__(self, coefs, intercept, sigma_u, A_solve, B_solve, names=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.k_ar = len(coefs)\n    self.neqs = coefs.shape[1]\n    self.coefs = coefs\n    self.intercept = intercept\n    self.sigma_u = sigma_u\n    self.A_solve = A_solve\n    self.B_solve = B_solve\n    self.names = names",
            "def __init__(self, coefs, intercept, sigma_u, A_solve, B_solve, names=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.k_ar = len(coefs)\n    self.neqs = coefs.shape[1]\n    self.coefs = coefs\n    self.intercept = intercept\n    self.sigma_u = sigma_u\n    self.A_solve = A_solve\n    self.B_solve = B_solve\n    self.names = names"
        ]
    },
    {
        "func_name": "orth_ma_rep",
        "original": "def orth_ma_rep(self, maxn=10, P=None):\n    \"\"\"\n\n        Unavailable for SVAR\n        \"\"\"\n    raise NotImplementedError",
        "mutated": [
            "def orth_ma_rep(self, maxn=10, P=None):\n    if False:\n        i = 10\n    '\\n\\n        Unavailable for SVAR\\n        '\n    raise NotImplementedError",
            "def orth_ma_rep(self, maxn=10, P=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n        Unavailable for SVAR\\n        '\n    raise NotImplementedError",
            "def orth_ma_rep(self, maxn=10, P=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n        Unavailable for SVAR\\n        '\n    raise NotImplementedError",
            "def orth_ma_rep(self, maxn=10, P=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n        Unavailable for SVAR\\n        '\n    raise NotImplementedError",
            "def orth_ma_rep(self, maxn=10, P=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n        Unavailable for SVAR\\n        '\n    raise NotImplementedError"
        ]
    },
    {
        "func_name": "svar_ma_rep",
        "original": "def svar_ma_rep(self, maxn=10, P=None):\n    \"\"\"\n\n        Compute Structural MA coefficient matrices using MLE\n        of A, B\n        \"\"\"\n    if P is None:\n        A_solve = self.A_solve\n        B_solve = self.B_solve\n        P = np.dot(npl.inv(A_solve), B_solve)\n    ma_mats = self.ma_rep(maxn=maxn)\n    return np.array([np.dot(coefs, P) for coefs in ma_mats])",
        "mutated": [
            "def svar_ma_rep(self, maxn=10, P=None):\n    if False:\n        i = 10\n    '\\n\\n        Compute Structural MA coefficient matrices using MLE\\n        of A, B\\n        '\n    if P is None:\n        A_solve = self.A_solve\n        B_solve = self.B_solve\n        P = np.dot(npl.inv(A_solve), B_solve)\n    ma_mats = self.ma_rep(maxn=maxn)\n    return np.array([np.dot(coefs, P) for coefs in ma_mats])",
            "def svar_ma_rep(self, maxn=10, P=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n\\n        Compute Structural MA coefficient matrices using MLE\\n        of A, B\\n        '\n    if P is None:\n        A_solve = self.A_solve\n        B_solve = self.B_solve\n        P = np.dot(npl.inv(A_solve), B_solve)\n    ma_mats = self.ma_rep(maxn=maxn)\n    return np.array([np.dot(coefs, P) for coefs in ma_mats])",
            "def svar_ma_rep(self, maxn=10, P=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n\\n        Compute Structural MA coefficient matrices using MLE\\n        of A, B\\n        '\n    if P is None:\n        A_solve = self.A_solve\n        B_solve = self.B_solve\n        P = np.dot(npl.inv(A_solve), B_solve)\n    ma_mats = self.ma_rep(maxn=maxn)\n    return np.array([np.dot(coefs, P) for coefs in ma_mats])",
            "def svar_ma_rep(self, maxn=10, P=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n\\n        Compute Structural MA coefficient matrices using MLE\\n        of A, B\\n        '\n    if P is None:\n        A_solve = self.A_solve\n        B_solve = self.B_solve\n        P = np.dot(npl.inv(A_solve), B_solve)\n    ma_mats = self.ma_rep(maxn=maxn)\n    return np.array([np.dot(coefs, P) for coefs in ma_mats])",
            "def svar_ma_rep(self, maxn=10, P=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n\\n        Compute Structural MA coefficient matrices using MLE\\n        of A, B\\n        '\n    if P is None:\n        A_solve = self.A_solve\n        B_solve = self.B_solve\n        P = np.dot(npl.inv(A_solve), B_solve)\n    ma_mats = self.ma_rep(maxn=maxn)\n    return np.array([np.dot(coefs, P) for coefs in ma_mats])"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, endog, endog_lagged, params, sigma_u, lag_order, A=None, B=None, A_mask=None, B_mask=None, model=None, trend='c', names=None, dates=None):\n    self.model = model\n    self.endog = endog\n    self.endog_lagged = endog_lagged\n    self.dates = dates\n    (self.n_totobs, self.neqs) = self.endog.shape\n    self.nobs = self.n_totobs - lag_order\n    k_trend = util.get_trendorder(trend)\n    if k_trend > 0:\n        trendorder = k_trend - 1\n    else:\n        trendorder = None\n    self.k_trend = k_trend\n    self.k_exog = k_trend\n    self.trendorder = trendorder\n    self.exog_names = util.make_lag_names(names, lag_order, k_trend)\n    self.params = params\n    self.sigma_u = sigma_u\n    reshaped = self.params[self.k_trend:]\n    reshaped = reshaped.reshape((lag_order, self.neqs, self.neqs))\n    intercept = self.params[0]\n    coefs = reshaped.swapaxes(1, 2).copy()\n    self.A = A\n    self.B = B\n    self.A_mask = A_mask\n    self.B_mask = B_mask\n    super().__init__(coefs, intercept, sigma_u, A, B, names=names)",
        "mutated": [
            "def __init__(self, endog, endog_lagged, params, sigma_u, lag_order, A=None, B=None, A_mask=None, B_mask=None, model=None, trend='c', names=None, dates=None):\n    if False:\n        i = 10\n    self.model = model\n    self.endog = endog\n    self.endog_lagged = endog_lagged\n    self.dates = dates\n    (self.n_totobs, self.neqs) = self.endog.shape\n    self.nobs = self.n_totobs - lag_order\n    k_trend = util.get_trendorder(trend)\n    if k_trend > 0:\n        trendorder = k_trend - 1\n    else:\n        trendorder = None\n    self.k_trend = k_trend\n    self.k_exog = k_trend\n    self.trendorder = trendorder\n    self.exog_names = util.make_lag_names(names, lag_order, k_trend)\n    self.params = params\n    self.sigma_u = sigma_u\n    reshaped = self.params[self.k_trend:]\n    reshaped = reshaped.reshape((lag_order, self.neqs, self.neqs))\n    intercept = self.params[0]\n    coefs = reshaped.swapaxes(1, 2).copy()\n    self.A = A\n    self.B = B\n    self.A_mask = A_mask\n    self.B_mask = B_mask\n    super().__init__(coefs, intercept, sigma_u, A, B, names=names)",
            "def __init__(self, endog, endog_lagged, params, sigma_u, lag_order, A=None, B=None, A_mask=None, B_mask=None, model=None, trend='c', names=None, dates=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.model = model\n    self.endog = endog\n    self.endog_lagged = endog_lagged\n    self.dates = dates\n    (self.n_totobs, self.neqs) = self.endog.shape\n    self.nobs = self.n_totobs - lag_order\n    k_trend = util.get_trendorder(trend)\n    if k_trend > 0:\n        trendorder = k_trend - 1\n    else:\n        trendorder = None\n    self.k_trend = k_trend\n    self.k_exog = k_trend\n    self.trendorder = trendorder\n    self.exog_names = util.make_lag_names(names, lag_order, k_trend)\n    self.params = params\n    self.sigma_u = sigma_u\n    reshaped = self.params[self.k_trend:]\n    reshaped = reshaped.reshape((lag_order, self.neqs, self.neqs))\n    intercept = self.params[0]\n    coefs = reshaped.swapaxes(1, 2).copy()\n    self.A = A\n    self.B = B\n    self.A_mask = A_mask\n    self.B_mask = B_mask\n    super().__init__(coefs, intercept, sigma_u, A, B, names=names)",
            "def __init__(self, endog, endog_lagged, params, sigma_u, lag_order, A=None, B=None, A_mask=None, B_mask=None, model=None, trend='c', names=None, dates=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.model = model\n    self.endog = endog\n    self.endog_lagged = endog_lagged\n    self.dates = dates\n    (self.n_totobs, self.neqs) = self.endog.shape\n    self.nobs = self.n_totobs - lag_order\n    k_trend = util.get_trendorder(trend)\n    if k_trend > 0:\n        trendorder = k_trend - 1\n    else:\n        trendorder = None\n    self.k_trend = k_trend\n    self.k_exog = k_trend\n    self.trendorder = trendorder\n    self.exog_names = util.make_lag_names(names, lag_order, k_trend)\n    self.params = params\n    self.sigma_u = sigma_u\n    reshaped = self.params[self.k_trend:]\n    reshaped = reshaped.reshape((lag_order, self.neqs, self.neqs))\n    intercept = self.params[0]\n    coefs = reshaped.swapaxes(1, 2).copy()\n    self.A = A\n    self.B = B\n    self.A_mask = A_mask\n    self.B_mask = B_mask\n    super().__init__(coefs, intercept, sigma_u, A, B, names=names)",
            "def __init__(self, endog, endog_lagged, params, sigma_u, lag_order, A=None, B=None, A_mask=None, B_mask=None, model=None, trend='c', names=None, dates=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.model = model\n    self.endog = endog\n    self.endog_lagged = endog_lagged\n    self.dates = dates\n    (self.n_totobs, self.neqs) = self.endog.shape\n    self.nobs = self.n_totobs - lag_order\n    k_trend = util.get_trendorder(trend)\n    if k_trend > 0:\n        trendorder = k_trend - 1\n    else:\n        trendorder = None\n    self.k_trend = k_trend\n    self.k_exog = k_trend\n    self.trendorder = trendorder\n    self.exog_names = util.make_lag_names(names, lag_order, k_trend)\n    self.params = params\n    self.sigma_u = sigma_u\n    reshaped = self.params[self.k_trend:]\n    reshaped = reshaped.reshape((lag_order, self.neqs, self.neqs))\n    intercept = self.params[0]\n    coefs = reshaped.swapaxes(1, 2).copy()\n    self.A = A\n    self.B = B\n    self.A_mask = A_mask\n    self.B_mask = B_mask\n    super().__init__(coefs, intercept, sigma_u, A, B, names=names)",
            "def __init__(self, endog, endog_lagged, params, sigma_u, lag_order, A=None, B=None, A_mask=None, B_mask=None, model=None, trend='c', names=None, dates=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.model = model\n    self.endog = endog\n    self.endog_lagged = endog_lagged\n    self.dates = dates\n    (self.n_totobs, self.neqs) = self.endog.shape\n    self.nobs = self.n_totobs - lag_order\n    k_trend = util.get_trendorder(trend)\n    if k_trend > 0:\n        trendorder = k_trend - 1\n    else:\n        trendorder = None\n    self.k_trend = k_trend\n    self.k_exog = k_trend\n    self.trendorder = trendorder\n    self.exog_names = util.make_lag_names(names, lag_order, k_trend)\n    self.params = params\n    self.sigma_u = sigma_u\n    reshaped = self.params[self.k_trend:]\n    reshaped = reshaped.reshape((lag_order, self.neqs, self.neqs))\n    intercept = self.params[0]\n    coefs = reshaped.swapaxes(1, 2).copy()\n    self.A = A\n    self.B = B\n    self.A_mask = A_mask\n    self.B_mask = B_mask\n    super().__init__(coefs, intercept, sigma_u, A, B, names=names)"
        ]
    },
    {
        "func_name": "irf",
        "original": "def irf(self, periods=10, var_order=None):\n    \"\"\"\n        Analyze structural impulse responses to shocks in system\n\n        Parameters\n        ----------\n        periods : int\n\n        Returns\n        -------\n        irf : IRAnalysis\n        \"\"\"\n    A = self.A\n    B = self.B\n    P = np.dot(npl.inv(A), B)\n    return IRAnalysis(self, P=P, periods=periods, svar=True)",
        "mutated": [
            "def irf(self, periods=10, var_order=None):\n    if False:\n        i = 10\n    '\\n        Analyze structural impulse responses to shocks in system\\n\\n        Parameters\\n        ----------\\n        periods : int\\n\\n        Returns\\n        -------\\n        irf : IRAnalysis\\n        '\n    A = self.A\n    B = self.B\n    P = np.dot(npl.inv(A), B)\n    return IRAnalysis(self, P=P, periods=periods, svar=True)",
            "def irf(self, periods=10, var_order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Analyze structural impulse responses to shocks in system\\n\\n        Parameters\\n        ----------\\n        periods : int\\n\\n        Returns\\n        -------\\n        irf : IRAnalysis\\n        '\n    A = self.A\n    B = self.B\n    P = np.dot(npl.inv(A), B)\n    return IRAnalysis(self, P=P, periods=periods, svar=True)",
            "def irf(self, periods=10, var_order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Analyze structural impulse responses to shocks in system\\n\\n        Parameters\\n        ----------\\n        periods : int\\n\\n        Returns\\n        -------\\n        irf : IRAnalysis\\n        '\n    A = self.A\n    B = self.B\n    P = np.dot(npl.inv(A), B)\n    return IRAnalysis(self, P=P, periods=periods, svar=True)",
            "def irf(self, periods=10, var_order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Analyze structural impulse responses to shocks in system\\n\\n        Parameters\\n        ----------\\n        periods : int\\n\\n        Returns\\n        -------\\n        irf : IRAnalysis\\n        '\n    A = self.A\n    B = self.B\n    P = np.dot(npl.inv(A), B)\n    return IRAnalysis(self, P=P, periods=periods, svar=True)",
            "def irf(self, periods=10, var_order=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Analyze structural impulse responses to shocks in system\\n\\n        Parameters\\n        ----------\\n        periods : int\\n\\n        Returns\\n        -------\\n        irf : IRAnalysis\\n        '\n    A = self.A\n    B = self.B\n    P = np.dot(npl.inv(A), B)\n    return IRAnalysis(self, P=P, periods=periods, svar=True)"
        ]
    },
    {
        "func_name": "agg",
        "original": "def agg(impulses):\n    if cum:\n        return impulses.cumsum(axis=0)\n    return impulses",
        "mutated": [
            "def agg(impulses):\n    if False:\n        i = 10\n    if cum:\n        return impulses.cumsum(axis=0)\n    return impulses",
            "def agg(impulses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if cum:\n        return impulses.cumsum(axis=0)\n    return impulses",
            "def agg(impulses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if cum:\n        return impulses.cumsum(axis=0)\n    return impulses",
            "def agg(impulses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if cum:\n        return impulses.cumsum(axis=0)\n    return impulses",
            "def agg(impulses):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if cum:\n        return impulses.cumsum(axis=0)\n    return impulses"
        ]
    },
    {
        "func_name": "sirf_errband_mc",
        "original": "def sirf_errband_mc(self, orth=False, repl=1000, steps=10, signif=0.05, seed=None, burn=100, cum=False):\n    \"\"\"\n        Compute Monte Carlo integrated error bands assuming normally\n        distributed for impulse response functions\n\n        Parameters\n        ----------\n        orth : bool, default False\n            Compute orthogonalized impulse response error bands\n        repl : int\n            number of Monte Carlo replications to perform\n        steps : int, default 10\n            number of impulse response periods\n        signif : float (0 < signif <1)\n            Significance level for error bars, defaults to 95% CI\n        seed : int\n            np.random.seed for replications\n        burn : int\n            number of initial observations to discard for simulation\n        cum : bool, default False\n            produce cumulative irf error bands\n\n        Notes\n        -----\n        L\u00fctkepohl (2005) Appendix D\n\n        Returns\n        -------\n        Tuple of lower and upper arrays of ma_rep monte carlo standard errors\n        \"\"\"\n    neqs = self.neqs\n    mean = self.mean()\n    k_ar = self.k_ar\n    coefs = self.coefs\n    sigma_u = self.sigma_u\n    intercept = self.intercept\n    df_model = self.df_model\n    nobs = self.nobs\n    ma_coll = np.zeros((repl, steps + 1, neqs, neqs))\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_pass = self.model.A_original\n    B_pass = self.model.B_original\n    s_type = self.model.svar_type\n    g_list = []\n\n    def agg(impulses):\n        if cum:\n            return impulses.cumsum(axis=0)\n        return impulses\n    opt_A = A[A_mask]\n    opt_B = B[B_mask]\n    for i in range(repl):\n        sim = util.varsim(coefs, intercept, sigma_u, seed=seed, steps=nobs + burn)\n        sim = sim[burn:]\n        smod = SVAR(sim, svar_type=s_type, A=A_pass, B=B_pass)\n        if i == 10:\n            mean_AB = np.mean(g_list, axis=0)\n            split = len(A[A_mask])\n            opt_A = mean_AB[:split]\n            opt_B = mean_AB[split:]\n        sres = smod.fit(maxlags=k_ar, A_guess=opt_A, B_guess=opt_B)\n        if i < 10:\n            g_list.append(np.append(sres.A[A_mask].tolist(), sres.B[B_mask].tolist()))\n        ma_coll[i] = agg(sres.svar_ma_rep(maxn=steps))\n    ma_sort = np.sort(ma_coll, axis=0)\n    index = (int(round(signif / 2 * repl) - 1), int(round((1 - signif / 2) * repl) - 1))\n    lower = ma_sort[index[0], :, :, :]\n    upper = ma_sort[index[1], :, :, :]\n    return (lower, upper)",
        "mutated": [
            "def sirf_errband_mc(self, orth=False, repl=1000, steps=10, signif=0.05, seed=None, burn=100, cum=False):\n    if False:\n        i = 10\n    '\\n        Compute Monte Carlo integrated error bands assuming normally\\n        distributed for impulse response functions\\n\\n        Parameters\\n        ----------\\n        orth : bool, default False\\n            Compute orthogonalized impulse response error bands\\n        repl : int\\n            number of Monte Carlo replications to perform\\n        steps : int, default 10\\n            number of impulse response periods\\n        signif : float (0 < signif <1)\\n            Significance level for error bars, defaults to 95% CI\\n        seed : int\\n            np.random.seed for replications\\n        burn : int\\n            number of initial observations to discard for simulation\\n        cum : bool, default False\\n            produce cumulative irf error bands\\n\\n        Notes\\n        -----\\n        L\u00fctkepohl (2005) Appendix D\\n\\n        Returns\\n        -------\\n        Tuple of lower and upper arrays of ma_rep monte carlo standard errors\\n        '\n    neqs = self.neqs\n    mean = self.mean()\n    k_ar = self.k_ar\n    coefs = self.coefs\n    sigma_u = self.sigma_u\n    intercept = self.intercept\n    df_model = self.df_model\n    nobs = self.nobs\n    ma_coll = np.zeros((repl, steps + 1, neqs, neqs))\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_pass = self.model.A_original\n    B_pass = self.model.B_original\n    s_type = self.model.svar_type\n    g_list = []\n\n    def agg(impulses):\n        if cum:\n            return impulses.cumsum(axis=0)\n        return impulses\n    opt_A = A[A_mask]\n    opt_B = B[B_mask]\n    for i in range(repl):\n        sim = util.varsim(coefs, intercept, sigma_u, seed=seed, steps=nobs + burn)\n        sim = sim[burn:]\n        smod = SVAR(sim, svar_type=s_type, A=A_pass, B=B_pass)\n        if i == 10:\n            mean_AB = np.mean(g_list, axis=0)\n            split = len(A[A_mask])\n            opt_A = mean_AB[:split]\n            opt_B = mean_AB[split:]\n        sres = smod.fit(maxlags=k_ar, A_guess=opt_A, B_guess=opt_B)\n        if i < 10:\n            g_list.append(np.append(sres.A[A_mask].tolist(), sres.B[B_mask].tolist()))\n        ma_coll[i] = agg(sres.svar_ma_rep(maxn=steps))\n    ma_sort = np.sort(ma_coll, axis=0)\n    index = (int(round(signif / 2 * repl) - 1), int(round((1 - signif / 2) * repl) - 1))\n    lower = ma_sort[index[0], :, :, :]\n    upper = ma_sort[index[1], :, :, :]\n    return (lower, upper)",
            "def sirf_errband_mc(self, orth=False, repl=1000, steps=10, signif=0.05, seed=None, burn=100, cum=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Compute Monte Carlo integrated error bands assuming normally\\n        distributed for impulse response functions\\n\\n        Parameters\\n        ----------\\n        orth : bool, default False\\n            Compute orthogonalized impulse response error bands\\n        repl : int\\n            number of Monte Carlo replications to perform\\n        steps : int, default 10\\n            number of impulse response periods\\n        signif : float (0 < signif <1)\\n            Significance level for error bars, defaults to 95% CI\\n        seed : int\\n            np.random.seed for replications\\n        burn : int\\n            number of initial observations to discard for simulation\\n        cum : bool, default False\\n            produce cumulative irf error bands\\n\\n        Notes\\n        -----\\n        L\u00fctkepohl (2005) Appendix D\\n\\n        Returns\\n        -------\\n        Tuple of lower and upper arrays of ma_rep monte carlo standard errors\\n        '\n    neqs = self.neqs\n    mean = self.mean()\n    k_ar = self.k_ar\n    coefs = self.coefs\n    sigma_u = self.sigma_u\n    intercept = self.intercept\n    df_model = self.df_model\n    nobs = self.nobs\n    ma_coll = np.zeros((repl, steps + 1, neqs, neqs))\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_pass = self.model.A_original\n    B_pass = self.model.B_original\n    s_type = self.model.svar_type\n    g_list = []\n\n    def agg(impulses):\n        if cum:\n            return impulses.cumsum(axis=0)\n        return impulses\n    opt_A = A[A_mask]\n    opt_B = B[B_mask]\n    for i in range(repl):\n        sim = util.varsim(coefs, intercept, sigma_u, seed=seed, steps=nobs + burn)\n        sim = sim[burn:]\n        smod = SVAR(sim, svar_type=s_type, A=A_pass, B=B_pass)\n        if i == 10:\n            mean_AB = np.mean(g_list, axis=0)\n            split = len(A[A_mask])\n            opt_A = mean_AB[:split]\n            opt_B = mean_AB[split:]\n        sres = smod.fit(maxlags=k_ar, A_guess=opt_A, B_guess=opt_B)\n        if i < 10:\n            g_list.append(np.append(sres.A[A_mask].tolist(), sres.B[B_mask].tolist()))\n        ma_coll[i] = agg(sres.svar_ma_rep(maxn=steps))\n    ma_sort = np.sort(ma_coll, axis=0)\n    index = (int(round(signif / 2 * repl) - 1), int(round((1 - signif / 2) * repl) - 1))\n    lower = ma_sort[index[0], :, :, :]\n    upper = ma_sort[index[1], :, :, :]\n    return (lower, upper)",
            "def sirf_errband_mc(self, orth=False, repl=1000, steps=10, signif=0.05, seed=None, burn=100, cum=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Compute Monte Carlo integrated error bands assuming normally\\n        distributed for impulse response functions\\n\\n        Parameters\\n        ----------\\n        orth : bool, default False\\n            Compute orthogonalized impulse response error bands\\n        repl : int\\n            number of Monte Carlo replications to perform\\n        steps : int, default 10\\n            number of impulse response periods\\n        signif : float (0 < signif <1)\\n            Significance level for error bars, defaults to 95% CI\\n        seed : int\\n            np.random.seed for replications\\n        burn : int\\n            number of initial observations to discard for simulation\\n        cum : bool, default False\\n            produce cumulative irf error bands\\n\\n        Notes\\n        -----\\n        L\u00fctkepohl (2005) Appendix D\\n\\n        Returns\\n        -------\\n        Tuple of lower and upper arrays of ma_rep monte carlo standard errors\\n        '\n    neqs = self.neqs\n    mean = self.mean()\n    k_ar = self.k_ar\n    coefs = self.coefs\n    sigma_u = self.sigma_u\n    intercept = self.intercept\n    df_model = self.df_model\n    nobs = self.nobs\n    ma_coll = np.zeros((repl, steps + 1, neqs, neqs))\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_pass = self.model.A_original\n    B_pass = self.model.B_original\n    s_type = self.model.svar_type\n    g_list = []\n\n    def agg(impulses):\n        if cum:\n            return impulses.cumsum(axis=0)\n        return impulses\n    opt_A = A[A_mask]\n    opt_B = B[B_mask]\n    for i in range(repl):\n        sim = util.varsim(coefs, intercept, sigma_u, seed=seed, steps=nobs + burn)\n        sim = sim[burn:]\n        smod = SVAR(sim, svar_type=s_type, A=A_pass, B=B_pass)\n        if i == 10:\n            mean_AB = np.mean(g_list, axis=0)\n            split = len(A[A_mask])\n            opt_A = mean_AB[:split]\n            opt_B = mean_AB[split:]\n        sres = smod.fit(maxlags=k_ar, A_guess=opt_A, B_guess=opt_B)\n        if i < 10:\n            g_list.append(np.append(sres.A[A_mask].tolist(), sres.B[B_mask].tolist()))\n        ma_coll[i] = agg(sres.svar_ma_rep(maxn=steps))\n    ma_sort = np.sort(ma_coll, axis=0)\n    index = (int(round(signif / 2 * repl) - 1), int(round((1 - signif / 2) * repl) - 1))\n    lower = ma_sort[index[0], :, :, :]\n    upper = ma_sort[index[1], :, :, :]\n    return (lower, upper)",
            "def sirf_errband_mc(self, orth=False, repl=1000, steps=10, signif=0.05, seed=None, burn=100, cum=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Compute Monte Carlo integrated error bands assuming normally\\n        distributed for impulse response functions\\n\\n        Parameters\\n        ----------\\n        orth : bool, default False\\n            Compute orthogonalized impulse response error bands\\n        repl : int\\n            number of Monte Carlo replications to perform\\n        steps : int, default 10\\n            number of impulse response periods\\n        signif : float (0 < signif <1)\\n            Significance level for error bars, defaults to 95% CI\\n        seed : int\\n            np.random.seed for replications\\n        burn : int\\n            number of initial observations to discard for simulation\\n        cum : bool, default False\\n            produce cumulative irf error bands\\n\\n        Notes\\n        -----\\n        L\u00fctkepohl (2005) Appendix D\\n\\n        Returns\\n        -------\\n        Tuple of lower and upper arrays of ma_rep monte carlo standard errors\\n        '\n    neqs = self.neqs\n    mean = self.mean()\n    k_ar = self.k_ar\n    coefs = self.coefs\n    sigma_u = self.sigma_u\n    intercept = self.intercept\n    df_model = self.df_model\n    nobs = self.nobs\n    ma_coll = np.zeros((repl, steps + 1, neqs, neqs))\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_pass = self.model.A_original\n    B_pass = self.model.B_original\n    s_type = self.model.svar_type\n    g_list = []\n\n    def agg(impulses):\n        if cum:\n            return impulses.cumsum(axis=0)\n        return impulses\n    opt_A = A[A_mask]\n    opt_B = B[B_mask]\n    for i in range(repl):\n        sim = util.varsim(coefs, intercept, sigma_u, seed=seed, steps=nobs + burn)\n        sim = sim[burn:]\n        smod = SVAR(sim, svar_type=s_type, A=A_pass, B=B_pass)\n        if i == 10:\n            mean_AB = np.mean(g_list, axis=0)\n            split = len(A[A_mask])\n            opt_A = mean_AB[:split]\n            opt_B = mean_AB[split:]\n        sres = smod.fit(maxlags=k_ar, A_guess=opt_A, B_guess=opt_B)\n        if i < 10:\n            g_list.append(np.append(sres.A[A_mask].tolist(), sres.B[B_mask].tolist()))\n        ma_coll[i] = agg(sres.svar_ma_rep(maxn=steps))\n    ma_sort = np.sort(ma_coll, axis=0)\n    index = (int(round(signif / 2 * repl) - 1), int(round((1 - signif / 2) * repl) - 1))\n    lower = ma_sort[index[0], :, :, :]\n    upper = ma_sort[index[1], :, :, :]\n    return (lower, upper)",
            "def sirf_errband_mc(self, orth=False, repl=1000, steps=10, signif=0.05, seed=None, burn=100, cum=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Compute Monte Carlo integrated error bands assuming normally\\n        distributed for impulse response functions\\n\\n        Parameters\\n        ----------\\n        orth : bool, default False\\n            Compute orthogonalized impulse response error bands\\n        repl : int\\n            number of Monte Carlo replications to perform\\n        steps : int, default 10\\n            number of impulse response periods\\n        signif : float (0 < signif <1)\\n            Significance level for error bars, defaults to 95% CI\\n        seed : int\\n            np.random.seed for replications\\n        burn : int\\n            number of initial observations to discard for simulation\\n        cum : bool, default False\\n            produce cumulative irf error bands\\n\\n        Notes\\n        -----\\n        L\u00fctkepohl (2005) Appendix D\\n\\n        Returns\\n        -------\\n        Tuple of lower and upper arrays of ma_rep monte carlo standard errors\\n        '\n    neqs = self.neqs\n    mean = self.mean()\n    k_ar = self.k_ar\n    coefs = self.coefs\n    sigma_u = self.sigma_u\n    intercept = self.intercept\n    df_model = self.df_model\n    nobs = self.nobs\n    ma_coll = np.zeros((repl, steps + 1, neqs, neqs))\n    A = self.A\n    B = self.B\n    A_mask = self.A_mask\n    B_mask = self.B_mask\n    A_pass = self.model.A_original\n    B_pass = self.model.B_original\n    s_type = self.model.svar_type\n    g_list = []\n\n    def agg(impulses):\n        if cum:\n            return impulses.cumsum(axis=0)\n        return impulses\n    opt_A = A[A_mask]\n    opt_B = B[B_mask]\n    for i in range(repl):\n        sim = util.varsim(coefs, intercept, sigma_u, seed=seed, steps=nobs + burn)\n        sim = sim[burn:]\n        smod = SVAR(sim, svar_type=s_type, A=A_pass, B=B_pass)\n        if i == 10:\n            mean_AB = np.mean(g_list, axis=0)\n            split = len(A[A_mask])\n            opt_A = mean_AB[:split]\n            opt_B = mean_AB[split:]\n        sres = smod.fit(maxlags=k_ar, A_guess=opt_A, B_guess=opt_B)\n        if i < 10:\n            g_list.append(np.append(sres.A[A_mask].tolist(), sres.B[B_mask].tolist()))\n        ma_coll[i] = agg(sres.svar_ma_rep(maxn=steps))\n    ma_sort = np.sort(ma_coll, axis=0)\n    index = (int(round(signif / 2 * repl) - 1), int(round((1 - signif / 2) * repl) - 1))\n    lower = ma_sort[index[0], :, :, :]\n    upper = ma_sort[index[1], :, :, :]\n    return (lower, upper)"
        ]
    }
]