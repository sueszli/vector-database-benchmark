[
    {
        "func_name": "load_filtered_voc_instances",
        "original": "def load_filtered_voc_instances(name: str, root: str, dirname: str, split: str, classnames: str):\n    \"\"\"\n    Load Pascal VOC detection annotations to Detectron2 format.\n    Args:\n        dirname: Contain \"Annotations\", \"ImageSets\", \"JPEGImages\"\n        split (str): one of \"train\", \"test\", \"val\", \"trainval\"\n    \"\"\"\n    is_shots = 'shot' in name\n    dicts = []\n    if is_shots:\n        fileids = {}\n        split_dir = os.path.join(root, 'vocsplit')\n        shot = name.split('_')[-2].split('shot')[0]\n        seed = int(name.split('_seed')[-1])\n        split_dir = os.path.join(split_dir, 'seed{}'.format(seed))\n        for cls in classnames:\n            with PathManager.open(os.path.join(split_dir, 'box_{}shot_{}_train.txt'.format(shot, cls))) as f:\n                fileids_ = np.loadtxt(f, dtype=np.str_).tolist()\n                if isinstance(fileids_, str):\n                    fileids_ = [fileids_]\n                fileids_ = [fid.split('/')[-1].split('.jpg')[0] for fid in fileids_]\n                fileids[cls] = fileids_\n        for (cls, fileids_) in fileids.items():\n            dicts_ = []\n            for fileid in fileids_:\n                year = '2012' if '_' in fileid else '2007'\n                dir_voc = os.path.join(root, 'VOC{}'.format(year))\n                anno_file = os.path.join(dir_voc, 'Annotations', fileid + '.xml')\n                jpeg_file = os.path.join(dir_voc, 'JPEGImages', fileid + '.jpg')\n                tree = ET.parse(anno_file)\n                for obj in tree.findall('object'):\n                    r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n                    cls_ = obj.find('name').text\n                    if cls != cls_:\n                        continue\n                    bbox = obj.find('bndbox')\n                    bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                    bbox[0] -= 1.0\n                    bbox[1] -= 1.0\n                    instances = [{'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS}]\n                    r['annotations'] = instances\n                    dicts_.append(r)\n            if len(dicts_) > int(shot):\n                dicts_ = np.random.choice(dicts_, int(shot), replace=False)\n            dicts.extend(dicts_)\n    else:\n        with PathManager.open(os.path.join(root, dirname, 'ImageSets', 'Main', split + '.txt')) as f:\n            fileids = np.loadtxt(f, dtype=np.str_)\n        for fileid in fileids:\n            anno_file = os.path.join(root, dirname, 'Annotations', fileid + '.xml')\n            jpeg_file = os.path.join(root, dirname, 'JPEGImages', fileid + '.jpg')\n            tree = ET.parse(anno_file)\n            r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n            instances = []\n            for obj in tree.findall('object'):\n                cls = obj.find('name').text\n                if not cls in classnames:\n                    continue\n                bbox = obj.find('bndbox')\n                bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                bbox[0] -= 1.0\n                bbox[1] -= 1.0\n                instances.append({'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS})\n            r['annotations'] = instances\n            dicts.append(r)\n    return dicts",
        "mutated": [
            "def load_filtered_voc_instances(name: str, root: str, dirname: str, split: str, classnames: str):\n    if False:\n        i = 10\n    '\\n    Load Pascal VOC detection annotations to Detectron2 format.\\n    Args:\\n        dirname: Contain \"Annotations\", \"ImageSets\", \"JPEGImages\"\\n        split (str): one of \"train\", \"test\", \"val\", \"trainval\"\\n    '\n    is_shots = 'shot' in name\n    dicts = []\n    if is_shots:\n        fileids = {}\n        split_dir = os.path.join(root, 'vocsplit')\n        shot = name.split('_')[-2].split('shot')[0]\n        seed = int(name.split('_seed')[-1])\n        split_dir = os.path.join(split_dir, 'seed{}'.format(seed))\n        for cls in classnames:\n            with PathManager.open(os.path.join(split_dir, 'box_{}shot_{}_train.txt'.format(shot, cls))) as f:\n                fileids_ = np.loadtxt(f, dtype=np.str_).tolist()\n                if isinstance(fileids_, str):\n                    fileids_ = [fileids_]\n                fileids_ = [fid.split('/')[-1].split('.jpg')[0] for fid in fileids_]\n                fileids[cls] = fileids_\n        for (cls, fileids_) in fileids.items():\n            dicts_ = []\n            for fileid in fileids_:\n                year = '2012' if '_' in fileid else '2007'\n                dir_voc = os.path.join(root, 'VOC{}'.format(year))\n                anno_file = os.path.join(dir_voc, 'Annotations', fileid + '.xml')\n                jpeg_file = os.path.join(dir_voc, 'JPEGImages', fileid + '.jpg')\n                tree = ET.parse(anno_file)\n                for obj in tree.findall('object'):\n                    r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n                    cls_ = obj.find('name').text\n                    if cls != cls_:\n                        continue\n                    bbox = obj.find('bndbox')\n                    bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                    bbox[0] -= 1.0\n                    bbox[1] -= 1.0\n                    instances = [{'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS}]\n                    r['annotations'] = instances\n                    dicts_.append(r)\n            if len(dicts_) > int(shot):\n                dicts_ = np.random.choice(dicts_, int(shot), replace=False)\n            dicts.extend(dicts_)\n    else:\n        with PathManager.open(os.path.join(root, dirname, 'ImageSets', 'Main', split + '.txt')) as f:\n            fileids = np.loadtxt(f, dtype=np.str_)\n        for fileid in fileids:\n            anno_file = os.path.join(root, dirname, 'Annotations', fileid + '.xml')\n            jpeg_file = os.path.join(root, dirname, 'JPEGImages', fileid + '.jpg')\n            tree = ET.parse(anno_file)\n            r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n            instances = []\n            for obj in tree.findall('object'):\n                cls = obj.find('name').text\n                if not cls in classnames:\n                    continue\n                bbox = obj.find('bndbox')\n                bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                bbox[0] -= 1.0\n                bbox[1] -= 1.0\n                instances.append({'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS})\n            r['annotations'] = instances\n            dicts.append(r)\n    return dicts",
            "def load_filtered_voc_instances(name: str, root: str, dirname: str, split: str, classnames: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Load Pascal VOC detection annotations to Detectron2 format.\\n    Args:\\n        dirname: Contain \"Annotations\", \"ImageSets\", \"JPEGImages\"\\n        split (str): one of \"train\", \"test\", \"val\", \"trainval\"\\n    '\n    is_shots = 'shot' in name\n    dicts = []\n    if is_shots:\n        fileids = {}\n        split_dir = os.path.join(root, 'vocsplit')\n        shot = name.split('_')[-2].split('shot')[0]\n        seed = int(name.split('_seed')[-1])\n        split_dir = os.path.join(split_dir, 'seed{}'.format(seed))\n        for cls in classnames:\n            with PathManager.open(os.path.join(split_dir, 'box_{}shot_{}_train.txt'.format(shot, cls))) as f:\n                fileids_ = np.loadtxt(f, dtype=np.str_).tolist()\n                if isinstance(fileids_, str):\n                    fileids_ = [fileids_]\n                fileids_ = [fid.split('/')[-1].split('.jpg')[0] for fid in fileids_]\n                fileids[cls] = fileids_\n        for (cls, fileids_) in fileids.items():\n            dicts_ = []\n            for fileid in fileids_:\n                year = '2012' if '_' in fileid else '2007'\n                dir_voc = os.path.join(root, 'VOC{}'.format(year))\n                anno_file = os.path.join(dir_voc, 'Annotations', fileid + '.xml')\n                jpeg_file = os.path.join(dir_voc, 'JPEGImages', fileid + '.jpg')\n                tree = ET.parse(anno_file)\n                for obj in tree.findall('object'):\n                    r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n                    cls_ = obj.find('name').text\n                    if cls != cls_:\n                        continue\n                    bbox = obj.find('bndbox')\n                    bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                    bbox[0] -= 1.0\n                    bbox[1] -= 1.0\n                    instances = [{'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS}]\n                    r['annotations'] = instances\n                    dicts_.append(r)\n            if len(dicts_) > int(shot):\n                dicts_ = np.random.choice(dicts_, int(shot), replace=False)\n            dicts.extend(dicts_)\n    else:\n        with PathManager.open(os.path.join(root, dirname, 'ImageSets', 'Main', split + '.txt')) as f:\n            fileids = np.loadtxt(f, dtype=np.str_)\n        for fileid in fileids:\n            anno_file = os.path.join(root, dirname, 'Annotations', fileid + '.xml')\n            jpeg_file = os.path.join(root, dirname, 'JPEGImages', fileid + '.jpg')\n            tree = ET.parse(anno_file)\n            r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n            instances = []\n            for obj in tree.findall('object'):\n                cls = obj.find('name').text\n                if not cls in classnames:\n                    continue\n                bbox = obj.find('bndbox')\n                bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                bbox[0] -= 1.0\n                bbox[1] -= 1.0\n                instances.append({'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS})\n            r['annotations'] = instances\n            dicts.append(r)\n    return dicts",
            "def load_filtered_voc_instances(name: str, root: str, dirname: str, split: str, classnames: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Load Pascal VOC detection annotations to Detectron2 format.\\n    Args:\\n        dirname: Contain \"Annotations\", \"ImageSets\", \"JPEGImages\"\\n        split (str): one of \"train\", \"test\", \"val\", \"trainval\"\\n    '\n    is_shots = 'shot' in name\n    dicts = []\n    if is_shots:\n        fileids = {}\n        split_dir = os.path.join(root, 'vocsplit')\n        shot = name.split('_')[-2].split('shot')[0]\n        seed = int(name.split('_seed')[-1])\n        split_dir = os.path.join(split_dir, 'seed{}'.format(seed))\n        for cls in classnames:\n            with PathManager.open(os.path.join(split_dir, 'box_{}shot_{}_train.txt'.format(shot, cls))) as f:\n                fileids_ = np.loadtxt(f, dtype=np.str_).tolist()\n                if isinstance(fileids_, str):\n                    fileids_ = [fileids_]\n                fileids_ = [fid.split('/')[-1].split('.jpg')[0] for fid in fileids_]\n                fileids[cls] = fileids_\n        for (cls, fileids_) in fileids.items():\n            dicts_ = []\n            for fileid in fileids_:\n                year = '2012' if '_' in fileid else '2007'\n                dir_voc = os.path.join(root, 'VOC{}'.format(year))\n                anno_file = os.path.join(dir_voc, 'Annotations', fileid + '.xml')\n                jpeg_file = os.path.join(dir_voc, 'JPEGImages', fileid + '.jpg')\n                tree = ET.parse(anno_file)\n                for obj in tree.findall('object'):\n                    r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n                    cls_ = obj.find('name').text\n                    if cls != cls_:\n                        continue\n                    bbox = obj.find('bndbox')\n                    bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                    bbox[0] -= 1.0\n                    bbox[1] -= 1.0\n                    instances = [{'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS}]\n                    r['annotations'] = instances\n                    dicts_.append(r)\n            if len(dicts_) > int(shot):\n                dicts_ = np.random.choice(dicts_, int(shot), replace=False)\n            dicts.extend(dicts_)\n    else:\n        with PathManager.open(os.path.join(root, dirname, 'ImageSets', 'Main', split + '.txt')) as f:\n            fileids = np.loadtxt(f, dtype=np.str_)\n        for fileid in fileids:\n            anno_file = os.path.join(root, dirname, 'Annotations', fileid + '.xml')\n            jpeg_file = os.path.join(root, dirname, 'JPEGImages', fileid + '.jpg')\n            tree = ET.parse(anno_file)\n            r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n            instances = []\n            for obj in tree.findall('object'):\n                cls = obj.find('name').text\n                if not cls in classnames:\n                    continue\n                bbox = obj.find('bndbox')\n                bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                bbox[0] -= 1.0\n                bbox[1] -= 1.0\n                instances.append({'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS})\n            r['annotations'] = instances\n            dicts.append(r)\n    return dicts",
            "def load_filtered_voc_instances(name: str, root: str, dirname: str, split: str, classnames: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Load Pascal VOC detection annotations to Detectron2 format.\\n    Args:\\n        dirname: Contain \"Annotations\", \"ImageSets\", \"JPEGImages\"\\n        split (str): one of \"train\", \"test\", \"val\", \"trainval\"\\n    '\n    is_shots = 'shot' in name\n    dicts = []\n    if is_shots:\n        fileids = {}\n        split_dir = os.path.join(root, 'vocsplit')\n        shot = name.split('_')[-2].split('shot')[0]\n        seed = int(name.split('_seed')[-1])\n        split_dir = os.path.join(split_dir, 'seed{}'.format(seed))\n        for cls in classnames:\n            with PathManager.open(os.path.join(split_dir, 'box_{}shot_{}_train.txt'.format(shot, cls))) as f:\n                fileids_ = np.loadtxt(f, dtype=np.str_).tolist()\n                if isinstance(fileids_, str):\n                    fileids_ = [fileids_]\n                fileids_ = [fid.split('/')[-1].split('.jpg')[0] for fid in fileids_]\n                fileids[cls] = fileids_\n        for (cls, fileids_) in fileids.items():\n            dicts_ = []\n            for fileid in fileids_:\n                year = '2012' if '_' in fileid else '2007'\n                dir_voc = os.path.join(root, 'VOC{}'.format(year))\n                anno_file = os.path.join(dir_voc, 'Annotations', fileid + '.xml')\n                jpeg_file = os.path.join(dir_voc, 'JPEGImages', fileid + '.jpg')\n                tree = ET.parse(anno_file)\n                for obj in tree.findall('object'):\n                    r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n                    cls_ = obj.find('name').text\n                    if cls != cls_:\n                        continue\n                    bbox = obj.find('bndbox')\n                    bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                    bbox[0] -= 1.0\n                    bbox[1] -= 1.0\n                    instances = [{'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS}]\n                    r['annotations'] = instances\n                    dicts_.append(r)\n            if len(dicts_) > int(shot):\n                dicts_ = np.random.choice(dicts_, int(shot), replace=False)\n            dicts.extend(dicts_)\n    else:\n        with PathManager.open(os.path.join(root, dirname, 'ImageSets', 'Main', split + '.txt')) as f:\n            fileids = np.loadtxt(f, dtype=np.str_)\n        for fileid in fileids:\n            anno_file = os.path.join(root, dirname, 'Annotations', fileid + '.xml')\n            jpeg_file = os.path.join(root, dirname, 'JPEGImages', fileid + '.jpg')\n            tree = ET.parse(anno_file)\n            r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n            instances = []\n            for obj in tree.findall('object'):\n                cls = obj.find('name').text\n                if not cls in classnames:\n                    continue\n                bbox = obj.find('bndbox')\n                bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                bbox[0] -= 1.0\n                bbox[1] -= 1.0\n                instances.append({'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS})\n            r['annotations'] = instances\n            dicts.append(r)\n    return dicts",
            "def load_filtered_voc_instances(name: str, root: str, dirname: str, split: str, classnames: str):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Load Pascal VOC detection annotations to Detectron2 format.\\n    Args:\\n        dirname: Contain \"Annotations\", \"ImageSets\", \"JPEGImages\"\\n        split (str): one of \"train\", \"test\", \"val\", \"trainval\"\\n    '\n    is_shots = 'shot' in name\n    dicts = []\n    if is_shots:\n        fileids = {}\n        split_dir = os.path.join(root, 'vocsplit')\n        shot = name.split('_')[-2].split('shot')[0]\n        seed = int(name.split('_seed')[-1])\n        split_dir = os.path.join(split_dir, 'seed{}'.format(seed))\n        for cls in classnames:\n            with PathManager.open(os.path.join(split_dir, 'box_{}shot_{}_train.txt'.format(shot, cls))) as f:\n                fileids_ = np.loadtxt(f, dtype=np.str_).tolist()\n                if isinstance(fileids_, str):\n                    fileids_ = [fileids_]\n                fileids_ = [fid.split('/')[-1].split('.jpg')[0] for fid in fileids_]\n                fileids[cls] = fileids_\n        for (cls, fileids_) in fileids.items():\n            dicts_ = []\n            for fileid in fileids_:\n                year = '2012' if '_' in fileid else '2007'\n                dir_voc = os.path.join(root, 'VOC{}'.format(year))\n                anno_file = os.path.join(dir_voc, 'Annotations', fileid + '.xml')\n                jpeg_file = os.path.join(dir_voc, 'JPEGImages', fileid + '.jpg')\n                tree = ET.parse(anno_file)\n                for obj in tree.findall('object'):\n                    r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n                    cls_ = obj.find('name').text\n                    if cls != cls_:\n                        continue\n                    bbox = obj.find('bndbox')\n                    bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                    bbox[0] -= 1.0\n                    bbox[1] -= 1.0\n                    instances = [{'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS}]\n                    r['annotations'] = instances\n                    dicts_.append(r)\n            if len(dicts_) > int(shot):\n                dicts_ = np.random.choice(dicts_, int(shot), replace=False)\n            dicts.extend(dicts_)\n    else:\n        with PathManager.open(os.path.join(root, dirname, 'ImageSets', 'Main', split + '.txt')) as f:\n            fileids = np.loadtxt(f, dtype=np.str_)\n        for fileid in fileids:\n            anno_file = os.path.join(root, dirname, 'Annotations', fileid + '.xml')\n            jpeg_file = os.path.join(root, dirname, 'JPEGImages', fileid + '.jpg')\n            tree = ET.parse(anno_file)\n            r = {'file_name': jpeg_file, 'image_id': fileid, 'height': int(tree.findall('./size/height')[0].text), 'width': int(tree.findall('./size/width')[0].text)}\n            instances = []\n            for obj in tree.findall('object'):\n                cls = obj.find('name').text\n                if not cls in classnames:\n                    continue\n                bbox = obj.find('bndbox')\n                bbox = [float(bbox.find(x).text) for x in ['xmin', 'ymin', 'xmax', 'ymax']]\n                bbox[0] -= 1.0\n                bbox[1] -= 1.0\n                instances.append({'category_id': classnames.index(cls), 'bbox': bbox, 'bbox_mode': BoxMode.XYXY_ABS})\n            r['annotations'] = instances\n            dicts.append(r)\n    return dicts"
        ]
    },
    {
        "func_name": "register_meta_voc",
        "original": "def register_meta_voc(name, root, dirname, split, year, keepclasses, sid):\n    if keepclasses.startswith('base_novel'):\n        thing_classes = PASCAL_VOC_ALL_CATEGORIES[sid]\n    elif keepclasses.startswith('base'):\n        thing_classes = PASCAL_VOC_BASE_CATEGORIES[sid]\n    elif keepclasses.startswith('novel'):\n        thing_classes = PASCAL_VOC_NOVEL_CATEGORIES[sid]\n    DatasetCatalog.register(name, lambda : load_filtered_voc_instances(name, root, dirname, split, thing_classes))\n    MetadataCatalog.get(name).set(thing_classes=thing_classes, dirname=os.path.join(root, dirname), year=year, split=split, base_classes=PASCAL_VOC_BASE_CATEGORIES[sid], novel_classes=PASCAL_VOC_NOVEL_CATEGORIES[sid])",
        "mutated": [
            "def register_meta_voc(name, root, dirname, split, year, keepclasses, sid):\n    if False:\n        i = 10\n    if keepclasses.startswith('base_novel'):\n        thing_classes = PASCAL_VOC_ALL_CATEGORIES[sid]\n    elif keepclasses.startswith('base'):\n        thing_classes = PASCAL_VOC_BASE_CATEGORIES[sid]\n    elif keepclasses.startswith('novel'):\n        thing_classes = PASCAL_VOC_NOVEL_CATEGORIES[sid]\n    DatasetCatalog.register(name, lambda : load_filtered_voc_instances(name, root, dirname, split, thing_classes))\n    MetadataCatalog.get(name).set(thing_classes=thing_classes, dirname=os.path.join(root, dirname), year=year, split=split, base_classes=PASCAL_VOC_BASE_CATEGORIES[sid], novel_classes=PASCAL_VOC_NOVEL_CATEGORIES[sid])",
            "def register_meta_voc(name, root, dirname, split, year, keepclasses, sid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if keepclasses.startswith('base_novel'):\n        thing_classes = PASCAL_VOC_ALL_CATEGORIES[sid]\n    elif keepclasses.startswith('base'):\n        thing_classes = PASCAL_VOC_BASE_CATEGORIES[sid]\n    elif keepclasses.startswith('novel'):\n        thing_classes = PASCAL_VOC_NOVEL_CATEGORIES[sid]\n    DatasetCatalog.register(name, lambda : load_filtered_voc_instances(name, root, dirname, split, thing_classes))\n    MetadataCatalog.get(name).set(thing_classes=thing_classes, dirname=os.path.join(root, dirname), year=year, split=split, base_classes=PASCAL_VOC_BASE_CATEGORIES[sid], novel_classes=PASCAL_VOC_NOVEL_CATEGORIES[sid])",
            "def register_meta_voc(name, root, dirname, split, year, keepclasses, sid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if keepclasses.startswith('base_novel'):\n        thing_classes = PASCAL_VOC_ALL_CATEGORIES[sid]\n    elif keepclasses.startswith('base'):\n        thing_classes = PASCAL_VOC_BASE_CATEGORIES[sid]\n    elif keepclasses.startswith('novel'):\n        thing_classes = PASCAL_VOC_NOVEL_CATEGORIES[sid]\n    DatasetCatalog.register(name, lambda : load_filtered_voc_instances(name, root, dirname, split, thing_classes))\n    MetadataCatalog.get(name).set(thing_classes=thing_classes, dirname=os.path.join(root, dirname), year=year, split=split, base_classes=PASCAL_VOC_BASE_CATEGORIES[sid], novel_classes=PASCAL_VOC_NOVEL_CATEGORIES[sid])",
            "def register_meta_voc(name, root, dirname, split, year, keepclasses, sid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if keepclasses.startswith('base_novel'):\n        thing_classes = PASCAL_VOC_ALL_CATEGORIES[sid]\n    elif keepclasses.startswith('base'):\n        thing_classes = PASCAL_VOC_BASE_CATEGORIES[sid]\n    elif keepclasses.startswith('novel'):\n        thing_classes = PASCAL_VOC_NOVEL_CATEGORIES[sid]\n    DatasetCatalog.register(name, lambda : load_filtered_voc_instances(name, root, dirname, split, thing_classes))\n    MetadataCatalog.get(name).set(thing_classes=thing_classes, dirname=os.path.join(root, dirname), year=year, split=split, base_classes=PASCAL_VOC_BASE_CATEGORIES[sid], novel_classes=PASCAL_VOC_NOVEL_CATEGORIES[sid])",
            "def register_meta_voc(name, root, dirname, split, year, keepclasses, sid):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if keepclasses.startswith('base_novel'):\n        thing_classes = PASCAL_VOC_ALL_CATEGORIES[sid]\n    elif keepclasses.startswith('base'):\n        thing_classes = PASCAL_VOC_BASE_CATEGORIES[sid]\n    elif keepclasses.startswith('novel'):\n        thing_classes = PASCAL_VOC_NOVEL_CATEGORIES[sid]\n    DatasetCatalog.register(name, lambda : load_filtered_voc_instances(name, root, dirname, split, thing_classes))\n    MetadataCatalog.get(name).set(thing_classes=thing_classes, dirname=os.path.join(root, dirname), year=year, split=split, base_classes=PASCAL_VOC_BASE_CATEGORIES[sid], novel_classes=PASCAL_VOC_NOVEL_CATEGORIES[sid])"
        ]
    },
    {
        "func_name": "register_all_voc",
        "original": "def register_all_voc(root='datasets'):\n    METASPLITS = [('voc_2007_trainval_base1', 'VOC2007', 'trainval', 'base1', 1), ('voc_2007_trainval_base2', 'VOC2007', 'trainval', 'base2', 2), ('voc_2007_trainval_base3', 'VOC2007', 'trainval', 'base3', 3), ('voc_2012_trainval_base1', 'VOC2012', 'trainval', 'base1', 1), ('voc_2012_trainval_base2', 'VOC2012', 'trainval', 'base2', 2), ('voc_2012_trainval_base3', 'VOC2012', 'trainval', 'base3', 3), ('voc_2007_trainval_all1', 'VOC2007', 'trainval', 'base_novel_1', 1), ('voc_2007_trainval_all2', 'VOC2007', 'trainval', 'base_novel_2', 2), ('voc_2007_trainval_all3', 'VOC2007', 'trainval', 'base_novel_3', 3), ('voc_2012_trainval_all1', 'VOC2012', 'trainval', 'base_novel_1', 1), ('voc_2012_trainval_all2', 'VOC2012', 'trainval', 'base_novel_2', 2), ('voc_2012_trainval_all3', 'VOC2012', 'trainval', 'base_novel_3', 3), ('voc_2007_test_base1', 'VOC2007', 'test', 'base1', 1), ('voc_2007_test_base2', 'VOC2007', 'test', 'base2', 2), ('voc_2007_test_base3', 'VOC2007', 'test', 'base3', 3), ('voc_2007_test_novel1', 'VOC2007', 'test', 'novel1', 1), ('voc_2007_test_novel2', 'VOC2007', 'test', 'novel2', 2), ('voc_2007_test_novel3', 'VOC2007', 'test', 'novel3', 3), ('voc_2007_test_all1', 'VOC2007', 'test', 'base_novel_1', 1), ('voc_2007_test_all2', 'VOC2007', 'test', 'base_novel_2', 2), ('voc_2007_test_all3', 'VOC2007', 'test', 'base_novel_3', 3)]\n    for prefix in ['all', 'novel']:\n        for sid in range(1, 4):\n            for shot in [1, 2, 3, 5, 10]:\n                for year in [2007, 2012]:\n                    for seed in range(30):\n                        seed = '_seed{}'.format(seed)\n                        name = 'voc_{}_trainval_{}{}_{}shot{}'.format(year, prefix, sid, shot, seed)\n                        dirname = 'VOC{}'.format(year)\n                        img_file = '{}_{}shot_split_{}_trainval'.format(prefix, shot, sid)\n                        keepclasses = 'base_novel_{}'.format(sid) if prefix == 'all' else 'novel{}'.format(sid)\n                        METASPLITS.append((name, dirname, img_file, keepclasses, sid))\n    for (name, dirname, split, keepclasses, sid) in METASPLITS:\n        if name in DatasetCatalog:\n            continue\n        year = 2007 if '2007' in name else 2012\n        register_meta_voc(name, root, dirname, split, year, keepclasses, sid)\n        MetadataCatalog.get(name).evaluator_type = 'pascal_voc'",
        "mutated": [
            "def register_all_voc(root='datasets'):\n    if False:\n        i = 10\n    METASPLITS = [('voc_2007_trainval_base1', 'VOC2007', 'trainval', 'base1', 1), ('voc_2007_trainval_base2', 'VOC2007', 'trainval', 'base2', 2), ('voc_2007_trainval_base3', 'VOC2007', 'trainval', 'base3', 3), ('voc_2012_trainval_base1', 'VOC2012', 'trainval', 'base1', 1), ('voc_2012_trainval_base2', 'VOC2012', 'trainval', 'base2', 2), ('voc_2012_trainval_base3', 'VOC2012', 'trainval', 'base3', 3), ('voc_2007_trainval_all1', 'VOC2007', 'trainval', 'base_novel_1', 1), ('voc_2007_trainval_all2', 'VOC2007', 'trainval', 'base_novel_2', 2), ('voc_2007_trainval_all3', 'VOC2007', 'trainval', 'base_novel_3', 3), ('voc_2012_trainval_all1', 'VOC2012', 'trainval', 'base_novel_1', 1), ('voc_2012_trainval_all2', 'VOC2012', 'trainval', 'base_novel_2', 2), ('voc_2012_trainval_all3', 'VOC2012', 'trainval', 'base_novel_3', 3), ('voc_2007_test_base1', 'VOC2007', 'test', 'base1', 1), ('voc_2007_test_base2', 'VOC2007', 'test', 'base2', 2), ('voc_2007_test_base3', 'VOC2007', 'test', 'base3', 3), ('voc_2007_test_novel1', 'VOC2007', 'test', 'novel1', 1), ('voc_2007_test_novel2', 'VOC2007', 'test', 'novel2', 2), ('voc_2007_test_novel3', 'VOC2007', 'test', 'novel3', 3), ('voc_2007_test_all1', 'VOC2007', 'test', 'base_novel_1', 1), ('voc_2007_test_all2', 'VOC2007', 'test', 'base_novel_2', 2), ('voc_2007_test_all3', 'VOC2007', 'test', 'base_novel_3', 3)]\n    for prefix in ['all', 'novel']:\n        for sid in range(1, 4):\n            for shot in [1, 2, 3, 5, 10]:\n                for year in [2007, 2012]:\n                    for seed in range(30):\n                        seed = '_seed{}'.format(seed)\n                        name = 'voc_{}_trainval_{}{}_{}shot{}'.format(year, prefix, sid, shot, seed)\n                        dirname = 'VOC{}'.format(year)\n                        img_file = '{}_{}shot_split_{}_trainval'.format(prefix, shot, sid)\n                        keepclasses = 'base_novel_{}'.format(sid) if prefix == 'all' else 'novel{}'.format(sid)\n                        METASPLITS.append((name, dirname, img_file, keepclasses, sid))\n    for (name, dirname, split, keepclasses, sid) in METASPLITS:\n        if name in DatasetCatalog:\n            continue\n        year = 2007 if '2007' in name else 2012\n        register_meta_voc(name, root, dirname, split, year, keepclasses, sid)\n        MetadataCatalog.get(name).evaluator_type = 'pascal_voc'",
            "def register_all_voc(root='datasets'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    METASPLITS = [('voc_2007_trainval_base1', 'VOC2007', 'trainval', 'base1', 1), ('voc_2007_trainval_base2', 'VOC2007', 'trainval', 'base2', 2), ('voc_2007_trainval_base3', 'VOC2007', 'trainval', 'base3', 3), ('voc_2012_trainval_base1', 'VOC2012', 'trainval', 'base1', 1), ('voc_2012_trainval_base2', 'VOC2012', 'trainval', 'base2', 2), ('voc_2012_trainval_base3', 'VOC2012', 'trainval', 'base3', 3), ('voc_2007_trainval_all1', 'VOC2007', 'trainval', 'base_novel_1', 1), ('voc_2007_trainval_all2', 'VOC2007', 'trainval', 'base_novel_2', 2), ('voc_2007_trainval_all3', 'VOC2007', 'trainval', 'base_novel_3', 3), ('voc_2012_trainval_all1', 'VOC2012', 'trainval', 'base_novel_1', 1), ('voc_2012_trainval_all2', 'VOC2012', 'trainval', 'base_novel_2', 2), ('voc_2012_trainval_all3', 'VOC2012', 'trainval', 'base_novel_3', 3), ('voc_2007_test_base1', 'VOC2007', 'test', 'base1', 1), ('voc_2007_test_base2', 'VOC2007', 'test', 'base2', 2), ('voc_2007_test_base3', 'VOC2007', 'test', 'base3', 3), ('voc_2007_test_novel1', 'VOC2007', 'test', 'novel1', 1), ('voc_2007_test_novel2', 'VOC2007', 'test', 'novel2', 2), ('voc_2007_test_novel3', 'VOC2007', 'test', 'novel3', 3), ('voc_2007_test_all1', 'VOC2007', 'test', 'base_novel_1', 1), ('voc_2007_test_all2', 'VOC2007', 'test', 'base_novel_2', 2), ('voc_2007_test_all3', 'VOC2007', 'test', 'base_novel_3', 3)]\n    for prefix in ['all', 'novel']:\n        for sid in range(1, 4):\n            for shot in [1, 2, 3, 5, 10]:\n                for year in [2007, 2012]:\n                    for seed in range(30):\n                        seed = '_seed{}'.format(seed)\n                        name = 'voc_{}_trainval_{}{}_{}shot{}'.format(year, prefix, sid, shot, seed)\n                        dirname = 'VOC{}'.format(year)\n                        img_file = '{}_{}shot_split_{}_trainval'.format(prefix, shot, sid)\n                        keepclasses = 'base_novel_{}'.format(sid) if prefix == 'all' else 'novel{}'.format(sid)\n                        METASPLITS.append((name, dirname, img_file, keepclasses, sid))\n    for (name, dirname, split, keepclasses, sid) in METASPLITS:\n        if name in DatasetCatalog:\n            continue\n        year = 2007 if '2007' in name else 2012\n        register_meta_voc(name, root, dirname, split, year, keepclasses, sid)\n        MetadataCatalog.get(name).evaluator_type = 'pascal_voc'",
            "def register_all_voc(root='datasets'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    METASPLITS = [('voc_2007_trainval_base1', 'VOC2007', 'trainval', 'base1', 1), ('voc_2007_trainval_base2', 'VOC2007', 'trainval', 'base2', 2), ('voc_2007_trainval_base3', 'VOC2007', 'trainval', 'base3', 3), ('voc_2012_trainval_base1', 'VOC2012', 'trainval', 'base1', 1), ('voc_2012_trainval_base2', 'VOC2012', 'trainval', 'base2', 2), ('voc_2012_trainval_base3', 'VOC2012', 'trainval', 'base3', 3), ('voc_2007_trainval_all1', 'VOC2007', 'trainval', 'base_novel_1', 1), ('voc_2007_trainval_all2', 'VOC2007', 'trainval', 'base_novel_2', 2), ('voc_2007_trainval_all3', 'VOC2007', 'trainval', 'base_novel_3', 3), ('voc_2012_trainval_all1', 'VOC2012', 'trainval', 'base_novel_1', 1), ('voc_2012_trainval_all2', 'VOC2012', 'trainval', 'base_novel_2', 2), ('voc_2012_trainval_all3', 'VOC2012', 'trainval', 'base_novel_3', 3), ('voc_2007_test_base1', 'VOC2007', 'test', 'base1', 1), ('voc_2007_test_base2', 'VOC2007', 'test', 'base2', 2), ('voc_2007_test_base3', 'VOC2007', 'test', 'base3', 3), ('voc_2007_test_novel1', 'VOC2007', 'test', 'novel1', 1), ('voc_2007_test_novel2', 'VOC2007', 'test', 'novel2', 2), ('voc_2007_test_novel3', 'VOC2007', 'test', 'novel3', 3), ('voc_2007_test_all1', 'VOC2007', 'test', 'base_novel_1', 1), ('voc_2007_test_all2', 'VOC2007', 'test', 'base_novel_2', 2), ('voc_2007_test_all3', 'VOC2007', 'test', 'base_novel_3', 3)]\n    for prefix in ['all', 'novel']:\n        for sid in range(1, 4):\n            for shot in [1, 2, 3, 5, 10]:\n                for year in [2007, 2012]:\n                    for seed in range(30):\n                        seed = '_seed{}'.format(seed)\n                        name = 'voc_{}_trainval_{}{}_{}shot{}'.format(year, prefix, sid, shot, seed)\n                        dirname = 'VOC{}'.format(year)\n                        img_file = '{}_{}shot_split_{}_trainval'.format(prefix, shot, sid)\n                        keepclasses = 'base_novel_{}'.format(sid) if prefix == 'all' else 'novel{}'.format(sid)\n                        METASPLITS.append((name, dirname, img_file, keepclasses, sid))\n    for (name, dirname, split, keepclasses, sid) in METASPLITS:\n        if name in DatasetCatalog:\n            continue\n        year = 2007 if '2007' in name else 2012\n        register_meta_voc(name, root, dirname, split, year, keepclasses, sid)\n        MetadataCatalog.get(name).evaluator_type = 'pascal_voc'",
            "def register_all_voc(root='datasets'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    METASPLITS = [('voc_2007_trainval_base1', 'VOC2007', 'trainval', 'base1', 1), ('voc_2007_trainval_base2', 'VOC2007', 'trainval', 'base2', 2), ('voc_2007_trainval_base3', 'VOC2007', 'trainval', 'base3', 3), ('voc_2012_trainval_base1', 'VOC2012', 'trainval', 'base1', 1), ('voc_2012_trainval_base2', 'VOC2012', 'trainval', 'base2', 2), ('voc_2012_trainval_base3', 'VOC2012', 'trainval', 'base3', 3), ('voc_2007_trainval_all1', 'VOC2007', 'trainval', 'base_novel_1', 1), ('voc_2007_trainval_all2', 'VOC2007', 'trainval', 'base_novel_2', 2), ('voc_2007_trainval_all3', 'VOC2007', 'trainval', 'base_novel_3', 3), ('voc_2012_trainval_all1', 'VOC2012', 'trainval', 'base_novel_1', 1), ('voc_2012_trainval_all2', 'VOC2012', 'trainval', 'base_novel_2', 2), ('voc_2012_trainval_all3', 'VOC2012', 'trainval', 'base_novel_3', 3), ('voc_2007_test_base1', 'VOC2007', 'test', 'base1', 1), ('voc_2007_test_base2', 'VOC2007', 'test', 'base2', 2), ('voc_2007_test_base3', 'VOC2007', 'test', 'base3', 3), ('voc_2007_test_novel1', 'VOC2007', 'test', 'novel1', 1), ('voc_2007_test_novel2', 'VOC2007', 'test', 'novel2', 2), ('voc_2007_test_novel3', 'VOC2007', 'test', 'novel3', 3), ('voc_2007_test_all1', 'VOC2007', 'test', 'base_novel_1', 1), ('voc_2007_test_all2', 'VOC2007', 'test', 'base_novel_2', 2), ('voc_2007_test_all3', 'VOC2007', 'test', 'base_novel_3', 3)]\n    for prefix in ['all', 'novel']:\n        for sid in range(1, 4):\n            for shot in [1, 2, 3, 5, 10]:\n                for year in [2007, 2012]:\n                    for seed in range(30):\n                        seed = '_seed{}'.format(seed)\n                        name = 'voc_{}_trainval_{}{}_{}shot{}'.format(year, prefix, sid, shot, seed)\n                        dirname = 'VOC{}'.format(year)\n                        img_file = '{}_{}shot_split_{}_trainval'.format(prefix, shot, sid)\n                        keepclasses = 'base_novel_{}'.format(sid) if prefix == 'all' else 'novel{}'.format(sid)\n                        METASPLITS.append((name, dirname, img_file, keepclasses, sid))\n    for (name, dirname, split, keepclasses, sid) in METASPLITS:\n        if name in DatasetCatalog:\n            continue\n        year = 2007 if '2007' in name else 2012\n        register_meta_voc(name, root, dirname, split, year, keepclasses, sid)\n        MetadataCatalog.get(name).evaluator_type = 'pascal_voc'",
            "def register_all_voc(root='datasets'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    METASPLITS = [('voc_2007_trainval_base1', 'VOC2007', 'trainval', 'base1', 1), ('voc_2007_trainval_base2', 'VOC2007', 'trainval', 'base2', 2), ('voc_2007_trainval_base3', 'VOC2007', 'trainval', 'base3', 3), ('voc_2012_trainval_base1', 'VOC2012', 'trainval', 'base1', 1), ('voc_2012_trainval_base2', 'VOC2012', 'trainval', 'base2', 2), ('voc_2012_trainval_base3', 'VOC2012', 'trainval', 'base3', 3), ('voc_2007_trainval_all1', 'VOC2007', 'trainval', 'base_novel_1', 1), ('voc_2007_trainval_all2', 'VOC2007', 'trainval', 'base_novel_2', 2), ('voc_2007_trainval_all3', 'VOC2007', 'trainval', 'base_novel_3', 3), ('voc_2012_trainval_all1', 'VOC2012', 'trainval', 'base_novel_1', 1), ('voc_2012_trainval_all2', 'VOC2012', 'trainval', 'base_novel_2', 2), ('voc_2012_trainval_all3', 'VOC2012', 'trainval', 'base_novel_3', 3), ('voc_2007_test_base1', 'VOC2007', 'test', 'base1', 1), ('voc_2007_test_base2', 'VOC2007', 'test', 'base2', 2), ('voc_2007_test_base3', 'VOC2007', 'test', 'base3', 3), ('voc_2007_test_novel1', 'VOC2007', 'test', 'novel1', 1), ('voc_2007_test_novel2', 'VOC2007', 'test', 'novel2', 2), ('voc_2007_test_novel3', 'VOC2007', 'test', 'novel3', 3), ('voc_2007_test_all1', 'VOC2007', 'test', 'base_novel_1', 1), ('voc_2007_test_all2', 'VOC2007', 'test', 'base_novel_2', 2), ('voc_2007_test_all3', 'VOC2007', 'test', 'base_novel_3', 3)]\n    for prefix in ['all', 'novel']:\n        for sid in range(1, 4):\n            for shot in [1, 2, 3, 5, 10]:\n                for year in [2007, 2012]:\n                    for seed in range(30):\n                        seed = '_seed{}'.format(seed)\n                        name = 'voc_{}_trainval_{}{}_{}shot{}'.format(year, prefix, sid, shot, seed)\n                        dirname = 'VOC{}'.format(year)\n                        img_file = '{}_{}shot_split_{}_trainval'.format(prefix, shot, sid)\n                        keepclasses = 'base_novel_{}'.format(sid) if prefix == 'all' else 'novel{}'.format(sid)\n                        METASPLITS.append((name, dirname, img_file, keepclasses, sid))\n    for (name, dirname, split, keepclasses, sid) in METASPLITS:\n        if name in DatasetCatalog:\n            continue\n        year = 2007 if '2007' in name else 2012\n        register_meta_voc(name, root, dirname, split, year, keepclasses, sid)\n        MetadataCatalog.get(name).evaluator_type = 'pascal_voc'"
        ]
    }
]