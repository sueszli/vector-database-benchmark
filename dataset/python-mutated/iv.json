[
    {
        "func_name": "prepare_events",
        "original": "def prepare_events(events):\n    \"\"\"Standardize event functions and extract is_terminal and direction.\"\"\"\n    if callable(events):\n        events = (events,)\n    if events is not None:\n        is_terminal = np.empty(len(events), dtype=bool)\n        direction = np.empty(len(events))\n        for (i, event) in enumerate(events):\n            try:\n                is_terminal[i] = event.terminal\n            except AttributeError:\n                is_terminal[i] = False\n            try:\n                direction[i] = event.direction\n            except AttributeError:\n                direction[i] = 0\n    else:\n        is_terminal = None\n        direction = None\n    return (events, is_terminal, direction)",
        "mutated": [
            "def prepare_events(events):\n    if False:\n        i = 10\n    'Standardize event functions and extract is_terminal and direction.'\n    if callable(events):\n        events = (events,)\n    if events is not None:\n        is_terminal = np.empty(len(events), dtype=bool)\n        direction = np.empty(len(events))\n        for (i, event) in enumerate(events):\n            try:\n                is_terminal[i] = event.terminal\n            except AttributeError:\n                is_terminal[i] = False\n            try:\n                direction[i] = event.direction\n            except AttributeError:\n                direction[i] = 0\n    else:\n        is_terminal = None\n        direction = None\n    return (events, is_terminal, direction)",
            "def prepare_events(events):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Standardize event functions and extract is_terminal and direction.'\n    if callable(events):\n        events = (events,)\n    if events is not None:\n        is_terminal = np.empty(len(events), dtype=bool)\n        direction = np.empty(len(events))\n        for (i, event) in enumerate(events):\n            try:\n                is_terminal[i] = event.terminal\n            except AttributeError:\n                is_terminal[i] = False\n            try:\n                direction[i] = event.direction\n            except AttributeError:\n                direction[i] = 0\n    else:\n        is_terminal = None\n        direction = None\n    return (events, is_terminal, direction)",
            "def prepare_events(events):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Standardize event functions and extract is_terminal and direction.'\n    if callable(events):\n        events = (events,)\n    if events is not None:\n        is_terminal = np.empty(len(events), dtype=bool)\n        direction = np.empty(len(events))\n        for (i, event) in enumerate(events):\n            try:\n                is_terminal[i] = event.terminal\n            except AttributeError:\n                is_terminal[i] = False\n            try:\n                direction[i] = event.direction\n            except AttributeError:\n                direction[i] = 0\n    else:\n        is_terminal = None\n        direction = None\n    return (events, is_terminal, direction)",
            "def prepare_events(events):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Standardize event functions and extract is_terminal and direction.'\n    if callable(events):\n        events = (events,)\n    if events is not None:\n        is_terminal = np.empty(len(events), dtype=bool)\n        direction = np.empty(len(events))\n        for (i, event) in enumerate(events):\n            try:\n                is_terminal[i] = event.terminal\n            except AttributeError:\n                is_terminal[i] = False\n            try:\n                direction[i] = event.direction\n            except AttributeError:\n                direction[i] = 0\n    else:\n        is_terminal = None\n        direction = None\n    return (events, is_terminal, direction)",
            "def prepare_events(events):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Standardize event functions and extract is_terminal and direction.'\n    if callable(events):\n        events = (events,)\n    if events is not None:\n        is_terminal = np.empty(len(events), dtype=bool)\n        direction = np.empty(len(events))\n        for (i, event) in enumerate(events):\n            try:\n                is_terminal[i] = event.terminal\n            except AttributeError:\n                is_terminal[i] = False\n            try:\n                direction[i] = event.direction\n            except AttributeError:\n                direction[i] = 0\n    else:\n        is_terminal = None\n        direction = None\n    return (events, is_terminal, direction)"
        ]
    },
    {
        "func_name": "solve_event_equation",
        "original": "def solve_event_equation(event, sol, t_old, t):\n    \"\"\"Solve an equation corresponding to an ODE event.\n\n    The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an\n    ODE solver using some sort of interpolation. It is solved by\n    `scipy.optimize.brentq` with xtol=atol=4*EPS.\n\n    Parameters\n    ----------\n    event : callable\n        Function ``event(t, y)``.\n    sol : callable\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\n        and  `t`.\n    t_old, t : float\n        Previous and new values of time. They will be used as a bracketing\n        interval.\n\n    Returns\n    -------\n    root : float\n        Found solution.\n    \"\"\"\n    from scipy.optimize import brentq\n    return brentq(lambda t: event(t, sol(t)), t_old, t, xtol=4 * EPS, rtol=4 * EPS)",
        "mutated": [
            "def solve_event_equation(event, sol, t_old, t):\n    if False:\n        i = 10\n    'Solve an equation corresponding to an ODE event.\\n\\n    The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an\\n    ODE solver using some sort of interpolation. It is solved by\\n    `scipy.optimize.brentq` with xtol=atol=4*EPS.\\n\\n    Parameters\\n    ----------\\n    event : callable\\n        Function ``event(t, y)``.\\n    sol : callable\\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\\n        and  `t`.\\n    t_old, t : float\\n        Previous and new values of time. They will be used as a bracketing\\n        interval.\\n\\n    Returns\\n    -------\\n    root : float\\n        Found solution.\\n    '\n    from scipy.optimize import brentq\n    return brentq(lambda t: event(t, sol(t)), t_old, t, xtol=4 * EPS, rtol=4 * EPS)",
            "def solve_event_equation(event, sol, t_old, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Solve an equation corresponding to an ODE event.\\n\\n    The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an\\n    ODE solver using some sort of interpolation. It is solved by\\n    `scipy.optimize.brentq` with xtol=atol=4*EPS.\\n\\n    Parameters\\n    ----------\\n    event : callable\\n        Function ``event(t, y)``.\\n    sol : callable\\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\\n        and  `t`.\\n    t_old, t : float\\n        Previous and new values of time. They will be used as a bracketing\\n        interval.\\n\\n    Returns\\n    -------\\n    root : float\\n        Found solution.\\n    '\n    from scipy.optimize import brentq\n    return brentq(lambda t: event(t, sol(t)), t_old, t, xtol=4 * EPS, rtol=4 * EPS)",
            "def solve_event_equation(event, sol, t_old, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Solve an equation corresponding to an ODE event.\\n\\n    The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an\\n    ODE solver using some sort of interpolation. It is solved by\\n    `scipy.optimize.brentq` with xtol=atol=4*EPS.\\n\\n    Parameters\\n    ----------\\n    event : callable\\n        Function ``event(t, y)``.\\n    sol : callable\\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\\n        and  `t`.\\n    t_old, t : float\\n        Previous and new values of time. They will be used as a bracketing\\n        interval.\\n\\n    Returns\\n    -------\\n    root : float\\n        Found solution.\\n    '\n    from scipy.optimize import brentq\n    return brentq(lambda t: event(t, sol(t)), t_old, t, xtol=4 * EPS, rtol=4 * EPS)",
            "def solve_event_equation(event, sol, t_old, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Solve an equation corresponding to an ODE event.\\n\\n    The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an\\n    ODE solver using some sort of interpolation. It is solved by\\n    `scipy.optimize.brentq` with xtol=atol=4*EPS.\\n\\n    Parameters\\n    ----------\\n    event : callable\\n        Function ``event(t, y)``.\\n    sol : callable\\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\\n        and  `t`.\\n    t_old, t : float\\n        Previous and new values of time. They will be used as a bracketing\\n        interval.\\n\\n    Returns\\n    -------\\n    root : float\\n        Found solution.\\n    '\n    from scipy.optimize import brentq\n    return brentq(lambda t: event(t, sol(t)), t_old, t, xtol=4 * EPS, rtol=4 * EPS)",
            "def solve_event_equation(event, sol, t_old, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Solve an equation corresponding to an ODE event.\\n\\n    The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an\\n    ODE solver using some sort of interpolation. It is solved by\\n    `scipy.optimize.brentq` with xtol=atol=4*EPS.\\n\\n    Parameters\\n    ----------\\n    event : callable\\n        Function ``event(t, y)``.\\n    sol : callable\\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\\n        and  `t`.\\n    t_old, t : float\\n        Previous and new values of time. They will be used as a bracketing\\n        interval.\\n\\n    Returns\\n    -------\\n    root : float\\n        Found solution.\\n    '\n    from scipy.optimize import brentq\n    return brentq(lambda t: event(t, sol(t)), t_old, t, xtol=4 * EPS, rtol=4 * EPS)"
        ]
    },
    {
        "func_name": "handle_events",
        "original": "def handle_events(sol, events, active_events, is_terminal, t_old, t):\n    \"\"\"Helper function to handle events.\n\n    Parameters\n    ----------\n    sol : DenseOutput\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\n        and  `t`.\n    events : list of callables, length n_events\n        Event functions with signatures ``event(t, y)``.\n    active_events : ndarray\n        Indices of events which occurred.\n    is_terminal : ndarray, shape (n_events,)\n        Which events are terminal.\n    t_old, t : float\n        Previous and new values of time.\n\n    Returns\n    -------\n    root_indices : ndarray\n        Indices of events which take zero between `t_old` and `t` and before\n        a possible termination.\n    roots : ndarray\n        Values of t at which events occurred.\n    terminate : bool\n        Whether a terminal event occurred.\n    \"\"\"\n    roots = [solve_event_equation(events[event_index], sol, t_old, t) for event_index in active_events]\n    roots = np.asarray(roots)\n    if np.any(is_terminal[active_events]):\n        if t > t_old:\n            order = np.argsort(roots)\n        else:\n            order = np.argsort(-roots)\n        active_events = active_events[order]\n        roots = roots[order]\n        t = np.nonzero(is_terminal[active_events])[0][0]\n        active_events = active_events[:t + 1]\n        roots = roots[:t + 1]\n        terminate = True\n    else:\n        terminate = False\n    return (active_events, roots, terminate)",
        "mutated": [
            "def handle_events(sol, events, active_events, is_terminal, t_old, t):\n    if False:\n        i = 10\n    'Helper function to handle events.\\n\\n    Parameters\\n    ----------\\n    sol : DenseOutput\\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\\n        and  `t`.\\n    events : list of callables, length n_events\\n        Event functions with signatures ``event(t, y)``.\\n    active_events : ndarray\\n        Indices of events which occurred.\\n    is_terminal : ndarray, shape (n_events,)\\n        Which events are terminal.\\n    t_old, t : float\\n        Previous and new values of time.\\n\\n    Returns\\n    -------\\n    root_indices : ndarray\\n        Indices of events which take zero between `t_old` and `t` and before\\n        a possible termination.\\n    roots : ndarray\\n        Values of t at which events occurred.\\n    terminate : bool\\n        Whether a terminal event occurred.\\n    '\n    roots = [solve_event_equation(events[event_index], sol, t_old, t) for event_index in active_events]\n    roots = np.asarray(roots)\n    if np.any(is_terminal[active_events]):\n        if t > t_old:\n            order = np.argsort(roots)\n        else:\n            order = np.argsort(-roots)\n        active_events = active_events[order]\n        roots = roots[order]\n        t = np.nonzero(is_terminal[active_events])[0][0]\n        active_events = active_events[:t + 1]\n        roots = roots[:t + 1]\n        terminate = True\n    else:\n        terminate = False\n    return (active_events, roots, terminate)",
            "def handle_events(sol, events, active_events, is_terminal, t_old, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Helper function to handle events.\\n\\n    Parameters\\n    ----------\\n    sol : DenseOutput\\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\\n        and  `t`.\\n    events : list of callables, length n_events\\n        Event functions with signatures ``event(t, y)``.\\n    active_events : ndarray\\n        Indices of events which occurred.\\n    is_terminal : ndarray, shape (n_events,)\\n        Which events are terminal.\\n    t_old, t : float\\n        Previous and new values of time.\\n\\n    Returns\\n    -------\\n    root_indices : ndarray\\n        Indices of events which take zero between `t_old` and `t` and before\\n        a possible termination.\\n    roots : ndarray\\n        Values of t at which events occurred.\\n    terminate : bool\\n        Whether a terminal event occurred.\\n    '\n    roots = [solve_event_equation(events[event_index], sol, t_old, t) for event_index in active_events]\n    roots = np.asarray(roots)\n    if np.any(is_terminal[active_events]):\n        if t > t_old:\n            order = np.argsort(roots)\n        else:\n            order = np.argsort(-roots)\n        active_events = active_events[order]\n        roots = roots[order]\n        t = np.nonzero(is_terminal[active_events])[0][0]\n        active_events = active_events[:t + 1]\n        roots = roots[:t + 1]\n        terminate = True\n    else:\n        terminate = False\n    return (active_events, roots, terminate)",
            "def handle_events(sol, events, active_events, is_terminal, t_old, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Helper function to handle events.\\n\\n    Parameters\\n    ----------\\n    sol : DenseOutput\\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\\n        and  `t`.\\n    events : list of callables, length n_events\\n        Event functions with signatures ``event(t, y)``.\\n    active_events : ndarray\\n        Indices of events which occurred.\\n    is_terminal : ndarray, shape (n_events,)\\n        Which events are terminal.\\n    t_old, t : float\\n        Previous and new values of time.\\n\\n    Returns\\n    -------\\n    root_indices : ndarray\\n        Indices of events which take zero between `t_old` and `t` and before\\n        a possible termination.\\n    roots : ndarray\\n        Values of t at which events occurred.\\n    terminate : bool\\n        Whether a terminal event occurred.\\n    '\n    roots = [solve_event_equation(events[event_index], sol, t_old, t) for event_index in active_events]\n    roots = np.asarray(roots)\n    if np.any(is_terminal[active_events]):\n        if t > t_old:\n            order = np.argsort(roots)\n        else:\n            order = np.argsort(-roots)\n        active_events = active_events[order]\n        roots = roots[order]\n        t = np.nonzero(is_terminal[active_events])[0][0]\n        active_events = active_events[:t + 1]\n        roots = roots[:t + 1]\n        terminate = True\n    else:\n        terminate = False\n    return (active_events, roots, terminate)",
            "def handle_events(sol, events, active_events, is_terminal, t_old, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Helper function to handle events.\\n\\n    Parameters\\n    ----------\\n    sol : DenseOutput\\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\\n        and  `t`.\\n    events : list of callables, length n_events\\n        Event functions with signatures ``event(t, y)``.\\n    active_events : ndarray\\n        Indices of events which occurred.\\n    is_terminal : ndarray, shape (n_events,)\\n        Which events are terminal.\\n    t_old, t : float\\n        Previous and new values of time.\\n\\n    Returns\\n    -------\\n    root_indices : ndarray\\n        Indices of events which take zero between `t_old` and `t` and before\\n        a possible termination.\\n    roots : ndarray\\n        Values of t at which events occurred.\\n    terminate : bool\\n        Whether a terminal event occurred.\\n    '\n    roots = [solve_event_equation(events[event_index], sol, t_old, t) for event_index in active_events]\n    roots = np.asarray(roots)\n    if np.any(is_terminal[active_events]):\n        if t > t_old:\n            order = np.argsort(roots)\n        else:\n            order = np.argsort(-roots)\n        active_events = active_events[order]\n        roots = roots[order]\n        t = np.nonzero(is_terminal[active_events])[0][0]\n        active_events = active_events[:t + 1]\n        roots = roots[:t + 1]\n        terminate = True\n    else:\n        terminate = False\n    return (active_events, roots, terminate)",
            "def handle_events(sol, events, active_events, is_terminal, t_old, t):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Helper function to handle events.\\n\\n    Parameters\\n    ----------\\n    sol : DenseOutput\\n        Function ``sol(t)`` which evaluates an ODE solution between `t_old`\\n        and  `t`.\\n    events : list of callables, length n_events\\n        Event functions with signatures ``event(t, y)``.\\n    active_events : ndarray\\n        Indices of events which occurred.\\n    is_terminal : ndarray, shape (n_events,)\\n        Which events are terminal.\\n    t_old, t : float\\n        Previous and new values of time.\\n\\n    Returns\\n    -------\\n    root_indices : ndarray\\n        Indices of events which take zero between `t_old` and `t` and before\\n        a possible termination.\\n    roots : ndarray\\n        Values of t at which events occurred.\\n    terminate : bool\\n        Whether a terminal event occurred.\\n    '\n    roots = [solve_event_equation(events[event_index], sol, t_old, t) for event_index in active_events]\n    roots = np.asarray(roots)\n    if np.any(is_terminal[active_events]):\n        if t > t_old:\n            order = np.argsort(roots)\n        else:\n            order = np.argsort(-roots)\n        active_events = active_events[order]\n        roots = roots[order]\n        t = np.nonzero(is_terminal[active_events])[0][0]\n        active_events = active_events[:t + 1]\n        roots = roots[:t + 1]\n        terminate = True\n    else:\n        terminate = False\n    return (active_events, roots, terminate)"
        ]
    },
    {
        "func_name": "find_active_events",
        "original": "def find_active_events(g, g_new, direction):\n    \"\"\"Find which event occurred during an integration step.\n\n    Parameters\n    ----------\n    g, g_new : array_like, shape (n_events,)\n        Values of event functions at a current and next points.\n    direction : ndarray, shape (n_events,)\n        Event \"direction\" according to the definition in `solve_ivp`.\n\n    Returns\n    -------\n    active_events : ndarray\n        Indices of events which occurred during the step.\n    \"\"\"\n    (g, g_new) = (np.asarray(g), np.asarray(g_new))\n    up = (g <= 0) & (g_new >= 0)\n    down = (g >= 0) & (g_new <= 0)\n    either = up | down\n    mask = up & (direction > 0) | down & (direction < 0) | either & (direction == 0)\n    return np.nonzero(mask)[0]",
        "mutated": [
            "def find_active_events(g, g_new, direction):\n    if False:\n        i = 10\n    'Find which event occurred during an integration step.\\n\\n    Parameters\\n    ----------\\n    g, g_new : array_like, shape (n_events,)\\n        Values of event functions at a current and next points.\\n    direction : ndarray, shape (n_events,)\\n        Event \"direction\" according to the definition in `solve_ivp`.\\n\\n    Returns\\n    -------\\n    active_events : ndarray\\n        Indices of events which occurred during the step.\\n    '\n    (g, g_new) = (np.asarray(g), np.asarray(g_new))\n    up = (g <= 0) & (g_new >= 0)\n    down = (g >= 0) & (g_new <= 0)\n    either = up | down\n    mask = up & (direction > 0) | down & (direction < 0) | either & (direction == 0)\n    return np.nonzero(mask)[0]",
            "def find_active_events(g, g_new, direction):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Find which event occurred during an integration step.\\n\\n    Parameters\\n    ----------\\n    g, g_new : array_like, shape (n_events,)\\n        Values of event functions at a current and next points.\\n    direction : ndarray, shape (n_events,)\\n        Event \"direction\" according to the definition in `solve_ivp`.\\n\\n    Returns\\n    -------\\n    active_events : ndarray\\n        Indices of events which occurred during the step.\\n    '\n    (g, g_new) = (np.asarray(g), np.asarray(g_new))\n    up = (g <= 0) & (g_new >= 0)\n    down = (g >= 0) & (g_new <= 0)\n    either = up | down\n    mask = up & (direction > 0) | down & (direction < 0) | either & (direction == 0)\n    return np.nonzero(mask)[0]",
            "def find_active_events(g, g_new, direction):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Find which event occurred during an integration step.\\n\\n    Parameters\\n    ----------\\n    g, g_new : array_like, shape (n_events,)\\n        Values of event functions at a current and next points.\\n    direction : ndarray, shape (n_events,)\\n        Event \"direction\" according to the definition in `solve_ivp`.\\n\\n    Returns\\n    -------\\n    active_events : ndarray\\n        Indices of events which occurred during the step.\\n    '\n    (g, g_new) = (np.asarray(g), np.asarray(g_new))\n    up = (g <= 0) & (g_new >= 0)\n    down = (g >= 0) & (g_new <= 0)\n    either = up | down\n    mask = up & (direction > 0) | down & (direction < 0) | either & (direction == 0)\n    return np.nonzero(mask)[0]",
            "def find_active_events(g, g_new, direction):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Find which event occurred during an integration step.\\n\\n    Parameters\\n    ----------\\n    g, g_new : array_like, shape (n_events,)\\n        Values of event functions at a current and next points.\\n    direction : ndarray, shape (n_events,)\\n        Event \"direction\" according to the definition in `solve_ivp`.\\n\\n    Returns\\n    -------\\n    active_events : ndarray\\n        Indices of events which occurred during the step.\\n    '\n    (g, g_new) = (np.asarray(g), np.asarray(g_new))\n    up = (g <= 0) & (g_new >= 0)\n    down = (g >= 0) & (g_new <= 0)\n    either = up | down\n    mask = up & (direction > 0) | down & (direction < 0) | either & (direction == 0)\n    return np.nonzero(mask)[0]",
            "def find_active_events(g, g_new, direction):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Find which event occurred during an integration step.\\n\\n    Parameters\\n    ----------\\n    g, g_new : array_like, shape (n_events,)\\n        Values of event functions at a current and next points.\\n    direction : ndarray, shape (n_events,)\\n        Event \"direction\" according to the definition in `solve_ivp`.\\n\\n    Returns\\n    -------\\n    active_events : ndarray\\n        Indices of events which occurred during the step.\\n    '\n    (g, g_new) = (np.asarray(g), np.asarray(g_new))\n    up = (g <= 0) & (g_new >= 0)\n    down = (g >= 0) & (g_new <= 0)\n    either = up | down\n    mask = up & (direction > 0) | down & (direction < 0) | either & (direction == 0)\n    return np.nonzero(mask)[0]"
        ]
    },
    {
        "func_name": "fun",
        "original": "def fun(t, x, fun=fun):\n    return fun(t, x, *args)",
        "mutated": [
            "def fun(t, x, fun=fun):\n    if False:\n        i = 10\n    return fun(t, x, *args)",
            "def fun(t, x, fun=fun):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    return fun(t, x, *args)",
            "def fun(t, x, fun=fun):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    return fun(t, x, *args)",
            "def fun(t, x, fun=fun):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    return fun(t, x, *args)",
            "def fun(t, x, fun=fun):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    return fun(t, x, *args)"
        ]
    },
    {
        "func_name": "solve_ivp",
        "original": "def solve_ivp(fun, t_span, y0, method='RK45', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options):\n    \"\"\"Solve an initial value problem for a system of ODEs.\n\n    This function numerically integrates a system of ordinary differential\n    equations given an initial value::\n\n        dy / dt = f(t, y)\n        y(t0) = y0\n\n    Here t is a 1-D independent variable (time), y(t) is an\n    N-D vector-valued function (state), and an N-D\n    vector-valued function f(t, y) determines the differential equations.\n    The goal is to find y(t) approximately satisfying the differential\n    equations, given an initial value y(t0)=y0.\n\n    Some of the solvers support integration in the complex domain, but note\n    that for stiff ODE solvers, the right-hand side must be\n    complex-differentiable (satisfy Cauchy-Riemann equations [11]_).\n    To solve a problem in the complex domain, pass y0 with a complex data type.\n    Another option always available is to rewrite your problem for real and\n    imaginary parts separately.\n\n    Parameters\n    ----------\n    fun : callable\n        Right-hand side of the system: the time derivative of the state ``y``\n        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a\n        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. Additional\n        arguments need to be passed if ``args`` is used (see documentation of\n        ``args`` argument). ``fun`` must return an array of the same shape as\n        ``y``. See `vectorized` for more information.\n    t_span : 2-member sequence\n        Interval of integration (t0, tf). The solver starts with t=t0 and\n        integrates until it reaches t=tf. Both t0 and tf must be floats\n        or values interpretable by the float conversion function.\n    y0 : array_like, shape (n,)\n        Initial state. For problems in the complex domain, pass `y0` with a\n        complex data type (even if the initial value is purely real).\n    method : string or `OdeSolver`, optional\n        Integration method to use:\n\n            * 'RK45' (default): Explicit Runge-Kutta method of order 5(4) [1]_.\n              The error is controlled assuming accuracy of the fourth-order\n              method, but steps are taken using the fifth-order accurate\n              formula (local extrapolation is done). A quartic interpolation\n              polynomial is used for the dense output [2]_. Can be applied in\n              the complex domain.\n            * 'RK23': Explicit Runge-Kutta method of order 3(2) [3]_. The error\n              is controlled assuming accuracy of the second-order method, but\n              steps are taken using the third-order accurate formula (local\n              extrapolation is done). A cubic Hermite polynomial is used for the\n              dense output. Can be applied in the complex domain.\n            * 'DOP853': Explicit Runge-Kutta method of order 8 [13]_.\n              Python implementation of the \"DOP853\" algorithm originally\n              written in Fortran [14]_. A 7-th order interpolation polynomial\n              accurate to 7-th order is used for the dense output.\n              Can be applied in the complex domain.\n            * 'Radau': Implicit Runge-Kutta method of the Radau IIA family of\n              order 5 [4]_. The error is controlled with a third-order accurate\n              embedded formula. A cubic polynomial which satisfies the\n              collocation conditions is used for the dense output.\n            * 'BDF': Implicit multi-step variable-order (1 to 5) method based\n              on a backward differentiation formula for the derivative\n              approximation [5]_. The implementation follows the one described\n              in [6]_. A quasi-constant step scheme is used and accuracy is\n              enhanced using the NDF modification. Can be applied in the\n              complex domain.\n            * 'LSODA': Adams/BDF method with automatic stiffness detection and\n              switching [7]_, [8]_. This is a wrapper of the Fortran solver\n              from ODEPACK.\n\n        Explicit Runge-Kutta methods ('RK23', 'RK45', 'DOP853') should be used\n        for non-stiff problems and implicit methods ('Radau', 'BDF') for\n        stiff problems [9]_. Among Runge-Kutta methods, 'DOP853' is recommended\n        for solving with high precision (low values of `rtol` and `atol`).\n\n        If not sure, first try to run 'RK45'. If it makes unusually many\n        iterations, diverges, or fails, your problem is likely to be stiff and\n        you should use 'Radau' or 'BDF'. 'LSODA' can also be a good universal\n        choice, but it might be somewhat less convenient to work with as it\n        wraps old Fortran code.\n\n        You can also pass an arbitrary class derived from `OdeSolver` which\n        implements the solver.\n    t_eval : array_like or None, optional\n        Times at which to store the computed solution, must be sorted and lie\n        within `t_span`. If None (default), use points selected by the solver.\n    dense_output : bool, optional\n        Whether to compute a continuous solution. Default is False.\n    events : callable, or list of callables, optional\n        Events to track. If None (default), no events will be tracked.\n        Each event occurs at the zeros of a continuous function of time and\n        state. Each function must have the signature ``event(t, y)`` where\n        additional argument have to be passed if ``args`` is used (see\n        documentation of ``args`` argument). Each function must return a\n        float. The solver will find an accurate value of `t` at which\n        ``event(t, y(t)) = 0`` using a root-finding algorithm. By default,\n        all zeros will be found. The solver looks for a sign change over\n        each step, so if multiple zero crossings occur within one step,\n        events may be missed. Additionally each `event` function might\n        have the following attributes:\n\n            terminal: bool, optional\n                Whether to terminate integration if this event occurs.\n                Implicitly False if not assigned.\n            direction: float, optional\n                Direction of a zero crossing. If `direction` is positive,\n                `event` will only trigger when going from negative to positive,\n                and vice versa if `direction` is negative. If 0, then either\n                direction will trigger event. Implicitly 0 if not assigned.\n\n        You can assign attributes like ``event.terminal = True`` to any\n        function in Python.\n    vectorized : bool, optional\n        Whether `fun` can be called in a vectorized fashion. Default is False.\n\n        If ``vectorized`` is False, `fun` will always be called with ``y`` of\n        shape ``(n,)``, where ``n = len(y0)``.\n\n        If ``vectorized`` is True, `fun` may be called with ``y`` of shape\n        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave\n        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of\n        the returned array is the time derivative of the state corresponding\n        with a column of ``y``).\n\n        Setting ``vectorized=True`` allows for faster finite difference\n        approximation of the Jacobian by methods 'Radau' and 'BDF', but\n        will result in slower execution for other methods and for 'Radau' and\n        'BDF' in some circumstances (e.g. small ``len(y0)``).\n    args : tuple, optional\n        Additional arguments to pass to the user-defined functions.  If given,\n        the additional arguments are passed to all user-defined functions.\n        So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,\n        then `jac` (if given) and any event functions must have the same\n        signature, and `args` must be a tuple of length 3.\n    **options\n        Options passed to a chosen solver. All options available for already\n        implemented solvers are listed below.\n    first_step : float or None, optional\n        Initial step size. Default is `None` which means that the algorithm\n        should choose.\n    max_step : float, optional\n        Maximum allowed step size. Default is np.inf, i.e., the step size is not\n        bounded and determined solely by the solver.\n    rtol, atol : float or array_like, optional\n        Relative and absolute tolerances. The solver keeps the local error\n        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a\n        relative accuracy (number of correct digits), while `atol` controls\n        absolute accuracy (number of correct decimal places). To achieve the\n        desired `rtol`, set `atol` to be smaller than the smallest value that\n        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the\n        allowable error. If `atol` is larger than ``rtol * abs(y)`` the\n        number of correct digits is not guaranteed. Conversely, to achieve the\n        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller\n        than `atol`. If components of y have different scales, it might be\n        beneficial to set different `atol` values for different components by\n        passing array_like with shape (n,) for `atol`. Default values are\n        1e-3 for `rtol` and 1e-6 for `atol`.\n    jac : array_like, sparse_matrix, callable or None, optional\n        Jacobian matrix of the right-hand side of the system with respect\n        to y, required by the 'Radau', 'BDF' and 'LSODA' method. The\n        Jacobian matrix has shape (n, n) and its element (i, j) is equal to\n        ``d f_i / d y_j``.  There are three ways to define the Jacobian:\n\n            * If array_like or sparse_matrix, the Jacobian is assumed to\n              be constant. Not supported by 'LSODA'.\n            * If callable, the Jacobian is assumed to depend on both\n              t and y; it will be called as ``jac(t, y)``, as necessary.\n              Additional arguments have to be passed if ``args`` is\n              used (see documentation of ``args`` argument).\n              For 'Radau' and 'BDF' methods, the return value might be a\n              sparse matrix.\n            * If None (default), the Jacobian will be approximated by\n              finite differences.\n\n        It is generally recommended to provide the Jacobian rather than\n        relying on a finite-difference approximation.\n    jac_sparsity : array_like, sparse matrix or None, optional\n        Defines a sparsity structure of the Jacobian matrix for a finite-\n        difference approximation. Its shape must be (n, n). This argument\n        is ignored if `jac` is not `None`. If the Jacobian has only few\n        non-zero elements in *each* row, providing the sparsity structure\n        will greatly speed up the computations [10]_. A zero entry means that\n        a corresponding element in the Jacobian is always zero. If None\n        (default), the Jacobian is assumed to be dense.\n        Not supported by 'LSODA', see `lband` and `uband` instead.\n    lband, uband : int or None, optional\n        Parameters defining the bandwidth of the Jacobian for the 'LSODA'\n        method, i.e., ``jac[i, j] != 0 only for i - lband <= j <= i + uband``.\n        Default is None. Setting these requires your jac routine to return the\n        Jacobian in the packed format: the returned array must have ``n``\n        columns and ``uband + lband + 1`` rows in which Jacobian diagonals are\n        written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.\n        The same format is used in `scipy.linalg.solve_banded` (check for an\n        illustration).  These parameters can be also used with ``jac=None`` to\n        reduce the number of Jacobian elements estimated by finite differences.\n    min_step : float, optional\n        The minimum allowed step size for 'LSODA' method.\n        By default `min_step` is zero.\n\n    Returns\n    -------\n    Bunch object with the following fields defined:\n    t : ndarray, shape (n_points,)\n        Time points.\n    y : ndarray, shape (n, n_points)\n        Values of the solution at `t`.\n    sol : `OdeSolution` or None\n        Found solution as `OdeSolution` instance; None if `dense_output` was\n        set to False.\n    t_events : list of ndarray or None\n        Contains for each event type a list of arrays at which an event of\n        that type event was detected. None if `events` was None.\n    y_events : list of ndarray or None\n        For each value of `t_events`, the corresponding value of the solution.\n        None if `events` was None.\n    nfev : int\n        Number of evaluations of the right-hand side.\n    njev : int\n        Number of evaluations of the Jacobian.\n    nlu : int\n        Number of LU decompositions.\n    status : int\n        Reason for algorithm termination:\n\n            * -1: Integration step failed.\n            *  0: The solver successfully reached the end of `tspan`.\n            *  1: A termination event occurred.\n\n    message : string\n        Human-readable description of the termination reason.\n    success : bool\n        True if the solver reached the interval end or a termination event\n        occurred (``status >= 0``).\n\n    References\n    ----------\n    .. [1] J. R. Dormand, P. J. Prince, \"A family of embedded Runge-Kutta\n           formulae\", Journal of Computational and Applied Mathematics, Vol. 6,\n           No. 1, pp. 19-26, 1980.\n    .. [2] L. W. Shampine, \"Some Practical Runge-Kutta Formulas\", Mathematics\n           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.\n    .. [3] P. Bogacki, L.F. Shampine, \"A 3(2) Pair of Runge-Kutta Formulas\",\n           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.\n    .. [4] E. Hairer, G. Wanner, \"Solving Ordinary Differential Equations II:\n           Stiff and Differential-Algebraic Problems\", Sec. IV.8.\n    .. [5] `Backward Differentiation Formula\n            <https://en.wikipedia.org/wiki/Backward_differentiation_formula>`_\n            on Wikipedia.\n    .. [6] L. F. Shampine, M. W. Reichelt, \"THE MATLAB ODE SUITE\", SIAM J. SCI.\n           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.\n    .. [7] A. C. Hindmarsh, \"ODEPACK, A Systematized Collection of ODE\n           Solvers,\" IMACS Transactions on Scientific Computation, Vol 1.,\n           pp. 55-64, 1983.\n    .. [8] L. Petzold, \"Automatic selection of methods for solving stiff and\n           nonstiff systems of ordinary differential equations\", SIAM Journal\n           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,\n           1983.\n    .. [9] `Stiff equation <https://en.wikipedia.org/wiki/Stiff_equation>`_ on\n           Wikipedia.\n    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, \"On the estimation of\n            sparse Jacobian matrices\", Journal of the Institute of Mathematics\n            and its Applications, 13, pp. 117-120, 1974.\n    .. [11] `Cauchy-Riemann equations\n             <https://en.wikipedia.org/wiki/Cauchy-Riemann_equations>`_ on\n             Wikipedia.\n    .. [12] `Lotka-Volterra equations\n            <https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations>`_\n            on Wikipedia.\n    .. [13] E. Hairer, S. P. Norsett G. Wanner, \"Solving Ordinary Differential\n            Equations I: Nonstiff Problems\", Sec. II.\n    .. [14] `Page with original Fortran code of DOP853\n            <http://www.unige.ch/~hairer/software.html>`_.\n\n    Examples\n    --------\n    Basic exponential decay showing automatically chosen time points.\n\n    >>> import numpy as np\n    >>> from scipy.integrate import solve_ivp\n    >>> def exponential_decay(t, y): return -0.5 * y\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])\n    >>> print(sol.t)\n    [ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806\n      8.33328988 10.        ]\n    >>> print(sol.y)\n    [[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045\n      0.03107158 0.01350781]\n     [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091\n      0.06214316 0.02701561]\n     [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181\n      0.12428631 0.05403123]]\n\n    Specifying points where the solution is desired.\n\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],\n    ...                 t_eval=[0, 1, 2, 4, 10])\n    >>> print(sol.t)\n    [ 0  1  2  4 10]\n    >>> print(sol.y)\n    [[2.         1.21305369 0.73534021 0.27066736 0.01350938]\n     [4.         2.42610739 1.47068043 0.54133472 0.02701876]\n     [8.         4.85221478 2.94136085 1.08266944 0.05403753]]\n\n    Cannon fired upward with terminal event upon impact. The ``terminal`` and\n    ``direction`` fields of an event are applied by monkey patching a function.\n    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts\n    at position 0 with velocity +10. Note that the integration never reaches\n    t=100 because the event is terminal.\n\n    >>> def upward_cannon(t, y): return [y[1], -0.5]\n    >>> def hit_ground(t, y): return y[0]\n    >>> hit_ground.terminal = True\n    >>> hit_ground.direction = -1\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)\n    >>> print(sol.t_events)\n    [array([40.])]\n    >>> print(sol.t)\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\n\n    Use `dense_output` and `events` to find position, which is 100, at the apex\n    of the cannonball's trajectory. Apex is not defined as terminal, so both\n    apex and hit_ground are found. There is no information at t=20, so the sol\n    attribute is used to evaluate the solution. The sol attribute is returned\n    by setting ``dense_output=True``. Alternatively, the `y_events` attribute\n    can be used to access the solution at the time of the event.\n\n    >>> def apex(t, y): return y[1]\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10],\n    ...                 events=(hit_ground, apex), dense_output=True)\n    >>> print(sol.t_events)\n    [array([40.]), array([20.])]\n    >>> print(sol.t)\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\n    >>> print(sol.sol(sol.t_events[1][0]))\n    [100.   0.]\n    >>> print(sol.y_events)\n    [array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]\n\n    As an example of a system with additional parameters, we'll implement\n    the Lotka-Volterra equations [12]_.\n\n    >>> def lotkavolterra(t, z, a, b, c, d):\n    ...     x, y = z\n    ...     return [a*x - b*x*y, -c*y + d*x*y]\n    ...\n\n    We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`\n    argument.\n\n    >>> sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),\n    ...                 dense_output=True)\n\n    Compute a dense solution and plot it.\n\n    >>> t = np.linspace(0, 15, 300)\n    >>> z = sol.sol(t)\n    >>> import matplotlib.pyplot as plt\n    >>> plt.plot(t, z.T)\n    >>> plt.xlabel('t')\n    >>> plt.legend(['x', 'y'], shadow=True)\n    >>> plt.title('Lotka-Volterra System')\n    >>> plt.show()\n\n    A couple examples of using solve_ivp to solve the differential\n    equation ``y' = Ay`` with complex matrix ``A``.\n\n    >>> A = np.array([[-0.25 + 0.14j, 0, 0.33 + 0.44j],\n    ...               [0.25 + 0.58j, -0.2 + 0.14j, 0],\n    ...               [0, 0.2 + 0.4j, -0.1 + 0.97j]])\n\n    Solving an IVP with ``A`` from above and ``y`` as 3x1 vector:\n\n    >>> def deriv_vec(t, y):\n    ...     return A @ y\n    >>> result = solve_ivp(deriv_vec, [0, 25],\n    ...                    np.array([10 + 0j, 20 + 0j, 30 + 0j]),\n    ...                    t_eval=np.linspace(0, 25, 101))\n    >>> print(result.y[:, 0])\n    [10.+0.j 20.+0.j 30.+0.j]\n    >>> print(result.y[:, -1])\n    [18.46291039+45.25653651j 10.01569306+36.23293216j\n     -4.98662741+80.07360388j]\n\n    Solving an IVP with ``A`` from above with ``y`` as 3x3 matrix :\n\n    >>> def deriv_mat(t, y):\n    ...     return (A @ y.reshape(3, 3)).flatten()\n    >>> y0 = np.array([[2 + 0j, 3 + 0j, 4 + 0j],\n    ...                [5 + 0j, 6 + 0j, 7 + 0j],\n    ...                [9 + 0j, 34 + 0j, 78 + 0j]])\n\n    >>> result = solve_ivp(deriv_mat, [0, 25], y0.flatten(),\n    ...                    t_eval=np.linspace(0, 25, 101))\n    >>> print(result.y[:, 0].reshape(3, 3))\n    [[ 2.+0.j  3.+0.j  4.+0.j]\n     [ 5.+0.j  6.+0.j  7.+0.j]\n     [ 9.+0.j 34.+0.j 78.+0.j]]\n    >>> print(result.y[:, -1].reshape(3, 3))\n    [[  5.67451179 +12.07938445j  17.2888073  +31.03278837j\n        37.83405768 +63.25138759j]\n     [  3.39949503 +11.82123994j  21.32530996 +44.88668871j\n        53.17531184+103.80400411j]\n     [ -2.26105874 +22.19277664j -15.1255713  +70.19616341j\n       -38.34616845+153.29039931j]]\n\n\n    \"\"\"\n    if method not in METHODS and (not (inspect.isclass(method) and issubclass(method, OdeSolver))):\n        raise ValueError('`method` must be one of {} or OdeSolver class.'.format(METHODS))\n    (t0, tf) = map(float, t_span)\n    if args is not None:\n        try:\n            _ = [*args]\n        except TypeError as exp:\n            suggestion_tuple = f\"Supplied 'args' cannot be unpacked. Please supply `args` as a tuple (e.g. `args=({args},)`)\"\n            raise TypeError(suggestion_tuple) from exp\n\n        def fun(t, x, fun=fun):\n            return fun(t, x, *args)\n        jac = options.get('jac')\n        if callable(jac):\n            options['jac'] = lambda t, x: jac(t, x, *args)\n    if t_eval is not None:\n        t_eval = np.asarray(t_eval)\n        if t_eval.ndim != 1:\n            raise ValueError('`t_eval` must be 1-dimensional.')\n        if np.any(t_eval < min(t0, tf)) or np.any(t_eval > max(t0, tf)):\n            raise ValueError('Values in `t_eval` are not within `t_span`.')\n        d = np.diff(t_eval)\n        if tf > t0 and np.any(d <= 0) or (tf < t0 and np.any(d >= 0)):\n            raise ValueError('Values in `t_eval` are not properly sorted.')\n        if tf > t0:\n            t_eval_i = 0\n        else:\n            t_eval = t_eval[::-1]\n            t_eval_i = t_eval.shape[0]\n    if method in METHODS:\n        method = METHODS[method]\n    solver = method(fun, t0, y0, tf, vectorized=vectorized, **options)\n    if t_eval is None:\n        ts = [t0]\n        ys = [y0]\n    elif t_eval is not None and dense_output:\n        ts = []\n        ti = [t0]\n        ys = []\n    else:\n        ts = []\n        ys = []\n    interpolants = []\n    (events, is_terminal, event_dir) = prepare_events(events)\n    if events is not None:\n        if args is not None:\n            events = [lambda t, x, event=event: event(t, x, *args) for event in events]\n        g = [event(t0, y0) for event in events]\n        t_events = [[] for _ in range(len(events))]\n        y_events = [[] for _ in range(len(events))]\n    else:\n        t_events = None\n        y_events = None\n    status = None\n    while status is None:\n        message = solver.step()\n        if solver.status == 'finished':\n            status = 0\n        elif solver.status == 'failed':\n            status = -1\n            break\n        t_old = solver.t_old\n        t = solver.t\n        y = solver.y\n        if dense_output:\n            sol = solver.dense_output()\n            interpolants.append(sol)\n        else:\n            sol = None\n        if events is not None:\n            g_new = [event(t, y) for event in events]\n            active_events = find_active_events(g, g_new, event_dir)\n            if active_events.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                (root_indices, roots, terminate) = handle_events(sol, events, active_events, is_terminal, t_old, t)\n                for (e, te) in zip(root_indices, roots):\n                    t_events[e].append(te)\n                    y_events[e].append(sol(te))\n                if terminate:\n                    status = 1\n                    t = roots[-1]\n                    y = sol(t)\n            g = g_new\n        if t_eval is None:\n            ts.append(t)\n            ys.append(y)\n        else:\n            if solver.direction > 0:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='right')\n                t_eval_step = t_eval[t_eval_i:t_eval_i_new]\n            else:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='left')\n                t_eval_step = t_eval[t_eval_i_new:t_eval_i][::-1]\n            if t_eval_step.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                ts.append(t_eval_step)\n                ys.append(sol(t_eval_step))\n                t_eval_i = t_eval_i_new\n        if t_eval is not None and dense_output:\n            ti.append(t)\n    message = MESSAGES.get(status, message)\n    if t_events is not None:\n        t_events = [np.asarray(te) for te in t_events]\n        y_events = [np.asarray(ye) for ye in y_events]\n    if t_eval is None:\n        ts = np.array(ts)\n        ys = np.vstack(ys).T\n    elif ts:\n        ts = np.hstack(ts)\n        ys = np.hstack(ys)\n    if dense_output:\n        if t_eval is None:\n            sol = OdeSolution(ts, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n        else:\n            sol = OdeSolution(ti, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n    else:\n        sol = None\n    return OdeResult(t=ts, y=ys, sol=sol, t_events=t_events, y_events=y_events, nfev=solver.nfev, njev=solver.njev, nlu=solver.nlu, status=status, message=message, success=status >= 0)",
        "mutated": [
            "def solve_ivp(fun, t_span, y0, method='RK45', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options):\n    if False:\n        i = 10\n    'Solve an initial value problem for a system of ODEs.\\n\\n    This function numerically integrates a system of ordinary differential\\n    equations given an initial value::\\n\\n        dy / dt = f(t, y)\\n        y(t0) = y0\\n\\n    Here t is a 1-D independent variable (time), y(t) is an\\n    N-D vector-valued function (state), and an N-D\\n    vector-valued function f(t, y) determines the differential equations.\\n    The goal is to find y(t) approximately satisfying the differential\\n    equations, given an initial value y(t0)=y0.\\n\\n    Some of the solvers support integration in the complex domain, but note\\n    that for stiff ODE solvers, the right-hand side must be\\n    complex-differentiable (satisfy Cauchy-Riemann equations [11]_).\\n    To solve a problem in the complex domain, pass y0 with a complex data type.\\n    Another option always available is to rewrite your problem for real and\\n    imaginary parts separately.\\n\\n    Parameters\\n    ----------\\n    fun : callable\\n        Right-hand side of the system: the time derivative of the state ``y``\\n        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a\\n        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. Additional\\n        arguments need to be passed if ``args`` is used (see documentation of\\n        ``args`` argument). ``fun`` must return an array of the same shape as\\n        ``y``. See `vectorized` for more information.\\n    t_span : 2-member sequence\\n        Interval of integration (t0, tf). The solver starts with t=t0 and\\n        integrates until it reaches t=tf. Both t0 and tf must be floats\\n        or values interpretable by the float conversion function.\\n    y0 : array_like, shape (n,)\\n        Initial state. For problems in the complex domain, pass `y0` with a\\n        complex data type (even if the initial value is purely real).\\n    method : string or `OdeSolver`, optional\\n        Integration method to use:\\n\\n            * \\'RK45\\' (default): Explicit Runge-Kutta method of order 5(4) [1]_.\\n              The error is controlled assuming accuracy of the fourth-order\\n              method, but steps are taken using the fifth-order accurate\\n              formula (local extrapolation is done). A quartic interpolation\\n              polynomial is used for the dense output [2]_. Can be applied in\\n              the complex domain.\\n            * \\'RK23\\': Explicit Runge-Kutta method of order 3(2) [3]_. The error\\n              is controlled assuming accuracy of the second-order method, but\\n              steps are taken using the third-order accurate formula (local\\n              extrapolation is done). A cubic Hermite polynomial is used for the\\n              dense output. Can be applied in the complex domain.\\n            * \\'DOP853\\': Explicit Runge-Kutta method of order 8 [13]_.\\n              Python implementation of the \"DOP853\" algorithm originally\\n              written in Fortran [14]_. A 7-th order interpolation polynomial\\n              accurate to 7-th order is used for the dense output.\\n              Can be applied in the complex domain.\\n            * \\'Radau\\': Implicit Runge-Kutta method of the Radau IIA family of\\n              order 5 [4]_. The error is controlled with a third-order accurate\\n              embedded formula. A cubic polynomial which satisfies the\\n              collocation conditions is used for the dense output.\\n            * \\'BDF\\': Implicit multi-step variable-order (1 to 5) method based\\n              on a backward differentiation formula for the derivative\\n              approximation [5]_. The implementation follows the one described\\n              in [6]_. A quasi-constant step scheme is used and accuracy is\\n              enhanced using the NDF modification. Can be applied in the\\n              complex domain.\\n            * \\'LSODA\\': Adams/BDF method with automatic stiffness detection and\\n              switching [7]_, [8]_. This is a wrapper of the Fortran solver\\n              from ODEPACK.\\n\\n        Explicit Runge-Kutta methods (\\'RK23\\', \\'RK45\\', \\'DOP853\\') should be used\\n        for non-stiff problems and implicit methods (\\'Radau\\', \\'BDF\\') for\\n        stiff problems [9]_. Among Runge-Kutta methods, \\'DOP853\\' is recommended\\n        for solving with high precision (low values of `rtol` and `atol`).\\n\\n        If not sure, first try to run \\'RK45\\'. If it makes unusually many\\n        iterations, diverges, or fails, your problem is likely to be stiff and\\n        you should use \\'Radau\\' or \\'BDF\\'. \\'LSODA\\' can also be a good universal\\n        choice, but it might be somewhat less convenient to work with as it\\n        wraps old Fortran code.\\n\\n        You can also pass an arbitrary class derived from `OdeSolver` which\\n        implements the solver.\\n    t_eval : array_like or None, optional\\n        Times at which to store the computed solution, must be sorted and lie\\n        within `t_span`. If None (default), use points selected by the solver.\\n    dense_output : bool, optional\\n        Whether to compute a continuous solution. Default is False.\\n    events : callable, or list of callables, optional\\n        Events to track. If None (default), no events will be tracked.\\n        Each event occurs at the zeros of a continuous function of time and\\n        state. Each function must have the signature ``event(t, y)`` where\\n        additional argument have to be passed if ``args`` is used (see\\n        documentation of ``args`` argument). Each function must return a\\n        float. The solver will find an accurate value of `t` at which\\n        ``event(t, y(t)) = 0`` using a root-finding algorithm. By default,\\n        all zeros will be found. The solver looks for a sign change over\\n        each step, so if multiple zero crossings occur within one step,\\n        events may be missed. Additionally each `event` function might\\n        have the following attributes:\\n\\n            terminal: bool, optional\\n                Whether to terminate integration if this event occurs.\\n                Implicitly False if not assigned.\\n            direction: float, optional\\n                Direction of a zero crossing. If `direction` is positive,\\n                `event` will only trigger when going from negative to positive,\\n                and vice versa if `direction` is negative. If 0, then either\\n                direction will trigger event. Implicitly 0 if not assigned.\\n\\n        You can assign attributes like ``event.terminal = True`` to any\\n        function in Python.\\n    vectorized : bool, optional\\n        Whether `fun` can be called in a vectorized fashion. Default is False.\\n\\n        If ``vectorized`` is False, `fun` will always be called with ``y`` of\\n        shape ``(n,)``, where ``n = len(y0)``.\\n\\n        If ``vectorized`` is True, `fun` may be called with ``y`` of shape\\n        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave\\n        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of\\n        the returned array is the time derivative of the state corresponding\\n        with a column of ``y``).\\n\\n        Setting ``vectorized=True`` allows for faster finite difference\\n        approximation of the Jacobian by methods \\'Radau\\' and \\'BDF\\', but\\n        will result in slower execution for other methods and for \\'Radau\\' and\\n        \\'BDF\\' in some circumstances (e.g. small ``len(y0)``).\\n    args : tuple, optional\\n        Additional arguments to pass to the user-defined functions.  If given,\\n        the additional arguments are passed to all user-defined functions.\\n        So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,\\n        then `jac` (if given) and any event functions must have the same\\n        signature, and `args` must be a tuple of length 3.\\n    **options\\n        Options passed to a chosen solver. All options available for already\\n        implemented solvers are listed below.\\n    first_step : float or None, optional\\n        Initial step size. Default is `None` which means that the algorithm\\n        should choose.\\n    max_step : float, optional\\n        Maximum allowed step size. Default is np.inf, i.e., the step size is not\\n        bounded and determined solely by the solver.\\n    rtol, atol : float or array_like, optional\\n        Relative and absolute tolerances. The solver keeps the local error\\n        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a\\n        relative accuracy (number of correct digits), while `atol` controls\\n        absolute accuracy (number of correct decimal places). To achieve the\\n        desired `rtol`, set `atol` to be smaller than the smallest value that\\n        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the\\n        allowable error. If `atol` is larger than ``rtol * abs(y)`` the\\n        number of correct digits is not guaranteed. Conversely, to achieve the\\n        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller\\n        than `atol`. If components of y have different scales, it might be\\n        beneficial to set different `atol` values for different components by\\n        passing array_like with shape (n,) for `atol`. Default values are\\n        1e-3 for `rtol` and 1e-6 for `atol`.\\n    jac : array_like, sparse_matrix, callable or None, optional\\n        Jacobian matrix of the right-hand side of the system with respect\\n        to y, required by the \\'Radau\\', \\'BDF\\' and \\'LSODA\\' method. The\\n        Jacobian matrix has shape (n, n) and its element (i, j) is equal to\\n        ``d f_i / d y_j``.  There are three ways to define the Jacobian:\\n\\n            * If array_like or sparse_matrix, the Jacobian is assumed to\\n              be constant. Not supported by \\'LSODA\\'.\\n            * If callable, the Jacobian is assumed to depend on both\\n              t and y; it will be called as ``jac(t, y)``, as necessary.\\n              Additional arguments have to be passed if ``args`` is\\n              used (see documentation of ``args`` argument).\\n              For \\'Radau\\' and \\'BDF\\' methods, the return value might be a\\n              sparse matrix.\\n            * If None (default), the Jacobian will be approximated by\\n              finite differences.\\n\\n        It is generally recommended to provide the Jacobian rather than\\n        relying on a finite-difference approximation.\\n    jac_sparsity : array_like, sparse matrix or None, optional\\n        Defines a sparsity structure of the Jacobian matrix for a finite-\\n        difference approximation. Its shape must be (n, n). This argument\\n        is ignored if `jac` is not `None`. If the Jacobian has only few\\n        non-zero elements in *each* row, providing the sparsity structure\\n        will greatly speed up the computations [10]_. A zero entry means that\\n        a corresponding element in the Jacobian is always zero. If None\\n        (default), the Jacobian is assumed to be dense.\\n        Not supported by \\'LSODA\\', see `lband` and `uband` instead.\\n    lband, uband : int or None, optional\\n        Parameters defining the bandwidth of the Jacobian for the \\'LSODA\\'\\n        method, i.e., ``jac[i, j] != 0 only for i - lband <= j <= i + uband``.\\n        Default is None. Setting these requires your jac routine to return the\\n        Jacobian in the packed format: the returned array must have ``n``\\n        columns and ``uband + lband + 1`` rows in which Jacobian diagonals are\\n        written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.\\n        The same format is used in `scipy.linalg.solve_banded` (check for an\\n        illustration).  These parameters can be also used with ``jac=None`` to\\n        reduce the number of Jacobian elements estimated by finite differences.\\n    min_step : float, optional\\n        The minimum allowed step size for \\'LSODA\\' method.\\n        By default `min_step` is zero.\\n\\n    Returns\\n    -------\\n    Bunch object with the following fields defined:\\n    t : ndarray, shape (n_points,)\\n        Time points.\\n    y : ndarray, shape (n, n_points)\\n        Values of the solution at `t`.\\n    sol : `OdeSolution` or None\\n        Found solution as `OdeSolution` instance; None if `dense_output` was\\n        set to False.\\n    t_events : list of ndarray or None\\n        Contains for each event type a list of arrays at which an event of\\n        that type event was detected. None if `events` was None.\\n    y_events : list of ndarray or None\\n        For each value of `t_events`, the corresponding value of the solution.\\n        None if `events` was None.\\n    nfev : int\\n        Number of evaluations of the right-hand side.\\n    njev : int\\n        Number of evaluations of the Jacobian.\\n    nlu : int\\n        Number of LU decompositions.\\n    status : int\\n        Reason for algorithm termination:\\n\\n            * -1: Integration step failed.\\n            *  0: The solver successfully reached the end of `tspan`.\\n            *  1: A termination event occurred.\\n\\n    message : string\\n        Human-readable description of the termination reason.\\n    success : bool\\n        True if the solver reached the interval end or a termination event\\n        occurred (``status >= 0``).\\n\\n    References\\n    ----------\\n    .. [1] J. R. Dormand, P. J. Prince, \"A family of embedded Runge-Kutta\\n           formulae\", Journal of Computational and Applied Mathematics, Vol. 6,\\n           No. 1, pp. 19-26, 1980.\\n    .. [2] L. W. Shampine, \"Some Practical Runge-Kutta Formulas\", Mathematics\\n           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.\\n    .. [3] P. Bogacki, L.F. Shampine, \"A 3(2) Pair of Runge-Kutta Formulas\",\\n           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.\\n    .. [4] E. Hairer, G. Wanner, \"Solving Ordinary Differential Equations II:\\n           Stiff and Differential-Algebraic Problems\", Sec. IV.8.\\n    .. [5] `Backward Differentiation Formula\\n            <https://en.wikipedia.org/wiki/Backward_differentiation_formula>`_\\n            on Wikipedia.\\n    .. [6] L. F. Shampine, M. W. Reichelt, \"THE MATLAB ODE SUITE\", SIAM J. SCI.\\n           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.\\n    .. [7] A. C. Hindmarsh, \"ODEPACK, A Systematized Collection of ODE\\n           Solvers,\" IMACS Transactions on Scientific Computation, Vol 1.,\\n           pp. 55-64, 1983.\\n    .. [8] L. Petzold, \"Automatic selection of methods for solving stiff and\\n           nonstiff systems of ordinary differential equations\", SIAM Journal\\n           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,\\n           1983.\\n    .. [9] `Stiff equation <https://en.wikipedia.org/wiki/Stiff_equation>`_ on\\n           Wikipedia.\\n    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, \"On the estimation of\\n            sparse Jacobian matrices\", Journal of the Institute of Mathematics\\n            and its Applications, 13, pp. 117-120, 1974.\\n    .. [11] `Cauchy-Riemann equations\\n             <https://en.wikipedia.org/wiki/Cauchy-Riemann_equations>`_ on\\n             Wikipedia.\\n    .. [12] `Lotka-Volterra equations\\n            <https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations>`_\\n            on Wikipedia.\\n    .. [13] E. Hairer, S. P. Norsett G. Wanner, \"Solving Ordinary Differential\\n            Equations I: Nonstiff Problems\", Sec. II.\\n    .. [14] `Page with original Fortran code of DOP853\\n            <http://www.unige.ch/~hairer/software.html>`_.\\n\\n    Examples\\n    --------\\n    Basic exponential decay showing automatically chosen time points.\\n\\n    >>> import numpy as np\\n    >>> from scipy.integrate import solve_ivp\\n    >>> def exponential_decay(t, y): return -0.5 * y\\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])\\n    >>> print(sol.t)\\n    [ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806\\n      8.33328988 10.        ]\\n    >>> print(sol.y)\\n    [[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045\\n      0.03107158 0.01350781]\\n     [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091\\n      0.06214316 0.02701561]\\n     [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181\\n      0.12428631 0.05403123]]\\n\\n    Specifying points where the solution is desired.\\n\\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],\\n    ...                 t_eval=[0, 1, 2, 4, 10])\\n    >>> print(sol.t)\\n    [ 0  1  2  4 10]\\n    >>> print(sol.y)\\n    [[2.         1.21305369 0.73534021 0.27066736 0.01350938]\\n     [4.         2.42610739 1.47068043 0.54133472 0.02701876]\\n     [8.         4.85221478 2.94136085 1.08266944 0.05403753]]\\n\\n    Cannon fired upward with terminal event upon impact. The ``terminal`` and\\n    ``direction`` fields of an event are applied by monkey patching a function.\\n    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts\\n    at position 0 with velocity +10. Note that the integration never reaches\\n    t=100 because the event is terminal.\\n\\n    >>> def upward_cannon(t, y): return [y[1], -0.5]\\n    >>> def hit_ground(t, y): return y[0]\\n    >>> hit_ground.terminal = True\\n    >>> hit_ground.direction = -1\\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)\\n    >>> print(sol.t_events)\\n    [array([40.])]\\n    >>> print(sol.t)\\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\\n\\n    Use `dense_output` and `events` to find position, which is 100, at the apex\\n    of the cannonball\\'s trajectory. Apex is not defined as terminal, so both\\n    apex and hit_ground are found. There is no information at t=20, so the sol\\n    attribute is used to evaluate the solution. The sol attribute is returned\\n    by setting ``dense_output=True``. Alternatively, the `y_events` attribute\\n    can be used to access the solution at the time of the event.\\n\\n    >>> def apex(t, y): return y[1]\\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10],\\n    ...                 events=(hit_ground, apex), dense_output=True)\\n    >>> print(sol.t_events)\\n    [array([40.]), array([20.])]\\n    >>> print(sol.t)\\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\\n    >>> print(sol.sol(sol.t_events[1][0]))\\n    [100.   0.]\\n    >>> print(sol.y_events)\\n    [array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]\\n\\n    As an example of a system with additional parameters, we\\'ll implement\\n    the Lotka-Volterra equations [12]_.\\n\\n    >>> def lotkavolterra(t, z, a, b, c, d):\\n    ...     x, y = z\\n    ...     return [a*x - b*x*y, -c*y + d*x*y]\\n    ...\\n\\n    We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`\\n    argument.\\n\\n    >>> sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),\\n    ...                 dense_output=True)\\n\\n    Compute a dense solution and plot it.\\n\\n    >>> t = np.linspace(0, 15, 300)\\n    >>> z = sol.sol(t)\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(t, z.T)\\n    >>> plt.xlabel(\\'t\\')\\n    >>> plt.legend([\\'x\\', \\'y\\'], shadow=True)\\n    >>> plt.title(\\'Lotka-Volterra System\\')\\n    >>> plt.show()\\n\\n    A couple examples of using solve_ivp to solve the differential\\n    equation ``y\\' = Ay`` with complex matrix ``A``.\\n\\n    >>> A = np.array([[-0.25 + 0.14j, 0, 0.33 + 0.44j],\\n    ...               [0.25 + 0.58j, -0.2 + 0.14j, 0],\\n    ...               [0, 0.2 + 0.4j, -0.1 + 0.97j]])\\n\\n    Solving an IVP with ``A`` from above and ``y`` as 3x1 vector:\\n\\n    >>> def deriv_vec(t, y):\\n    ...     return A @ y\\n    >>> result = solve_ivp(deriv_vec, [0, 25],\\n    ...                    np.array([10 + 0j, 20 + 0j, 30 + 0j]),\\n    ...                    t_eval=np.linspace(0, 25, 101))\\n    >>> print(result.y[:, 0])\\n    [10.+0.j 20.+0.j 30.+0.j]\\n    >>> print(result.y[:, -1])\\n    [18.46291039+45.25653651j 10.01569306+36.23293216j\\n     -4.98662741+80.07360388j]\\n\\n    Solving an IVP with ``A`` from above with ``y`` as 3x3 matrix :\\n\\n    >>> def deriv_mat(t, y):\\n    ...     return (A @ y.reshape(3, 3)).flatten()\\n    >>> y0 = np.array([[2 + 0j, 3 + 0j, 4 + 0j],\\n    ...                [5 + 0j, 6 + 0j, 7 + 0j],\\n    ...                [9 + 0j, 34 + 0j, 78 + 0j]])\\n\\n    >>> result = solve_ivp(deriv_mat, [0, 25], y0.flatten(),\\n    ...                    t_eval=np.linspace(0, 25, 101))\\n    >>> print(result.y[:, 0].reshape(3, 3))\\n    [[ 2.+0.j  3.+0.j  4.+0.j]\\n     [ 5.+0.j  6.+0.j  7.+0.j]\\n     [ 9.+0.j 34.+0.j 78.+0.j]]\\n    >>> print(result.y[:, -1].reshape(3, 3))\\n    [[  5.67451179 +12.07938445j  17.2888073  +31.03278837j\\n        37.83405768 +63.25138759j]\\n     [  3.39949503 +11.82123994j  21.32530996 +44.88668871j\\n        53.17531184+103.80400411j]\\n     [ -2.26105874 +22.19277664j -15.1255713  +70.19616341j\\n       -38.34616845+153.29039931j]]\\n\\n\\n    '\n    if method not in METHODS and (not (inspect.isclass(method) and issubclass(method, OdeSolver))):\n        raise ValueError('`method` must be one of {} or OdeSolver class.'.format(METHODS))\n    (t0, tf) = map(float, t_span)\n    if args is not None:\n        try:\n            _ = [*args]\n        except TypeError as exp:\n            suggestion_tuple = f\"Supplied 'args' cannot be unpacked. Please supply `args` as a tuple (e.g. `args=({args},)`)\"\n            raise TypeError(suggestion_tuple) from exp\n\n        def fun(t, x, fun=fun):\n            return fun(t, x, *args)\n        jac = options.get('jac')\n        if callable(jac):\n            options['jac'] = lambda t, x: jac(t, x, *args)\n    if t_eval is not None:\n        t_eval = np.asarray(t_eval)\n        if t_eval.ndim != 1:\n            raise ValueError('`t_eval` must be 1-dimensional.')\n        if np.any(t_eval < min(t0, tf)) or np.any(t_eval > max(t0, tf)):\n            raise ValueError('Values in `t_eval` are not within `t_span`.')\n        d = np.diff(t_eval)\n        if tf > t0 and np.any(d <= 0) or (tf < t0 and np.any(d >= 0)):\n            raise ValueError('Values in `t_eval` are not properly sorted.')\n        if tf > t0:\n            t_eval_i = 0\n        else:\n            t_eval = t_eval[::-1]\n            t_eval_i = t_eval.shape[0]\n    if method in METHODS:\n        method = METHODS[method]\n    solver = method(fun, t0, y0, tf, vectorized=vectorized, **options)\n    if t_eval is None:\n        ts = [t0]\n        ys = [y0]\n    elif t_eval is not None and dense_output:\n        ts = []\n        ti = [t0]\n        ys = []\n    else:\n        ts = []\n        ys = []\n    interpolants = []\n    (events, is_terminal, event_dir) = prepare_events(events)\n    if events is not None:\n        if args is not None:\n            events = [lambda t, x, event=event: event(t, x, *args) for event in events]\n        g = [event(t0, y0) for event in events]\n        t_events = [[] for _ in range(len(events))]\n        y_events = [[] for _ in range(len(events))]\n    else:\n        t_events = None\n        y_events = None\n    status = None\n    while status is None:\n        message = solver.step()\n        if solver.status == 'finished':\n            status = 0\n        elif solver.status == 'failed':\n            status = -1\n            break\n        t_old = solver.t_old\n        t = solver.t\n        y = solver.y\n        if dense_output:\n            sol = solver.dense_output()\n            interpolants.append(sol)\n        else:\n            sol = None\n        if events is not None:\n            g_new = [event(t, y) for event in events]\n            active_events = find_active_events(g, g_new, event_dir)\n            if active_events.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                (root_indices, roots, terminate) = handle_events(sol, events, active_events, is_terminal, t_old, t)\n                for (e, te) in zip(root_indices, roots):\n                    t_events[e].append(te)\n                    y_events[e].append(sol(te))\n                if terminate:\n                    status = 1\n                    t = roots[-1]\n                    y = sol(t)\n            g = g_new\n        if t_eval is None:\n            ts.append(t)\n            ys.append(y)\n        else:\n            if solver.direction > 0:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='right')\n                t_eval_step = t_eval[t_eval_i:t_eval_i_new]\n            else:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='left')\n                t_eval_step = t_eval[t_eval_i_new:t_eval_i][::-1]\n            if t_eval_step.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                ts.append(t_eval_step)\n                ys.append(sol(t_eval_step))\n                t_eval_i = t_eval_i_new\n        if t_eval is not None and dense_output:\n            ti.append(t)\n    message = MESSAGES.get(status, message)\n    if t_events is not None:\n        t_events = [np.asarray(te) for te in t_events]\n        y_events = [np.asarray(ye) for ye in y_events]\n    if t_eval is None:\n        ts = np.array(ts)\n        ys = np.vstack(ys).T\n    elif ts:\n        ts = np.hstack(ts)\n        ys = np.hstack(ys)\n    if dense_output:\n        if t_eval is None:\n            sol = OdeSolution(ts, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n        else:\n            sol = OdeSolution(ti, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n    else:\n        sol = None\n    return OdeResult(t=ts, y=ys, sol=sol, t_events=t_events, y_events=y_events, nfev=solver.nfev, njev=solver.njev, nlu=solver.nlu, status=status, message=message, success=status >= 0)",
            "def solve_ivp(fun, t_span, y0, method='RK45', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Solve an initial value problem for a system of ODEs.\\n\\n    This function numerically integrates a system of ordinary differential\\n    equations given an initial value::\\n\\n        dy / dt = f(t, y)\\n        y(t0) = y0\\n\\n    Here t is a 1-D independent variable (time), y(t) is an\\n    N-D vector-valued function (state), and an N-D\\n    vector-valued function f(t, y) determines the differential equations.\\n    The goal is to find y(t) approximately satisfying the differential\\n    equations, given an initial value y(t0)=y0.\\n\\n    Some of the solvers support integration in the complex domain, but note\\n    that for stiff ODE solvers, the right-hand side must be\\n    complex-differentiable (satisfy Cauchy-Riemann equations [11]_).\\n    To solve a problem in the complex domain, pass y0 with a complex data type.\\n    Another option always available is to rewrite your problem for real and\\n    imaginary parts separately.\\n\\n    Parameters\\n    ----------\\n    fun : callable\\n        Right-hand side of the system: the time derivative of the state ``y``\\n        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a\\n        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. Additional\\n        arguments need to be passed if ``args`` is used (see documentation of\\n        ``args`` argument). ``fun`` must return an array of the same shape as\\n        ``y``. See `vectorized` for more information.\\n    t_span : 2-member sequence\\n        Interval of integration (t0, tf). The solver starts with t=t0 and\\n        integrates until it reaches t=tf. Both t0 and tf must be floats\\n        or values interpretable by the float conversion function.\\n    y0 : array_like, shape (n,)\\n        Initial state. For problems in the complex domain, pass `y0` with a\\n        complex data type (even if the initial value is purely real).\\n    method : string or `OdeSolver`, optional\\n        Integration method to use:\\n\\n            * \\'RK45\\' (default): Explicit Runge-Kutta method of order 5(4) [1]_.\\n              The error is controlled assuming accuracy of the fourth-order\\n              method, but steps are taken using the fifth-order accurate\\n              formula (local extrapolation is done). A quartic interpolation\\n              polynomial is used for the dense output [2]_. Can be applied in\\n              the complex domain.\\n            * \\'RK23\\': Explicit Runge-Kutta method of order 3(2) [3]_. The error\\n              is controlled assuming accuracy of the second-order method, but\\n              steps are taken using the third-order accurate formula (local\\n              extrapolation is done). A cubic Hermite polynomial is used for the\\n              dense output. Can be applied in the complex domain.\\n            * \\'DOP853\\': Explicit Runge-Kutta method of order 8 [13]_.\\n              Python implementation of the \"DOP853\" algorithm originally\\n              written in Fortran [14]_. A 7-th order interpolation polynomial\\n              accurate to 7-th order is used for the dense output.\\n              Can be applied in the complex domain.\\n            * \\'Radau\\': Implicit Runge-Kutta method of the Radau IIA family of\\n              order 5 [4]_. The error is controlled with a third-order accurate\\n              embedded formula. A cubic polynomial which satisfies the\\n              collocation conditions is used for the dense output.\\n            * \\'BDF\\': Implicit multi-step variable-order (1 to 5) method based\\n              on a backward differentiation formula for the derivative\\n              approximation [5]_. The implementation follows the one described\\n              in [6]_. A quasi-constant step scheme is used and accuracy is\\n              enhanced using the NDF modification. Can be applied in the\\n              complex domain.\\n            * \\'LSODA\\': Adams/BDF method with automatic stiffness detection and\\n              switching [7]_, [8]_. This is a wrapper of the Fortran solver\\n              from ODEPACK.\\n\\n        Explicit Runge-Kutta methods (\\'RK23\\', \\'RK45\\', \\'DOP853\\') should be used\\n        for non-stiff problems and implicit methods (\\'Radau\\', \\'BDF\\') for\\n        stiff problems [9]_. Among Runge-Kutta methods, \\'DOP853\\' is recommended\\n        for solving with high precision (low values of `rtol` and `atol`).\\n\\n        If not sure, first try to run \\'RK45\\'. If it makes unusually many\\n        iterations, diverges, or fails, your problem is likely to be stiff and\\n        you should use \\'Radau\\' or \\'BDF\\'. \\'LSODA\\' can also be a good universal\\n        choice, but it might be somewhat less convenient to work with as it\\n        wraps old Fortran code.\\n\\n        You can also pass an arbitrary class derived from `OdeSolver` which\\n        implements the solver.\\n    t_eval : array_like or None, optional\\n        Times at which to store the computed solution, must be sorted and lie\\n        within `t_span`. If None (default), use points selected by the solver.\\n    dense_output : bool, optional\\n        Whether to compute a continuous solution. Default is False.\\n    events : callable, or list of callables, optional\\n        Events to track. If None (default), no events will be tracked.\\n        Each event occurs at the zeros of a continuous function of time and\\n        state. Each function must have the signature ``event(t, y)`` where\\n        additional argument have to be passed if ``args`` is used (see\\n        documentation of ``args`` argument). Each function must return a\\n        float. The solver will find an accurate value of `t` at which\\n        ``event(t, y(t)) = 0`` using a root-finding algorithm. By default,\\n        all zeros will be found. The solver looks for a sign change over\\n        each step, so if multiple zero crossings occur within one step,\\n        events may be missed. Additionally each `event` function might\\n        have the following attributes:\\n\\n            terminal: bool, optional\\n                Whether to terminate integration if this event occurs.\\n                Implicitly False if not assigned.\\n            direction: float, optional\\n                Direction of a zero crossing. If `direction` is positive,\\n                `event` will only trigger when going from negative to positive,\\n                and vice versa if `direction` is negative. If 0, then either\\n                direction will trigger event. Implicitly 0 if not assigned.\\n\\n        You can assign attributes like ``event.terminal = True`` to any\\n        function in Python.\\n    vectorized : bool, optional\\n        Whether `fun` can be called in a vectorized fashion. Default is False.\\n\\n        If ``vectorized`` is False, `fun` will always be called with ``y`` of\\n        shape ``(n,)``, where ``n = len(y0)``.\\n\\n        If ``vectorized`` is True, `fun` may be called with ``y`` of shape\\n        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave\\n        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of\\n        the returned array is the time derivative of the state corresponding\\n        with a column of ``y``).\\n\\n        Setting ``vectorized=True`` allows for faster finite difference\\n        approximation of the Jacobian by methods \\'Radau\\' and \\'BDF\\', but\\n        will result in slower execution for other methods and for \\'Radau\\' and\\n        \\'BDF\\' in some circumstances (e.g. small ``len(y0)``).\\n    args : tuple, optional\\n        Additional arguments to pass to the user-defined functions.  If given,\\n        the additional arguments are passed to all user-defined functions.\\n        So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,\\n        then `jac` (if given) and any event functions must have the same\\n        signature, and `args` must be a tuple of length 3.\\n    **options\\n        Options passed to a chosen solver. All options available for already\\n        implemented solvers are listed below.\\n    first_step : float or None, optional\\n        Initial step size. Default is `None` which means that the algorithm\\n        should choose.\\n    max_step : float, optional\\n        Maximum allowed step size. Default is np.inf, i.e., the step size is not\\n        bounded and determined solely by the solver.\\n    rtol, atol : float or array_like, optional\\n        Relative and absolute tolerances. The solver keeps the local error\\n        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a\\n        relative accuracy (number of correct digits), while `atol` controls\\n        absolute accuracy (number of correct decimal places). To achieve the\\n        desired `rtol`, set `atol` to be smaller than the smallest value that\\n        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the\\n        allowable error. If `atol` is larger than ``rtol * abs(y)`` the\\n        number of correct digits is not guaranteed. Conversely, to achieve the\\n        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller\\n        than `atol`. If components of y have different scales, it might be\\n        beneficial to set different `atol` values for different components by\\n        passing array_like with shape (n,) for `atol`. Default values are\\n        1e-3 for `rtol` and 1e-6 for `atol`.\\n    jac : array_like, sparse_matrix, callable or None, optional\\n        Jacobian matrix of the right-hand side of the system with respect\\n        to y, required by the \\'Radau\\', \\'BDF\\' and \\'LSODA\\' method. The\\n        Jacobian matrix has shape (n, n) and its element (i, j) is equal to\\n        ``d f_i / d y_j``.  There are three ways to define the Jacobian:\\n\\n            * If array_like or sparse_matrix, the Jacobian is assumed to\\n              be constant. Not supported by \\'LSODA\\'.\\n            * If callable, the Jacobian is assumed to depend on both\\n              t and y; it will be called as ``jac(t, y)``, as necessary.\\n              Additional arguments have to be passed if ``args`` is\\n              used (see documentation of ``args`` argument).\\n              For \\'Radau\\' and \\'BDF\\' methods, the return value might be a\\n              sparse matrix.\\n            * If None (default), the Jacobian will be approximated by\\n              finite differences.\\n\\n        It is generally recommended to provide the Jacobian rather than\\n        relying on a finite-difference approximation.\\n    jac_sparsity : array_like, sparse matrix or None, optional\\n        Defines a sparsity structure of the Jacobian matrix for a finite-\\n        difference approximation. Its shape must be (n, n). This argument\\n        is ignored if `jac` is not `None`. If the Jacobian has only few\\n        non-zero elements in *each* row, providing the sparsity structure\\n        will greatly speed up the computations [10]_. A zero entry means that\\n        a corresponding element in the Jacobian is always zero. If None\\n        (default), the Jacobian is assumed to be dense.\\n        Not supported by \\'LSODA\\', see `lband` and `uband` instead.\\n    lband, uband : int or None, optional\\n        Parameters defining the bandwidth of the Jacobian for the \\'LSODA\\'\\n        method, i.e., ``jac[i, j] != 0 only for i - lband <= j <= i + uband``.\\n        Default is None. Setting these requires your jac routine to return the\\n        Jacobian in the packed format: the returned array must have ``n``\\n        columns and ``uband + lband + 1`` rows in which Jacobian diagonals are\\n        written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.\\n        The same format is used in `scipy.linalg.solve_banded` (check for an\\n        illustration).  These parameters can be also used with ``jac=None`` to\\n        reduce the number of Jacobian elements estimated by finite differences.\\n    min_step : float, optional\\n        The minimum allowed step size for \\'LSODA\\' method.\\n        By default `min_step` is zero.\\n\\n    Returns\\n    -------\\n    Bunch object with the following fields defined:\\n    t : ndarray, shape (n_points,)\\n        Time points.\\n    y : ndarray, shape (n, n_points)\\n        Values of the solution at `t`.\\n    sol : `OdeSolution` or None\\n        Found solution as `OdeSolution` instance; None if `dense_output` was\\n        set to False.\\n    t_events : list of ndarray or None\\n        Contains for each event type a list of arrays at which an event of\\n        that type event was detected. None if `events` was None.\\n    y_events : list of ndarray or None\\n        For each value of `t_events`, the corresponding value of the solution.\\n        None if `events` was None.\\n    nfev : int\\n        Number of evaluations of the right-hand side.\\n    njev : int\\n        Number of evaluations of the Jacobian.\\n    nlu : int\\n        Number of LU decompositions.\\n    status : int\\n        Reason for algorithm termination:\\n\\n            * -1: Integration step failed.\\n            *  0: The solver successfully reached the end of `tspan`.\\n            *  1: A termination event occurred.\\n\\n    message : string\\n        Human-readable description of the termination reason.\\n    success : bool\\n        True if the solver reached the interval end or a termination event\\n        occurred (``status >= 0``).\\n\\n    References\\n    ----------\\n    .. [1] J. R. Dormand, P. J. Prince, \"A family of embedded Runge-Kutta\\n           formulae\", Journal of Computational and Applied Mathematics, Vol. 6,\\n           No. 1, pp. 19-26, 1980.\\n    .. [2] L. W. Shampine, \"Some Practical Runge-Kutta Formulas\", Mathematics\\n           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.\\n    .. [3] P. Bogacki, L.F. Shampine, \"A 3(2) Pair of Runge-Kutta Formulas\",\\n           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.\\n    .. [4] E. Hairer, G. Wanner, \"Solving Ordinary Differential Equations II:\\n           Stiff and Differential-Algebraic Problems\", Sec. IV.8.\\n    .. [5] `Backward Differentiation Formula\\n            <https://en.wikipedia.org/wiki/Backward_differentiation_formula>`_\\n            on Wikipedia.\\n    .. [6] L. F. Shampine, M. W. Reichelt, \"THE MATLAB ODE SUITE\", SIAM J. SCI.\\n           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.\\n    .. [7] A. C. Hindmarsh, \"ODEPACK, A Systematized Collection of ODE\\n           Solvers,\" IMACS Transactions on Scientific Computation, Vol 1.,\\n           pp. 55-64, 1983.\\n    .. [8] L. Petzold, \"Automatic selection of methods for solving stiff and\\n           nonstiff systems of ordinary differential equations\", SIAM Journal\\n           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,\\n           1983.\\n    .. [9] `Stiff equation <https://en.wikipedia.org/wiki/Stiff_equation>`_ on\\n           Wikipedia.\\n    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, \"On the estimation of\\n            sparse Jacobian matrices\", Journal of the Institute of Mathematics\\n            and its Applications, 13, pp. 117-120, 1974.\\n    .. [11] `Cauchy-Riemann equations\\n             <https://en.wikipedia.org/wiki/Cauchy-Riemann_equations>`_ on\\n             Wikipedia.\\n    .. [12] `Lotka-Volterra equations\\n            <https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations>`_\\n            on Wikipedia.\\n    .. [13] E. Hairer, S. P. Norsett G. Wanner, \"Solving Ordinary Differential\\n            Equations I: Nonstiff Problems\", Sec. II.\\n    .. [14] `Page with original Fortran code of DOP853\\n            <http://www.unige.ch/~hairer/software.html>`_.\\n\\n    Examples\\n    --------\\n    Basic exponential decay showing automatically chosen time points.\\n\\n    >>> import numpy as np\\n    >>> from scipy.integrate import solve_ivp\\n    >>> def exponential_decay(t, y): return -0.5 * y\\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])\\n    >>> print(sol.t)\\n    [ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806\\n      8.33328988 10.        ]\\n    >>> print(sol.y)\\n    [[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045\\n      0.03107158 0.01350781]\\n     [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091\\n      0.06214316 0.02701561]\\n     [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181\\n      0.12428631 0.05403123]]\\n\\n    Specifying points where the solution is desired.\\n\\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],\\n    ...                 t_eval=[0, 1, 2, 4, 10])\\n    >>> print(sol.t)\\n    [ 0  1  2  4 10]\\n    >>> print(sol.y)\\n    [[2.         1.21305369 0.73534021 0.27066736 0.01350938]\\n     [4.         2.42610739 1.47068043 0.54133472 0.02701876]\\n     [8.         4.85221478 2.94136085 1.08266944 0.05403753]]\\n\\n    Cannon fired upward with terminal event upon impact. The ``terminal`` and\\n    ``direction`` fields of an event are applied by monkey patching a function.\\n    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts\\n    at position 0 with velocity +10. Note that the integration never reaches\\n    t=100 because the event is terminal.\\n\\n    >>> def upward_cannon(t, y): return [y[1], -0.5]\\n    >>> def hit_ground(t, y): return y[0]\\n    >>> hit_ground.terminal = True\\n    >>> hit_ground.direction = -1\\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)\\n    >>> print(sol.t_events)\\n    [array([40.])]\\n    >>> print(sol.t)\\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\\n\\n    Use `dense_output` and `events` to find position, which is 100, at the apex\\n    of the cannonball\\'s trajectory. Apex is not defined as terminal, so both\\n    apex and hit_ground are found. There is no information at t=20, so the sol\\n    attribute is used to evaluate the solution. The sol attribute is returned\\n    by setting ``dense_output=True``. Alternatively, the `y_events` attribute\\n    can be used to access the solution at the time of the event.\\n\\n    >>> def apex(t, y): return y[1]\\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10],\\n    ...                 events=(hit_ground, apex), dense_output=True)\\n    >>> print(sol.t_events)\\n    [array([40.]), array([20.])]\\n    >>> print(sol.t)\\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\\n    >>> print(sol.sol(sol.t_events[1][0]))\\n    [100.   0.]\\n    >>> print(sol.y_events)\\n    [array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]\\n\\n    As an example of a system with additional parameters, we\\'ll implement\\n    the Lotka-Volterra equations [12]_.\\n\\n    >>> def lotkavolterra(t, z, a, b, c, d):\\n    ...     x, y = z\\n    ...     return [a*x - b*x*y, -c*y + d*x*y]\\n    ...\\n\\n    We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`\\n    argument.\\n\\n    >>> sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),\\n    ...                 dense_output=True)\\n\\n    Compute a dense solution and plot it.\\n\\n    >>> t = np.linspace(0, 15, 300)\\n    >>> z = sol.sol(t)\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(t, z.T)\\n    >>> plt.xlabel(\\'t\\')\\n    >>> plt.legend([\\'x\\', \\'y\\'], shadow=True)\\n    >>> plt.title(\\'Lotka-Volterra System\\')\\n    >>> plt.show()\\n\\n    A couple examples of using solve_ivp to solve the differential\\n    equation ``y\\' = Ay`` with complex matrix ``A``.\\n\\n    >>> A = np.array([[-0.25 + 0.14j, 0, 0.33 + 0.44j],\\n    ...               [0.25 + 0.58j, -0.2 + 0.14j, 0],\\n    ...               [0, 0.2 + 0.4j, -0.1 + 0.97j]])\\n\\n    Solving an IVP with ``A`` from above and ``y`` as 3x1 vector:\\n\\n    >>> def deriv_vec(t, y):\\n    ...     return A @ y\\n    >>> result = solve_ivp(deriv_vec, [0, 25],\\n    ...                    np.array([10 + 0j, 20 + 0j, 30 + 0j]),\\n    ...                    t_eval=np.linspace(0, 25, 101))\\n    >>> print(result.y[:, 0])\\n    [10.+0.j 20.+0.j 30.+0.j]\\n    >>> print(result.y[:, -1])\\n    [18.46291039+45.25653651j 10.01569306+36.23293216j\\n     -4.98662741+80.07360388j]\\n\\n    Solving an IVP with ``A`` from above with ``y`` as 3x3 matrix :\\n\\n    >>> def deriv_mat(t, y):\\n    ...     return (A @ y.reshape(3, 3)).flatten()\\n    >>> y0 = np.array([[2 + 0j, 3 + 0j, 4 + 0j],\\n    ...                [5 + 0j, 6 + 0j, 7 + 0j],\\n    ...                [9 + 0j, 34 + 0j, 78 + 0j]])\\n\\n    >>> result = solve_ivp(deriv_mat, [0, 25], y0.flatten(),\\n    ...                    t_eval=np.linspace(0, 25, 101))\\n    >>> print(result.y[:, 0].reshape(3, 3))\\n    [[ 2.+0.j  3.+0.j  4.+0.j]\\n     [ 5.+0.j  6.+0.j  7.+0.j]\\n     [ 9.+0.j 34.+0.j 78.+0.j]]\\n    >>> print(result.y[:, -1].reshape(3, 3))\\n    [[  5.67451179 +12.07938445j  17.2888073  +31.03278837j\\n        37.83405768 +63.25138759j]\\n     [  3.39949503 +11.82123994j  21.32530996 +44.88668871j\\n        53.17531184+103.80400411j]\\n     [ -2.26105874 +22.19277664j -15.1255713  +70.19616341j\\n       -38.34616845+153.29039931j]]\\n\\n\\n    '\n    if method not in METHODS and (not (inspect.isclass(method) and issubclass(method, OdeSolver))):\n        raise ValueError('`method` must be one of {} or OdeSolver class.'.format(METHODS))\n    (t0, tf) = map(float, t_span)\n    if args is not None:\n        try:\n            _ = [*args]\n        except TypeError as exp:\n            suggestion_tuple = f\"Supplied 'args' cannot be unpacked. Please supply `args` as a tuple (e.g. `args=({args},)`)\"\n            raise TypeError(suggestion_tuple) from exp\n\n        def fun(t, x, fun=fun):\n            return fun(t, x, *args)\n        jac = options.get('jac')\n        if callable(jac):\n            options['jac'] = lambda t, x: jac(t, x, *args)\n    if t_eval is not None:\n        t_eval = np.asarray(t_eval)\n        if t_eval.ndim != 1:\n            raise ValueError('`t_eval` must be 1-dimensional.')\n        if np.any(t_eval < min(t0, tf)) or np.any(t_eval > max(t0, tf)):\n            raise ValueError('Values in `t_eval` are not within `t_span`.')\n        d = np.diff(t_eval)\n        if tf > t0 and np.any(d <= 0) or (tf < t0 and np.any(d >= 0)):\n            raise ValueError('Values in `t_eval` are not properly sorted.')\n        if tf > t0:\n            t_eval_i = 0\n        else:\n            t_eval = t_eval[::-1]\n            t_eval_i = t_eval.shape[0]\n    if method in METHODS:\n        method = METHODS[method]\n    solver = method(fun, t0, y0, tf, vectorized=vectorized, **options)\n    if t_eval is None:\n        ts = [t0]\n        ys = [y0]\n    elif t_eval is not None and dense_output:\n        ts = []\n        ti = [t0]\n        ys = []\n    else:\n        ts = []\n        ys = []\n    interpolants = []\n    (events, is_terminal, event_dir) = prepare_events(events)\n    if events is not None:\n        if args is not None:\n            events = [lambda t, x, event=event: event(t, x, *args) for event in events]\n        g = [event(t0, y0) for event in events]\n        t_events = [[] for _ in range(len(events))]\n        y_events = [[] for _ in range(len(events))]\n    else:\n        t_events = None\n        y_events = None\n    status = None\n    while status is None:\n        message = solver.step()\n        if solver.status == 'finished':\n            status = 0\n        elif solver.status == 'failed':\n            status = -1\n            break\n        t_old = solver.t_old\n        t = solver.t\n        y = solver.y\n        if dense_output:\n            sol = solver.dense_output()\n            interpolants.append(sol)\n        else:\n            sol = None\n        if events is not None:\n            g_new = [event(t, y) for event in events]\n            active_events = find_active_events(g, g_new, event_dir)\n            if active_events.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                (root_indices, roots, terminate) = handle_events(sol, events, active_events, is_terminal, t_old, t)\n                for (e, te) in zip(root_indices, roots):\n                    t_events[e].append(te)\n                    y_events[e].append(sol(te))\n                if terminate:\n                    status = 1\n                    t = roots[-1]\n                    y = sol(t)\n            g = g_new\n        if t_eval is None:\n            ts.append(t)\n            ys.append(y)\n        else:\n            if solver.direction > 0:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='right')\n                t_eval_step = t_eval[t_eval_i:t_eval_i_new]\n            else:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='left')\n                t_eval_step = t_eval[t_eval_i_new:t_eval_i][::-1]\n            if t_eval_step.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                ts.append(t_eval_step)\n                ys.append(sol(t_eval_step))\n                t_eval_i = t_eval_i_new\n        if t_eval is not None and dense_output:\n            ti.append(t)\n    message = MESSAGES.get(status, message)\n    if t_events is not None:\n        t_events = [np.asarray(te) for te in t_events]\n        y_events = [np.asarray(ye) for ye in y_events]\n    if t_eval is None:\n        ts = np.array(ts)\n        ys = np.vstack(ys).T\n    elif ts:\n        ts = np.hstack(ts)\n        ys = np.hstack(ys)\n    if dense_output:\n        if t_eval is None:\n            sol = OdeSolution(ts, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n        else:\n            sol = OdeSolution(ti, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n    else:\n        sol = None\n    return OdeResult(t=ts, y=ys, sol=sol, t_events=t_events, y_events=y_events, nfev=solver.nfev, njev=solver.njev, nlu=solver.nlu, status=status, message=message, success=status >= 0)",
            "def solve_ivp(fun, t_span, y0, method='RK45', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Solve an initial value problem for a system of ODEs.\\n\\n    This function numerically integrates a system of ordinary differential\\n    equations given an initial value::\\n\\n        dy / dt = f(t, y)\\n        y(t0) = y0\\n\\n    Here t is a 1-D independent variable (time), y(t) is an\\n    N-D vector-valued function (state), and an N-D\\n    vector-valued function f(t, y) determines the differential equations.\\n    The goal is to find y(t) approximately satisfying the differential\\n    equations, given an initial value y(t0)=y0.\\n\\n    Some of the solvers support integration in the complex domain, but note\\n    that for stiff ODE solvers, the right-hand side must be\\n    complex-differentiable (satisfy Cauchy-Riemann equations [11]_).\\n    To solve a problem in the complex domain, pass y0 with a complex data type.\\n    Another option always available is to rewrite your problem for real and\\n    imaginary parts separately.\\n\\n    Parameters\\n    ----------\\n    fun : callable\\n        Right-hand side of the system: the time derivative of the state ``y``\\n        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a\\n        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. Additional\\n        arguments need to be passed if ``args`` is used (see documentation of\\n        ``args`` argument). ``fun`` must return an array of the same shape as\\n        ``y``. See `vectorized` for more information.\\n    t_span : 2-member sequence\\n        Interval of integration (t0, tf). The solver starts with t=t0 and\\n        integrates until it reaches t=tf. Both t0 and tf must be floats\\n        or values interpretable by the float conversion function.\\n    y0 : array_like, shape (n,)\\n        Initial state. For problems in the complex domain, pass `y0` with a\\n        complex data type (even if the initial value is purely real).\\n    method : string or `OdeSolver`, optional\\n        Integration method to use:\\n\\n            * \\'RK45\\' (default): Explicit Runge-Kutta method of order 5(4) [1]_.\\n              The error is controlled assuming accuracy of the fourth-order\\n              method, but steps are taken using the fifth-order accurate\\n              formula (local extrapolation is done). A quartic interpolation\\n              polynomial is used for the dense output [2]_. Can be applied in\\n              the complex domain.\\n            * \\'RK23\\': Explicit Runge-Kutta method of order 3(2) [3]_. The error\\n              is controlled assuming accuracy of the second-order method, but\\n              steps are taken using the third-order accurate formula (local\\n              extrapolation is done). A cubic Hermite polynomial is used for the\\n              dense output. Can be applied in the complex domain.\\n            * \\'DOP853\\': Explicit Runge-Kutta method of order 8 [13]_.\\n              Python implementation of the \"DOP853\" algorithm originally\\n              written in Fortran [14]_. A 7-th order interpolation polynomial\\n              accurate to 7-th order is used for the dense output.\\n              Can be applied in the complex domain.\\n            * \\'Radau\\': Implicit Runge-Kutta method of the Radau IIA family of\\n              order 5 [4]_. The error is controlled with a third-order accurate\\n              embedded formula. A cubic polynomial which satisfies the\\n              collocation conditions is used for the dense output.\\n            * \\'BDF\\': Implicit multi-step variable-order (1 to 5) method based\\n              on a backward differentiation formula for the derivative\\n              approximation [5]_. The implementation follows the one described\\n              in [6]_. A quasi-constant step scheme is used and accuracy is\\n              enhanced using the NDF modification. Can be applied in the\\n              complex domain.\\n            * \\'LSODA\\': Adams/BDF method with automatic stiffness detection and\\n              switching [7]_, [8]_. This is a wrapper of the Fortran solver\\n              from ODEPACK.\\n\\n        Explicit Runge-Kutta methods (\\'RK23\\', \\'RK45\\', \\'DOP853\\') should be used\\n        for non-stiff problems and implicit methods (\\'Radau\\', \\'BDF\\') for\\n        stiff problems [9]_. Among Runge-Kutta methods, \\'DOP853\\' is recommended\\n        for solving with high precision (low values of `rtol` and `atol`).\\n\\n        If not sure, first try to run \\'RK45\\'. If it makes unusually many\\n        iterations, diverges, or fails, your problem is likely to be stiff and\\n        you should use \\'Radau\\' or \\'BDF\\'. \\'LSODA\\' can also be a good universal\\n        choice, but it might be somewhat less convenient to work with as it\\n        wraps old Fortran code.\\n\\n        You can also pass an arbitrary class derived from `OdeSolver` which\\n        implements the solver.\\n    t_eval : array_like or None, optional\\n        Times at which to store the computed solution, must be sorted and lie\\n        within `t_span`. If None (default), use points selected by the solver.\\n    dense_output : bool, optional\\n        Whether to compute a continuous solution. Default is False.\\n    events : callable, or list of callables, optional\\n        Events to track. If None (default), no events will be tracked.\\n        Each event occurs at the zeros of a continuous function of time and\\n        state. Each function must have the signature ``event(t, y)`` where\\n        additional argument have to be passed if ``args`` is used (see\\n        documentation of ``args`` argument). Each function must return a\\n        float. The solver will find an accurate value of `t` at which\\n        ``event(t, y(t)) = 0`` using a root-finding algorithm. By default,\\n        all zeros will be found. The solver looks for a sign change over\\n        each step, so if multiple zero crossings occur within one step,\\n        events may be missed. Additionally each `event` function might\\n        have the following attributes:\\n\\n            terminal: bool, optional\\n                Whether to terminate integration if this event occurs.\\n                Implicitly False if not assigned.\\n            direction: float, optional\\n                Direction of a zero crossing. If `direction` is positive,\\n                `event` will only trigger when going from negative to positive,\\n                and vice versa if `direction` is negative. If 0, then either\\n                direction will trigger event. Implicitly 0 if not assigned.\\n\\n        You can assign attributes like ``event.terminal = True`` to any\\n        function in Python.\\n    vectorized : bool, optional\\n        Whether `fun` can be called in a vectorized fashion. Default is False.\\n\\n        If ``vectorized`` is False, `fun` will always be called with ``y`` of\\n        shape ``(n,)``, where ``n = len(y0)``.\\n\\n        If ``vectorized`` is True, `fun` may be called with ``y`` of shape\\n        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave\\n        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of\\n        the returned array is the time derivative of the state corresponding\\n        with a column of ``y``).\\n\\n        Setting ``vectorized=True`` allows for faster finite difference\\n        approximation of the Jacobian by methods \\'Radau\\' and \\'BDF\\', but\\n        will result in slower execution for other methods and for \\'Radau\\' and\\n        \\'BDF\\' in some circumstances (e.g. small ``len(y0)``).\\n    args : tuple, optional\\n        Additional arguments to pass to the user-defined functions.  If given,\\n        the additional arguments are passed to all user-defined functions.\\n        So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,\\n        then `jac` (if given) and any event functions must have the same\\n        signature, and `args` must be a tuple of length 3.\\n    **options\\n        Options passed to a chosen solver. All options available for already\\n        implemented solvers are listed below.\\n    first_step : float or None, optional\\n        Initial step size. Default is `None` which means that the algorithm\\n        should choose.\\n    max_step : float, optional\\n        Maximum allowed step size. Default is np.inf, i.e., the step size is not\\n        bounded and determined solely by the solver.\\n    rtol, atol : float or array_like, optional\\n        Relative and absolute tolerances. The solver keeps the local error\\n        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a\\n        relative accuracy (number of correct digits), while `atol` controls\\n        absolute accuracy (number of correct decimal places). To achieve the\\n        desired `rtol`, set `atol` to be smaller than the smallest value that\\n        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the\\n        allowable error. If `atol` is larger than ``rtol * abs(y)`` the\\n        number of correct digits is not guaranteed. Conversely, to achieve the\\n        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller\\n        than `atol`. If components of y have different scales, it might be\\n        beneficial to set different `atol` values for different components by\\n        passing array_like with shape (n,) for `atol`. Default values are\\n        1e-3 for `rtol` and 1e-6 for `atol`.\\n    jac : array_like, sparse_matrix, callable or None, optional\\n        Jacobian matrix of the right-hand side of the system with respect\\n        to y, required by the \\'Radau\\', \\'BDF\\' and \\'LSODA\\' method. The\\n        Jacobian matrix has shape (n, n) and its element (i, j) is equal to\\n        ``d f_i / d y_j``.  There are three ways to define the Jacobian:\\n\\n            * If array_like or sparse_matrix, the Jacobian is assumed to\\n              be constant. Not supported by \\'LSODA\\'.\\n            * If callable, the Jacobian is assumed to depend on both\\n              t and y; it will be called as ``jac(t, y)``, as necessary.\\n              Additional arguments have to be passed if ``args`` is\\n              used (see documentation of ``args`` argument).\\n              For \\'Radau\\' and \\'BDF\\' methods, the return value might be a\\n              sparse matrix.\\n            * If None (default), the Jacobian will be approximated by\\n              finite differences.\\n\\n        It is generally recommended to provide the Jacobian rather than\\n        relying on a finite-difference approximation.\\n    jac_sparsity : array_like, sparse matrix or None, optional\\n        Defines a sparsity structure of the Jacobian matrix for a finite-\\n        difference approximation. Its shape must be (n, n). This argument\\n        is ignored if `jac` is not `None`. If the Jacobian has only few\\n        non-zero elements in *each* row, providing the sparsity structure\\n        will greatly speed up the computations [10]_. A zero entry means that\\n        a corresponding element in the Jacobian is always zero. If None\\n        (default), the Jacobian is assumed to be dense.\\n        Not supported by \\'LSODA\\', see `lband` and `uband` instead.\\n    lband, uband : int or None, optional\\n        Parameters defining the bandwidth of the Jacobian for the \\'LSODA\\'\\n        method, i.e., ``jac[i, j] != 0 only for i - lband <= j <= i + uband``.\\n        Default is None. Setting these requires your jac routine to return the\\n        Jacobian in the packed format: the returned array must have ``n``\\n        columns and ``uband + lband + 1`` rows in which Jacobian diagonals are\\n        written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.\\n        The same format is used in `scipy.linalg.solve_banded` (check for an\\n        illustration).  These parameters can be also used with ``jac=None`` to\\n        reduce the number of Jacobian elements estimated by finite differences.\\n    min_step : float, optional\\n        The minimum allowed step size for \\'LSODA\\' method.\\n        By default `min_step` is zero.\\n\\n    Returns\\n    -------\\n    Bunch object with the following fields defined:\\n    t : ndarray, shape (n_points,)\\n        Time points.\\n    y : ndarray, shape (n, n_points)\\n        Values of the solution at `t`.\\n    sol : `OdeSolution` or None\\n        Found solution as `OdeSolution` instance; None if `dense_output` was\\n        set to False.\\n    t_events : list of ndarray or None\\n        Contains for each event type a list of arrays at which an event of\\n        that type event was detected. None if `events` was None.\\n    y_events : list of ndarray or None\\n        For each value of `t_events`, the corresponding value of the solution.\\n        None if `events` was None.\\n    nfev : int\\n        Number of evaluations of the right-hand side.\\n    njev : int\\n        Number of evaluations of the Jacobian.\\n    nlu : int\\n        Number of LU decompositions.\\n    status : int\\n        Reason for algorithm termination:\\n\\n            * -1: Integration step failed.\\n            *  0: The solver successfully reached the end of `tspan`.\\n            *  1: A termination event occurred.\\n\\n    message : string\\n        Human-readable description of the termination reason.\\n    success : bool\\n        True if the solver reached the interval end or a termination event\\n        occurred (``status >= 0``).\\n\\n    References\\n    ----------\\n    .. [1] J. R. Dormand, P. J. Prince, \"A family of embedded Runge-Kutta\\n           formulae\", Journal of Computational and Applied Mathematics, Vol. 6,\\n           No. 1, pp. 19-26, 1980.\\n    .. [2] L. W. Shampine, \"Some Practical Runge-Kutta Formulas\", Mathematics\\n           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.\\n    .. [3] P. Bogacki, L.F. Shampine, \"A 3(2) Pair of Runge-Kutta Formulas\",\\n           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.\\n    .. [4] E. Hairer, G. Wanner, \"Solving Ordinary Differential Equations II:\\n           Stiff and Differential-Algebraic Problems\", Sec. IV.8.\\n    .. [5] `Backward Differentiation Formula\\n            <https://en.wikipedia.org/wiki/Backward_differentiation_formula>`_\\n            on Wikipedia.\\n    .. [6] L. F. Shampine, M. W. Reichelt, \"THE MATLAB ODE SUITE\", SIAM J. SCI.\\n           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.\\n    .. [7] A. C. Hindmarsh, \"ODEPACK, A Systematized Collection of ODE\\n           Solvers,\" IMACS Transactions on Scientific Computation, Vol 1.,\\n           pp. 55-64, 1983.\\n    .. [8] L. Petzold, \"Automatic selection of methods for solving stiff and\\n           nonstiff systems of ordinary differential equations\", SIAM Journal\\n           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,\\n           1983.\\n    .. [9] `Stiff equation <https://en.wikipedia.org/wiki/Stiff_equation>`_ on\\n           Wikipedia.\\n    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, \"On the estimation of\\n            sparse Jacobian matrices\", Journal of the Institute of Mathematics\\n            and its Applications, 13, pp. 117-120, 1974.\\n    .. [11] `Cauchy-Riemann equations\\n             <https://en.wikipedia.org/wiki/Cauchy-Riemann_equations>`_ on\\n             Wikipedia.\\n    .. [12] `Lotka-Volterra equations\\n            <https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations>`_\\n            on Wikipedia.\\n    .. [13] E. Hairer, S. P. Norsett G. Wanner, \"Solving Ordinary Differential\\n            Equations I: Nonstiff Problems\", Sec. II.\\n    .. [14] `Page with original Fortran code of DOP853\\n            <http://www.unige.ch/~hairer/software.html>`_.\\n\\n    Examples\\n    --------\\n    Basic exponential decay showing automatically chosen time points.\\n\\n    >>> import numpy as np\\n    >>> from scipy.integrate import solve_ivp\\n    >>> def exponential_decay(t, y): return -0.5 * y\\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])\\n    >>> print(sol.t)\\n    [ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806\\n      8.33328988 10.        ]\\n    >>> print(sol.y)\\n    [[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045\\n      0.03107158 0.01350781]\\n     [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091\\n      0.06214316 0.02701561]\\n     [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181\\n      0.12428631 0.05403123]]\\n\\n    Specifying points where the solution is desired.\\n\\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],\\n    ...                 t_eval=[0, 1, 2, 4, 10])\\n    >>> print(sol.t)\\n    [ 0  1  2  4 10]\\n    >>> print(sol.y)\\n    [[2.         1.21305369 0.73534021 0.27066736 0.01350938]\\n     [4.         2.42610739 1.47068043 0.54133472 0.02701876]\\n     [8.         4.85221478 2.94136085 1.08266944 0.05403753]]\\n\\n    Cannon fired upward with terminal event upon impact. The ``terminal`` and\\n    ``direction`` fields of an event are applied by monkey patching a function.\\n    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts\\n    at position 0 with velocity +10. Note that the integration never reaches\\n    t=100 because the event is terminal.\\n\\n    >>> def upward_cannon(t, y): return [y[1], -0.5]\\n    >>> def hit_ground(t, y): return y[0]\\n    >>> hit_ground.terminal = True\\n    >>> hit_ground.direction = -1\\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)\\n    >>> print(sol.t_events)\\n    [array([40.])]\\n    >>> print(sol.t)\\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\\n\\n    Use `dense_output` and `events` to find position, which is 100, at the apex\\n    of the cannonball\\'s trajectory. Apex is not defined as terminal, so both\\n    apex and hit_ground are found. There is no information at t=20, so the sol\\n    attribute is used to evaluate the solution. The sol attribute is returned\\n    by setting ``dense_output=True``. Alternatively, the `y_events` attribute\\n    can be used to access the solution at the time of the event.\\n\\n    >>> def apex(t, y): return y[1]\\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10],\\n    ...                 events=(hit_ground, apex), dense_output=True)\\n    >>> print(sol.t_events)\\n    [array([40.]), array([20.])]\\n    >>> print(sol.t)\\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\\n    >>> print(sol.sol(sol.t_events[1][0]))\\n    [100.   0.]\\n    >>> print(sol.y_events)\\n    [array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]\\n\\n    As an example of a system with additional parameters, we\\'ll implement\\n    the Lotka-Volterra equations [12]_.\\n\\n    >>> def lotkavolterra(t, z, a, b, c, d):\\n    ...     x, y = z\\n    ...     return [a*x - b*x*y, -c*y + d*x*y]\\n    ...\\n\\n    We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`\\n    argument.\\n\\n    >>> sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),\\n    ...                 dense_output=True)\\n\\n    Compute a dense solution and plot it.\\n\\n    >>> t = np.linspace(0, 15, 300)\\n    >>> z = sol.sol(t)\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(t, z.T)\\n    >>> plt.xlabel(\\'t\\')\\n    >>> plt.legend([\\'x\\', \\'y\\'], shadow=True)\\n    >>> plt.title(\\'Lotka-Volterra System\\')\\n    >>> plt.show()\\n\\n    A couple examples of using solve_ivp to solve the differential\\n    equation ``y\\' = Ay`` with complex matrix ``A``.\\n\\n    >>> A = np.array([[-0.25 + 0.14j, 0, 0.33 + 0.44j],\\n    ...               [0.25 + 0.58j, -0.2 + 0.14j, 0],\\n    ...               [0, 0.2 + 0.4j, -0.1 + 0.97j]])\\n\\n    Solving an IVP with ``A`` from above and ``y`` as 3x1 vector:\\n\\n    >>> def deriv_vec(t, y):\\n    ...     return A @ y\\n    >>> result = solve_ivp(deriv_vec, [0, 25],\\n    ...                    np.array([10 + 0j, 20 + 0j, 30 + 0j]),\\n    ...                    t_eval=np.linspace(0, 25, 101))\\n    >>> print(result.y[:, 0])\\n    [10.+0.j 20.+0.j 30.+0.j]\\n    >>> print(result.y[:, -1])\\n    [18.46291039+45.25653651j 10.01569306+36.23293216j\\n     -4.98662741+80.07360388j]\\n\\n    Solving an IVP with ``A`` from above with ``y`` as 3x3 matrix :\\n\\n    >>> def deriv_mat(t, y):\\n    ...     return (A @ y.reshape(3, 3)).flatten()\\n    >>> y0 = np.array([[2 + 0j, 3 + 0j, 4 + 0j],\\n    ...                [5 + 0j, 6 + 0j, 7 + 0j],\\n    ...                [9 + 0j, 34 + 0j, 78 + 0j]])\\n\\n    >>> result = solve_ivp(deriv_mat, [0, 25], y0.flatten(),\\n    ...                    t_eval=np.linspace(0, 25, 101))\\n    >>> print(result.y[:, 0].reshape(3, 3))\\n    [[ 2.+0.j  3.+0.j  4.+0.j]\\n     [ 5.+0.j  6.+0.j  7.+0.j]\\n     [ 9.+0.j 34.+0.j 78.+0.j]]\\n    >>> print(result.y[:, -1].reshape(3, 3))\\n    [[  5.67451179 +12.07938445j  17.2888073  +31.03278837j\\n        37.83405768 +63.25138759j]\\n     [  3.39949503 +11.82123994j  21.32530996 +44.88668871j\\n        53.17531184+103.80400411j]\\n     [ -2.26105874 +22.19277664j -15.1255713  +70.19616341j\\n       -38.34616845+153.29039931j]]\\n\\n\\n    '\n    if method not in METHODS and (not (inspect.isclass(method) and issubclass(method, OdeSolver))):\n        raise ValueError('`method` must be one of {} or OdeSolver class.'.format(METHODS))\n    (t0, tf) = map(float, t_span)\n    if args is not None:\n        try:\n            _ = [*args]\n        except TypeError as exp:\n            suggestion_tuple = f\"Supplied 'args' cannot be unpacked. Please supply `args` as a tuple (e.g. `args=({args},)`)\"\n            raise TypeError(suggestion_tuple) from exp\n\n        def fun(t, x, fun=fun):\n            return fun(t, x, *args)\n        jac = options.get('jac')\n        if callable(jac):\n            options['jac'] = lambda t, x: jac(t, x, *args)\n    if t_eval is not None:\n        t_eval = np.asarray(t_eval)\n        if t_eval.ndim != 1:\n            raise ValueError('`t_eval` must be 1-dimensional.')\n        if np.any(t_eval < min(t0, tf)) or np.any(t_eval > max(t0, tf)):\n            raise ValueError('Values in `t_eval` are not within `t_span`.')\n        d = np.diff(t_eval)\n        if tf > t0 and np.any(d <= 0) or (tf < t0 and np.any(d >= 0)):\n            raise ValueError('Values in `t_eval` are not properly sorted.')\n        if tf > t0:\n            t_eval_i = 0\n        else:\n            t_eval = t_eval[::-1]\n            t_eval_i = t_eval.shape[0]\n    if method in METHODS:\n        method = METHODS[method]\n    solver = method(fun, t0, y0, tf, vectorized=vectorized, **options)\n    if t_eval is None:\n        ts = [t0]\n        ys = [y0]\n    elif t_eval is not None and dense_output:\n        ts = []\n        ti = [t0]\n        ys = []\n    else:\n        ts = []\n        ys = []\n    interpolants = []\n    (events, is_terminal, event_dir) = prepare_events(events)\n    if events is not None:\n        if args is not None:\n            events = [lambda t, x, event=event: event(t, x, *args) for event in events]\n        g = [event(t0, y0) for event in events]\n        t_events = [[] for _ in range(len(events))]\n        y_events = [[] for _ in range(len(events))]\n    else:\n        t_events = None\n        y_events = None\n    status = None\n    while status is None:\n        message = solver.step()\n        if solver.status == 'finished':\n            status = 0\n        elif solver.status == 'failed':\n            status = -1\n            break\n        t_old = solver.t_old\n        t = solver.t\n        y = solver.y\n        if dense_output:\n            sol = solver.dense_output()\n            interpolants.append(sol)\n        else:\n            sol = None\n        if events is not None:\n            g_new = [event(t, y) for event in events]\n            active_events = find_active_events(g, g_new, event_dir)\n            if active_events.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                (root_indices, roots, terminate) = handle_events(sol, events, active_events, is_terminal, t_old, t)\n                for (e, te) in zip(root_indices, roots):\n                    t_events[e].append(te)\n                    y_events[e].append(sol(te))\n                if terminate:\n                    status = 1\n                    t = roots[-1]\n                    y = sol(t)\n            g = g_new\n        if t_eval is None:\n            ts.append(t)\n            ys.append(y)\n        else:\n            if solver.direction > 0:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='right')\n                t_eval_step = t_eval[t_eval_i:t_eval_i_new]\n            else:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='left')\n                t_eval_step = t_eval[t_eval_i_new:t_eval_i][::-1]\n            if t_eval_step.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                ts.append(t_eval_step)\n                ys.append(sol(t_eval_step))\n                t_eval_i = t_eval_i_new\n        if t_eval is not None and dense_output:\n            ti.append(t)\n    message = MESSAGES.get(status, message)\n    if t_events is not None:\n        t_events = [np.asarray(te) for te in t_events]\n        y_events = [np.asarray(ye) for ye in y_events]\n    if t_eval is None:\n        ts = np.array(ts)\n        ys = np.vstack(ys).T\n    elif ts:\n        ts = np.hstack(ts)\n        ys = np.hstack(ys)\n    if dense_output:\n        if t_eval is None:\n            sol = OdeSolution(ts, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n        else:\n            sol = OdeSolution(ti, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n    else:\n        sol = None\n    return OdeResult(t=ts, y=ys, sol=sol, t_events=t_events, y_events=y_events, nfev=solver.nfev, njev=solver.njev, nlu=solver.nlu, status=status, message=message, success=status >= 0)",
            "def solve_ivp(fun, t_span, y0, method='RK45', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Solve an initial value problem for a system of ODEs.\\n\\n    This function numerically integrates a system of ordinary differential\\n    equations given an initial value::\\n\\n        dy / dt = f(t, y)\\n        y(t0) = y0\\n\\n    Here t is a 1-D independent variable (time), y(t) is an\\n    N-D vector-valued function (state), and an N-D\\n    vector-valued function f(t, y) determines the differential equations.\\n    The goal is to find y(t) approximately satisfying the differential\\n    equations, given an initial value y(t0)=y0.\\n\\n    Some of the solvers support integration in the complex domain, but note\\n    that for stiff ODE solvers, the right-hand side must be\\n    complex-differentiable (satisfy Cauchy-Riemann equations [11]_).\\n    To solve a problem in the complex domain, pass y0 with a complex data type.\\n    Another option always available is to rewrite your problem for real and\\n    imaginary parts separately.\\n\\n    Parameters\\n    ----------\\n    fun : callable\\n        Right-hand side of the system: the time derivative of the state ``y``\\n        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a\\n        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. Additional\\n        arguments need to be passed if ``args`` is used (see documentation of\\n        ``args`` argument). ``fun`` must return an array of the same shape as\\n        ``y``. See `vectorized` for more information.\\n    t_span : 2-member sequence\\n        Interval of integration (t0, tf). The solver starts with t=t0 and\\n        integrates until it reaches t=tf. Both t0 and tf must be floats\\n        or values interpretable by the float conversion function.\\n    y0 : array_like, shape (n,)\\n        Initial state. For problems in the complex domain, pass `y0` with a\\n        complex data type (even if the initial value is purely real).\\n    method : string or `OdeSolver`, optional\\n        Integration method to use:\\n\\n            * \\'RK45\\' (default): Explicit Runge-Kutta method of order 5(4) [1]_.\\n              The error is controlled assuming accuracy of the fourth-order\\n              method, but steps are taken using the fifth-order accurate\\n              formula (local extrapolation is done). A quartic interpolation\\n              polynomial is used for the dense output [2]_. Can be applied in\\n              the complex domain.\\n            * \\'RK23\\': Explicit Runge-Kutta method of order 3(2) [3]_. The error\\n              is controlled assuming accuracy of the second-order method, but\\n              steps are taken using the third-order accurate formula (local\\n              extrapolation is done). A cubic Hermite polynomial is used for the\\n              dense output. Can be applied in the complex domain.\\n            * \\'DOP853\\': Explicit Runge-Kutta method of order 8 [13]_.\\n              Python implementation of the \"DOP853\" algorithm originally\\n              written in Fortran [14]_. A 7-th order interpolation polynomial\\n              accurate to 7-th order is used for the dense output.\\n              Can be applied in the complex domain.\\n            * \\'Radau\\': Implicit Runge-Kutta method of the Radau IIA family of\\n              order 5 [4]_. The error is controlled with a third-order accurate\\n              embedded formula. A cubic polynomial which satisfies the\\n              collocation conditions is used for the dense output.\\n            * \\'BDF\\': Implicit multi-step variable-order (1 to 5) method based\\n              on a backward differentiation formula for the derivative\\n              approximation [5]_. The implementation follows the one described\\n              in [6]_. A quasi-constant step scheme is used and accuracy is\\n              enhanced using the NDF modification. Can be applied in the\\n              complex domain.\\n            * \\'LSODA\\': Adams/BDF method with automatic stiffness detection and\\n              switching [7]_, [8]_. This is a wrapper of the Fortran solver\\n              from ODEPACK.\\n\\n        Explicit Runge-Kutta methods (\\'RK23\\', \\'RK45\\', \\'DOP853\\') should be used\\n        for non-stiff problems and implicit methods (\\'Radau\\', \\'BDF\\') for\\n        stiff problems [9]_. Among Runge-Kutta methods, \\'DOP853\\' is recommended\\n        for solving with high precision (low values of `rtol` and `atol`).\\n\\n        If not sure, first try to run \\'RK45\\'. If it makes unusually many\\n        iterations, diverges, or fails, your problem is likely to be stiff and\\n        you should use \\'Radau\\' or \\'BDF\\'. \\'LSODA\\' can also be a good universal\\n        choice, but it might be somewhat less convenient to work with as it\\n        wraps old Fortran code.\\n\\n        You can also pass an arbitrary class derived from `OdeSolver` which\\n        implements the solver.\\n    t_eval : array_like or None, optional\\n        Times at which to store the computed solution, must be sorted and lie\\n        within `t_span`. If None (default), use points selected by the solver.\\n    dense_output : bool, optional\\n        Whether to compute a continuous solution. Default is False.\\n    events : callable, or list of callables, optional\\n        Events to track. If None (default), no events will be tracked.\\n        Each event occurs at the zeros of a continuous function of time and\\n        state. Each function must have the signature ``event(t, y)`` where\\n        additional argument have to be passed if ``args`` is used (see\\n        documentation of ``args`` argument). Each function must return a\\n        float. The solver will find an accurate value of `t` at which\\n        ``event(t, y(t)) = 0`` using a root-finding algorithm. By default,\\n        all zeros will be found. The solver looks for a sign change over\\n        each step, so if multiple zero crossings occur within one step,\\n        events may be missed. Additionally each `event` function might\\n        have the following attributes:\\n\\n            terminal: bool, optional\\n                Whether to terminate integration if this event occurs.\\n                Implicitly False if not assigned.\\n            direction: float, optional\\n                Direction of a zero crossing. If `direction` is positive,\\n                `event` will only trigger when going from negative to positive,\\n                and vice versa if `direction` is negative. If 0, then either\\n                direction will trigger event. Implicitly 0 if not assigned.\\n\\n        You can assign attributes like ``event.terminal = True`` to any\\n        function in Python.\\n    vectorized : bool, optional\\n        Whether `fun` can be called in a vectorized fashion. Default is False.\\n\\n        If ``vectorized`` is False, `fun` will always be called with ``y`` of\\n        shape ``(n,)``, where ``n = len(y0)``.\\n\\n        If ``vectorized`` is True, `fun` may be called with ``y`` of shape\\n        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave\\n        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of\\n        the returned array is the time derivative of the state corresponding\\n        with a column of ``y``).\\n\\n        Setting ``vectorized=True`` allows for faster finite difference\\n        approximation of the Jacobian by methods \\'Radau\\' and \\'BDF\\', but\\n        will result in slower execution for other methods and for \\'Radau\\' and\\n        \\'BDF\\' in some circumstances (e.g. small ``len(y0)``).\\n    args : tuple, optional\\n        Additional arguments to pass to the user-defined functions.  If given,\\n        the additional arguments are passed to all user-defined functions.\\n        So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,\\n        then `jac` (if given) and any event functions must have the same\\n        signature, and `args` must be a tuple of length 3.\\n    **options\\n        Options passed to a chosen solver. All options available for already\\n        implemented solvers are listed below.\\n    first_step : float or None, optional\\n        Initial step size. Default is `None` which means that the algorithm\\n        should choose.\\n    max_step : float, optional\\n        Maximum allowed step size. Default is np.inf, i.e., the step size is not\\n        bounded and determined solely by the solver.\\n    rtol, atol : float or array_like, optional\\n        Relative and absolute tolerances. The solver keeps the local error\\n        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a\\n        relative accuracy (number of correct digits), while `atol` controls\\n        absolute accuracy (number of correct decimal places). To achieve the\\n        desired `rtol`, set `atol` to be smaller than the smallest value that\\n        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the\\n        allowable error. If `atol` is larger than ``rtol * abs(y)`` the\\n        number of correct digits is not guaranteed. Conversely, to achieve the\\n        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller\\n        than `atol`. If components of y have different scales, it might be\\n        beneficial to set different `atol` values for different components by\\n        passing array_like with shape (n,) for `atol`. Default values are\\n        1e-3 for `rtol` and 1e-6 for `atol`.\\n    jac : array_like, sparse_matrix, callable or None, optional\\n        Jacobian matrix of the right-hand side of the system with respect\\n        to y, required by the \\'Radau\\', \\'BDF\\' and \\'LSODA\\' method. The\\n        Jacobian matrix has shape (n, n) and its element (i, j) is equal to\\n        ``d f_i / d y_j``.  There are three ways to define the Jacobian:\\n\\n            * If array_like or sparse_matrix, the Jacobian is assumed to\\n              be constant. Not supported by \\'LSODA\\'.\\n            * If callable, the Jacobian is assumed to depend on both\\n              t and y; it will be called as ``jac(t, y)``, as necessary.\\n              Additional arguments have to be passed if ``args`` is\\n              used (see documentation of ``args`` argument).\\n              For \\'Radau\\' and \\'BDF\\' methods, the return value might be a\\n              sparse matrix.\\n            * If None (default), the Jacobian will be approximated by\\n              finite differences.\\n\\n        It is generally recommended to provide the Jacobian rather than\\n        relying on a finite-difference approximation.\\n    jac_sparsity : array_like, sparse matrix or None, optional\\n        Defines a sparsity structure of the Jacobian matrix for a finite-\\n        difference approximation. Its shape must be (n, n). This argument\\n        is ignored if `jac` is not `None`. If the Jacobian has only few\\n        non-zero elements in *each* row, providing the sparsity structure\\n        will greatly speed up the computations [10]_. A zero entry means that\\n        a corresponding element in the Jacobian is always zero. If None\\n        (default), the Jacobian is assumed to be dense.\\n        Not supported by \\'LSODA\\', see `lband` and `uband` instead.\\n    lband, uband : int or None, optional\\n        Parameters defining the bandwidth of the Jacobian for the \\'LSODA\\'\\n        method, i.e., ``jac[i, j] != 0 only for i - lband <= j <= i + uband``.\\n        Default is None. Setting these requires your jac routine to return the\\n        Jacobian in the packed format: the returned array must have ``n``\\n        columns and ``uband + lband + 1`` rows in which Jacobian diagonals are\\n        written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.\\n        The same format is used in `scipy.linalg.solve_banded` (check for an\\n        illustration).  These parameters can be also used with ``jac=None`` to\\n        reduce the number of Jacobian elements estimated by finite differences.\\n    min_step : float, optional\\n        The minimum allowed step size for \\'LSODA\\' method.\\n        By default `min_step` is zero.\\n\\n    Returns\\n    -------\\n    Bunch object with the following fields defined:\\n    t : ndarray, shape (n_points,)\\n        Time points.\\n    y : ndarray, shape (n, n_points)\\n        Values of the solution at `t`.\\n    sol : `OdeSolution` or None\\n        Found solution as `OdeSolution` instance; None if `dense_output` was\\n        set to False.\\n    t_events : list of ndarray or None\\n        Contains for each event type a list of arrays at which an event of\\n        that type event was detected. None if `events` was None.\\n    y_events : list of ndarray or None\\n        For each value of `t_events`, the corresponding value of the solution.\\n        None if `events` was None.\\n    nfev : int\\n        Number of evaluations of the right-hand side.\\n    njev : int\\n        Number of evaluations of the Jacobian.\\n    nlu : int\\n        Number of LU decompositions.\\n    status : int\\n        Reason for algorithm termination:\\n\\n            * -1: Integration step failed.\\n            *  0: The solver successfully reached the end of `tspan`.\\n            *  1: A termination event occurred.\\n\\n    message : string\\n        Human-readable description of the termination reason.\\n    success : bool\\n        True if the solver reached the interval end or a termination event\\n        occurred (``status >= 0``).\\n\\n    References\\n    ----------\\n    .. [1] J. R. Dormand, P. J. Prince, \"A family of embedded Runge-Kutta\\n           formulae\", Journal of Computational and Applied Mathematics, Vol. 6,\\n           No. 1, pp. 19-26, 1980.\\n    .. [2] L. W. Shampine, \"Some Practical Runge-Kutta Formulas\", Mathematics\\n           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.\\n    .. [3] P. Bogacki, L.F. Shampine, \"A 3(2) Pair of Runge-Kutta Formulas\",\\n           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.\\n    .. [4] E. Hairer, G. Wanner, \"Solving Ordinary Differential Equations II:\\n           Stiff and Differential-Algebraic Problems\", Sec. IV.8.\\n    .. [5] `Backward Differentiation Formula\\n            <https://en.wikipedia.org/wiki/Backward_differentiation_formula>`_\\n            on Wikipedia.\\n    .. [6] L. F. Shampine, M. W. Reichelt, \"THE MATLAB ODE SUITE\", SIAM J. SCI.\\n           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.\\n    .. [7] A. C. Hindmarsh, \"ODEPACK, A Systematized Collection of ODE\\n           Solvers,\" IMACS Transactions on Scientific Computation, Vol 1.,\\n           pp. 55-64, 1983.\\n    .. [8] L. Petzold, \"Automatic selection of methods for solving stiff and\\n           nonstiff systems of ordinary differential equations\", SIAM Journal\\n           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,\\n           1983.\\n    .. [9] `Stiff equation <https://en.wikipedia.org/wiki/Stiff_equation>`_ on\\n           Wikipedia.\\n    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, \"On the estimation of\\n            sparse Jacobian matrices\", Journal of the Institute of Mathematics\\n            and its Applications, 13, pp. 117-120, 1974.\\n    .. [11] `Cauchy-Riemann equations\\n             <https://en.wikipedia.org/wiki/Cauchy-Riemann_equations>`_ on\\n             Wikipedia.\\n    .. [12] `Lotka-Volterra equations\\n            <https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations>`_\\n            on Wikipedia.\\n    .. [13] E. Hairer, S. P. Norsett G. Wanner, \"Solving Ordinary Differential\\n            Equations I: Nonstiff Problems\", Sec. II.\\n    .. [14] `Page with original Fortran code of DOP853\\n            <http://www.unige.ch/~hairer/software.html>`_.\\n\\n    Examples\\n    --------\\n    Basic exponential decay showing automatically chosen time points.\\n\\n    >>> import numpy as np\\n    >>> from scipy.integrate import solve_ivp\\n    >>> def exponential_decay(t, y): return -0.5 * y\\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])\\n    >>> print(sol.t)\\n    [ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806\\n      8.33328988 10.        ]\\n    >>> print(sol.y)\\n    [[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045\\n      0.03107158 0.01350781]\\n     [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091\\n      0.06214316 0.02701561]\\n     [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181\\n      0.12428631 0.05403123]]\\n\\n    Specifying points where the solution is desired.\\n\\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],\\n    ...                 t_eval=[0, 1, 2, 4, 10])\\n    >>> print(sol.t)\\n    [ 0  1  2  4 10]\\n    >>> print(sol.y)\\n    [[2.         1.21305369 0.73534021 0.27066736 0.01350938]\\n     [4.         2.42610739 1.47068043 0.54133472 0.02701876]\\n     [8.         4.85221478 2.94136085 1.08266944 0.05403753]]\\n\\n    Cannon fired upward with terminal event upon impact. The ``terminal`` and\\n    ``direction`` fields of an event are applied by monkey patching a function.\\n    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts\\n    at position 0 with velocity +10. Note that the integration never reaches\\n    t=100 because the event is terminal.\\n\\n    >>> def upward_cannon(t, y): return [y[1], -0.5]\\n    >>> def hit_ground(t, y): return y[0]\\n    >>> hit_ground.terminal = True\\n    >>> hit_ground.direction = -1\\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)\\n    >>> print(sol.t_events)\\n    [array([40.])]\\n    >>> print(sol.t)\\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\\n\\n    Use `dense_output` and `events` to find position, which is 100, at the apex\\n    of the cannonball\\'s trajectory. Apex is not defined as terminal, so both\\n    apex and hit_ground are found. There is no information at t=20, so the sol\\n    attribute is used to evaluate the solution. The sol attribute is returned\\n    by setting ``dense_output=True``. Alternatively, the `y_events` attribute\\n    can be used to access the solution at the time of the event.\\n\\n    >>> def apex(t, y): return y[1]\\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10],\\n    ...                 events=(hit_ground, apex), dense_output=True)\\n    >>> print(sol.t_events)\\n    [array([40.]), array([20.])]\\n    >>> print(sol.t)\\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\\n    >>> print(sol.sol(sol.t_events[1][0]))\\n    [100.   0.]\\n    >>> print(sol.y_events)\\n    [array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]\\n\\n    As an example of a system with additional parameters, we\\'ll implement\\n    the Lotka-Volterra equations [12]_.\\n\\n    >>> def lotkavolterra(t, z, a, b, c, d):\\n    ...     x, y = z\\n    ...     return [a*x - b*x*y, -c*y + d*x*y]\\n    ...\\n\\n    We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`\\n    argument.\\n\\n    >>> sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),\\n    ...                 dense_output=True)\\n\\n    Compute a dense solution and plot it.\\n\\n    >>> t = np.linspace(0, 15, 300)\\n    >>> z = sol.sol(t)\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(t, z.T)\\n    >>> plt.xlabel(\\'t\\')\\n    >>> plt.legend([\\'x\\', \\'y\\'], shadow=True)\\n    >>> plt.title(\\'Lotka-Volterra System\\')\\n    >>> plt.show()\\n\\n    A couple examples of using solve_ivp to solve the differential\\n    equation ``y\\' = Ay`` with complex matrix ``A``.\\n\\n    >>> A = np.array([[-0.25 + 0.14j, 0, 0.33 + 0.44j],\\n    ...               [0.25 + 0.58j, -0.2 + 0.14j, 0],\\n    ...               [0, 0.2 + 0.4j, -0.1 + 0.97j]])\\n\\n    Solving an IVP with ``A`` from above and ``y`` as 3x1 vector:\\n\\n    >>> def deriv_vec(t, y):\\n    ...     return A @ y\\n    >>> result = solve_ivp(deriv_vec, [0, 25],\\n    ...                    np.array([10 + 0j, 20 + 0j, 30 + 0j]),\\n    ...                    t_eval=np.linspace(0, 25, 101))\\n    >>> print(result.y[:, 0])\\n    [10.+0.j 20.+0.j 30.+0.j]\\n    >>> print(result.y[:, -1])\\n    [18.46291039+45.25653651j 10.01569306+36.23293216j\\n     -4.98662741+80.07360388j]\\n\\n    Solving an IVP with ``A`` from above with ``y`` as 3x3 matrix :\\n\\n    >>> def deriv_mat(t, y):\\n    ...     return (A @ y.reshape(3, 3)).flatten()\\n    >>> y0 = np.array([[2 + 0j, 3 + 0j, 4 + 0j],\\n    ...                [5 + 0j, 6 + 0j, 7 + 0j],\\n    ...                [9 + 0j, 34 + 0j, 78 + 0j]])\\n\\n    >>> result = solve_ivp(deriv_mat, [0, 25], y0.flatten(),\\n    ...                    t_eval=np.linspace(0, 25, 101))\\n    >>> print(result.y[:, 0].reshape(3, 3))\\n    [[ 2.+0.j  3.+0.j  4.+0.j]\\n     [ 5.+0.j  6.+0.j  7.+0.j]\\n     [ 9.+0.j 34.+0.j 78.+0.j]]\\n    >>> print(result.y[:, -1].reshape(3, 3))\\n    [[  5.67451179 +12.07938445j  17.2888073  +31.03278837j\\n        37.83405768 +63.25138759j]\\n     [  3.39949503 +11.82123994j  21.32530996 +44.88668871j\\n        53.17531184+103.80400411j]\\n     [ -2.26105874 +22.19277664j -15.1255713  +70.19616341j\\n       -38.34616845+153.29039931j]]\\n\\n\\n    '\n    if method not in METHODS and (not (inspect.isclass(method) and issubclass(method, OdeSolver))):\n        raise ValueError('`method` must be one of {} or OdeSolver class.'.format(METHODS))\n    (t0, tf) = map(float, t_span)\n    if args is not None:\n        try:\n            _ = [*args]\n        except TypeError as exp:\n            suggestion_tuple = f\"Supplied 'args' cannot be unpacked. Please supply `args` as a tuple (e.g. `args=({args},)`)\"\n            raise TypeError(suggestion_tuple) from exp\n\n        def fun(t, x, fun=fun):\n            return fun(t, x, *args)\n        jac = options.get('jac')\n        if callable(jac):\n            options['jac'] = lambda t, x: jac(t, x, *args)\n    if t_eval is not None:\n        t_eval = np.asarray(t_eval)\n        if t_eval.ndim != 1:\n            raise ValueError('`t_eval` must be 1-dimensional.')\n        if np.any(t_eval < min(t0, tf)) or np.any(t_eval > max(t0, tf)):\n            raise ValueError('Values in `t_eval` are not within `t_span`.')\n        d = np.diff(t_eval)\n        if tf > t0 and np.any(d <= 0) or (tf < t0 and np.any(d >= 0)):\n            raise ValueError('Values in `t_eval` are not properly sorted.')\n        if tf > t0:\n            t_eval_i = 0\n        else:\n            t_eval = t_eval[::-1]\n            t_eval_i = t_eval.shape[0]\n    if method in METHODS:\n        method = METHODS[method]\n    solver = method(fun, t0, y0, tf, vectorized=vectorized, **options)\n    if t_eval is None:\n        ts = [t0]\n        ys = [y0]\n    elif t_eval is not None and dense_output:\n        ts = []\n        ti = [t0]\n        ys = []\n    else:\n        ts = []\n        ys = []\n    interpolants = []\n    (events, is_terminal, event_dir) = prepare_events(events)\n    if events is not None:\n        if args is not None:\n            events = [lambda t, x, event=event: event(t, x, *args) for event in events]\n        g = [event(t0, y0) for event in events]\n        t_events = [[] for _ in range(len(events))]\n        y_events = [[] for _ in range(len(events))]\n    else:\n        t_events = None\n        y_events = None\n    status = None\n    while status is None:\n        message = solver.step()\n        if solver.status == 'finished':\n            status = 0\n        elif solver.status == 'failed':\n            status = -1\n            break\n        t_old = solver.t_old\n        t = solver.t\n        y = solver.y\n        if dense_output:\n            sol = solver.dense_output()\n            interpolants.append(sol)\n        else:\n            sol = None\n        if events is not None:\n            g_new = [event(t, y) for event in events]\n            active_events = find_active_events(g, g_new, event_dir)\n            if active_events.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                (root_indices, roots, terminate) = handle_events(sol, events, active_events, is_terminal, t_old, t)\n                for (e, te) in zip(root_indices, roots):\n                    t_events[e].append(te)\n                    y_events[e].append(sol(te))\n                if terminate:\n                    status = 1\n                    t = roots[-1]\n                    y = sol(t)\n            g = g_new\n        if t_eval is None:\n            ts.append(t)\n            ys.append(y)\n        else:\n            if solver.direction > 0:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='right')\n                t_eval_step = t_eval[t_eval_i:t_eval_i_new]\n            else:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='left')\n                t_eval_step = t_eval[t_eval_i_new:t_eval_i][::-1]\n            if t_eval_step.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                ts.append(t_eval_step)\n                ys.append(sol(t_eval_step))\n                t_eval_i = t_eval_i_new\n        if t_eval is not None and dense_output:\n            ti.append(t)\n    message = MESSAGES.get(status, message)\n    if t_events is not None:\n        t_events = [np.asarray(te) for te in t_events]\n        y_events = [np.asarray(ye) for ye in y_events]\n    if t_eval is None:\n        ts = np.array(ts)\n        ys = np.vstack(ys).T\n    elif ts:\n        ts = np.hstack(ts)\n        ys = np.hstack(ys)\n    if dense_output:\n        if t_eval is None:\n            sol = OdeSolution(ts, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n        else:\n            sol = OdeSolution(ti, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n    else:\n        sol = None\n    return OdeResult(t=ts, y=ys, sol=sol, t_events=t_events, y_events=y_events, nfev=solver.nfev, njev=solver.njev, nlu=solver.nlu, status=status, message=message, success=status >= 0)",
            "def solve_ivp(fun, t_span, y0, method='RK45', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Solve an initial value problem for a system of ODEs.\\n\\n    This function numerically integrates a system of ordinary differential\\n    equations given an initial value::\\n\\n        dy / dt = f(t, y)\\n        y(t0) = y0\\n\\n    Here t is a 1-D independent variable (time), y(t) is an\\n    N-D vector-valued function (state), and an N-D\\n    vector-valued function f(t, y) determines the differential equations.\\n    The goal is to find y(t) approximately satisfying the differential\\n    equations, given an initial value y(t0)=y0.\\n\\n    Some of the solvers support integration in the complex domain, but note\\n    that for stiff ODE solvers, the right-hand side must be\\n    complex-differentiable (satisfy Cauchy-Riemann equations [11]_).\\n    To solve a problem in the complex domain, pass y0 with a complex data type.\\n    Another option always available is to rewrite your problem for real and\\n    imaginary parts separately.\\n\\n    Parameters\\n    ----------\\n    fun : callable\\n        Right-hand side of the system: the time derivative of the state ``y``\\n        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a\\n        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. Additional\\n        arguments need to be passed if ``args`` is used (see documentation of\\n        ``args`` argument). ``fun`` must return an array of the same shape as\\n        ``y``. See `vectorized` for more information.\\n    t_span : 2-member sequence\\n        Interval of integration (t0, tf). The solver starts with t=t0 and\\n        integrates until it reaches t=tf. Both t0 and tf must be floats\\n        or values interpretable by the float conversion function.\\n    y0 : array_like, shape (n,)\\n        Initial state. For problems in the complex domain, pass `y0` with a\\n        complex data type (even if the initial value is purely real).\\n    method : string or `OdeSolver`, optional\\n        Integration method to use:\\n\\n            * \\'RK45\\' (default): Explicit Runge-Kutta method of order 5(4) [1]_.\\n              The error is controlled assuming accuracy of the fourth-order\\n              method, but steps are taken using the fifth-order accurate\\n              formula (local extrapolation is done). A quartic interpolation\\n              polynomial is used for the dense output [2]_. Can be applied in\\n              the complex domain.\\n            * \\'RK23\\': Explicit Runge-Kutta method of order 3(2) [3]_. The error\\n              is controlled assuming accuracy of the second-order method, but\\n              steps are taken using the third-order accurate formula (local\\n              extrapolation is done). A cubic Hermite polynomial is used for the\\n              dense output. Can be applied in the complex domain.\\n            * \\'DOP853\\': Explicit Runge-Kutta method of order 8 [13]_.\\n              Python implementation of the \"DOP853\" algorithm originally\\n              written in Fortran [14]_. A 7-th order interpolation polynomial\\n              accurate to 7-th order is used for the dense output.\\n              Can be applied in the complex domain.\\n            * \\'Radau\\': Implicit Runge-Kutta method of the Radau IIA family of\\n              order 5 [4]_. The error is controlled with a third-order accurate\\n              embedded formula. A cubic polynomial which satisfies the\\n              collocation conditions is used for the dense output.\\n            * \\'BDF\\': Implicit multi-step variable-order (1 to 5) method based\\n              on a backward differentiation formula for the derivative\\n              approximation [5]_. The implementation follows the one described\\n              in [6]_. A quasi-constant step scheme is used and accuracy is\\n              enhanced using the NDF modification. Can be applied in the\\n              complex domain.\\n            * \\'LSODA\\': Adams/BDF method with automatic stiffness detection and\\n              switching [7]_, [8]_. This is a wrapper of the Fortran solver\\n              from ODEPACK.\\n\\n        Explicit Runge-Kutta methods (\\'RK23\\', \\'RK45\\', \\'DOP853\\') should be used\\n        for non-stiff problems and implicit methods (\\'Radau\\', \\'BDF\\') for\\n        stiff problems [9]_. Among Runge-Kutta methods, \\'DOP853\\' is recommended\\n        for solving with high precision (low values of `rtol` and `atol`).\\n\\n        If not sure, first try to run \\'RK45\\'. If it makes unusually many\\n        iterations, diverges, or fails, your problem is likely to be stiff and\\n        you should use \\'Radau\\' or \\'BDF\\'. \\'LSODA\\' can also be a good universal\\n        choice, but it might be somewhat less convenient to work with as it\\n        wraps old Fortran code.\\n\\n        You can also pass an arbitrary class derived from `OdeSolver` which\\n        implements the solver.\\n    t_eval : array_like or None, optional\\n        Times at which to store the computed solution, must be sorted and lie\\n        within `t_span`. If None (default), use points selected by the solver.\\n    dense_output : bool, optional\\n        Whether to compute a continuous solution. Default is False.\\n    events : callable, or list of callables, optional\\n        Events to track. If None (default), no events will be tracked.\\n        Each event occurs at the zeros of a continuous function of time and\\n        state. Each function must have the signature ``event(t, y)`` where\\n        additional argument have to be passed if ``args`` is used (see\\n        documentation of ``args`` argument). Each function must return a\\n        float. The solver will find an accurate value of `t` at which\\n        ``event(t, y(t)) = 0`` using a root-finding algorithm. By default,\\n        all zeros will be found. The solver looks for a sign change over\\n        each step, so if multiple zero crossings occur within one step,\\n        events may be missed. Additionally each `event` function might\\n        have the following attributes:\\n\\n            terminal: bool, optional\\n                Whether to terminate integration if this event occurs.\\n                Implicitly False if not assigned.\\n            direction: float, optional\\n                Direction of a zero crossing. If `direction` is positive,\\n                `event` will only trigger when going from negative to positive,\\n                and vice versa if `direction` is negative. If 0, then either\\n                direction will trigger event. Implicitly 0 if not assigned.\\n\\n        You can assign attributes like ``event.terminal = True`` to any\\n        function in Python.\\n    vectorized : bool, optional\\n        Whether `fun` can be called in a vectorized fashion. Default is False.\\n\\n        If ``vectorized`` is False, `fun` will always be called with ``y`` of\\n        shape ``(n,)``, where ``n = len(y0)``.\\n\\n        If ``vectorized`` is True, `fun` may be called with ``y`` of shape\\n        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave\\n        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of\\n        the returned array is the time derivative of the state corresponding\\n        with a column of ``y``).\\n\\n        Setting ``vectorized=True`` allows for faster finite difference\\n        approximation of the Jacobian by methods \\'Radau\\' and \\'BDF\\', but\\n        will result in slower execution for other methods and for \\'Radau\\' and\\n        \\'BDF\\' in some circumstances (e.g. small ``len(y0)``).\\n    args : tuple, optional\\n        Additional arguments to pass to the user-defined functions.  If given,\\n        the additional arguments are passed to all user-defined functions.\\n        So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,\\n        then `jac` (if given) and any event functions must have the same\\n        signature, and `args` must be a tuple of length 3.\\n    **options\\n        Options passed to a chosen solver. All options available for already\\n        implemented solvers are listed below.\\n    first_step : float or None, optional\\n        Initial step size. Default is `None` which means that the algorithm\\n        should choose.\\n    max_step : float, optional\\n        Maximum allowed step size. Default is np.inf, i.e., the step size is not\\n        bounded and determined solely by the solver.\\n    rtol, atol : float or array_like, optional\\n        Relative and absolute tolerances. The solver keeps the local error\\n        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a\\n        relative accuracy (number of correct digits), while `atol` controls\\n        absolute accuracy (number of correct decimal places). To achieve the\\n        desired `rtol`, set `atol` to be smaller than the smallest value that\\n        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the\\n        allowable error. If `atol` is larger than ``rtol * abs(y)`` the\\n        number of correct digits is not guaranteed. Conversely, to achieve the\\n        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller\\n        than `atol`. If components of y have different scales, it might be\\n        beneficial to set different `atol` values for different components by\\n        passing array_like with shape (n,) for `atol`. Default values are\\n        1e-3 for `rtol` and 1e-6 for `atol`.\\n    jac : array_like, sparse_matrix, callable or None, optional\\n        Jacobian matrix of the right-hand side of the system with respect\\n        to y, required by the \\'Radau\\', \\'BDF\\' and \\'LSODA\\' method. The\\n        Jacobian matrix has shape (n, n) and its element (i, j) is equal to\\n        ``d f_i / d y_j``.  There are three ways to define the Jacobian:\\n\\n            * If array_like or sparse_matrix, the Jacobian is assumed to\\n              be constant. Not supported by \\'LSODA\\'.\\n            * If callable, the Jacobian is assumed to depend on both\\n              t and y; it will be called as ``jac(t, y)``, as necessary.\\n              Additional arguments have to be passed if ``args`` is\\n              used (see documentation of ``args`` argument).\\n              For \\'Radau\\' and \\'BDF\\' methods, the return value might be a\\n              sparse matrix.\\n            * If None (default), the Jacobian will be approximated by\\n              finite differences.\\n\\n        It is generally recommended to provide the Jacobian rather than\\n        relying on a finite-difference approximation.\\n    jac_sparsity : array_like, sparse matrix or None, optional\\n        Defines a sparsity structure of the Jacobian matrix for a finite-\\n        difference approximation. Its shape must be (n, n). This argument\\n        is ignored if `jac` is not `None`. If the Jacobian has only few\\n        non-zero elements in *each* row, providing the sparsity structure\\n        will greatly speed up the computations [10]_. A zero entry means that\\n        a corresponding element in the Jacobian is always zero. If None\\n        (default), the Jacobian is assumed to be dense.\\n        Not supported by \\'LSODA\\', see `lband` and `uband` instead.\\n    lband, uband : int or None, optional\\n        Parameters defining the bandwidth of the Jacobian for the \\'LSODA\\'\\n        method, i.e., ``jac[i, j] != 0 only for i - lband <= j <= i + uband``.\\n        Default is None. Setting these requires your jac routine to return the\\n        Jacobian in the packed format: the returned array must have ``n``\\n        columns and ``uband + lband + 1`` rows in which Jacobian diagonals are\\n        written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.\\n        The same format is used in `scipy.linalg.solve_banded` (check for an\\n        illustration).  These parameters can be also used with ``jac=None`` to\\n        reduce the number of Jacobian elements estimated by finite differences.\\n    min_step : float, optional\\n        The minimum allowed step size for \\'LSODA\\' method.\\n        By default `min_step` is zero.\\n\\n    Returns\\n    -------\\n    Bunch object with the following fields defined:\\n    t : ndarray, shape (n_points,)\\n        Time points.\\n    y : ndarray, shape (n, n_points)\\n        Values of the solution at `t`.\\n    sol : `OdeSolution` or None\\n        Found solution as `OdeSolution` instance; None if `dense_output` was\\n        set to False.\\n    t_events : list of ndarray or None\\n        Contains for each event type a list of arrays at which an event of\\n        that type event was detected. None if `events` was None.\\n    y_events : list of ndarray or None\\n        For each value of `t_events`, the corresponding value of the solution.\\n        None if `events` was None.\\n    nfev : int\\n        Number of evaluations of the right-hand side.\\n    njev : int\\n        Number of evaluations of the Jacobian.\\n    nlu : int\\n        Number of LU decompositions.\\n    status : int\\n        Reason for algorithm termination:\\n\\n            * -1: Integration step failed.\\n            *  0: The solver successfully reached the end of `tspan`.\\n            *  1: A termination event occurred.\\n\\n    message : string\\n        Human-readable description of the termination reason.\\n    success : bool\\n        True if the solver reached the interval end or a termination event\\n        occurred (``status >= 0``).\\n\\n    References\\n    ----------\\n    .. [1] J. R. Dormand, P. J. Prince, \"A family of embedded Runge-Kutta\\n           formulae\", Journal of Computational and Applied Mathematics, Vol. 6,\\n           No. 1, pp. 19-26, 1980.\\n    .. [2] L. W. Shampine, \"Some Practical Runge-Kutta Formulas\", Mathematics\\n           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.\\n    .. [3] P. Bogacki, L.F. Shampine, \"A 3(2) Pair of Runge-Kutta Formulas\",\\n           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.\\n    .. [4] E. Hairer, G. Wanner, \"Solving Ordinary Differential Equations II:\\n           Stiff and Differential-Algebraic Problems\", Sec. IV.8.\\n    .. [5] `Backward Differentiation Formula\\n            <https://en.wikipedia.org/wiki/Backward_differentiation_formula>`_\\n            on Wikipedia.\\n    .. [6] L. F. Shampine, M. W. Reichelt, \"THE MATLAB ODE SUITE\", SIAM J. SCI.\\n           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.\\n    .. [7] A. C. Hindmarsh, \"ODEPACK, A Systematized Collection of ODE\\n           Solvers,\" IMACS Transactions on Scientific Computation, Vol 1.,\\n           pp. 55-64, 1983.\\n    .. [8] L. Petzold, \"Automatic selection of methods for solving stiff and\\n           nonstiff systems of ordinary differential equations\", SIAM Journal\\n           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,\\n           1983.\\n    .. [9] `Stiff equation <https://en.wikipedia.org/wiki/Stiff_equation>`_ on\\n           Wikipedia.\\n    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, \"On the estimation of\\n            sparse Jacobian matrices\", Journal of the Institute of Mathematics\\n            and its Applications, 13, pp. 117-120, 1974.\\n    .. [11] `Cauchy-Riemann equations\\n             <https://en.wikipedia.org/wiki/Cauchy-Riemann_equations>`_ on\\n             Wikipedia.\\n    .. [12] `Lotka-Volterra equations\\n            <https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations>`_\\n            on Wikipedia.\\n    .. [13] E. Hairer, S. P. Norsett G. Wanner, \"Solving Ordinary Differential\\n            Equations I: Nonstiff Problems\", Sec. II.\\n    .. [14] `Page with original Fortran code of DOP853\\n            <http://www.unige.ch/~hairer/software.html>`_.\\n\\n    Examples\\n    --------\\n    Basic exponential decay showing automatically chosen time points.\\n\\n    >>> import numpy as np\\n    >>> from scipy.integrate import solve_ivp\\n    >>> def exponential_decay(t, y): return -0.5 * y\\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])\\n    >>> print(sol.t)\\n    [ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806\\n      8.33328988 10.        ]\\n    >>> print(sol.y)\\n    [[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045\\n      0.03107158 0.01350781]\\n     [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091\\n      0.06214316 0.02701561]\\n     [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181\\n      0.12428631 0.05403123]]\\n\\n    Specifying points where the solution is desired.\\n\\n    >>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],\\n    ...                 t_eval=[0, 1, 2, 4, 10])\\n    >>> print(sol.t)\\n    [ 0  1  2  4 10]\\n    >>> print(sol.y)\\n    [[2.         1.21305369 0.73534021 0.27066736 0.01350938]\\n     [4.         2.42610739 1.47068043 0.54133472 0.02701876]\\n     [8.         4.85221478 2.94136085 1.08266944 0.05403753]]\\n\\n    Cannon fired upward with terminal event upon impact. The ``terminal`` and\\n    ``direction`` fields of an event are applied by monkey patching a function.\\n    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts\\n    at position 0 with velocity +10. Note that the integration never reaches\\n    t=100 because the event is terminal.\\n\\n    >>> def upward_cannon(t, y): return [y[1], -0.5]\\n    >>> def hit_ground(t, y): return y[0]\\n    >>> hit_ground.terminal = True\\n    >>> hit_ground.direction = -1\\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)\\n    >>> print(sol.t_events)\\n    [array([40.])]\\n    >>> print(sol.t)\\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\\n\\n    Use `dense_output` and `events` to find position, which is 100, at the apex\\n    of the cannonball\\'s trajectory. Apex is not defined as terminal, so both\\n    apex and hit_ground are found. There is no information at t=20, so the sol\\n    attribute is used to evaluate the solution. The sol attribute is returned\\n    by setting ``dense_output=True``. Alternatively, the `y_events` attribute\\n    can be used to access the solution at the time of the event.\\n\\n    >>> def apex(t, y): return y[1]\\n    >>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10],\\n    ...                 events=(hit_ground, apex), dense_output=True)\\n    >>> print(sol.t_events)\\n    [array([40.]), array([20.])]\\n    >>> print(sol.t)\\n    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\\n     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\\n    >>> print(sol.sol(sol.t_events[1][0]))\\n    [100.   0.]\\n    >>> print(sol.y_events)\\n    [array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])]\\n\\n    As an example of a system with additional parameters, we\\'ll implement\\n    the Lotka-Volterra equations [12]_.\\n\\n    >>> def lotkavolterra(t, z, a, b, c, d):\\n    ...     x, y = z\\n    ...     return [a*x - b*x*y, -c*y + d*x*y]\\n    ...\\n\\n    We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`\\n    argument.\\n\\n    >>> sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),\\n    ...                 dense_output=True)\\n\\n    Compute a dense solution and plot it.\\n\\n    >>> t = np.linspace(0, 15, 300)\\n    >>> z = sol.sol(t)\\n    >>> import matplotlib.pyplot as plt\\n    >>> plt.plot(t, z.T)\\n    >>> plt.xlabel(\\'t\\')\\n    >>> plt.legend([\\'x\\', \\'y\\'], shadow=True)\\n    >>> plt.title(\\'Lotka-Volterra System\\')\\n    >>> plt.show()\\n\\n    A couple examples of using solve_ivp to solve the differential\\n    equation ``y\\' = Ay`` with complex matrix ``A``.\\n\\n    >>> A = np.array([[-0.25 + 0.14j, 0, 0.33 + 0.44j],\\n    ...               [0.25 + 0.58j, -0.2 + 0.14j, 0],\\n    ...               [0, 0.2 + 0.4j, -0.1 + 0.97j]])\\n\\n    Solving an IVP with ``A`` from above and ``y`` as 3x1 vector:\\n\\n    >>> def deriv_vec(t, y):\\n    ...     return A @ y\\n    >>> result = solve_ivp(deriv_vec, [0, 25],\\n    ...                    np.array([10 + 0j, 20 + 0j, 30 + 0j]),\\n    ...                    t_eval=np.linspace(0, 25, 101))\\n    >>> print(result.y[:, 0])\\n    [10.+0.j 20.+0.j 30.+0.j]\\n    >>> print(result.y[:, -1])\\n    [18.46291039+45.25653651j 10.01569306+36.23293216j\\n     -4.98662741+80.07360388j]\\n\\n    Solving an IVP with ``A`` from above with ``y`` as 3x3 matrix :\\n\\n    >>> def deriv_mat(t, y):\\n    ...     return (A @ y.reshape(3, 3)).flatten()\\n    >>> y0 = np.array([[2 + 0j, 3 + 0j, 4 + 0j],\\n    ...                [5 + 0j, 6 + 0j, 7 + 0j],\\n    ...                [9 + 0j, 34 + 0j, 78 + 0j]])\\n\\n    >>> result = solve_ivp(deriv_mat, [0, 25], y0.flatten(),\\n    ...                    t_eval=np.linspace(0, 25, 101))\\n    >>> print(result.y[:, 0].reshape(3, 3))\\n    [[ 2.+0.j  3.+0.j  4.+0.j]\\n     [ 5.+0.j  6.+0.j  7.+0.j]\\n     [ 9.+0.j 34.+0.j 78.+0.j]]\\n    >>> print(result.y[:, -1].reshape(3, 3))\\n    [[  5.67451179 +12.07938445j  17.2888073  +31.03278837j\\n        37.83405768 +63.25138759j]\\n     [  3.39949503 +11.82123994j  21.32530996 +44.88668871j\\n        53.17531184+103.80400411j]\\n     [ -2.26105874 +22.19277664j -15.1255713  +70.19616341j\\n       -38.34616845+153.29039931j]]\\n\\n\\n    '\n    if method not in METHODS and (not (inspect.isclass(method) and issubclass(method, OdeSolver))):\n        raise ValueError('`method` must be one of {} or OdeSolver class.'.format(METHODS))\n    (t0, tf) = map(float, t_span)\n    if args is not None:\n        try:\n            _ = [*args]\n        except TypeError as exp:\n            suggestion_tuple = f\"Supplied 'args' cannot be unpacked. Please supply `args` as a tuple (e.g. `args=({args},)`)\"\n            raise TypeError(suggestion_tuple) from exp\n\n        def fun(t, x, fun=fun):\n            return fun(t, x, *args)\n        jac = options.get('jac')\n        if callable(jac):\n            options['jac'] = lambda t, x: jac(t, x, *args)\n    if t_eval is not None:\n        t_eval = np.asarray(t_eval)\n        if t_eval.ndim != 1:\n            raise ValueError('`t_eval` must be 1-dimensional.')\n        if np.any(t_eval < min(t0, tf)) or np.any(t_eval > max(t0, tf)):\n            raise ValueError('Values in `t_eval` are not within `t_span`.')\n        d = np.diff(t_eval)\n        if tf > t0 and np.any(d <= 0) or (tf < t0 and np.any(d >= 0)):\n            raise ValueError('Values in `t_eval` are not properly sorted.')\n        if tf > t0:\n            t_eval_i = 0\n        else:\n            t_eval = t_eval[::-1]\n            t_eval_i = t_eval.shape[0]\n    if method in METHODS:\n        method = METHODS[method]\n    solver = method(fun, t0, y0, tf, vectorized=vectorized, **options)\n    if t_eval is None:\n        ts = [t0]\n        ys = [y0]\n    elif t_eval is not None and dense_output:\n        ts = []\n        ti = [t0]\n        ys = []\n    else:\n        ts = []\n        ys = []\n    interpolants = []\n    (events, is_terminal, event_dir) = prepare_events(events)\n    if events is not None:\n        if args is not None:\n            events = [lambda t, x, event=event: event(t, x, *args) for event in events]\n        g = [event(t0, y0) for event in events]\n        t_events = [[] for _ in range(len(events))]\n        y_events = [[] for _ in range(len(events))]\n    else:\n        t_events = None\n        y_events = None\n    status = None\n    while status is None:\n        message = solver.step()\n        if solver.status == 'finished':\n            status = 0\n        elif solver.status == 'failed':\n            status = -1\n            break\n        t_old = solver.t_old\n        t = solver.t\n        y = solver.y\n        if dense_output:\n            sol = solver.dense_output()\n            interpolants.append(sol)\n        else:\n            sol = None\n        if events is not None:\n            g_new = [event(t, y) for event in events]\n            active_events = find_active_events(g, g_new, event_dir)\n            if active_events.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                (root_indices, roots, terminate) = handle_events(sol, events, active_events, is_terminal, t_old, t)\n                for (e, te) in zip(root_indices, roots):\n                    t_events[e].append(te)\n                    y_events[e].append(sol(te))\n                if terminate:\n                    status = 1\n                    t = roots[-1]\n                    y = sol(t)\n            g = g_new\n        if t_eval is None:\n            ts.append(t)\n            ys.append(y)\n        else:\n            if solver.direction > 0:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='right')\n                t_eval_step = t_eval[t_eval_i:t_eval_i_new]\n            else:\n                t_eval_i_new = np.searchsorted(t_eval, t, side='left')\n                t_eval_step = t_eval[t_eval_i_new:t_eval_i][::-1]\n            if t_eval_step.size > 0:\n                if sol is None:\n                    sol = solver.dense_output()\n                ts.append(t_eval_step)\n                ys.append(sol(t_eval_step))\n                t_eval_i = t_eval_i_new\n        if t_eval is not None and dense_output:\n            ti.append(t)\n    message = MESSAGES.get(status, message)\n    if t_events is not None:\n        t_events = [np.asarray(te) for te in t_events]\n        y_events = [np.asarray(ye) for ye in y_events]\n    if t_eval is None:\n        ts = np.array(ts)\n        ys = np.vstack(ys).T\n    elif ts:\n        ts = np.hstack(ts)\n        ys = np.hstack(ys)\n    if dense_output:\n        if t_eval is None:\n            sol = OdeSolution(ts, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n        else:\n            sol = OdeSolution(ti, interpolants, alt_segment=True if method in [BDF, LSODA] else False)\n    else:\n        sol = None\n    return OdeResult(t=ts, y=ys, sol=sol, t_events=t_events, y_events=y_events, nfev=solver.nfev, njev=solver.njev, nlu=solver.nlu, status=status, message=message, success=status >= 0)"
        ]
    }
]