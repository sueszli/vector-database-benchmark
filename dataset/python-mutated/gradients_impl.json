[
    {
        "func_name": "gradients",
        "original": "@tf_export(v1=['gradients'])\ndef gradients(ys, xs, grad_ys=None, name='gradients', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    \"\"\"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\n\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\n  is a list of `Tensor`, holding the gradients received by the\n  `ys`. The list must be the same length as `ys`.\n\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\n\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\n  user can provide their own initial `grad_ys` to compute the\n  derivatives using a different initial gradient for each y (e.g., if\n  one wanted to weight the gradient differently for each value in\n  each y).\n\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\n  with respect to all `xs`. These tensors will not be backpropagated through,\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\n  other things, this allows computation of partial derivatives as opposed to\n  total derivatives. For example:\n\n  ```python\n  a = tf.constant(0.)\n  b = 2 * a\n  g = tf.gradients(a + b, [a, b], stop_gradients=[a, b])\n  ```\n\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\n  equivalent to:\n\n  ```python\n  a = tf.stop_gradient(tf.constant(0.))\n  b = tf.stop_gradient(2 * a)\n  g = tf.gradients(a + b, [a, b])\n  ```\n\n  `stop_gradients` provides a way of stopping gradient after the graph has\n  already been constructed, as compared to `tf.stop_gradient` which is used\n  during graph construction.  When the two approaches are combined,\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\n  `stop_gradients`, whichever is encountered first.\n\n  All integer tensors are considered constant with respect to all `xs`, as if\n  they were included in `stop_gradients`.\n\n  `unconnected_gradients` determines the value returned for each x in xs if it\n  is unconnected in the graph to ys. By default this is None to safeguard\n  against errors. Mathematically these gradients are zero which can be requested\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\n  following options and behaviors:\n\n  ```python\n  a = tf.ones([1, 2])\n  b = tf.ones([3, 1])\n  g1 = tf.gradients([b], [a], unconnected_gradients='none')\n  sess.run(g1)  # [None]\n\n  g2 = tf.gradients([b], [a], unconnected_gradients='zero')\n  sess.run(g2)  # [array([[0., 0.]], dtype=float32)]\n  ```\n\n  Let us take one practical example which comes during the back propogation\n  phase. This function is used to evaluate the derivatives of the cost function\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\n  provides the exaplantion of what it is actually used for :\n\n  ```python\n  Ws = tf.constant(0.)\n  bs = 2 * Ws\n  cost = Ws + bs  # This is just an example. So, please ignore the formulas.\n  g = tf.gradients(cost, [Ws, bs])\n  dCost_dW, dCost_db = g\n  ```\n\n\n  Args:\n    ys: A `Tensor` or list of tensors to be differentiated.\n    xs: A `Tensor` or list of tensors to be used for differentiation.\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\n      `ys` and holding the gradients computed for each y in `ys`.\n    name: Optional name to use for grouping all the gradient ops together.\n      defaults to 'gradients'.\n    colocate_gradients_with_ops: If True, try colocating gradients with\n      the corresponding op.\n    gate_gradients: If True, add a tuple around the gradients returned\n      for an operations.  This avoids some race conditions.\n    aggregation_method: Specifies the method used to combine gradient terms.\n      Accepted values are constants defined in the class `AggregationMethod`.\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\n      through.\n    unconnected_gradients: Optional. Specifies the gradient value returned when\n      the given input tensors are unconnected. Accepted values are constants\n      defined in the class `tf.UnconnectedGradients` and the default value is\n      `none`.\n\n  Returns:\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\n    for y in `ys` and for x in `xs`.\n\n  Raises:\n    LookupError: if one of the operations between `x` and `y` does not\n      have a registered gradient function.\n    ValueError: if the arguments are invalid.\n    RuntimeError: if called in Eager mode.\n\n  \"\"\"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, colocate_gradients_with_ops, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)",
        "mutated": [
            "@tf_export(v1=['gradients'])\ndef gradients(ys, xs, grad_ys=None, name='gradients', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    if False:\n        i = 10\n    \"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\\n\\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\\n  is a list of `Tensor`, holding the gradients received by the\\n  `ys`. The list must be the same length as `ys`.\\n\\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\\n\\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\\n  user can provide their own initial `grad_ys` to compute the\\n  derivatives using a different initial gradient for each y (e.g., if\\n  one wanted to weight the gradient differently for each value in\\n  each y).\\n\\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\\n  with respect to all `xs`. These tensors will not be backpropagated through,\\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\\n  other things, this allows computation of partial derivatives as opposed to\\n  total derivatives. For example:\\n\\n  ```python\\n  a = tf.constant(0.)\\n  b = 2 * a\\n  g = tf.gradients(a + b, [a, b], stop_gradients=[a, b])\\n  ```\\n\\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\\n  equivalent to:\\n\\n  ```python\\n  a = tf.stop_gradient(tf.constant(0.))\\n  b = tf.stop_gradient(2 * a)\\n  g = tf.gradients(a + b, [a, b])\\n  ```\\n\\n  `stop_gradients` provides a way of stopping gradient after the graph has\\n  already been constructed, as compared to `tf.stop_gradient` which is used\\n  during graph construction.  When the two approaches are combined,\\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\\n  `stop_gradients`, whichever is encountered first.\\n\\n  All integer tensors are considered constant with respect to all `xs`, as if\\n  they were included in `stop_gradients`.\\n\\n  `unconnected_gradients` determines the value returned for each x in xs if it\\n  is unconnected in the graph to ys. By default this is None to safeguard\\n  against errors. Mathematically these gradients are zero which can be requested\\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\\n  following options and behaviors:\\n\\n  ```python\\n  a = tf.ones([1, 2])\\n  b = tf.ones([3, 1])\\n  g1 = tf.gradients([b], [a], unconnected_gradients='none')\\n  sess.run(g1)  # [None]\\n\\n  g2 = tf.gradients([b], [a], unconnected_gradients='zero')\\n  sess.run(g2)  # [array([[0., 0.]], dtype=float32)]\\n  ```\\n\\n  Let us take one practical example which comes during the back propogation\\n  phase. This function is used to evaluate the derivatives of the cost function\\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\\n  provides the exaplantion of what it is actually used for :\\n\\n  ```python\\n  Ws = tf.constant(0.)\\n  bs = 2 * Ws\\n  cost = Ws + bs  # This is just an example. So, please ignore the formulas.\\n  g = tf.gradients(cost, [Ws, bs])\\n  dCost_dW, dCost_db = g\\n  ```\\n\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\\n      `ys` and holding the gradients computed for each y in `ys`.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'gradients'.\\n    colocate_gradients_with_ops: If True, try colocating gradients with\\n      the corresponding op.\\n    gate_gradients: If True, add a tuple around the gradients returned\\n      for an operations.  This avoids some race conditions.\\n    aggregation_method: Specifies the method used to combine gradient terms.\\n      Accepted values are constants defined in the class `AggregationMethod`.\\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\\n      through.\\n    unconnected_gradients: Optional. Specifies the gradient value returned when\\n      the given input tensors are unconnected. Accepted values are constants\\n      defined in the class `tf.UnconnectedGradients` and the default value is\\n      `none`.\\n\\n  Returns:\\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\\n    for y in `ys` and for x in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `x` and `y` does not\\n      have a registered gradient function.\\n    ValueError: if the arguments are invalid.\\n    RuntimeError: if called in Eager mode.\\n\\n  \"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, colocate_gradients_with_ops, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)",
            "@tf_export(v1=['gradients'])\ndef gradients(ys, xs, grad_ys=None, name='gradients', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\\n\\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\\n  is a list of `Tensor`, holding the gradients received by the\\n  `ys`. The list must be the same length as `ys`.\\n\\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\\n\\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\\n  user can provide their own initial `grad_ys` to compute the\\n  derivatives using a different initial gradient for each y (e.g., if\\n  one wanted to weight the gradient differently for each value in\\n  each y).\\n\\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\\n  with respect to all `xs`. These tensors will not be backpropagated through,\\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\\n  other things, this allows computation of partial derivatives as opposed to\\n  total derivatives. For example:\\n\\n  ```python\\n  a = tf.constant(0.)\\n  b = 2 * a\\n  g = tf.gradients(a + b, [a, b], stop_gradients=[a, b])\\n  ```\\n\\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\\n  equivalent to:\\n\\n  ```python\\n  a = tf.stop_gradient(tf.constant(0.))\\n  b = tf.stop_gradient(2 * a)\\n  g = tf.gradients(a + b, [a, b])\\n  ```\\n\\n  `stop_gradients` provides a way of stopping gradient after the graph has\\n  already been constructed, as compared to `tf.stop_gradient` which is used\\n  during graph construction.  When the two approaches are combined,\\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\\n  `stop_gradients`, whichever is encountered first.\\n\\n  All integer tensors are considered constant with respect to all `xs`, as if\\n  they were included in `stop_gradients`.\\n\\n  `unconnected_gradients` determines the value returned for each x in xs if it\\n  is unconnected in the graph to ys. By default this is None to safeguard\\n  against errors. Mathematically these gradients are zero which can be requested\\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\\n  following options and behaviors:\\n\\n  ```python\\n  a = tf.ones([1, 2])\\n  b = tf.ones([3, 1])\\n  g1 = tf.gradients([b], [a], unconnected_gradients='none')\\n  sess.run(g1)  # [None]\\n\\n  g2 = tf.gradients([b], [a], unconnected_gradients='zero')\\n  sess.run(g2)  # [array([[0., 0.]], dtype=float32)]\\n  ```\\n\\n  Let us take one practical example which comes during the back propogation\\n  phase. This function is used to evaluate the derivatives of the cost function\\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\\n  provides the exaplantion of what it is actually used for :\\n\\n  ```python\\n  Ws = tf.constant(0.)\\n  bs = 2 * Ws\\n  cost = Ws + bs  # This is just an example. So, please ignore the formulas.\\n  g = tf.gradients(cost, [Ws, bs])\\n  dCost_dW, dCost_db = g\\n  ```\\n\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\\n      `ys` and holding the gradients computed for each y in `ys`.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'gradients'.\\n    colocate_gradients_with_ops: If True, try colocating gradients with\\n      the corresponding op.\\n    gate_gradients: If True, add a tuple around the gradients returned\\n      for an operations.  This avoids some race conditions.\\n    aggregation_method: Specifies the method used to combine gradient terms.\\n      Accepted values are constants defined in the class `AggregationMethod`.\\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\\n      through.\\n    unconnected_gradients: Optional. Specifies the gradient value returned when\\n      the given input tensors are unconnected. Accepted values are constants\\n      defined in the class `tf.UnconnectedGradients` and the default value is\\n      `none`.\\n\\n  Returns:\\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\\n    for y in `ys` and for x in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `x` and `y` does not\\n      have a registered gradient function.\\n    ValueError: if the arguments are invalid.\\n    RuntimeError: if called in Eager mode.\\n\\n  \"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, colocate_gradients_with_ops, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)",
            "@tf_export(v1=['gradients'])\ndef gradients(ys, xs, grad_ys=None, name='gradients', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\\n\\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\\n  is a list of `Tensor`, holding the gradients received by the\\n  `ys`. The list must be the same length as `ys`.\\n\\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\\n\\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\\n  user can provide their own initial `grad_ys` to compute the\\n  derivatives using a different initial gradient for each y (e.g., if\\n  one wanted to weight the gradient differently for each value in\\n  each y).\\n\\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\\n  with respect to all `xs`. These tensors will not be backpropagated through,\\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\\n  other things, this allows computation of partial derivatives as opposed to\\n  total derivatives. For example:\\n\\n  ```python\\n  a = tf.constant(0.)\\n  b = 2 * a\\n  g = tf.gradients(a + b, [a, b], stop_gradients=[a, b])\\n  ```\\n\\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\\n  equivalent to:\\n\\n  ```python\\n  a = tf.stop_gradient(tf.constant(0.))\\n  b = tf.stop_gradient(2 * a)\\n  g = tf.gradients(a + b, [a, b])\\n  ```\\n\\n  `stop_gradients` provides a way of stopping gradient after the graph has\\n  already been constructed, as compared to `tf.stop_gradient` which is used\\n  during graph construction.  When the two approaches are combined,\\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\\n  `stop_gradients`, whichever is encountered first.\\n\\n  All integer tensors are considered constant with respect to all `xs`, as if\\n  they were included in `stop_gradients`.\\n\\n  `unconnected_gradients` determines the value returned for each x in xs if it\\n  is unconnected in the graph to ys. By default this is None to safeguard\\n  against errors. Mathematically these gradients are zero which can be requested\\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\\n  following options and behaviors:\\n\\n  ```python\\n  a = tf.ones([1, 2])\\n  b = tf.ones([3, 1])\\n  g1 = tf.gradients([b], [a], unconnected_gradients='none')\\n  sess.run(g1)  # [None]\\n\\n  g2 = tf.gradients([b], [a], unconnected_gradients='zero')\\n  sess.run(g2)  # [array([[0., 0.]], dtype=float32)]\\n  ```\\n\\n  Let us take one practical example which comes during the back propogation\\n  phase. This function is used to evaluate the derivatives of the cost function\\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\\n  provides the exaplantion of what it is actually used for :\\n\\n  ```python\\n  Ws = tf.constant(0.)\\n  bs = 2 * Ws\\n  cost = Ws + bs  # This is just an example. So, please ignore the formulas.\\n  g = tf.gradients(cost, [Ws, bs])\\n  dCost_dW, dCost_db = g\\n  ```\\n\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\\n      `ys` and holding the gradients computed for each y in `ys`.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'gradients'.\\n    colocate_gradients_with_ops: If True, try colocating gradients with\\n      the corresponding op.\\n    gate_gradients: If True, add a tuple around the gradients returned\\n      for an operations.  This avoids some race conditions.\\n    aggregation_method: Specifies the method used to combine gradient terms.\\n      Accepted values are constants defined in the class `AggregationMethod`.\\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\\n      through.\\n    unconnected_gradients: Optional. Specifies the gradient value returned when\\n      the given input tensors are unconnected. Accepted values are constants\\n      defined in the class `tf.UnconnectedGradients` and the default value is\\n      `none`.\\n\\n  Returns:\\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\\n    for y in `ys` and for x in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `x` and `y` does not\\n      have a registered gradient function.\\n    ValueError: if the arguments are invalid.\\n    RuntimeError: if called in Eager mode.\\n\\n  \"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, colocate_gradients_with_ops, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)",
            "@tf_export(v1=['gradients'])\ndef gradients(ys, xs, grad_ys=None, name='gradients', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\\n\\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\\n  is a list of `Tensor`, holding the gradients received by the\\n  `ys`. The list must be the same length as `ys`.\\n\\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\\n\\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\\n  user can provide their own initial `grad_ys` to compute the\\n  derivatives using a different initial gradient for each y (e.g., if\\n  one wanted to weight the gradient differently for each value in\\n  each y).\\n\\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\\n  with respect to all `xs`. These tensors will not be backpropagated through,\\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\\n  other things, this allows computation of partial derivatives as opposed to\\n  total derivatives. For example:\\n\\n  ```python\\n  a = tf.constant(0.)\\n  b = 2 * a\\n  g = tf.gradients(a + b, [a, b], stop_gradients=[a, b])\\n  ```\\n\\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\\n  equivalent to:\\n\\n  ```python\\n  a = tf.stop_gradient(tf.constant(0.))\\n  b = tf.stop_gradient(2 * a)\\n  g = tf.gradients(a + b, [a, b])\\n  ```\\n\\n  `stop_gradients` provides a way of stopping gradient after the graph has\\n  already been constructed, as compared to `tf.stop_gradient` which is used\\n  during graph construction.  When the two approaches are combined,\\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\\n  `stop_gradients`, whichever is encountered first.\\n\\n  All integer tensors are considered constant with respect to all `xs`, as if\\n  they were included in `stop_gradients`.\\n\\n  `unconnected_gradients` determines the value returned for each x in xs if it\\n  is unconnected in the graph to ys. By default this is None to safeguard\\n  against errors. Mathematically these gradients are zero which can be requested\\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\\n  following options and behaviors:\\n\\n  ```python\\n  a = tf.ones([1, 2])\\n  b = tf.ones([3, 1])\\n  g1 = tf.gradients([b], [a], unconnected_gradients='none')\\n  sess.run(g1)  # [None]\\n\\n  g2 = tf.gradients([b], [a], unconnected_gradients='zero')\\n  sess.run(g2)  # [array([[0., 0.]], dtype=float32)]\\n  ```\\n\\n  Let us take one practical example which comes during the back propogation\\n  phase. This function is used to evaluate the derivatives of the cost function\\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\\n  provides the exaplantion of what it is actually used for :\\n\\n  ```python\\n  Ws = tf.constant(0.)\\n  bs = 2 * Ws\\n  cost = Ws + bs  # This is just an example. So, please ignore the formulas.\\n  g = tf.gradients(cost, [Ws, bs])\\n  dCost_dW, dCost_db = g\\n  ```\\n\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\\n      `ys` and holding the gradients computed for each y in `ys`.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'gradients'.\\n    colocate_gradients_with_ops: If True, try colocating gradients with\\n      the corresponding op.\\n    gate_gradients: If True, add a tuple around the gradients returned\\n      for an operations.  This avoids some race conditions.\\n    aggregation_method: Specifies the method used to combine gradient terms.\\n      Accepted values are constants defined in the class `AggregationMethod`.\\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\\n      through.\\n    unconnected_gradients: Optional. Specifies the gradient value returned when\\n      the given input tensors are unconnected. Accepted values are constants\\n      defined in the class `tf.UnconnectedGradients` and the default value is\\n      `none`.\\n\\n  Returns:\\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\\n    for y in `ys` and for x in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `x` and `y` does not\\n      have a registered gradient function.\\n    ValueError: if the arguments are invalid.\\n    RuntimeError: if called in Eager mode.\\n\\n  \"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, colocate_gradients_with_ops, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)",
            "@tf_export(v1=['gradients'])\ndef gradients(ys, xs, grad_ys=None, name='gradients', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\\n\\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\\n  is a list of `Tensor`, holding the gradients received by the\\n  `ys`. The list must be the same length as `ys`.\\n\\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\\n\\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\\n  user can provide their own initial `grad_ys` to compute the\\n  derivatives using a different initial gradient for each y (e.g., if\\n  one wanted to weight the gradient differently for each value in\\n  each y).\\n\\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\\n  with respect to all `xs`. These tensors will not be backpropagated through,\\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\\n  other things, this allows computation of partial derivatives as opposed to\\n  total derivatives. For example:\\n\\n  ```python\\n  a = tf.constant(0.)\\n  b = 2 * a\\n  g = tf.gradients(a + b, [a, b], stop_gradients=[a, b])\\n  ```\\n\\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\\n  equivalent to:\\n\\n  ```python\\n  a = tf.stop_gradient(tf.constant(0.))\\n  b = tf.stop_gradient(2 * a)\\n  g = tf.gradients(a + b, [a, b])\\n  ```\\n\\n  `stop_gradients` provides a way of stopping gradient after the graph has\\n  already been constructed, as compared to `tf.stop_gradient` which is used\\n  during graph construction.  When the two approaches are combined,\\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\\n  `stop_gradients`, whichever is encountered first.\\n\\n  All integer tensors are considered constant with respect to all `xs`, as if\\n  they were included in `stop_gradients`.\\n\\n  `unconnected_gradients` determines the value returned for each x in xs if it\\n  is unconnected in the graph to ys. By default this is None to safeguard\\n  against errors. Mathematically these gradients are zero which can be requested\\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\\n  following options and behaviors:\\n\\n  ```python\\n  a = tf.ones([1, 2])\\n  b = tf.ones([3, 1])\\n  g1 = tf.gradients([b], [a], unconnected_gradients='none')\\n  sess.run(g1)  # [None]\\n\\n  g2 = tf.gradients([b], [a], unconnected_gradients='zero')\\n  sess.run(g2)  # [array([[0., 0.]], dtype=float32)]\\n  ```\\n\\n  Let us take one practical example which comes during the back propogation\\n  phase. This function is used to evaluate the derivatives of the cost function\\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\\n  provides the exaplantion of what it is actually used for :\\n\\n  ```python\\n  Ws = tf.constant(0.)\\n  bs = 2 * Ws\\n  cost = Ws + bs  # This is just an example. So, please ignore the formulas.\\n  g = tf.gradients(cost, [Ws, bs])\\n  dCost_dW, dCost_db = g\\n  ```\\n\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\\n      `ys` and holding the gradients computed for each y in `ys`.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'gradients'.\\n    colocate_gradients_with_ops: If True, try colocating gradients with\\n      the corresponding op.\\n    gate_gradients: If True, add a tuple around the gradients returned\\n      for an operations.  This avoids some race conditions.\\n    aggregation_method: Specifies the method used to combine gradient terms.\\n      Accepted values are constants defined in the class `AggregationMethod`.\\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\\n      through.\\n    unconnected_gradients: Optional. Specifies the gradient value returned when\\n      the given input tensors are unconnected. Accepted values are constants\\n      defined in the class `tf.UnconnectedGradients` and the default value is\\n      `none`.\\n\\n  Returns:\\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\\n    for y in `ys` and for x in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `x` and `y` does not\\n      have a registered gradient function.\\n    ValueError: if the arguments are invalid.\\n    RuntimeError: if called in Eager mode.\\n\\n  \"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, colocate_gradients_with_ops, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)"
        ]
    },
    {
        "func_name": "gradients_v2",
        "original": "@tf_export('gradients', v1=[])\ndef gradients_v2(ys, xs, grad_ys=None, name='gradients', gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    \"\"\"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\n\n  `tf.gradients` is only valid in a graph context. In particular,\n  it is valid in the context of a `tf.function` wrapper, where code\n  is executing as a graph.\n\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\n  is a list of `Tensor`, holding the gradients received by the\n  `ys`. The list must be the same length as `ys`.\n\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\n\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\n  user can provide their own initial `grad_ys` to compute the\n  derivatives using a different initial gradient for each y (e.g., if\n  one wanted to weight the gradient differently for each value in\n  each y).\n\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\n  with respect to all `xs`. These tensors will not be backpropagated through,\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\n  other things, this allows computation of partial derivatives as opposed to\n  total derivatives. For example:\n\n  >>> @tf.function\n  ... def example():\n  ...   a = tf.constant(0.)\n  ...   b = 2 * a\n  ...   return tf.gradients(a + b, [a, b], stop_gradients=[a, b])\n  >>> example()\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\n\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\n  equivalent to:\n\n  >>> @tf.function\n  ... def example():\n  ...   a = tf.stop_gradient(tf.constant(0.))\n  ...   b = tf.stop_gradient(2 * a)\n  ...   return tf.gradients(a + b, [a, b])\n  >>> example()\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\n\n  `stop_gradients` provides a way of stopping gradient after the graph has\n  already been constructed, as compared to `tf.stop_gradient` which is used\n  during graph construction.  When the two approaches are combined,\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\n  `stop_gradients`, whichever is encountered first.\n\n  All integer tensors are considered constant with respect to all `xs`, as if\n  they were included in `stop_gradients`.\n\n  `unconnected_gradients` determines the value returned for each x in xs if it\n  is unconnected in the graph to ys. By default this is None to safeguard\n  against errors. Mathematically these gradients are zero which can be requested\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\n  following options and behaviors:\n\n  >>> @tf.function\n  ... def example(use_zero):\n  ...   a = tf.ones([1, 2])\n  ...   b = tf.ones([3, 1])\n  ...   if use_zero:\n  ...     return tf.gradients([b], [a], unconnected_gradients='zero')\n  ...   else:\n  ...     return tf.gradients([b], [a], unconnected_gradients='none')\n  >>> example(False)\n  [None]\n  >>> example(True)\n  [<tf.Tensor: shape=(1, 2), dtype=float32, numpy=array([[0., 0.]], ...)>]\n\n  Let us take one practical example which comes during the back propogation\n  phase. This function is used to evaluate the derivatives of the cost function\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\n  provides the exaplantion of what it is actually used for :\n\n  >>> @tf.function\n  ... def example():\n  ...   Ws = tf.constant(0.)\n  ...   bs = 2 * Ws\n  ...   cost = Ws + bs  # This is just an example. Please ignore the formulas.\n  ...   g = tf.gradients(cost, [Ws, bs])\n  ...   dCost_dW, dCost_db = g\n  ...   return dCost_dW, dCost_db\n  >>> example()\n  (<tf.Tensor: shape=(), dtype=float32, numpy=3.0>,\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>)\n\n  Args:\n    ys: A `Tensor` or list of tensors to be differentiated.\n    xs: A `Tensor` or list of tensors to be used for differentiation.\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\n      `ys` and holding the gradients computed for each y in `ys`.\n    name: Optional name to use for grouping all the gradient ops together.\n      defaults to 'gradients'.\n    gate_gradients: If True, add a tuple around the gradients returned\n      for an operations.  This avoids some race conditions.\n    aggregation_method: Specifies the method used to combine gradient terms.\n      Accepted values are constants defined in the class `AggregationMethod`.\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\n      through.\n    unconnected_gradients: Optional. Specifies the gradient value returned when\n      the given input tensors are unconnected. Accepted values are constants\n      defined in the class `tf.UnconnectedGradients` and the default value is\n      `none`.\n\n  Returns:\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\n    for y in `ys` and for x in `xs`.\n\n  Raises:\n    LookupError: if one of the operations between `x` and `y` does not\n      have a registered gradient function.\n    ValueError: if the arguments are invalid.\n    RuntimeError: if called in Eager mode.\n\n  \"\"\"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, True, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)",
        "mutated": [
            "@tf_export('gradients', v1=[])\ndef gradients_v2(ys, xs, grad_ys=None, name='gradients', gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    if False:\n        i = 10\n    \"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\\n\\n  `tf.gradients` is only valid in a graph context. In particular,\\n  it is valid in the context of a `tf.function` wrapper, where code\\n  is executing as a graph.\\n\\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\\n  is a list of `Tensor`, holding the gradients received by the\\n  `ys`. The list must be the same length as `ys`.\\n\\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\\n\\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\\n  user can provide their own initial `grad_ys` to compute the\\n  derivatives using a different initial gradient for each y (e.g., if\\n  one wanted to weight the gradient differently for each value in\\n  each y).\\n\\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\\n  with respect to all `xs`. These tensors will not be backpropagated through,\\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\\n  other things, this allows computation of partial derivatives as opposed to\\n  total derivatives. For example:\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   a = tf.constant(0.)\\n  ...   b = 2 * a\\n  ...   return tf.gradients(a + b, [a, b], stop_gradients=[a, b])\\n  >>> example()\\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\\n\\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\\n  equivalent to:\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   a = tf.stop_gradient(tf.constant(0.))\\n  ...   b = tf.stop_gradient(2 * a)\\n  ...   return tf.gradients(a + b, [a, b])\\n  >>> example()\\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\\n\\n  `stop_gradients` provides a way of stopping gradient after the graph has\\n  already been constructed, as compared to `tf.stop_gradient` which is used\\n  during graph construction.  When the two approaches are combined,\\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\\n  `stop_gradients`, whichever is encountered first.\\n\\n  All integer tensors are considered constant with respect to all `xs`, as if\\n  they were included in `stop_gradients`.\\n\\n  `unconnected_gradients` determines the value returned for each x in xs if it\\n  is unconnected in the graph to ys. By default this is None to safeguard\\n  against errors. Mathematically these gradients are zero which can be requested\\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\\n  following options and behaviors:\\n\\n  >>> @tf.function\\n  ... def example(use_zero):\\n  ...   a = tf.ones([1, 2])\\n  ...   b = tf.ones([3, 1])\\n  ...   if use_zero:\\n  ...     return tf.gradients([b], [a], unconnected_gradients='zero')\\n  ...   else:\\n  ...     return tf.gradients([b], [a], unconnected_gradients='none')\\n  >>> example(False)\\n  [None]\\n  >>> example(True)\\n  [<tf.Tensor: shape=(1, 2), dtype=float32, numpy=array([[0., 0.]], ...)>]\\n\\n  Let us take one practical example which comes during the back propogation\\n  phase. This function is used to evaluate the derivatives of the cost function\\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\\n  provides the exaplantion of what it is actually used for :\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   Ws = tf.constant(0.)\\n  ...   bs = 2 * Ws\\n  ...   cost = Ws + bs  # This is just an example. Please ignore the formulas.\\n  ...   g = tf.gradients(cost, [Ws, bs])\\n  ...   dCost_dW, dCost_db = g\\n  ...   return dCost_dW, dCost_db\\n  >>> example()\\n  (<tf.Tensor: shape=(), dtype=float32, numpy=3.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>)\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\\n      `ys` and holding the gradients computed for each y in `ys`.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'gradients'.\\n    gate_gradients: If True, add a tuple around the gradients returned\\n      for an operations.  This avoids some race conditions.\\n    aggregation_method: Specifies the method used to combine gradient terms.\\n      Accepted values are constants defined in the class `AggregationMethod`.\\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\\n      through.\\n    unconnected_gradients: Optional. Specifies the gradient value returned when\\n      the given input tensors are unconnected. Accepted values are constants\\n      defined in the class `tf.UnconnectedGradients` and the default value is\\n      `none`.\\n\\n  Returns:\\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\\n    for y in `ys` and for x in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `x` and `y` does not\\n      have a registered gradient function.\\n    ValueError: if the arguments are invalid.\\n    RuntimeError: if called in Eager mode.\\n\\n  \"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, True, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)",
            "@tf_export('gradients', v1=[])\ndef gradients_v2(ys, xs, grad_ys=None, name='gradients', gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\\n\\n  `tf.gradients` is only valid in a graph context. In particular,\\n  it is valid in the context of a `tf.function` wrapper, where code\\n  is executing as a graph.\\n\\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\\n  is a list of `Tensor`, holding the gradients received by the\\n  `ys`. The list must be the same length as `ys`.\\n\\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\\n\\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\\n  user can provide their own initial `grad_ys` to compute the\\n  derivatives using a different initial gradient for each y (e.g., if\\n  one wanted to weight the gradient differently for each value in\\n  each y).\\n\\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\\n  with respect to all `xs`. These tensors will not be backpropagated through,\\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\\n  other things, this allows computation of partial derivatives as opposed to\\n  total derivatives. For example:\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   a = tf.constant(0.)\\n  ...   b = 2 * a\\n  ...   return tf.gradients(a + b, [a, b], stop_gradients=[a, b])\\n  >>> example()\\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\\n\\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\\n  equivalent to:\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   a = tf.stop_gradient(tf.constant(0.))\\n  ...   b = tf.stop_gradient(2 * a)\\n  ...   return tf.gradients(a + b, [a, b])\\n  >>> example()\\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\\n\\n  `stop_gradients` provides a way of stopping gradient after the graph has\\n  already been constructed, as compared to `tf.stop_gradient` which is used\\n  during graph construction.  When the two approaches are combined,\\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\\n  `stop_gradients`, whichever is encountered first.\\n\\n  All integer tensors are considered constant with respect to all `xs`, as if\\n  they were included in `stop_gradients`.\\n\\n  `unconnected_gradients` determines the value returned for each x in xs if it\\n  is unconnected in the graph to ys. By default this is None to safeguard\\n  against errors. Mathematically these gradients are zero which can be requested\\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\\n  following options and behaviors:\\n\\n  >>> @tf.function\\n  ... def example(use_zero):\\n  ...   a = tf.ones([1, 2])\\n  ...   b = tf.ones([3, 1])\\n  ...   if use_zero:\\n  ...     return tf.gradients([b], [a], unconnected_gradients='zero')\\n  ...   else:\\n  ...     return tf.gradients([b], [a], unconnected_gradients='none')\\n  >>> example(False)\\n  [None]\\n  >>> example(True)\\n  [<tf.Tensor: shape=(1, 2), dtype=float32, numpy=array([[0., 0.]], ...)>]\\n\\n  Let us take one practical example which comes during the back propogation\\n  phase. This function is used to evaluate the derivatives of the cost function\\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\\n  provides the exaplantion of what it is actually used for :\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   Ws = tf.constant(0.)\\n  ...   bs = 2 * Ws\\n  ...   cost = Ws + bs  # This is just an example. Please ignore the formulas.\\n  ...   g = tf.gradients(cost, [Ws, bs])\\n  ...   dCost_dW, dCost_db = g\\n  ...   return dCost_dW, dCost_db\\n  >>> example()\\n  (<tf.Tensor: shape=(), dtype=float32, numpy=3.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>)\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\\n      `ys` and holding the gradients computed for each y in `ys`.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'gradients'.\\n    gate_gradients: If True, add a tuple around the gradients returned\\n      for an operations.  This avoids some race conditions.\\n    aggregation_method: Specifies the method used to combine gradient terms.\\n      Accepted values are constants defined in the class `AggregationMethod`.\\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\\n      through.\\n    unconnected_gradients: Optional. Specifies the gradient value returned when\\n      the given input tensors are unconnected. Accepted values are constants\\n      defined in the class `tf.UnconnectedGradients` and the default value is\\n      `none`.\\n\\n  Returns:\\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\\n    for y in `ys` and for x in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `x` and `y` does not\\n      have a registered gradient function.\\n    ValueError: if the arguments are invalid.\\n    RuntimeError: if called in Eager mode.\\n\\n  \"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, True, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)",
            "@tf_export('gradients', v1=[])\ndef gradients_v2(ys, xs, grad_ys=None, name='gradients', gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\\n\\n  `tf.gradients` is only valid in a graph context. In particular,\\n  it is valid in the context of a `tf.function` wrapper, where code\\n  is executing as a graph.\\n\\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\\n  is a list of `Tensor`, holding the gradients received by the\\n  `ys`. The list must be the same length as `ys`.\\n\\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\\n\\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\\n  user can provide their own initial `grad_ys` to compute the\\n  derivatives using a different initial gradient for each y (e.g., if\\n  one wanted to weight the gradient differently for each value in\\n  each y).\\n\\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\\n  with respect to all `xs`. These tensors will not be backpropagated through,\\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\\n  other things, this allows computation of partial derivatives as opposed to\\n  total derivatives. For example:\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   a = tf.constant(0.)\\n  ...   b = 2 * a\\n  ...   return tf.gradients(a + b, [a, b], stop_gradients=[a, b])\\n  >>> example()\\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\\n\\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\\n  equivalent to:\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   a = tf.stop_gradient(tf.constant(0.))\\n  ...   b = tf.stop_gradient(2 * a)\\n  ...   return tf.gradients(a + b, [a, b])\\n  >>> example()\\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\\n\\n  `stop_gradients` provides a way of stopping gradient after the graph has\\n  already been constructed, as compared to `tf.stop_gradient` which is used\\n  during graph construction.  When the two approaches are combined,\\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\\n  `stop_gradients`, whichever is encountered first.\\n\\n  All integer tensors are considered constant with respect to all `xs`, as if\\n  they were included in `stop_gradients`.\\n\\n  `unconnected_gradients` determines the value returned for each x in xs if it\\n  is unconnected in the graph to ys. By default this is None to safeguard\\n  against errors. Mathematically these gradients are zero which can be requested\\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\\n  following options and behaviors:\\n\\n  >>> @tf.function\\n  ... def example(use_zero):\\n  ...   a = tf.ones([1, 2])\\n  ...   b = tf.ones([3, 1])\\n  ...   if use_zero:\\n  ...     return tf.gradients([b], [a], unconnected_gradients='zero')\\n  ...   else:\\n  ...     return tf.gradients([b], [a], unconnected_gradients='none')\\n  >>> example(False)\\n  [None]\\n  >>> example(True)\\n  [<tf.Tensor: shape=(1, 2), dtype=float32, numpy=array([[0., 0.]], ...)>]\\n\\n  Let us take one practical example which comes during the back propogation\\n  phase. This function is used to evaluate the derivatives of the cost function\\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\\n  provides the exaplantion of what it is actually used for :\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   Ws = tf.constant(0.)\\n  ...   bs = 2 * Ws\\n  ...   cost = Ws + bs  # This is just an example. Please ignore the formulas.\\n  ...   g = tf.gradients(cost, [Ws, bs])\\n  ...   dCost_dW, dCost_db = g\\n  ...   return dCost_dW, dCost_db\\n  >>> example()\\n  (<tf.Tensor: shape=(), dtype=float32, numpy=3.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>)\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\\n      `ys` and holding the gradients computed for each y in `ys`.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'gradients'.\\n    gate_gradients: If True, add a tuple around the gradients returned\\n      for an operations.  This avoids some race conditions.\\n    aggregation_method: Specifies the method used to combine gradient terms.\\n      Accepted values are constants defined in the class `AggregationMethod`.\\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\\n      through.\\n    unconnected_gradients: Optional. Specifies the gradient value returned when\\n      the given input tensors are unconnected. Accepted values are constants\\n      defined in the class `tf.UnconnectedGradients` and the default value is\\n      `none`.\\n\\n  Returns:\\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\\n    for y in `ys` and for x in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `x` and `y` does not\\n      have a registered gradient function.\\n    ValueError: if the arguments are invalid.\\n    RuntimeError: if called in Eager mode.\\n\\n  \"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, True, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)",
            "@tf_export('gradients', v1=[])\ndef gradients_v2(ys, xs, grad_ys=None, name='gradients', gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\\n\\n  `tf.gradients` is only valid in a graph context. In particular,\\n  it is valid in the context of a `tf.function` wrapper, where code\\n  is executing as a graph.\\n\\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\\n  is a list of `Tensor`, holding the gradients received by the\\n  `ys`. The list must be the same length as `ys`.\\n\\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\\n\\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\\n  user can provide their own initial `grad_ys` to compute the\\n  derivatives using a different initial gradient for each y (e.g., if\\n  one wanted to weight the gradient differently for each value in\\n  each y).\\n\\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\\n  with respect to all `xs`. These tensors will not be backpropagated through,\\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\\n  other things, this allows computation of partial derivatives as opposed to\\n  total derivatives. For example:\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   a = tf.constant(0.)\\n  ...   b = 2 * a\\n  ...   return tf.gradients(a + b, [a, b], stop_gradients=[a, b])\\n  >>> example()\\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\\n\\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\\n  equivalent to:\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   a = tf.stop_gradient(tf.constant(0.))\\n  ...   b = tf.stop_gradient(2 * a)\\n  ...   return tf.gradients(a + b, [a, b])\\n  >>> example()\\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\\n\\n  `stop_gradients` provides a way of stopping gradient after the graph has\\n  already been constructed, as compared to `tf.stop_gradient` which is used\\n  during graph construction.  When the two approaches are combined,\\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\\n  `stop_gradients`, whichever is encountered first.\\n\\n  All integer tensors are considered constant with respect to all `xs`, as if\\n  they were included in `stop_gradients`.\\n\\n  `unconnected_gradients` determines the value returned for each x in xs if it\\n  is unconnected in the graph to ys. By default this is None to safeguard\\n  against errors. Mathematically these gradients are zero which can be requested\\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\\n  following options and behaviors:\\n\\n  >>> @tf.function\\n  ... def example(use_zero):\\n  ...   a = tf.ones([1, 2])\\n  ...   b = tf.ones([3, 1])\\n  ...   if use_zero:\\n  ...     return tf.gradients([b], [a], unconnected_gradients='zero')\\n  ...   else:\\n  ...     return tf.gradients([b], [a], unconnected_gradients='none')\\n  >>> example(False)\\n  [None]\\n  >>> example(True)\\n  [<tf.Tensor: shape=(1, 2), dtype=float32, numpy=array([[0., 0.]], ...)>]\\n\\n  Let us take one practical example which comes during the back propogation\\n  phase. This function is used to evaluate the derivatives of the cost function\\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\\n  provides the exaplantion of what it is actually used for :\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   Ws = tf.constant(0.)\\n  ...   bs = 2 * Ws\\n  ...   cost = Ws + bs  # This is just an example. Please ignore the formulas.\\n  ...   g = tf.gradients(cost, [Ws, bs])\\n  ...   dCost_dW, dCost_db = g\\n  ...   return dCost_dW, dCost_db\\n  >>> example()\\n  (<tf.Tensor: shape=(), dtype=float32, numpy=3.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>)\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\\n      `ys` and holding the gradients computed for each y in `ys`.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'gradients'.\\n    gate_gradients: If True, add a tuple around the gradients returned\\n      for an operations.  This avoids some race conditions.\\n    aggregation_method: Specifies the method used to combine gradient terms.\\n      Accepted values are constants defined in the class `AggregationMethod`.\\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\\n      through.\\n    unconnected_gradients: Optional. Specifies the gradient value returned when\\n      the given input tensors are unconnected. Accepted values are constants\\n      defined in the class `tf.UnconnectedGradients` and the default value is\\n      `none`.\\n\\n  Returns:\\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\\n    for y in `ys` and for x in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `x` and `y` does not\\n      have a registered gradient function.\\n    ValueError: if the arguments are invalid.\\n    RuntimeError: if called in Eager mode.\\n\\n  \"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, True, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)",
            "@tf_export('gradients', v1=[])\ndef gradients_v2(ys, xs, grad_ys=None, name='gradients', gate_gradients=False, aggregation_method=None, stop_gradients=None, unconnected_gradients=UnconnectedGradients.NONE):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Constructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\\n\\n  `tf.gradients` is only valid in a graph context. In particular,\\n  it is valid in the context of a `tf.function` wrapper, where code\\n  is executing as a graph.\\n\\n  `ys` and `xs` are each a `Tensor` or a list of tensors.  `grad_ys`\\n  is a list of `Tensor`, holding the gradients received by the\\n  `ys`. The list must be the same length as `ys`.\\n\\n  `gradients()` adds ops to the graph to output the derivatives of `ys` with\\n  respect to `xs`.  It returns a list of `Tensor` of length `len(xs)` where\\n  each tensor is the `sum(dy/dx)` for y in `ys` and for x in `xs`.\\n\\n  `grad_ys` is a list of tensors of the same length as `ys` that holds\\n  the initial gradients for each y in `ys`.  When `grad_ys` is None,\\n  we fill in a tensor of '1's of the shape of y for each y in `ys`.  A\\n  user can provide their own initial `grad_ys` to compute the\\n  derivatives using a different initial gradient for each y (e.g., if\\n  one wanted to weight the gradient differently for each value in\\n  each y).\\n\\n  `stop_gradients` is a `Tensor` or a list of tensors to be considered constant\\n  with respect to all `xs`. These tensors will not be backpropagated through,\\n  as though they had been explicitly disconnected using `stop_gradient`.  Among\\n  other things, this allows computation of partial derivatives as opposed to\\n  total derivatives. For example:\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   a = tf.constant(0.)\\n  ...   b = 2 * a\\n  ...   return tf.gradients(a + b, [a, b], stop_gradients=[a, b])\\n  >>> example()\\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\\n\\n  Here the partial derivatives `g` evaluate to `[1.0, 1.0]`, compared to the\\n  total derivatives `tf.gradients(a + b, [a, b])`, which take into account the\\n  influence of `a` on `b` and evaluate to `[3.0, 1.0]`.  Note that the above is\\n  equivalent to:\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   a = tf.stop_gradient(tf.constant(0.))\\n  ...   b = tf.stop_gradient(2 * a)\\n  ...   return tf.gradients(a + b, [a, b])\\n  >>> example()\\n  [<tf.Tensor: shape=(), dtype=float32, numpy=1.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>]\\n\\n  `stop_gradients` provides a way of stopping gradient after the graph has\\n  already been constructed, as compared to `tf.stop_gradient` which is used\\n  during graph construction.  When the two approaches are combined,\\n  backpropagation stops at both `tf.stop_gradient` nodes and nodes in\\n  `stop_gradients`, whichever is encountered first.\\n\\n  All integer tensors are considered constant with respect to all `xs`, as if\\n  they were included in `stop_gradients`.\\n\\n  `unconnected_gradients` determines the value returned for each x in xs if it\\n  is unconnected in the graph to ys. By default this is None to safeguard\\n  against errors. Mathematically these gradients are zero which can be requested\\n  using the `'zero'` option. `tf.UnconnectedGradients` provides the\\n  following options and behaviors:\\n\\n  >>> @tf.function\\n  ... def example(use_zero):\\n  ...   a = tf.ones([1, 2])\\n  ...   b = tf.ones([3, 1])\\n  ...   if use_zero:\\n  ...     return tf.gradients([b], [a], unconnected_gradients='zero')\\n  ...   else:\\n  ...     return tf.gradients([b], [a], unconnected_gradients='none')\\n  >>> example(False)\\n  [None]\\n  >>> example(True)\\n  [<tf.Tensor: shape=(1, 2), dtype=float32, numpy=array([[0., 0.]], ...)>]\\n\\n  Let us take one practical example which comes during the back propogation\\n  phase. This function is used to evaluate the derivatives of the cost function\\n  with respect to Weights `Ws` and Biases `bs`. Below sample implementation\\n  provides the exaplantion of what it is actually used for :\\n\\n  >>> @tf.function\\n  ... def example():\\n  ...   Ws = tf.constant(0.)\\n  ...   bs = 2 * Ws\\n  ...   cost = Ws + bs  # This is just an example. Please ignore the formulas.\\n  ...   g = tf.gradients(cost, [Ws, bs])\\n  ...   dCost_dW, dCost_db = g\\n  ...   return dCost_dW, dCost_db\\n  >>> example()\\n  (<tf.Tensor: shape=(), dtype=float32, numpy=3.0>,\\n  <tf.Tensor: shape=(), dtype=float32, numpy=1.0>)\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    grad_ys: Optional. A `Tensor` or list of tensors the same size as\\n      `ys` and holding the gradients computed for each y in `ys`.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'gradients'.\\n    gate_gradients: If True, add a tuple around the gradients returned\\n      for an operations.  This avoids some race conditions.\\n    aggregation_method: Specifies the method used to combine gradient terms.\\n      Accepted values are constants defined in the class `AggregationMethod`.\\n    stop_gradients: Optional. A `Tensor` or list of tensors not to differentiate\\n      through.\\n    unconnected_gradients: Optional. Specifies the gradient value returned when\\n      the given input tensors are unconnected. Accepted values are constants\\n      defined in the class `tf.UnconnectedGradients` and the default value is\\n      `none`.\\n\\n  Returns:\\n    A list of `Tensor` of length `len(xs)` where each tensor is the `sum(dy/dx)`\\n    for y in `ys` and for x in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `x` and `y` does not\\n      have a registered gradient function.\\n    ValueError: if the arguments are invalid.\\n    RuntimeError: if called in Eager mode.\\n\\n  \"\n    with ops.get_default_graph()._mutation_lock():\n        return gradients_util._GradientsHelper(ys, xs, grad_ys, name, True, gate_gradients, aggregation_method, stop_gradients, unconnected_gradients)"
        ]
    },
    {
        "func_name": "_hessian_vector_product",
        "original": "def _hessian_vector_product(ys, xs, v):\n    \"\"\"Multiply the Hessian of `ys` wrt `xs` by `v`.\n\n  This is an efficient construction that uses a backprop-like approach\n  to compute the product between the Hessian and another vector. The\n  Hessian is usually too large to be explicitly computed or even\n  represented, but this method allows us to at least multiply by it\n  for the same big-O cost as backprop.\n\n  Implicit Hessian-vector products are the main practical, scalable way\n  of using second derivatives with neural networks. They allow us to\n  do things like construct Krylov subspaces and approximate conjugate\n  gradient descent.\n\n  Example: if `y` = 1/2 `x`^T A `x`, then `hessian_vector_product(y,\n  x, v)` will return an expression that evaluates to the same values\n  as (A + A.T) `v`.\n\n  Args:\n    ys: A scalar value, or a tensor or list of tensors to be summed to\n        yield a scalar.\n    xs: A list of tensors that we should construct the Hessian over.\n    v: A list of tensors, with the same shapes as xs, that we want to\n       multiply by the Hessian.\n\n  Returns:\n    A list of tensors (or if the list would be length 1, a single tensor)\n    containing the product between the Hessian and `v`.\n\n  Raises:\n    ValueError: `xs` and `v` have different length.\n\n  \"\"\"\n    length = len(xs)\n    if len(v) != length:\n        raise ValueError('xs and v must have the same length.')\n    grads = gradients(ys, xs)\n    assert len(grads) == length\n    elemwise_products = [math_ops.multiply(grad_elem, array_ops.stop_gradient(v_elem)) for (grad_elem, v_elem) in zip(grads, v) if grad_elem is not None]\n    return gradients(elemwise_products, xs)",
        "mutated": [
            "def _hessian_vector_product(ys, xs, v):\n    if False:\n        i = 10\n    'Multiply the Hessian of `ys` wrt `xs` by `v`.\\n\\n  This is an efficient construction that uses a backprop-like approach\\n  to compute the product between the Hessian and another vector. The\\n  Hessian is usually too large to be explicitly computed or even\\n  represented, but this method allows us to at least multiply by it\\n  for the same big-O cost as backprop.\\n\\n  Implicit Hessian-vector products are the main practical, scalable way\\n  of using second derivatives with neural networks. They allow us to\\n  do things like construct Krylov subspaces and approximate conjugate\\n  gradient descent.\\n\\n  Example: if `y` = 1/2 `x`^T A `x`, then `hessian_vector_product(y,\\n  x, v)` will return an expression that evaluates to the same values\\n  as (A + A.T) `v`.\\n\\n  Args:\\n    ys: A scalar value, or a tensor or list of tensors to be summed to\\n        yield a scalar.\\n    xs: A list of tensors that we should construct the Hessian over.\\n    v: A list of tensors, with the same shapes as xs, that we want to\\n       multiply by the Hessian.\\n\\n  Returns:\\n    A list of tensors (or if the list would be length 1, a single tensor)\\n    containing the product between the Hessian and `v`.\\n\\n  Raises:\\n    ValueError: `xs` and `v` have different length.\\n\\n  '\n    length = len(xs)\n    if len(v) != length:\n        raise ValueError('xs and v must have the same length.')\n    grads = gradients(ys, xs)\n    assert len(grads) == length\n    elemwise_products = [math_ops.multiply(grad_elem, array_ops.stop_gradient(v_elem)) for (grad_elem, v_elem) in zip(grads, v) if grad_elem is not None]\n    return gradients(elemwise_products, xs)",
            "def _hessian_vector_product(ys, xs, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Multiply the Hessian of `ys` wrt `xs` by `v`.\\n\\n  This is an efficient construction that uses a backprop-like approach\\n  to compute the product between the Hessian and another vector. The\\n  Hessian is usually too large to be explicitly computed or even\\n  represented, but this method allows us to at least multiply by it\\n  for the same big-O cost as backprop.\\n\\n  Implicit Hessian-vector products are the main practical, scalable way\\n  of using second derivatives with neural networks. They allow us to\\n  do things like construct Krylov subspaces and approximate conjugate\\n  gradient descent.\\n\\n  Example: if `y` = 1/2 `x`^T A `x`, then `hessian_vector_product(y,\\n  x, v)` will return an expression that evaluates to the same values\\n  as (A + A.T) `v`.\\n\\n  Args:\\n    ys: A scalar value, or a tensor or list of tensors to be summed to\\n        yield a scalar.\\n    xs: A list of tensors that we should construct the Hessian over.\\n    v: A list of tensors, with the same shapes as xs, that we want to\\n       multiply by the Hessian.\\n\\n  Returns:\\n    A list of tensors (or if the list would be length 1, a single tensor)\\n    containing the product between the Hessian and `v`.\\n\\n  Raises:\\n    ValueError: `xs` and `v` have different length.\\n\\n  '\n    length = len(xs)\n    if len(v) != length:\n        raise ValueError('xs and v must have the same length.')\n    grads = gradients(ys, xs)\n    assert len(grads) == length\n    elemwise_products = [math_ops.multiply(grad_elem, array_ops.stop_gradient(v_elem)) for (grad_elem, v_elem) in zip(grads, v) if grad_elem is not None]\n    return gradients(elemwise_products, xs)",
            "def _hessian_vector_product(ys, xs, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Multiply the Hessian of `ys` wrt `xs` by `v`.\\n\\n  This is an efficient construction that uses a backprop-like approach\\n  to compute the product between the Hessian and another vector. The\\n  Hessian is usually too large to be explicitly computed or even\\n  represented, but this method allows us to at least multiply by it\\n  for the same big-O cost as backprop.\\n\\n  Implicit Hessian-vector products are the main practical, scalable way\\n  of using second derivatives with neural networks. They allow us to\\n  do things like construct Krylov subspaces and approximate conjugate\\n  gradient descent.\\n\\n  Example: if `y` = 1/2 `x`^T A `x`, then `hessian_vector_product(y,\\n  x, v)` will return an expression that evaluates to the same values\\n  as (A + A.T) `v`.\\n\\n  Args:\\n    ys: A scalar value, or a tensor or list of tensors to be summed to\\n        yield a scalar.\\n    xs: A list of tensors that we should construct the Hessian over.\\n    v: A list of tensors, with the same shapes as xs, that we want to\\n       multiply by the Hessian.\\n\\n  Returns:\\n    A list of tensors (or if the list would be length 1, a single tensor)\\n    containing the product between the Hessian and `v`.\\n\\n  Raises:\\n    ValueError: `xs` and `v` have different length.\\n\\n  '\n    length = len(xs)\n    if len(v) != length:\n        raise ValueError('xs and v must have the same length.')\n    grads = gradients(ys, xs)\n    assert len(grads) == length\n    elemwise_products = [math_ops.multiply(grad_elem, array_ops.stop_gradient(v_elem)) for (grad_elem, v_elem) in zip(grads, v) if grad_elem is not None]\n    return gradients(elemwise_products, xs)",
            "def _hessian_vector_product(ys, xs, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Multiply the Hessian of `ys` wrt `xs` by `v`.\\n\\n  This is an efficient construction that uses a backprop-like approach\\n  to compute the product between the Hessian and another vector. The\\n  Hessian is usually too large to be explicitly computed or even\\n  represented, but this method allows us to at least multiply by it\\n  for the same big-O cost as backprop.\\n\\n  Implicit Hessian-vector products are the main practical, scalable way\\n  of using second derivatives with neural networks. They allow us to\\n  do things like construct Krylov subspaces and approximate conjugate\\n  gradient descent.\\n\\n  Example: if `y` = 1/2 `x`^T A `x`, then `hessian_vector_product(y,\\n  x, v)` will return an expression that evaluates to the same values\\n  as (A + A.T) `v`.\\n\\n  Args:\\n    ys: A scalar value, or a tensor or list of tensors to be summed to\\n        yield a scalar.\\n    xs: A list of tensors that we should construct the Hessian over.\\n    v: A list of tensors, with the same shapes as xs, that we want to\\n       multiply by the Hessian.\\n\\n  Returns:\\n    A list of tensors (or if the list would be length 1, a single tensor)\\n    containing the product between the Hessian and `v`.\\n\\n  Raises:\\n    ValueError: `xs` and `v` have different length.\\n\\n  '\n    length = len(xs)\n    if len(v) != length:\n        raise ValueError('xs and v must have the same length.')\n    grads = gradients(ys, xs)\n    assert len(grads) == length\n    elemwise_products = [math_ops.multiply(grad_elem, array_ops.stop_gradient(v_elem)) for (grad_elem, v_elem) in zip(grads, v) if grad_elem is not None]\n    return gradients(elemwise_products, xs)",
            "def _hessian_vector_product(ys, xs, v):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Multiply the Hessian of `ys` wrt `xs` by `v`.\\n\\n  This is an efficient construction that uses a backprop-like approach\\n  to compute the product between the Hessian and another vector. The\\n  Hessian is usually too large to be explicitly computed or even\\n  represented, but this method allows us to at least multiply by it\\n  for the same big-O cost as backprop.\\n\\n  Implicit Hessian-vector products are the main practical, scalable way\\n  of using second derivatives with neural networks. They allow us to\\n  do things like construct Krylov subspaces and approximate conjugate\\n  gradient descent.\\n\\n  Example: if `y` = 1/2 `x`^T A `x`, then `hessian_vector_product(y,\\n  x, v)` will return an expression that evaluates to the same values\\n  as (A + A.T) `v`.\\n\\n  Args:\\n    ys: A scalar value, or a tensor or list of tensors to be summed to\\n        yield a scalar.\\n    xs: A list of tensors that we should construct the Hessian over.\\n    v: A list of tensors, with the same shapes as xs, that we want to\\n       multiply by the Hessian.\\n\\n  Returns:\\n    A list of tensors (or if the list would be length 1, a single tensor)\\n    containing the product between the Hessian and `v`.\\n\\n  Raises:\\n    ValueError: `xs` and `v` have different length.\\n\\n  '\n    length = len(xs)\n    if len(v) != length:\n        raise ValueError('xs and v must have the same length.')\n    grads = gradients(ys, xs)\n    assert len(grads) == length\n    elemwise_products = [math_ops.multiply(grad_elem, array_ops.stop_gradient(v_elem)) for (grad_elem, v_elem) in zip(grads, v) if grad_elem is not None]\n    return gradients(elemwise_products, xs)"
        ]
    },
    {
        "func_name": "hessians",
        "original": "@tf_export(v1=['hessians'])\ndef hessians(ys, xs, name='hessians', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None):\n    \"\"\"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\n\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\n  where each tensor is the Hessian of `sum(ys)`.\n\n  The Hessian is a matrix of second-order partial derivatives of a scalar\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\n\n  Args:\n    ys: A `Tensor` or list of tensors to be differentiated.\n    xs: A `Tensor` or list of tensors to be used for differentiation.\n    name: Optional name to use for grouping all the gradient ops together.\n      defaults to 'hessians'.\n    colocate_gradients_with_ops: See `gradients()` documentation for details.\n    gate_gradients: See `gradients()` documentation for details.\n    aggregation_method: See `gradients()` documentation for details.\n\n  Returns:\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\n\n  Raises:\n    LookupError: if one of the operations between `xs` and `ys` does not\n      have a registered gradient function.\n  \"\"\"\n    xs = gradients_util._AsList(xs)\n    kwargs = {'colocate_gradients_with_ops': colocate_gradients_with_ops, 'gate_gradients': gate_gradients, 'aggregation_method': aggregation_method}\n    hessians = []\n    _gradients = gradients(ys, xs, **kwargs)\n    for (gradient, x) in zip(_gradients, xs):\n        gradient = array_ops.reshape(gradient, [-1])\n        n = array_ops.size(x)\n        loop_vars = [array_ops.constant(0, dtypes.int32), tensor_array_ops.TensorArray(x.dtype, n)]\n        (_, hessian) = while_loop.while_loop(lambda j, _: j < n, lambda j, result: (j + 1, result.write(j, gradients(gradient[j], x)[0])), loop_vars)\n        _shape = array_ops.shape(x)\n        _reshaped_hessian = array_ops.reshape(hessian.stack(), array_ops.concat((_shape, _shape), 0))\n        hessians.append(_reshaped_hessian)\n    return hessians",
        "mutated": [
            "@tf_export(v1=['hessians'])\ndef hessians(ys, xs, name='hessians', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None):\n    if False:\n        i = 10\n    \"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\\n\\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\\n  where each tensor is the Hessian of `sum(ys)`.\\n\\n  The Hessian is a matrix of second-order partial derivatives of a scalar\\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'hessians'.\\n    colocate_gradients_with_ops: See `gradients()` documentation for details.\\n    gate_gradients: See `gradients()` documentation for details.\\n    aggregation_method: See `gradients()` documentation for details.\\n\\n  Returns:\\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `xs` and `ys` does not\\n      have a registered gradient function.\\n  \"\n    xs = gradients_util._AsList(xs)\n    kwargs = {'colocate_gradients_with_ops': colocate_gradients_with_ops, 'gate_gradients': gate_gradients, 'aggregation_method': aggregation_method}\n    hessians = []\n    _gradients = gradients(ys, xs, **kwargs)\n    for (gradient, x) in zip(_gradients, xs):\n        gradient = array_ops.reshape(gradient, [-1])\n        n = array_ops.size(x)\n        loop_vars = [array_ops.constant(0, dtypes.int32), tensor_array_ops.TensorArray(x.dtype, n)]\n        (_, hessian) = while_loop.while_loop(lambda j, _: j < n, lambda j, result: (j + 1, result.write(j, gradients(gradient[j], x)[0])), loop_vars)\n        _shape = array_ops.shape(x)\n        _reshaped_hessian = array_ops.reshape(hessian.stack(), array_ops.concat((_shape, _shape), 0))\n        hessians.append(_reshaped_hessian)\n    return hessians",
            "@tf_export(v1=['hessians'])\ndef hessians(ys, xs, name='hessians', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\\n\\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\\n  where each tensor is the Hessian of `sum(ys)`.\\n\\n  The Hessian is a matrix of second-order partial derivatives of a scalar\\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'hessians'.\\n    colocate_gradients_with_ops: See `gradients()` documentation for details.\\n    gate_gradients: See `gradients()` documentation for details.\\n    aggregation_method: See `gradients()` documentation for details.\\n\\n  Returns:\\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `xs` and `ys` does not\\n      have a registered gradient function.\\n  \"\n    xs = gradients_util._AsList(xs)\n    kwargs = {'colocate_gradients_with_ops': colocate_gradients_with_ops, 'gate_gradients': gate_gradients, 'aggregation_method': aggregation_method}\n    hessians = []\n    _gradients = gradients(ys, xs, **kwargs)\n    for (gradient, x) in zip(_gradients, xs):\n        gradient = array_ops.reshape(gradient, [-1])\n        n = array_ops.size(x)\n        loop_vars = [array_ops.constant(0, dtypes.int32), tensor_array_ops.TensorArray(x.dtype, n)]\n        (_, hessian) = while_loop.while_loop(lambda j, _: j < n, lambda j, result: (j + 1, result.write(j, gradients(gradient[j], x)[0])), loop_vars)\n        _shape = array_ops.shape(x)\n        _reshaped_hessian = array_ops.reshape(hessian.stack(), array_ops.concat((_shape, _shape), 0))\n        hessians.append(_reshaped_hessian)\n    return hessians",
            "@tf_export(v1=['hessians'])\ndef hessians(ys, xs, name='hessians', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\\n\\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\\n  where each tensor is the Hessian of `sum(ys)`.\\n\\n  The Hessian is a matrix of second-order partial derivatives of a scalar\\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'hessians'.\\n    colocate_gradients_with_ops: See `gradients()` documentation for details.\\n    gate_gradients: See `gradients()` documentation for details.\\n    aggregation_method: See `gradients()` documentation for details.\\n\\n  Returns:\\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `xs` and `ys` does not\\n      have a registered gradient function.\\n  \"\n    xs = gradients_util._AsList(xs)\n    kwargs = {'colocate_gradients_with_ops': colocate_gradients_with_ops, 'gate_gradients': gate_gradients, 'aggregation_method': aggregation_method}\n    hessians = []\n    _gradients = gradients(ys, xs, **kwargs)\n    for (gradient, x) in zip(_gradients, xs):\n        gradient = array_ops.reshape(gradient, [-1])\n        n = array_ops.size(x)\n        loop_vars = [array_ops.constant(0, dtypes.int32), tensor_array_ops.TensorArray(x.dtype, n)]\n        (_, hessian) = while_loop.while_loop(lambda j, _: j < n, lambda j, result: (j + 1, result.write(j, gradients(gradient[j], x)[0])), loop_vars)\n        _shape = array_ops.shape(x)\n        _reshaped_hessian = array_ops.reshape(hessian.stack(), array_ops.concat((_shape, _shape), 0))\n        hessians.append(_reshaped_hessian)\n    return hessians",
            "@tf_export(v1=['hessians'])\ndef hessians(ys, xs, name='hessians', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\\n\\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\\n  where each tensor is the Hessian of `sum(ys)`.\\n\\n  The Hessian is a matrix of second-order partial derivatives of a scalar\\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'hessians'.\\n    colocate_gradients_with_ops: See `gradients()` documentation for details.\\n    gate_gradients: See `gradients()` documentation for details.\\n    aggregation_method: See `gradients()` documentation for details.\\n\\n  Returns:\\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `xs` and `ys` does not\\n      have a registered gradient function.\\n  \"\n    xs = gradients_util._AsList(xs)\n    kwargs = {'colocate_gradients_with_ops': colocate_gradients_with_ops, 'gate_gradients': gate_gradients, 'aggregation_method': aggregation_method}\n    hessians = []\n    _gradients = gradients(ys, xs, **kwargs)\n    for (gradient, x) in zip(_gradients, xs):\n        gradient = array_ops.reshape(gradient, [-1])\n        n = array_ops.size(x)\n        loop_vars = [array_ops.constant(0, dtypes.int32), tensor_array_ops.TensorArray(x.dtype, n)]\n        (_, hessian) = while_loop.while_loop(lambda j, _: j < n, lambda j, result: (j + 1, result.write(j, gradients(gradient[j], x)[0])), loop_vars)\n        _shape = array_ops.shape(x)\n        _reshaped_hessian = array_ops.reshape(hessian.stack(), array_ops.concat((_shape, _shape), 0))\n        hessians.append(_reshaped_hessian)\n    return hessians",
            "@tf_export(v1=['hessians'])\ndef hessians(ys, xs, name='hessians', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\\n\\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\\n  where each tensor is the Hessian of `sum(ys)`.\\n\\n  The Hessian is a matrix of second-order partial derivatives of a scalar\\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'hessians'.\\n    colocate_gradients_with_ops: See `gradients()` documentation for details.\\n    gate_gradients: See `gradients()` documentation for details.\\n    aggregation_method: See `gradients()` documentation for details.\\n\\n  Returns:\\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `xs` and `ys` does not\\n      have a registered gradient function.\\n  \"\n    xs = gradients_util._AsList(xs)\n    kwargs = {'colocate_gradients_with_ops': colocate_gradients_with_ops, 'gate_gradients': gate_gradients, 'aggregation_method': aggregation_method}\n    hessians = []\n    _gradients = gradients(ys, xs, **kwargs)\n    for (gradient, x) in zip(_gradients, xs):\n        gradient = array_ops.reshape(gradient, [-1])\n        n = array_ops.size(x)\n        loop_vars = [array_ops.constant(0, dtypes.int32), tensor_array_ops.TensorArray(x.dtype, n)]\n        (_, hessian) = while_loop.while_loop(lambda j, _: j < n, lambda j, result: (j + 1, result.write(j, gradients(gradient[j], x)[0])), loop_vars)\n        _shape = array_ops.shape(x)\n        _reshaped_hessian = array_ops.reshape(hessian.stack(), array_ops.concat((_shape, _shape), 0))\n        hessians.append(_reshaped_hessian)\n    return hessians"
        ]
    },
    {
        "func_name": "HessiansV2",
        "original": "@tf_export('hessians', v1=[])\ndef HessiansV2(ys, xs, gate_gradients=False, aggregation_method=None, name='hessians'):\n    \"\"\"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\n\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\n  where each tensor is the Hessian of `sum(ys)`.\n\n  The Hessian is a matrix of second-order partial derivatives of a scalar\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\n\n  Args:\n    ys: A `Tensor` or list of tensors to be differentiated.\n    xs: A `Tensor` or list of tensors to be used for differentiation.\n    gate_gradients: See `gradients()` documentation for details.\n    aggregation_method: See `gradients()` documentation for details.\n    name: Optional name to use for grouping all the gradient ops together.\n      defaults to 'hessians'.\n\n  Returns:\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\n\n  Raises:\n    LookupError: if one of the operations between `xs` and `ys` does not\n      have a registered gradient function.\n  \"\"\"\n    return hessians(ys, xs, name=name, colocate_gradients_with_ops=True, gate_gradients=gate_gradients, aggregation_method=aggregation_method)",
        "mutated": [
            "@tf_export('hessians', v1=[])\ndef HessiansV2(ys, xs, gate_gradients=False, aggregation_method=None, name='hessians'):\n    if False:\n        i = 10\n    \"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\\n\\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\\n  where each tensor is the Hessian of `sum(ys)`.\\n\\n  The Hessian is a matrix of second-order partial derivatives of a scalar\\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    gate_gradients: See `gradients()` documentation for details.\\n    aggregation_method: See `gradients()` documentation for details.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'hessians'.\\n\\n  Returns:\\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `xs` and `ys` does not\\n      have a registered gradient function.\\n  \"\n    return hessians(ys, xs, name=name, colocate_gradients_with_ops=True, gate_gradients=gate_gradients, aggregation_method=aggregation_method)",
            "@tf_export('hessians', v1=[])\ndef HessiansV2(ys, xs, gate_gradients=False, aggregation_method=None, name='hessians'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\\n\\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\\n  where each tensor is the Hessian of `sum(ys)`.\\n\\n  The Hessian is a matrix of second-order partial derivatives of a scalar\\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    gate_gradients: See `gradients()` documentation for details.\\n    aggregation_method: See `gradients()` documentation for details.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'hessians'.\\n\\n  Returns:\\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `xs` and `ys` does not\\n      have a registered gradient function.\\n  \"\n    return hessians(ys, xs, name=name, colocate_gradients_with_ops=True, gate_gradients=gate_gradients, aggregation_method=aggregation_method)",
            "@tf_export('hessians', v1=[])\ndef HessiansV2(ys, xs, gate_gradients=False, aggregation_method=None, name='hessians'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\\n\\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\\n  where each tensor is the Hessian of `sum(ys)`.\\n\\n  The Hessian is a matrix of second-order partial derivatives of a scalar\\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    gate_gradients: See `gradients()` documentation for details.\\n    aggregation_method: See `gradients()` documentation for details.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'hessians'.\\n\\n  Returns:\\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `xs` and `ys` does not\\n      have a registered gradient function.\\n  \"\n    return hessians(ys, xs, name=name, colocate_gradients_with_ops=True, gate_gradients=gate_gradients, aggregation_method=aggregation_method)",
            "@tf_export('hessians', v1=[])\ndef HessiansV2(ys, xs, gate_gradients=False, aggregation_method=None, name='hessians'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\\n\\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\\n  where each tensor is the Hessian of `sum(ys)`.\\n\\n  The Hessian is a matrix of second-order partial derivatives of a scalar\\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    gate_gradients: See `gradients()` documentation for details.\\n    aggregation_method: See `gradients()` documentation for details.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'hessians'.\\n\\n  Returns:\\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `xs` and `ys` does not\\n      have a registered gradient function.\\n  \"\n    return hessians(ys, xs, name=name, colocate_gradients_with_ops=True, gate_gradients=gate_gradients, aggregation_method=aggregation_method)",
            "@tf_export('hessians', v1=[])\ndef HessiansV2(ys, xs, gate_gradients=False, aggregation_method=None, name='hessians'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Constructs the Hessian of sum of `ys` with respect to `x` in `xs`.\\n\\n  `hessians()` adds ops to the graph to output the Hessian matrix of `ys`\\n  with respect to `xs`.  It returns a list of `Tensor` of length `len(xs)`\\n  where each tensor is the Hessian of `sum(ys)`.\\n\\n  The Hessian is a matrix of second-order partial derivatives of a scalar\\n  tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).\\n\\n  Args:\\n    ys: A `Tensor` or list of tensors to be differentiated.\\n    xs: A `Tensor` or list of tensors to be used for differentiation.\\n    gate_gradients: See `gradients()` documentation for details.\\n    aggregation_method: See `gradients()` documentation for details.\\n    name: Optional name to use for grouping all the gradient ops together.\\n      defaults to 'hessians'.\\n\\n  Returns:\\n    A list of Hessian matrices of `sum(ys)` for each `x` in `xs`.\\n\\n  Raises:\\n    LookupError: if one of the operations between `xs` and `ys` does not\\n      have a registered gradient function.\\n  \"\n    return hessians(ys, xs, name=name, colocate_gradients_with_ops=True, gate_gradients=gate_gradients, aggregation_method=aggregation_method)"
        ]
    }
]