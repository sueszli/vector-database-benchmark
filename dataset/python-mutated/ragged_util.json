[
    {
        "func_name": "assert_splits_match",
        "original": "def assert_splits_match(nested_splits_lists):\n    \"\"\"Checks that the given splits lists are identical.\n\n  Performs static tests to ensure that the given splits lists are identical,\n  and returns a list of control dependency op tensors that check that they are\n  fully identical.\n\n  Args:\n    nested_splits_lists: A list of nested_splits_lists, where each split_list is\n      a list of `splits` tensors from a `RaggedTensor`, ordered from outermost\n      ragged dimension to innermost ragged dimension.\n\n  Returns:\n    A list of control dependency op tensors.\n  Raises:\n    ValueError: If the splits are not identical.\n  \"\"\"\n    error_msg = 'Inputs must have identical ragged splits'\n    for splits_list in nested_splits_lists:\n        if len(splits_list) != len(nested_splits_lists[0]):\n            raise ValueError(error_msg)\n    return [check_ops.assert_equal(s1, s2, message=error_msg) for splits_list in nested_splits_lists[1:] for (s1, s2) in zip(nested_splits_lists[0], splits_list)]",
        "mutated": [
            "def assert_splits_match(nested_splits_lists):\n    if False:\n        i = 10\n    'Checks that the given splits lists are identical.\\n\\n  Performs static tests to ensure that the given splits lists are identical,\\n  and returns a list of control dependency op tensors that check that they are\\n  fully identical.\\n\\n  Args:\\n    nested_splits_lists: A list of nested_splits_lists, where each split_list is\\n      a list of `splits` tensors from a `RaggedTensor`, ordered from outermost\\n      ragged dimension to innermost ragged dimension.\\n\\n  Returns:\\n    A list of control dependency op tensors.\\n  Raises:\\n    ValueError: If the splits are not identical.\\n  '\n    error_msg = 'Inputs must have identical ragged splits'\n    for splits_list in nested_splits_lists:\n        if len(splits_list) != len(nested_splits_lists[0]):\n            raise ValueError(error_msg)\n    return [check_ops.assert_equal(s1, s2, message=error_msg) for splits_list in nested_splits_lists[1:] for (s1, s2) in zip(nested_splits_lists[0], splits_list)]",
            "def assert_splits_match(nested_splits_lists):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Checks that the given splits lists are identical.\\n\\n  Performs static tests to ensure that the given splits lists are identical,\\n  and returns a list of control dependency op tensors that check that they are\\n  fully identical.\\n\\n  Args:\\n    nested_splits_lists: A list of nested_splits_lists, where each split_list is\\n      a list of `splits` tensors from a `RaggedTensor`, ordered from outermost\\n      ragged dimension to innermost ragged dimension.\\n\\n  Returns:\\n    A list of control dependency op tensors.\\n  Raises:\\n    ValueError: If the splits are not identical.\\n  '\n    error_msg = 'Inputs must have identical ragged splits'\n    for splits_list in nested_splits_lists:\n        if len(splits_list) != len(nested_splits_lists[0]):\n            raise ValueError(error_msg)\n    return [check_ops.assert_equal(s1, s2, message=error_msg) for splits_list in nested_splits_lists[1:] for (s1, s2) in zip(nested_splits_lists[0], splits_list)]",
            "def assert_splits_match(nested_splits_lists):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Checks that the given splits lists are identical.\\n\\n  Performs static tests to ensure that the given splits lists are identical,\\n  and returns a list of control dependency op tensors that check that they are\\n  fully identical.\\n\\n  Args:\\n    nested_splits_lists: A list of nested_splits_lists, where each split_list is\\n      a list of `splits` tensors from a `RaggedTensor`, ordered from outermost\\n      ragged dimension to innermost ragged dimension.\\n\\n  Returns:\\n    A list of control dependency op tensors.\\n  Raises:\\n    ValueError: If the splits are not identical.\\n  '\n    error_msg = 'Inputs must have identical ragged splits'\n    for splits_list in nested_splits_lists:\n        if len(splits_list) != len(nested_splits_lists[0]):\n            raise ValueError(error_msg)\n    return [check_ops.assert_equal(s1, s2, message=error_msg) for splits_list in nested_splits_lists[1:] for (s1, s2) in zip(nested_splits_lists[0], splits_list)]",
            "def assert_splits_match(nested_splits_lists):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Checks that the given splits lists are identical.\\n\\n  Performs static tests to ensure that the given splits lists are identical,\\n  and returns a list of control dependency op tensors that check that they are\\n  fully identical.\\n\\n  Args:\\n    nested_splits_lists: A list of nested_splits_lists, where each split_list is\\n      a list of `splits` tensors from a `RaggedTensor`, ordered from outermost\\n      ragged dimension to innermost ragged dimension.\\n\\n  Returns:\\n    A list of control dependency op tensors.\\n  Raises:\\n    ValueError: If the splits are not identical.\\n  '\n    error_msg = 'Inputs must have identical ragged splits'\n    for splits_list in nested_splits_lists:\n        if len(splits_list) != len(nested_splits_lists[0]):\n            raise ValueError(error_msg)\n    return [check_ops.assert_equal(s1, s2, message=error_msg) for splits_list in nested_splits_lists[1:] for (s1, s2) in zip(nested_splits_lists[0], splits_list)]",
            "def assert_splits_match(nested_splits_lists):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Checks that the given splits lists are identical.\\n\\n  Performs static tests to ensure that the given splits lists are identical,\\n  and returns a list of control dependency op tensors that check that they are\\n  fully identical.\\n\\n  Args:\\n    nested_splits_lists: A list of nested_splits_lists, where each split_list is\\n      a list of `splits` tensors from a `RaggedTensor`, ordered from outermost\\n      ragged dimension to innermost ragged dimension.\\n\\n  Returns:\\n    A list of control dependency op tensors.\\n  Raises:\\n    ValueError: If the splits are not identical.\\n  '\n    error_msg = 'Inputs must have identical ragged splits'\n    for splits_list in nested_splits_lists:\n        if len(splits_list) != len(nested_splits_lists[0]):\n            raise ValueError(error_msg)\n    return [check_ops.assert_equal(s1, s2, message=error_msg) for splits_list in nested_splits_lists[1:] for (s1, s2) in zip(nested_splits_lists[0], splits_list)]"
        ]
    },
    {
        "func_name": "lengths_to_splits",
        "original": "def lengths_to_splits(lengths):\n    \"\"\"Returns splits corresponding to the given lengths.\"\"\"\n    return array_ops.concat([[0], math_ops.cumsum(lengths)], axis=-1)",
        "mutated": [
            "def lengths_to_splits(lengths):\n    if False:\n        i = 10\n    'Returns splits corresponding to the given lengths.'\n    return array_ops.concat([[0], math_ops.cumsum(lengths)], axis=-1)",
            "def lengths_to_splits(lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns splits corresponding to the given lengths.'\n    return array_ops.concat([[0], math_ops.cumsum(lengths)], axis=-1)",
            "def lengths_to_splits(lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns splits corresponding to the given lengths.'\n    return array_ops.concat([[0], math_ops.cumsum(lengths)], axis=-1)",
            "def lengths_to_splits(lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns splits corresponding to the given lengths.'\n    return array_ops.concat([[0], math_ops.cumsum(lengths)], axis=-1)",
            "def lengths_to_splits(lengths):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns splits corresponding to the given lengths.'\n    return array_ops.concat([[0], math_ops.cumsum(lengths)], axis=-1)"
        ]
    },
    {
        "func_name": "repeat_ranges",
        "original": "def repeat_ranges(params, splits, repeats):\n    \"\"\"Repeats each range of `params` (as specified by `splits`) `repeats` times.\n\n  Let the `i`th range of `params` be defined as\n  `params[splits[i]:splits[i + 1]]`.  Then this function returns a tensor\n  containing range 0 repeated `repeats[0]` times, followed by range 1 repeated\n  `repeats[1]`, ..., followed by the last range repeated `repeats[-1]` times.\n\n  Args:\n    params: The `Tensor` whose values should be repeated.\n    splits: A splits tensor indicating the ranges of `params` that should be\n      repeated. Elements should be non-negative integers.\n    repeats: The number of times each range should be repeated. Supports\n      broadcasting from a scalar value. Elements should be non-negative\n      integers.\n\n  Returns:\n    A `Tensor` with the same rank and type as `params`.\n\n  #### Example:\n\n  >>> print(repeat_ranges(\n  ...     params=tf.constant(['a', 'b', 'c']),\n  ...     splits=tf.constant([0, 2, 3]),\n  ...     repeats=tf.constant(3)))\n  tf.Tensor([b'a' b'b' b'a' b'b' b'a' b'b' b'c' b'c' b'c'],\n      shape=(9,), dtype=string)\n  \"\"\"\n    splits_checks = [check_ops.assert_non_negative(splits, message=\"Input argument 'splits' must be non-negative\"), check_ops.assert_integer(splits, message=f\"Input argument 'splits' must be integer, but got {splits.dtype} instead\")]\n    repeats_checks = [check_ops.assert_non_negative(repeats, message=\"Input argument 'repeats' must be non-negative\"), check_ops.assert_integer(repeats, message=f\"Input argument 'repeats' must be integer, but got {repeats.dtype} instead\")]\n    splits = control_flow_ops.with_dependencies(splits_checks, splits)\n    repeats = control_flow_ops.with_dependencies(repeats_checks, repeats)\n    if repeats.shape.ndims != 0:\n        repeated_starts = repeat(splits[:-1], repeats, axis=0)\n        repeated_limits = repeat(splits[1:], repeats, axis=0)\n    else:\n        repeated_splits = repeat(splits, repeats, axis=0)\n        n_splits = array_ops.shape(repeated_splits, out_type=repeats.dtype)[0]\n        repeated_starts = repeated_splits[:n_splits - repeats]\n        repeated_limits = repeated_splits[repeats:]\n    one = array_ops.ones((), repeated_starts.dtype)\n    offsets = gen_ragged_math_ops.ragged_range(repeated_starts, repeated_limits, one)\n    return array_ops.gather(params, offsets.rt_dense_values)",
        "mutated": [
            "def repeat_ranges(params, splits, repeats):\n    if False:\n        i = 10\n    \"Repeats each range of `params` (as specified by `splits`) `repeats` times.\\n\\n  Let the `i`th range of `params` be defined as\\n  `params[splits[i]:splits[i + 1]]`.  Then this function returns a tensor\\n  containing range 0 repeated `repeats[0]` times, followed by range 1 repeated\\n  `repeats[1]`, ..., followed by the last range repeated `repeats[-1]` times.\\n\\n  Args:\\n    params: The `Tensor` whose values should be repeated.\\n    splits: A splits tensor indicating the ranges of `params` that should be\\n      repeated. Elements should be non-negative integers.\\n    repeats: The number of times each range should be repeated. Supports\\n      broadcasting from a scalar value. Elements should be non-negative\\n      integers.\\n\\n  Returns:\\n    A `Tensor` with the same rank and type as `params`.\\n\\n  #### Example:\\n\\n  >>> print(repeat_ranges(\\n  ...     params=tf.constant(['a', 'b', 'c']),\\n  ...     splits=tf.constant([0, 2, 3]),\\n  ...     repeats=tf.constant(3)))\\n  tf.Tensor([b'a' b'b' b'a' b'b' b'a' b'b' b'c' b'c' b'c'],\\n      shape=(9,), dtype=string)\\n  \"\n    splits_checks = [check_ops.assert_non_negative(splits, message=\"Input argument 'splits' must be non-negative\"), check_ops.assert_integer(splits, message=f\"Input argument 'splits' must be integer, but got {splits.dtype} instead\")]\n    repeats_checks = [check_ops.assert_non_negative(repeats, message=\"Input argument 'repeats' must be non-negative\"), check_ops.assert_integer(repeats, message=f\"Input argument 'repeats' must be integer, but got {repeats.dtype} instead\")]\n    splits = control_flow_ops.with_dependencies(splits_checks, splits)\n    repeats = control_flow_ops.with_dependencies(repeats_checks, repeats)\n    if repeats.shape.ndims != 0:\n        repeated_starts = repeat(splits[:-1], repeats, axis=0)\n        repeated_limits = repeat(splits[1:], repeats, axis=0)\n    else:\n        repeated_splits = repeat(splits, repeats, axis=0)\n        n_splits = array_ops.shape(repeated_splits, out_type=repeats.dtype)[0]\n        repeated_starts = repeated_splits[:n_splits - repeats]\n        repeated_limits = repeated_splits[repeats:]\n    one = array_ops.ones((), repeated_starts.dtype)\n    offsets = gen_ragged_math_ops.ragged_range(repeated_starts, repeated_limits, one)\n    return array_ops.gather(params, offsets.rt_dense_values)",
            "def repeat_ranges(params, splits, repeats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Repeats each range of `params` (as specified by `splits`) `repeats` times.\\n\\n  Let the `i`th range of `params` be defined as\\n  `params[splits[i]:splits[i + 1]]`.  Then this function returns a tensor\\n  containing range 0 repeated `repeats[0]` times, followed by range 1 repeated\\n  `repeats[1]`, ..., followed by the last range repeated `repeats[-1]` times.\\n\\n  Args:\\n    params: The `Tensor` whose values should be repeated.\\n    splits: A splits tensor indicating the ranges of `params` that should be\\n      repeated. Elements should be non-negative integers.\\n    repeats: The number of times each range should be repeated. Supports\\n      broadcasting from a scalar value. Elements should be non-negative\\n      integers.\\n\\n  Returns:\\n    A `Tensor` with the same rank and type as `params`.\\n\\n  #### Example:\\n\\n  >>> print(repeat_ranges(\\n  ...     params=tf.constant(['a', 'b', 'c']),\\n  ...     splits=tf.constant([0, 2, 3]),\\n  ...     repeats=tf.constant(3)))\\n  tf.Tensor([b'a' b'b' b'a' b'b' b'a' b'b' b'c' b'c' b'c'],\\n      shape=(9,), dtype=string)\\n  \"\n    splits_checks = [check_ops.assert_non_negative(splits, message=\"Input argument 'splits' must be non-negative\"), check_ops.assert_integer(splits, message=f\"Input argument 'splits' must be integer, but got {splits.dtype} instead\")]\n    repeats_checks = [check_ops.assert_non_negative(repeats, message=\"Input argument 'repeats' must be non-negative\"), check_ops.assert_integer(repeats, message=f\"Input argument 'repeats' must be integer, but got {repeats.dtype} instead\")]\n    splits = control_flow_ops.with_dependencies(splits_checks, splits)\n    repeats = control_flow_ops.with_dependencies(repeats_checks, repeats)\n    if repeats.shape.ndims != 0:\n        repeated_starts = repeat(splits[:-1], repeats, axis=0)\n        repeated_limits = repeat(splits[1:], repeats, axis=0)\n    else:\n        repeated_splits = repeat(splits, repeats, axis=0)\n        n_splits = array_ops.shape(repeated_splits, out_type=repeats.dtype)[0]\n        repeated_starts = repeated_splits[:n_splits - repeats]\n        repeated_limits = repeated_splits[repeats:]\n    one = array_ops.ones((), repeated_starts.dtype)\n    offsets = gen_ragged_math_ops.ragged_range(repeated_starts, repeated_limits, one)\n    return array_ops.gather(params, offsets.rt_dense_values)",
            "def repeat_ranges(params, splits, repeats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Repeats each range of `params` (as specified by `splits`) `repeats` times.\\n\\n  Let the `i`th range of `params` be defined as\\n  `params[splits[i]:splits[i + 1]]`.  Then this function returns a tensor\\n  containing range 0 repeated `repeats[0]` times, followed by range 1 repeated\\n  `repeats[1]`, ..., followed by the last range repeated `repeats[-1]` times.\\n\\n  Args:\\n    params: The `Tensor` whose values should be repeated.\\n    splits: A splits tensor indicating the ranges of `params` that should be\\n      repeated. Elements should be non-negative integers.\\n    repeats: The number of times each range should be repeated. Supports\\n      broadcasting from a scalar value. Elements should be non-negative\\n      integers.\\n\\n  Returns:\\n    A `Tensor` with the same rank and type as `params`.\\n\\n  #### Example:\\n\\n  >>> print(repeat_ranges(\\n  ...     params=tf.constant(['a', 'b', 'c']),\\n  ...     splits=tf.constant([0, 2, 3]),\\n  ...     repeats=tf.constant(3)))\\n  tf.Tensor([b'a' b'b' b'a' b'b' b'a' b'b' b'c' b'c' b'c'],\\n      shape=(9,), dtype=string)\\n  \"\n    splits_checks = [check_ops.assert_non_negative(splits, message=\"Input argument 'splits' must be non-negative\"), check_ops.assert_integer(splits, message=f\"Input argument 'splits' must be integer, but got {splits.dtype} instead\")]\n    repeats_checks = [check_ops.assert_non_negative(repeats, message=\"Input argument 'repeats' must be non-negative\"), check_ops.assert_integer(repeats, message=f\"Input argument 'repeats' must be integer, but got {repeats.dtype} instead\")]\n    splits = control_flow_ops.with_dependencies(splits_checks, splits)\n    repeats = control_flow_ops.with_dependencies(repeats_checks, repeats)\n    if repeats.shape.ndims != 0:\n        repeated_starts = repeat(splits[:-1], repeats, axis=0)\n        repeated_limits = repeat(splits[1:], repeats, axis=0)\n    else:\n        repeated_splits = repeat(splits, repeats, axis=0)\n        n_splits = array_ops.shape(repeated_splits, out_type=repeats.dtype)[0]\n        repeated_starts = repeated_splits[:n_splits - repeats]\n        repeated_limits = repeated_splits[repeats:]\n    one = array_ops.ones((), repeated_starts.dtype)\n    offsets = gen_ragged_math_ops.ragged_range(repeated_starts, repeated_limits, one)\n    return array_ops.gather(params, offsets.rt_dense_values)",
            "def repeat_ranges(params, splits, repeats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Repeats each range of `params` (as specified by `splits`) `repeats` times.\\n\\n  Let the `i`th range of `params` be defined as\\n  `params[splits[i]:splits[i + 1]]`.  Then this function returns a tensor\\n  containing range 0 repeated `repeats[0]` times, followed by range 1 repeated\\n  `repeats[1]`, ..., followed by the last range repeated `repeats[-1]` times.\\n\\n  Args:\\n    params: The `Tensor` whose values should be repeated.\\n    splits: A splits tensor indicating the ranges of `params` that should be\\n      repeated. Elements should be non-negative integers.\\n    repeats: The number of times each range should be repeated. Supports\\n      broadcasting from a scalar value. Elements should be non-negative\\n      integers.\\n\\n  Returns:\\n    A `Tensor` with the same rank and type as `params`.\\n\\n  #### Example:\\n\\n  >>> print(repeat_ranges(\\n  ...     params=tf.constant(['a', 'b', 'c']),\\n  ...     splits=tf.constant([0, 2, 3]),\\n  ...     repeats=tf.constant(3)))\\n  tf.Tensor([b'a' b'b' b'a' b'b' b'a' b'b' b'c' b'c' b'c'],\\n      shape=(9,), dtype=string)\\n  \"\n    splits_checks = [check_ops.assert_non_negative(splits, message=\"Input argument 'splits' must be non-negative\"), check_ops.assert_integer(splits, message=f\"Input argument 'splits' must be integer, but got {splits.dtype} instead\")]\n    repeats_checks = [check_ops.assert_non_negative(repeats, message=\"Input argument 'repeats' must be non-negative\"), check_ops.assert_integer(repeats, message=f\"Input argument 'repeats' must be integer, but got {repeats.dtype} instead\")]\n    splits = control_flow_ops.with_dependencies(splits_checks, splits)\n    repeats = control_flow_ops.with_dependencies(repeats_checks, repeats)\n    if repeats.shape.ndims != 0:\n        repeated_starts = repeat(splits[:-1], repeats, axis=0)\n        repeated_limits = repeat(splits[1:], repeats, axis=0)\n    else:\n        repeated_splits = repeat(splits, repeats, axis=0)\n        n_splits = array_ops.shape(repeated_splits, out_type=repeats.dtype)[0]\n        repeated_starts = repeated_splits[:n_splits - repeats]\n        repeated_limits = repeated_splits[repeats:]\n    one = array_ops.ones((), repeated_starts.dtype)\n    offsets = gen_ragged_math_ops.ragged_range(repeated_starts, repeated_limits, one)\n    return array_ops.gather(params, offsets.rt_dense_values)",
            "def repeat_ranges(params, splits, repeats):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Repeats each range of `params` (as specified by `splits`) `repeats` times.\\n\\n  Let the `i`th range of `params` be defined as\\n  `params[splits[i]:splits[i + 1]]`.  Then this function returns a tensor\\n  containing range 0 repeated `repeats[0]` times, followed by range 1 repeated\\n  `repeats[1]`, ..., followed by the last range repeated `repeats[-1]` times.\\n\\n  Args:\\n    params: The `Tensor` whose values should be repeated.\\n    splits: A splits tensor indicating the ranges of `params` that should be\\n      repeated. Elements should be non-negative integers.\\n    repeats: The number of times each range should be repeated. Supports\\n      broadcasting from a scalar value. Elements should be non-negative\\n      integers.\\n\\n  Returns:\\n    A `Tensor` with the same rank and type as `params`.\\n\\n  #### Example:\\n\\n  >>> print(repeat_ranges(\\n  ...     params=tf.constant(['a', 'b', 'c']),\\n  ...     splits=tf.constant([0, 2, 3]),\\n  ...     repeats=tf.constant(3)))\\n  tf.Tensor([b'a' b'b' b'a' b'b' b'a' b'b' b'c' b'c' b'c'],\\n      shape=(9,), dtype=string)\\n  \"\n    splits_checks = [check_ops.assert_non_negative(splits, message=\"Input argument 'splits' must be non-negative\"), check_ops.assert_integer(splits, message=f\"Input argument 'splits' must be integer, but got {splits.dtype} instead\")]\n    repeats_checks = [check_ops.assert_non_negative(repeats, message=\"Input argument 'repeats' must be non-negative\"), check_ops.assert_integer(repeats, message=f\"Input argument 'repeats' must be integer, but got {repeats.dtype} instead\")]\n    splits = control_flow_ops.with_dependencies(splits_checks, splits)\n    repeats = control_flow_ops.with_dependencies(repeats_checks, repeats)\n    if repeats.shape.ndims != 0:\n        repeated_starts = repeat(splits[:-1], repeats, axis=0)\n        repeated_limits = repeat(splits[1:], repeats, axis=0)\n    else:\n        repeated_splits = repeat(splits, repeats, axis=0)\n        n_splits = array_ops.shape(repeated_splits, out_type=repeats.dtype)[0]\n        repeated_starts = repeated_splits[:n_splits - repeats]\n        repeated_limits = repeated_splits[repeats:]\n    one = array_ops.ones((), repeated_starts.dtype)\n    offsets = gen_ragged_math_ops.ragged_range(repeated_starts, repeated_limits, one)\n    return array_ops.gather(params, offsets.rt_dense_values)"
        ]
    }
]