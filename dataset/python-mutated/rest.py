"""
    E2B API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""
import io
import json
import logging
import re
import ssl
from urllib.parse import urlencode, quote_plus
import urllib3
from e2b.api.v2.client.exceptions import ApiException, UnauthorizedException, ForbiddenException, NotFoundException, ServiceException, ApiValueError, BadRequestException
logger = logging.getLogger(__name__)

class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        if False:
            i = 10
            return i + 15
        self.urllib3_response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = resp.data

    def getheaders(self):
        if False:
            i = 10
            return i + 15
        'Returns a dictionary of the response headers.'
        return self.urllib3_response.headers

    def getheader(self, name, default=None):
        if False:
            print('Hello World!')
        'Returns a given response header.'
        return self.urllib3_response.headers.get(name, default)

class RESTClientObject:

    def __init__(self, configuration, pools_size=4, maxsize=None) -> None:
        if False:
            i = 10
            return i + 15
        if configuration.verify_ssl:
            cert_reqs = ssl.CERT_REQUIRED
        else:
            cert_reqs = ssl.CERT_NONE
        addition_pool_args = {}
        if configuration.assert_hostname is not None:
            addition_pool_args['assert_hostname'] = configuration.assert_hostname
        if configuration.retries is not None:
            addition_pool_args['retries'] = configuration.retries
        if configuration.tls_server_name:
            addition_pool_args['server_hostname'] = configuration.tls_server_name
        if configuration.socket_options is not None:
            addition_pool_args['socket_options'] = configuration.socket_options
        if maxsize is None:
            if configuration.connection_pool_maxsize is not None:
                maxsize = configuration.connection_pool_maxsize
            else:
                maxsize = 4
        if configuration.proxy:
            self.pool_manager = urllib3.ProxyManager(num_pools=pools_size, maxsize=maxsize, cert_reqs=cert_reqs, ca_certs=configuration.ssl_ca_cert, cert_file=configuration.cert_file, key_file=configuration.key_file, proxy_url=configuration.proxy, proxy_headers=configuration.proxy_headers, **addition_pool_args)
        else:
            self.pool_manager = urllib3.PoolManager(num_pools=pools_size, maxsize=maxsize, cert_reqs=cert_reqs, ca_certs=configuration.ssl_ca_cert, cert_file=configuration.cert_file, key_file=configuration.key_file, **addition_pool_args)

    def request(self, method, url, query_params=None, headers=None, body=None, post_params=None, _preload_content=True, _request_timeout=None):
        if False:
            print('Hello World!')
        'Perform requests.\n\n        :param method: http request method\n        :param url: http request url\n        :param query_params: query parameters in the url\n        :param headers: http request headers\n        :param body: request json body, for `application/json`\n        :param post_params: request post parameters,\n                            `application/x-www-form-urlencoded`\n                            and `multipart/form-data`\n        :param _preload_content: if False, the urllib3.HTTPResponse object will\n                                 be returned without reading/decoding response\n                                 data. Default is True.\n        :param _request_timeout: timeout setting for this request. If one\n                                 number provided, it will be total request\n                                 timeout. It can also be a pair (tuple) of\n                                 (connection, read) timeouts.\n        '
        method = method.upper()
        assert method in ['GET', 'HEAD', 'DELETE', 'POST', 'PUT', 'PATCH', 'OPTIONS']
        if post_params and body:
            raise ApiValueError('body parameter cannot be used with post_params parameter.')
        post_params = post_params or {}
        headers = headers or {}
        query_params = {}
        timeout = None
        if _request_timeout:
            if isinstance(_request_timeout, (int, float)):
                timeout = urllib3.Timeout(total=_request_timeout)
            elif isinstance(_request_timeout, tuple) and len(_request_timeout) == 2:
                timeout = urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])
        try:
            if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
                if not headers.get('Content-Type') or re.search('json', headers['Content-Type'], re.IGNORECASE):
                    request_body = None
                    if body is not None:
                        request_body = json.dumps(body)
                    r = self.pool_manager.request(method, url, body=request_body, preload_content=_preload_content, timeout=timeout, headers=headers)
                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':
                    r = self.pool_manager.request(method, url, fields=post_params, encode_multipart=False, preload_content=_preload_content, timeout=timeout, headers=headers)
                elif headers['Content-Type'] == 'multipart/form-data':
                    del headers['Content-Type']
                    r = self.pool_manager.request(method, url, fields=post_params, encode_multipart=True, preload_content=_preload_content, timeout=timeout, headers=headers)
                elif isinstance(body, str) or isinstance(body, bytes):
                    request_body = body
                    r = self.pool_manager.request(method, url, body=request_body, preload_content=_preload_content, timeout=timeout, headers=headers)
                else:
                    msg = 'Cannot prepare a request message for provided\n                             arguments. Please check that your arguments match\n                             declared content type.'
                    raise ApiException(status=0, reason=msg)
            else:
                r = self.pool_manager.request(method, url, fields={}, preload_content=_preload_content, timeout=timeout, headers=headers)
        except urllib3.exceptions.SSLError as e:
            msg = '{0}\n{1}'.format(type(e).__name__, str(e))
            raise ApiException(status=0, reason=msg)
        if _preload_content:
            r = RESTResponse(r)
            logger.debug('response body: %s', r.data)
        if not 200 <= r.status <= 299:
            if r.status == 400:
                raise BadRequestException(http_resp=r)
            if r.status == 401:
                raise UnauthorizedException(http_resp=r)
            if r.status == 403:
                raise ForbiddenException(http_resp=r)
            if r.status == 404:
                raise NotFoundException(http_resp=r)
            if 500 <= r.status <= 599:
                raise ServiceException(http_resp=r)
            raise ApiException(http_resp=r)
        return r

    def get_request(self, url, headers=None, query_params=None, _preload_content=True, _request_timeout=None):
        if False:
            i = 10
            return i + 15
        return self.request('GET', url, headers=headers, _preload_content=_preload_content, _request_timeout=_request_timeout, query_params=query_params)

    def head_request(self, url, headers=None, query_params=None, _preload_content=True, _request_timeout=None):
        if False:
            for i in range(10):
                print('nop')
        return self.request('HEAD', url, headers=headers, _preload_content=_preload_content, _request_timeout=_request_timeout, query_params=query_params)

    def options_request(self, url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None):
        if False:
            i = 10
            return i + 15
        return self.request('OPTIONS', url, headers=headers, query_params=query_params, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)

    def delete_request(self, url, headers=None, query_params=None, body=None, _preload_content=True, _request_timeout=None):
        if False:
            for i in range(10):
                print('nop')
        return self.request('DELETE', url, headers=headers, query_params=query_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)

    def post_request(self, url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None):
        if False:
            for i in range(10):
                print('nop')
        return self.request('POST', url, headers=headers, query_params=query_params, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)

    def put_request(self, url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None):
        if False:
            i = 10
            return i + 15
        return self.request('PUT', url, headers=headers, query_params=query_params, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)

    def patch_request(self, url, headers=None, query_params=None, post_params=None, body=None, _preload_content=True, _request_timeout=None):
        if False:
            i = 10
            return i + 15
        return self.request('PATCH', url, headers=headers, query_params=query_params, post_params=post_params, _preload_content=_preload_content, _request_timeout=_request_timeout, body=body)