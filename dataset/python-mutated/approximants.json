[
    {
        "func_name": "approximants",
        "original": "@public\ndef approximants(l, X=Symbol('x'), simplify=False):\n    \"\"\"\n    Return a generator for consecutive Pade approximants for a series.\n    It can also be used for computing the rational generating function of a\n    series when possible, since the last approximant returned by the generator\n    will be the generating function (if any).\n\n    Explanation\n    ===========\n\n    The input list can contain more complex expressions than integer or rational\n    numbers; symbols may also be involved in the computation. An example below\n    show how to compute the generating function of the whole Pascal triangle.\n\n    The generator can be asked to apply the sympy.simplify function on each\n    generated term, which will make the computation slower; however it may be\n    useful when symbols are involved in the expressions.\n\n    Examples\n    ========\n\n    >>> from sympy.series import approximants\n    >>> from sympy import lucas, fibonacci, symbols, binomial\n    >>> g = [lucas(k) for k in range(16)]\n    >>> [e for e in approximants(g)]\n    [2, -4/(x - 2), (5*x - 2)/(3*x - 1), (x - 2)/(x**2 + x - 1)]\n\n    >>> h = [fibonacci(k) for k in range(16)]\n    >>> [e for e in approximants(h)]\n    [x, -x/(x - 1), (x**2 - x)/(2*x - 1), -x/(x**2 + x - 1)]\n\n    >>> x, t = symbols(\"x,t\")\n    >>> p=[sum(binomial(k,i)*x**i for i in range(k+1)) for k in range(16)]\n    >>> y = approximants(p, t)\n    >>> for k in range(3): print(next(y))\n    1\n    (x + 1)/((-x - 1)*(t*(x + 1) + (x + 1)/(-x - 1)))\n    nan\n\n    >>> y = approximants(p, t, simplify=True)\n    >>> for k in range(3): print(next(y))\n    1\n    -1/(t*(x + 1) - 1)\n    nan\n\n    See Also\n    ========\n\n    sympy.concrete.guess.guess_generating_function_rational\n    mpmath.pade\n    \"\"\"\n    from sympy.simplify import simplify as simp\n    from sympy.simplify.radsimp import denom\n    (p1, q1) = ([S.One], [S.Zero])\n    (p2, q2) = ([S.Zero], [S.One])\n    while len(l):\n        b = 0\n        while l[b] == 0:\n            b += 1\n            if b == len(l):\n                return\n        m = [S.One / l[b]]\n        for k in range(b + 1, len(l)):\n            s = 0\n            for j in range(b, k):\n                s -= l[j + 1] * m[b - j - 1]\n            m.append(s / l[b])\n        l = m\n        (a, l[0]) = (l[0], 0)\n        p = [0] * max(len(p2), b + len(p1))\n        q = [0] * max(len(q2), b + len(q1))\n        for k in range(len(p2)):\n            p[k] = a * p2[k]\n        for k in range(b, b + len(p1)):\n            p[k] += p1[k - b]\n        for k in range(len(q2)):\n            q[k] = a * q2[k]\n        for k in range(b, b + len(q1)):\n            q[k] += q1[k - b]\n        while p[-1] == 0:\n            p.pop()\n        while q[-1] == 0:\n            q.pop()\n        (p1, p2) = (p2, p)\n        (q1, q2) = (q2, q)\n        c = 1\n        for x in p:\n            c = lcm(c, denom(x))\n        for x in q:\n            c = lcm(c, denom(x))\n        out = sum((c * e * X ** k for (k, e) in enumerate(p))) / sum((c * e * X ** k for (k, e) in enumerate(q)))\n        if simplify:\n            yield simp(out)\n        else:\n            yield out\n    return",
        "mutated": [
            "@public\ndef approximants(l, X=Symbol('x'), simplify=False):\n    if False:\n        i = 10\n    '\\n    Return a generator for consecutive Pade approximants for a series.\\n    It can also be used for computing the rational generating function of a\\n    series when possible, since the last approximant returned by the generator\\n    will be the generating function (if any).\\n\\n    Explanation\\n    ===========\\n\\n    The input list can contain more complex expressions than integer or rational\\n    numbers; symbols may also be involved in the computation. An example below\\n    show how to compute the generating function of the whole Pascal triangle.\\n\\n    The generator can be asked to apply the sympy.simplify function on each\\n    generated term, which will make the computation slower; however it may be\\n    useful when symbols are involved in the expressions.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.series import approximants\\n    >>> from sympy import lucas, fibonacci, symbols, binomial\\n    >>> g = [lucas(k) for k in range(16)]\\n    >>> [e for e in approximants(g)]\\n    [2, -4/(x - 2), (5*x - 2)/(3*x - 1), (x - 2)/(x**2 + x - 1)]\\n\\n    >>> h = [fibonacci(k) for k in range(16)]\\n    >>> [e for e in approximants(h)]\\n    [x, -x/(x - 1), (x**2 - x)/(2*x - 1), -x/(x**2 + x - 1)]\\n\\n    >>> x, t = symbols(\"x,t\")\\n    >>> p=[sum(binomial(k,i)*x**i for i in range(k+1)) for k in range(16)]\\n    >>> y = approximants(p, t)\\n    >>> for k in range(3): print(next(y))\\n    1\\n    (x + 1)/((-x - 1)*(t*(x + 1) + (x + 1)/(-x - 1)))\\n    nan\\n\\n    >>> y = approximants(p, t, simplify=True)\\n    >>> for k in range(3): print(next(y))\\n    1\\n    -1/(t*(x + 1) - 1)\\n    nan\\n\\n    See Also\\n    ========\\n\\n    sympy.concrete.guess.guess_generating_function_rational\\n    mpmath.pade\\n    '\n    from sympy.simplify import simplify as simp\n    from sympy.simplify.radsimp import denom\n    (p1, q1) = ([S.One], [S.Zero])\n    (p2, q2) = ([S.Zero], [S.One])\n    while len(l):\n        b = 0\n        while l[b] == 0:\n            b += 1\n            if b == len(l):\n                return\n        m = [S.One / l[b]]\n        for k in range(b + 1, len(l)):\n            s = 0\n            for j in range(b, k):\n                s -= l[j + 1] * m[b - j - 1]\n            m.append(s / l[b])\n        l = m\n        (a, l[0]) = (l[0], 0)\n        p = [0] * max(len(p2), b + len(p1))\n        q = [0] * max(len(q2), b + len(q1))\n        for k in range(len(p2)):\n            p[k] = a * p2[k]\n        for k in range(b, b + len(p1)):\n            p[k] += p1[k - b]\n        for k in range(len(q2)):\n            q[k] = a * q2[k]\n        for k in range(b, b + len(q1)):\n            q[k] += q1[k - b]\n        while p[-1] == 0:\n            p.pop()\n        while q[-1] == 0:\n            q.pop()\n        (p1, p2) = (p2, p)\n        (q1, q2) = (q2, q)\n        c = 1\n        for x in p:\n            c = lcm(c, denom(x))\n        for x in q:\n            c = lcm(c, denom(x))\n        out = sum((c * e * X ** k for (k, e) in enumerate(p))) / sum((c * e * X ** k for (k, e) in enumerate(q)))\n        if simplify:\n            yield simp(out)\n        else:\n            yield out\n    return",
            "@public\ndef approximants(l, X=Symbol('x'), simplify=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Return a generator for consecutive Pade approximants for a series.\\n    It can also be used for computing the rational generating function of a\\n    series when possible, since the last approximant returned by the generator\\n    will be the generating function (if any).\\n\\n    Explanation\\n    ===========\\n\\n    The input list can contain more complex expressions than integer or rational\\n    numbers; symbols may also be involved in the computation. An example below\\n    show how to compute the generating function of the whole Pascal triangle.\\n\\n    The generator can be asked to apply the sympy.simplify function on each\\n    generated term, which will make the computation slower; however it may be\\n    useful when symbols are involved in the expressions.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.series import approximants\\n    >>> from sympy import lucas, fibonacci, symbols, binomial\\n    >>> g = [lucas(k) for k in range(16)]\\n    >>> [e for e in approximants(g)]\\n    [2, -4/(x - 2), (5*x - 2)/(3*x - 1), (x - 2)/(x**2 + x - 1)]\\n\\n    >>> h = [fibonacci(k) for k in range(16)]\\n    >>> [e for e in approximants(h)]\\n    [x, -x/(x - 1), (x**2 - x)/(2*x - 1), -x/(x**2 + x - 1)]\\n\\n    >>> x, t = symbols(\"x,t\")\\n    >>> p=[sum(binomial(k,i)*x**i for i in range(k+1)) for k in range(16)]\\n    >>> y = approximants(p, t)\\n    >>> for k in range(3): print(next(y))\\n    1\\n    (x + 1)/((-x - 1)*(t*(x + 1) + (x + 1)/(-x - 1)))\\n    nan\\n\\n    >>> y = approximants(p, t, simplify=True)\\n    >>> for k in range(3): print(next(y))\\n    1\\n    -1/(t*(x + 1) - 1)\\n    nan\\n\\n    See Also\\n    ========\\n\\n    sympy.concrete.guess.guess_generating_function_rational\\n    mpmath.pade\\n    '\n    from sympy.simplify import simplify as simp\n    from sympy.simplify.radsimp import denom\n    (p1, q1) = ([S.One], [S.Zero])\n    (p2, q2) = ([S.Zero], [S.One])\n    while len(l):\n        b = 0\n        while l[b] == 0:\n            b += 1\n            if b == len(l):\n                return\n        m = [S.One / l[b]]\n        for k in range(b + 1, len(l)):\n            s = 0\n            for j in range(b, k):\n                s -= l[j + 1] * m[b - j - 1]\n            m.append(s / l[b])\n        l = m\n        (a, l[0]) = (l[0], 0)\n        p = [0] * max(len(p2), b + len(p1))\n        q = [0] * max(len(q2), b + len(q1))\n        for k in range(len(p2)):\n            p[k] = a * p2[k]\n        for k in range(b, b + len(p1)):\n            p[k] += p1[k - b]\n        for k in range(len(q2)):\n            q[k] = a * q2[k]\n        for k in range(b, b + len(q1)):\n            q[k] += q1[k - b]\n        while p[-1] == 0:\n            p.pop()\n        while q[-1] == 0:\n            q.pop()\n        (p1, p2) = (p2, p)\n        (q1, q2) = (q2, q)\n        c = 1\n        for x in p:\n            c = lcm(c, denom(x))\n        for x in q:\n            c = lcm(c, denom(x))\n        out = sum((c * e * X ** k for (k, e) in enumerate(p))) / sum((c * e * X ** k for (k, e) in enumerate(q)))\n        if simplify:\n            yield simp(out)\n        else:\n            yield out\n    return",
            "@public\ndef approximants(l, X=Symbol('x'), simplify=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Return a generator for consecutive Pade approximants for a series.\\n    It can also be used for computing the rational generating function of a\\n    series when possible, since the last approximant returned by the generator\\n    will be the generating function (if any).\\n\\n    Explanation\\n    ===========\\n\\n    The input list can contain more complex expressions than integer or rational\\n    numbers; symbols may also be involved in the computation. An example below\\n    show how to compute the generating function of the whole Pascal triangle.\\n\\n    The generator can be asked to apply the sympy.simplify function on each\\n    generated term, which will make the computation slower; however it may be\\n    useful when symbols are involved in the expressions.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.series import approximants\\n    >>> from sympy import lucas, fibonacci, symbols, binomial\\n    >>> g = [lucas(k) for k in range(16)]\\n    >>> [e for e in approximants(g)]\\n    [2, -4/(x - 2), (5*x - 2)/(3*x - 1), (x - 2)/(x**2 + x - 1)]\\n\\n    >>> h = [fibonacci(k) for k in range(16)]\\n    >>> [e for e in approximants(h)]\\n    [x, -x/(x - 1), (x**2 - x)/(2*x - 1), -x/(x**2 + x - 1)]\\n\\n    >>> x, t = symbols(\"x,t\")\\n    >>> p=[sum(binomial(k,i)*x**i for i in range(k+1)) for k in range(16)]\\n    >>> y = approximants(p, t)\\n    >>> for k in range(3): print(next(y))\\n    1\\n    (x + 1)/((-x - 1)*(t*(x + 1) + (x + 1)/(-x - 1)))\\n    nan\\n\\n    >>> y = approximants(p, t, simplify=True)\\n    >>> for k in range(3): print(next(y))\\n    1\\n    -1/(t*(x + 1) - 1)\\n    nan\\n\\n    See Also\\n    ========\\n\\n    sympy.concrete.guess.guess_generating_function_rational\\n    mpmath.pade\\n    '\n    from sympy.simplify import simplify as simp\n    from sympy.simplify.radsimp import denom\n    (p1, q1) = ([S.One], [S.Zero])\n    (p2, q2) = ([S.Zero], [S.One])\n    while len(l):\n        b = 0\n        while l[b] == 0:\n            b += 1\n            if b == len(l):\n                return\n        m = [S.One / l[b]]\n        for k in range(b + 1, len(l)):\n            s = 0\n            for j in range(b, k):\n                s -= l[j + 1] * m[b - j - 1]\n            m.append(s / l[b])\n        l = m\n        (a, l[0]) = (l[0], 0)\n        p = [0] * max(len(p2), b + len(p1))\n        q = [0] * max(len(q2), b + len(q1))\n        for k in range(len(p2)):\n            p[k] = a * p2[k]\n        for k in range(b, b + len(p1)):\n            p[k] += p1[k - b]\n        for k in range(len(q2)):\n            q[k] = a * q2[k]\n        for k in range(b, b + len(q1)):\n            q[k] += q1[k - b]\n        while p[-1] == 0:\n            p.pop()\n        while q[-1] == 0:\n            q.pop()\n        (p1, p2) = (p2, p)\n        (q1, q2) = (q2, q)\n        c = 1\n        for x in p:\n            c = lcm(c, denom(x))\n        for x in q:\n            c = lcm(c, denom(x))\n        out = sum((c * e * X ** k for (k, e) in enumerate(p))) / sum((c * e * X ** k for (k, e) in enumerate(q)))\n        if simplify:\n            yield simp(out)\n        else:\n            yield out\n    return",
            "@public\ndef approximants(l, X=Symbol('x'), simplify=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Return a generator for consecutive Pade approximants for a series.\\n    It can also be used for computing the rational generating function of a\\n    series when possible, since the last approximant returned by the generator\\n    will be the generating function (if any).\\n\\n    Explanation\\n    ===========\\n\\n    The input list can contain more complex expressions than integer or rational\\n    numbers; symbols may also be involved in the computation. An example below\\n    show how to compute the generating function of the whole Pascal triangle.\\n\\n    The generator can be asked to apply the sympy.simplify function on each\\n    generated term, which will make the computation slower; however it may be\\n    useful when symbols are involved in the expressions.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.series import approximants\\n    >>> from sympy import lucas, fibonacci, symbols, binomial\\n    >>> g = [lucas(k) for k in range(16)]\\n    >>> [e for e in approximants(g)]\\n    [2, -4/(x - 2), (5*x - 2)/(3*x - 1), (x - 2)/(x**2 + x - 1)]\\n\\n    >>> h = [fibonacci(k) for k in range(16)]\\n    >>> [e for e in approximants(h)]\\n    [x, -x/(x - 1), (x**2 - x)/(2*x - 1), -x/(x**2 + x - 1)]\\n\\n    >>> x, t = symbols(\"x,t\")\\n    >>> p=[sum(binomial(k,i)*x**i for i in range(k+1)) for k in range(16)]\\n    >>> y = approximants(p, t)\\n    >>> for k in range(3): print(next(y))\\n    1\\n    (x + 1)/((-x - 1)*(t*(x + 1) + (x + 1)/(-x - 1)))\\n    nan\\n\\n    >>> y = approximants(p, t, simplify=True)\\n    >>> for k in range(3): print(next(y))\\n    1\\n    -1/(t*(x + 1) - 1)\\n    nan\\n\\n    See Also\\n    ========\\n\\n    sympy.concrete.guess.guess_generating_function_rational\\n    mpmath.pade\\n    '\n    from sympy.simplify import simplify as simp\n    from sympy.simplify.radsimp import denom\n    (p1, q1) = ([S.One], [S.Zero])\n    (p2, q2) = ([S.Zero], [S.One])\n    while len(l):\n        b = 0\n        while l[b] == 0:\n            b += 1\n            if b == len(l):\n                return\n        m = [S.One / l[b]]\n        for k in range(b + 1, len(l)):\n            s = 0\n            for j in range(b, k):\n                s -= l[j + 1] * m[b - j - 1]\n            m.append(s / l[b])\n        l = m\n        (a, l[0]) = (l[0], 0)\n        p = [0] * max(len(p2), b + len(p1))\n        q = [0] * max(len(q2), b + len(q1))\n        for k in range(len(p2)):\n            p[k] = a * p2[k]\n        for k in range(b, b + len(p1)):\n            p[k] += p1[k - b]\n        for k in range(len(q2)):\n            q[k] = a * q2[k]\n        for k in range(b, b + len(q1)):\n            q[k] += q1[k - b]\n        while p[-1] == 0:\n            p.pop()\n        while q[-1] == 0:\n            q.pop()\n        (p1, p2) = (p2, p)\n        (q1, q2) = (q2, q)\n        c = 1\n        for x in p:\n            c = lcm(c, denom(x))\n        for x in q:\n            c = lcm(c, denom(x))\n        out = sum((c * e * X ** k for (k, e) in enumerate(p))) / sum((c * e * X ** k for (k, e) in enumerate(q)))\n        if simplify:\n            yield simp(out)\n        else:\n            yield out\n    return",
            "@public\ndef approximants(l, X=Symbol('x'), simplify=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Return a generator for consecutive Pade approximants for a series.\\n    It can also be used for computing the rational generating function of a\\n    series when possible, since the last approximant returned by the generator\\n    will be the generating function (if any).\\n\\n    Explanation\\n    ===========\\n\\n    The input list can contain more complex expressions than integer or rational\\n    numbers; symbols may also be involved in the computation. An example below\\n    show how to compute the generating function of the whole Pascal triangle.\\n\\n    The generator can be asked to apply the sympy.simplify function on each\\n    generated term, which will make the computation slower; however it may be\\n    useful when symbols are involved in the expressions.\\n\\n    Examples\\n    ========\\n\\n    >>> from sympy.series import approximants\\n    >>> from sympy import lucas, fibonacci, symbols, binomial\\n    >>> g = [lucas(k) for k in range(16)]\\n    >>> [e for e in approximants(g)]\\n    [2, -4/(x - 2), (5*x - 2)/(3*x - 1), (x - 2)/(x**2 + x - 1)]\\n\\n    >>> h = [fibonacci(k) for k in range(16)]\\n    >>> [e for e in approximants(h)]\\n    [x, -x/(x - 1), (x**2 - x)/(2*x - 1), -x/(x**2 + x - 1)]\\n\\n    >>> x, t = symbols(\"x,t\")\\n    >>> p=[sum(binomial(k,i)*x**i for i in range(k+1)) for k in range(16)]\\n    >>> y = approximants(p, t)\\n    >>> for k in range(3): print(next(y))\\n    1\\n    (x + 1)/((-x - 1)*(t*(x + 1) + (x + 1)/(-x - 1)))\\n    nan\\n\\n    >>> y = approximants(p, t, simplify=True)\\n    >>> for k in range(3): print(next(y))\\n    1\\n    -1/(t*(x + 1) - 1)\\n    nan\\n\\n    See Also\\n    ========\\n\\n    sympy.concrete.guess.guess_generating_function_rational\\n    mpmath.pade\\n    '\n    from sympy.simplify import simplify as simp\n    from sympy.simplify.radsimp import denom\n    (p1, q1) = ([S.One], [S.Zero])\n    (p2, q2) = ([S.Zero], [S.One])\n    while len(l):\n        b = 0\n        while l[b] == 0:\n            b += 1\n            if b == len(l):\n                return\n        m = [S.One / l[b]]\n        for k in range(b + 1, len(l)):\n            s = 0\n            for j in range(b, k):\n                s -= l[j + 1] * m[b - j - 1]\n            m.append(s / l[b])\n        l = m\n        (a, l[0]) = (l[0], 0)\n        p = [0] * max(len(p2), b + len(p1))\n        q = [0] * max(len(q2), b + len(q1))\n        for k in range(len(p2)):\n            p[k] = a * p2[k]\n        for k in range(b, b + len(p1)):\n            p[k] += p1[k - b]\n        for k in range(len(q2)):\n            q[k] = a * q2[k]\n        for k in range(b, b + len(q1)):\n            q[k] += q1[k - b]\n        while p[-1] == 0:\n            p.pop()\n        while q[-1] == 0:\n            q.pop()\n        (p1, p2) = (p2, p)\n        (q1, q2) = (q2, q)\n        c = 1\n        for x in p:\n            c = lcm(c, denom(x))\n        for x in q:\n            c = lcm(c, denom(x))\n        out = sum((c * e * X ** k for (k, e) in enumerate(p))) / sum((c * e * X ** k for (k, e) in enumerate(q)))\n        if simplify:\n            yield simp(out)\n        else:\n            yield out\n    return"
        ]
    }
]