[
    {
        "func_name": "_extract_alignment_region",
        "original": "def _extract_alignment_region(alignment_seq_with_flanking, annotation):\n    \"\"\"Extract alignment region (PRIVATE).\n\n    Helper function for the main parsing code.\n\n    To get the actual pairwise alignment sequences, we must first\n    translate the un-gapped sequence based coordinates into positions\n    in the gapped sequence (which may have a flanking region shown\n    using leading - characters).  To date, I have never seen any\n    trailing flanking region shown in the m10 file, but the\n    following code should also cope with that.\n\n    Note that this code seems to work fine even when the \"sq_offset\"\n    entries are present as a result of using the -X command line option.\n    \"\"\"\n    align_stripped = alignment_seq_with_flanking.strip('-')\n    display_start = int(annotation['al_display_start'])\n    if int(annotation['al_start']) <= int(annotation['al_stop']):\n        start = int(annotation['al_start']) - display_start\n        end = int(annotation['al_stop']) - display_start + 1\n    else:\n        start = display_start - int(annotation['al_start'])\n        end = display_start - int(annotation['al_stop']) + 1\n    end += align_stripped.count('-')\n    if start < 0 or start >= end or end > len(align_stripped):\n        raise ValueError('Problem with sequence start/stop,\\n%s[%i:%i]\\n%s' % (alignment_seq_with_flanking, start, end, annotation))\n    return align_stripped[start:end]",
        "mutated": [
            "def _extract_alignment_region(alignment_seq_with_flanking, annotation):\n    if False:\n        i = 10\n    'Extract alignment region (PRIVATE).\\n\\n    Helper function for the main parsing code.\\n\\n    To get the actual pairwise alignment sequences, we must first\\n    translate the un-gapped sequence based coordinates into positions\\n    in the gapped sequence (which may have a flanking region shown\\n    using leading - characters).  To date, I have never seen any\\n    trailing flanking region shown in the m10 file, but the\\n    following code should also cope with that.\\n\\n    Note that this code seems to work fine even when the \"sq_offset\"\\n    entries are present as a result of using the -X command line option.\\n    '\n    align_stripped = alignment_seq_with_flanking.strip('-')\n    display_start = int(annotation['al_display_start'])\n    if int(annotation['al_start']) <= int(annotation['al_stop']):\n        start = int(annotation['al_start']) - display_start\n        end = int(annotation['al_stop']) - display_start + 1\n    else:\n        start = display_start - int(annotation['al_start'])\n        end = display_start - int(annotation['al_stop']) + 1\n    end += align_stripped.count('-')\n    if start < 0 or start >= end or end > len(align_stripped):\n        raise ValueError('Problem with sequence start/stop,\\n%s[%i:%i]\\n%s' % (alignment_seq_with_flanking, start, end, annotation))\n    return align_stripped[start:end]",
            "def _extract_alignment_region(alignment_seq_with_flanking, annotation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Extract alignment region (PRIVATE).\\n\\n    Helper function for the main parsing code.\\n\\n    To get the actual pairwise alignment sequences, we must first\\n    translate the un-gapped sequence based coordinates into positions\\n    in the gapped sequence (which may have a flanking region shown\\n    using leading - characters).  To date, I have never seen any\\n    trailing flanking region shown in the m10 file, but the\\n    following code should also cope with that.\\n\\n    Note that this code seems to work fine even when the \"sq_offset\"\\n    entries are present as a result of using the -X command line option.\\n    '\n    align_stripped = alignment_seq_with_flanking.strip('-')\n    display_start = int(annotation['al_display_start'])\n    if int(annotation['al_start']) <= int(annotation['al_stop']):\n        start = int(annotation['al_start']) - display_start\n        end = int(annotation['al_stop']) - display_start + 1\n    else:\n        start = display_start - int(annotation['al_start'])\n        end = display_start - int(annotation['al_stop']) + 1\n    end += align_stripped.count('-')\n    if start < 0 or start >= end or end > len(align_stripped):\n        raise ValueError('Problem with sequence start/stop,\\n%s[%i:%i]\\n%s' % (alignment_seq_with_flanking, start, end, annotation))\n    return align_stripped[start:end]",
            "def _extract_alignment_region(alignment_seq_with_flanking, annotation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Extract alignment region (PRIVATE).\\n\\n    Helper function for the main parsing code.\\n\\n    To get the actual pairwise alignment sequences, we must first\\n    translate the un-gapped sequence based coordinates into positions\\n    in the gapped sequence (which may have a flanking region shown\\n    using leading - characters).  To date, I have never seen any\\n    trailing flanking region shown in the m10 file, but the\\n    following code should also cope with that.\\n\\n    Note that this code seems to work fine even when the \"sq_offset\"\\n    entries are present as a result of using the -X command line option.\\n    '\n    align_stripped = alignment_seq_with_flanking.strip('-')\n    display_start = int(annotation['al_display_start'])\n    if int(annotation['al_start']) <= int(annotation['al_stop']):\n        start = int(annotation['al_start']) - display_start\n        end = int(annotation['al_stop']) - display_start + 1\n    else:\n        start = display_start - int(annotation['al_start'])\n        end = display_start - int(annotation['al_stop']) + 1\n    end += align_stripped.count('-')\n    if start < 0 or start >= end or end > len(align_stripped):\n        raise ValueError('Problem with sequence start/stop,\\n%s[%i:%i]\\n%s' % (alignment_seq_with_flanking, start, end, annotation))\n    return align_stripped[start:end]",
            "def _extract_alignment_region(alignment_seq_with_flanking, annotation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Extract alignment region (PRIVATE).\\n\\n    Helper function for the main parsing code.\\n\\n    To get the actual pairwise alignment sequences, we must first\\n    translate the un-gapped sequence based coordinates into positions\\n    in the gapped sequence (which may have a flanking region shown\\n    using leading - characters).  To date, I have never seen any\\n    trailing flanking region shown in the m10 file, but the\\n    following code should also cope with that.\\n\\n    Note that this code seems to work fine even when the \"sq_offset\"\\n    entries are present as a result of using the -X command line option.\\n    '\n    align_stripped = alignment_seq_with_flanking.strip('-')\n    display_start = int(annotation['al_display_start'])\n    if int(annotation['al_start']) <= int(annotation['al_stop']):\n        start = int(annotation['al_start']) - display_start\n        end = int(annotation['al_stop']) - display_start + 1\n    else:\n        start = display_start - int(annotation['al_start'])\n        end = display_start - int(annotation['al_stop']) + 1\n    end += align_stripped.count('-')\n    if start < 0 or start >= end or end > len(align_stripped):\n        raise ValueError('Problem with sequence start/stop,\\n%s[%i:%i]\\n%s' % (alignment_seq_with_flanking, start, end, annotation))\n    return align_stripped[start:end]",
            "def _extract_alignment_region(alignment_seq_with_flanking, annotation):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Extract alignment region (PRIVATE).\\n\\n    Helper function for the main parsing code.\\n\\n    To get the actual pairwise alignment sequences, we must first\\n    translate the un-gapped sequence based coordinates into positions\\n    in the gapped sequence (which may have a flanking region shown\\n    using leading - characters).  To date, I have never seen any\\n    trailing flanking region shown in the m10 file, but the\\n    following code should also cope with that.\\n\\n    Note that this code seems to work fine even when the \"sq_offset\"\\n    entries are present as a result of using the -X command line option.\\n    '\n    align_stripped = alignment_seq_with_flanking.strip('-')\n    display_start = int(annotation['al_display_start'])\n    if int(annotation['al_start']) <= int(annotation['al_stop']):\n        start = int(annotation['al_start']) - display_start\n        end = int(annotation['al_stop']) - display_start + 1\n    else:\n        start = display_start - int(annotation['al_start'])\n        end = display_start - int(annotation['al_stop']) + 1\n    end += align_stripped.count('-')\n    if start < 0 or start >= end or end > len(align_stripped):\n        raise ValueError('Problem with sequence start/stop,\\n%s[%i:%i]\\n%s' % (alignment_seq_with_flanking, start, end, annotation))\n    return align_stripped[start:end]"
        ]
    },
    {
        "func_name": "build_hsp",
        "original": "def build_hsp():\n    if not query_tags and (not match_tags):\n        raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n    assert query_tags, query_tags\n    assert match_tags, match_tags\n    evalue = align_tags.get('fa_expect')\n    tool = global_tags.get('tool', '').upper()\n    q = _extract_alignment_region(query_seq, query_tags)\n    if tool in ['TFASTX'] and len(match_seq) == len(q):\n        m = match_seq\n    else:\n        m = _extract_alignment_region(match_seq, match_tags)\n    if len(q) != len(m):\n        raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n    annotations = {}\n    records = []\n    annotations.update(header_tags)\n    annotations.update(align_tags)\n    record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n    record._al_start = int(query_tags['al_start'])\n    record._al_stop = int(query_tags['al_stop'])\n    if 'sq_type' in query_tags:\n        if query_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif query_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n    record._al_start = int(match_tags['al_start'])\n    record._al_stop = int(match_tags['al_stop'])\n    if 'sq_type' in match_tags:\n        if match_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif match_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    return MultipleSeqAlignment(records, annotations=annotations)",
        "mutated": [
            "def build_hsp():\n    if False:\n        i = 10\n    if not query_tags and (not match_tags):\n        raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n    assert query_tags, query_tags\n    assert match_tags, match_tags\n    evalue = align_tags.get('fa_expect')\n    tool = global_tags.get('tool', '').upper()\n    q = _extract_alignment_region(query_seq, query_tags)\n    if tool in ['TFASTX'] and len(match_seq) == len(q):\n        m = match_seq\n    else:\n        m = _extract_alignment_region(match_seq, match_tags)\n    if len(q) != len(m):\n        raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n    annotations = {}\n    records = []\n    annotations.update(header_tags)\n    annotations.update(align_tags)\n    record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n    record._al_start = int(query_tags['al_start'])\n    record._al_stop = int(query_tags['al_stop'])\n    if 'sq_type' in query_tags:\n        if query_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif query_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n    record._al_start = int(match_tags['al_start'])\n    record._al_stop = int(match_tags['al_stop'])\n    if 'sq_type' in match_tags:\n        if match_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif match_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    return MultipleSeqAlignment(records, annotations=annotations)",
            "def build_hsp():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if not query_tags and (not match_tags):\n        raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n    assert query_tags, query_tags\n    assert match_tags, match_tags\n    evalue = align_tags.get('fa_expect')\n    tool = global_tags.get('tool', '').upper()\n    q = _extract_alignment_region(query_seq, query_tags)\n    if tool in ['TFASTX'] and len(match_seq) == len(q):\n        m = match_seq\n    else:\n        m = _extract_alignment_region(match_seq, match_tags)\n    if len(q) != len(m):\n        raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n    annotations = {}\n    records = []\n    annotations.update(header_tags)\n    annotations.update(align_tags)\n    record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n    record._al_start = int(query_tags['al_start'])\n    record._al_stop = int(query_tags['al_stop'])\n    if 'sq_type' in query_tags:\n        if query_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif query_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n    record._al_start = int(match_tags['al_start'])\n    record._al_stop = int(match_tags['al_stop'])\n    if 'sq_type' in match_tags:\n        if match_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif match_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    return MultipleSeqAlignment(records, annotations=annotations)",
            "def build_hsp():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if not query_tags and (not match_tags):\n        raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n    assert query_tags, query_tags\n    assert match_tags, match_tags\n    evalue = align_tags.get('fa_expect')\n    tool = global_tags.get('tool', '').upper()\n    q = _extract_alignment_region(query_seq, query_tags)\n    if tool in ['TFASTX'] and len(match_seq) == len(q):\n        m = match_seq\n    else:\n        m = _extract_alignment_region(match_seq, match_tags)\n    if len(q) != len(m):\n        raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n    annotations = {}\n    records = []\n    annotations.update(header_tags)\n    annotations.update(align_tags)\n    record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n    record._al_start = int(query_tags['al_start'])\n    record._al_stop = int(query_tags['al_stop'])\n    if 'sq_type' in query_tags:\n        if query_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif query_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n    record._al_start = int(match_tags['al_start'])\n    record._al_stop = int(match_tags['al_stop'])\n    if 'sq_type' in match_tags:\n        if match_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif match_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    return MultipleSeqAlignment(records, annotations=annotations)",
            "def build_hsp():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if not query_tags and (not match_tags):\n        raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n    assert query_tags, query_tags\n    assert match_tags, match_tags\n    evalue = align_tags.get('fa_expect')\n    tool = global_tags.get('tool', '').upper()\n    q = _extract_alignment_region(query_seq, query_tags)\n    if tool in ['TFASTX'] and len(match_seq) == len(q):\n        m = match_seq\n    else:\n        m = _extract_alignment_region(match_seq, match_tags)\n    if len(q) != len(m):\n        raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n    annotations = {}\n    records = []\n    annotations.update(header_tags)\n    annotations.update(align_tags)\n    record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n    record._al_start = int(query_tags['al_start'])\n    record._al_stop = int(query_tags['al_stop'])\n    if 'sq_type' in query_tags:\n        if query_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif query_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n    record._al_start = int(match_tags['al_start'])\n    record._al_stop = int(match_tags['al_stop'])\n    if 'sq_type' in match_tags:\n        if match_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif match_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    return MultipleSeqAlignment(records, annotations=annotations)",
            "def build_hsp():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if not query_tags and (not match_tags):\n        raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n    assert query_tags, query_tags\n    assert match_tags, match_tags\n    evalue = align_tags.get('fa_expect')\n    tool = global_tags.get('tool', '').upper()\n    q = _extract_alignment_region(query_seq, query_tags)\n    if tool in ['TFASTX'] and len(match_seq) == len(q):\n        m = match_seq\n    else:\n        m = _extract_alignment_region(match_seq, match_tags)\n    if len(q) != len(m):\n        raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n    annotations = {}\n    records = []\n    annotations.update(header_tags)\n    annotations.update(align_tags)\n    record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n    record._al_start = int(query_tags['al_start'])\n    record._al_stop = int(query_tags['al_stop'])\n    if 'sq_type' in query_tags:\n        if query_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif query_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n    record._al_start = int(match_tags['al_start'])\n    record._al_stop = int(match_tags['al_stop'])\n    if 'sq_type' in match_tags:\n        if match_tags['sq_type'] == 'D':\n            record.annotations['molecule_type'] = 'DNA'\n        elif match_tags['sq_type'] == 'p':\n            record.annotations['molecule_type'] = 'protein'\n    records.append(record)\n    return MultipleSeqAlignment(records, annotations=annotations)"
        ]
    },
    {
        "func_name": "FastaM10Iterator",
        "original": "def FastaM10Iterator(handle, seq_count=None):\n    \"\"\"Alignment iterator for the FASTA tool's pairwise alignment output.\n\n    This is for reading the pairwise alignments output by Bill Pearson's\n    FASTA program when called with the -m 10 command line option for machine\n    readable output.  For more details about the FASTA tools, see the website\n    http://fasta.bioch.virginia.edu/ and the paper:\n\n         W.R. Pearson & D.J. Lipman PNAS (1988) 85:2444-2448\n\n    This class is intended to be used via the Bio.AlignIO.parse() function\n    by specifying the format as \"fasta-m10\" as shown in the following code::\n\n        from Bio import AlignIO\n        handle = ...\n        for a in AlignIO.parse(handle, \"fasta-m10\"):\n            assert len(a) == 2, \"Should be pairwise!\"\n            print(\"Alignment length %i\" % a.get_alignment_length())\n            for record in a:\n                print(\"%s %s %s\" % (record.seq, record.name, record.id))\n\n    Note that this is not a full blown parser for all the information\n    in the FASTA output - for example, most of the header and all of the\n    footer is ignored.  Also, the alignments are not batched according to\n    the input queries.\n\n    Also note that there can be up to about 30 letters of flanking region\n    included in the raw FASTA output as contextual information.  This is NOT\n    part of the alignment itself, and is not included in the resulting\n    MultipleSeqAlignment objects returned.\n    \"\"\"\n    state_PREAMBLE = -1\n    state_NONE = 0\n    state_QUERY_HEADER = 1\n    state_ALIGN_HEADER = 2\n    state_ALIGN_QUERY = 3\n    state_ALIGN_MATCH = 4\n    state_ALIGN_CONS = 5\n\n    def build_hsp():\n        if not query_tags and (not match_tags):\n            raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n        assert query_tags, query_tags\n        assert match_tags, match_tags\n        evalue = align_tags.get('fa_expect')\n        tool = global_tags.get('tool', '').upper()\n        q = _extract_alignment_region(query_seq, query_tags)\n        if tool in ['TFASTX'] and len(match_seq) == len(q):\n            m = match_seq\n        else:\n            m = _extract_alignment_region(match_seq, match_tags)\n        if len(q) != len(m):\n            raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n        annotations = {}\n        records = []\n        annotations.update(header_tags)\n        annotations.update(align_tags)\n        record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n        record._al_start = int(query_tags['al_start'])\n        record._al_stop = int(query_tags['al_stop'])\n        if 'sq_type' in query_tags:\n            if query_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif query_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n        record._al_start = int(match_tags['al_start'])\n        record._al_stop = int(match_tags['al_stop'])\n        if 'sq_type' in match_tags:\n            if match_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif match_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        return MultipleSeqAlignment(records, annotations=annotations)\n    state = state_PREAMBLE\n    query_id = None\n    match_id = None\n    query_descr = ''\n    match_descr = ''\n    global_tags = {}\n    header_tags = {}\n    align_tags = {}\n    query_tags = {}\n    match_tags = {}\n    query_seq = ''\n    match_seq = ''\n    cons_seq = ''\n    for line in handle:\n        if '>>>' in line and (not line.startswith('>>>')):\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_descr = line[line.find('>>>') + 3:].strip()\n            query_id = query_descr.split(None, 1)[0]\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('!! No '):\n            assert state == state_NONE\n            assert not header_tags\n            assert not align_tags\n            assert not match_tags\n            assert not query_tags\n            assert match_id is None\n            assert not query_seq\n            assert not match_seq\n            assert not cons_seq\n            query_id = None\n        elif line.strip() in ['>>><<<', '>>>///']:\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_id = None\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('>>>'):\n            assert query_id is not None\n            assert line[3:].split(', ', 1)[0] == query_id, line\n            assert match_id is None\n            assert not header_tags\n            assert not align_tags\n            assert not query_tags\n            assert not match_tags\n            assert not match_seq\n            assert not query_seq\n            assert not cons_seq\n            state = state_QUERY_HEADER\n        elif line.startswith('>>'):\n            if query_id and match_id:\n                yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            match_descr = line[2:].strip()\n            match_id = match_descr.split(None, 1)[0]\n            state = state_ALIGN_HEADER\n        elif line.startswith('>--'):\n            assert query_id and match_id, line\n            yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            state = state_ALIGN_HEADER\n        elif line.startswith('>'):\n            if state == state_ALIGN_HEADER:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert query_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_QUERY\n            elif state == state_ALIGN_QUERY:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert match_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_MATCH\n            elif state == state_NONE:\n                pass\n            else:\n                raise RuntimeError('state %i got %r' % (state, line))\n        elif line.startswith('; al_cons'):\n            assert state == state_ALIGN_MATCH, line\n            state = state_ALIGN_CONS\n        elif line.startswith('; '):\n            if ': ' in line:\n                (key, value) = (s.strip() for s in line[2:].split(': ', 1))\n            else:\n                import warnings\n                from Bio import BiopythonParserWarning\n                warnings.warn(f'Missing colon in line: {line!r}', BiopythonParserWarning)\n                try:\n                    (key, value) = (s.strip() for s in line[2:].split(' ', 1))\n                except ValueError:\n                    raise ValueError(f'Bad line: {line!r}') from None\n            if state == state_QUERY_HEADER:\n                header_tags[key] = value\n            elif state == state_ALIGN_HEADER:\n                align_tags[key] = value\n            elif state == state_ALIGN_QUERY:\n                query_tags[key] = value\n            elif state == state_ALIGN_MATCH:\n                match_tags[key] = value\n            else:\n                raise RuntimeError(f'Unexpected state {state!r}, {line!r}')\n        elif state == state_ALIGN_QUERY:\n            query_seq += line.strip()\n        elif state == state_ALIGN_MATCH:\n            match_seq += line.strip()\n        elif state == state_ALIGN_CONS:\n            cons_seq += line.strip('\\n')\n        elif state == state_PREAMBLE:\n            if line.startswith('#'):\n                global_tags['command'] = line[1:].strip()\n            elif line.startswith(' version '):\n                global_tags['version'] = line[9:].strip()\n            elif ' compares a ' in line:\n                global_tags['tool'] = line[:line.find(' compares a ')].strip()\n            elif ' searches a ' in line:\n                global_tags['tool'] = line[:line.find(' searches a ')].strip()\n        else:\n            pass",
        "mutated": [
            "def FastaM10Iterator(handle, seq_count=None):\n    if False:\n        i = 10\n    'Alignment iterator for the FASTA tool\\'s pairwise alignment output.\\n\\n    This is for reading the pairwise alignments output by Bill Pearson\\'s\\n    FASTA program when called with the -m 10 command line option for machine\\n    readable output.  For more details about the FASTA tools, see the website\\n    http://fasta.bioch.virginia.edu/ and the paper:\\n\\n         W.R. Pearson & D.J. Lipman PNAS (1988) 85:2444-2448\\n\\n    This class is intended to be used via the Bio.AlignIO.parse() function\\n    by specifying the format as \"fasta-m10\" as shown in the following code::\\n\\n        from Bio import AlignIO\\n        handle = ...\\n        for a in AlignIO.parse(handle, \"fasta-m10\"):\\n            assert len(a) == 2, \"Should be pairwise!\"\\n            print(\"Alignment length %i\" % a.get_alignment_length())\\n            for record in a:\\n                print(\"%s %s %s\" % (record.seq, record.name, record.id))\\n\\n    Note that this is not a full blown parser for all the information\\n    in the FASTA output - for example, most of the header and all of the\\n    footer is ignored.  Also, the alignments are not batched according to\\n    the input queries.\\n\\n    Also note that there can be up to about 30 letters of flanking region\\n    included in the raw FASTA output as contextual information.  This is NOT\\n    part of the alignment itself, and is not included in the resulting\\n    MultipleSeqAlignment objects returned.\\n    '\n    state_PREAMBLE = -1\n    state_NONE = 0\n    state_QUERY_HEADER = 1\n    state_ALIGN_HEADER = 2\n    state_ALIGN_QUERY = 3\n    state_ALIGN_MATCH = 4\n    state_ALIGN_CONS = 5\n\n    def build_hsp():\n        if not query_tags and (not match_tags):\n            raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n        assert query_tags, query_tags\n        assert match_tags, match_tags\n        evalue = align_tags.get('fa_expect')\n        tool = global_tags.get('tool', '').upper()\n        q = _extract_alignment_region(query_seq, query_tags)\n        if tool in ['TFASTX'] and len(match_seq) == len(q):\n            m = match_seq\n        else:\n            m = _extract_alignment_region(match_seq, match_tags)\n        if len(q) != len(m):\n            raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n        annotations = {}\n        records = []\n        annotations.update(header_tags)\n        annotations.update(align_tags)\n        record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n        record._al_start = int(query_tags['al_start'])\n        record._al_stop = int(query_tags['al_stop'])\n        if 'sq_type' in query_tags:\n            if query_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif query_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n        record._al_start = int(match_tags['al_start'])\n        record._al_stop = int(match_tags['al_stop'])\n        if 'sq_type' in match_tags:\n            if match_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif match_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        return MultipleSeqAlignment(records, annotations=annotations)\n    state = state_PREAMBLE\n    query_id = None\n    match_id = None\n    query_descr = ''\n    match_descr = ''\n    global_tags = {}\n    header_tags = {}\n    align_tags = {}\n    query_tags = {}\n    match_tags = {}\n    query_seq = ''\n    match_seq = ''\n    cons_seq = ''\n    for line in handle:\n        if '>>>' in line and (not line.startswith('>>>')):\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_descr = line[line.find('>>>') + 3:].strip()\n            query_id = query_descr.split(None, 1)[0]\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('!! No '):\n            assert state == state_NONE\n            assert not header_tags\n            assert not align_tags\n            assert not match_tags\n            assert not query_tags\n            assert match_id is None\n            assert not query_seq\n            assert not match_seq\n            assert not cons_seq\n            query_id = None\n        elif line.strip() in ['>>><<<', '>>>///']:\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_id = None\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('>>>'):\n            assert query_id is not None\n            assert line[3:].split(', ', 1)[0] == query_id, line\n            assert match_id is None\n            assert not header_tags\n            assert not align_tags\n            assert not query_tags\n            assert not match_tags\n            assert not match_seq\n            assert not query_seq\n            assert not cons_seq\n            state = state_QUERY_HEADER\n        elif line.startswith('>>'):\n            if query_id and match_id:\n                yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            match_descr = line[2:].strip()\n            match_id = match_descr.split(None, 1)[0]\n            state = state_ALIGN_HEADER\n        elif line.startswith('>--'):\n            assert query_id and match_id, line\n            yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            state = state_ALIGN_HEADER\n        elif line.startswith('>'):\n            if state == state_ALIGN_HEADER:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert query_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_QUERY\n            elif state == state_ALIGN_QUERY:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert match_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_MATCH\n            elif state == state_NONE:\n                pass\n            else:\n                raise RuntimeError('state %i got %r' % (state, line))\n        elif line.startswith('; al_cons'):\n            assert state == state_ALIGN_MATCH, line\n            state = state_ALIGN_CONS\n        elif line.startswith('; '):\n            if ': ' in line:\n                (key, value) = (s.strip() for s in line[2:].split(': ', 1))\n            else:\n                import warnings\n                from Bio import BiopythonParserWarning\n                warnings.warn(f'Missing colon in line: {line!r}', BiopythonParserWarning)\n                try:\n                    (key, value) = (s.strip() for s in line[2:].split(' ', 1))\n                except ValueError:\n                    raise ValueError(f'Bad line: {line!r}') from None\n            if state == state_QUERY_HEADER:\n                header_tags[key] = value\n            elif state == state_ALIGN_HEADER:\n                align_tags[key] = value\n            elif state == state_ALIGN_QUERY:\n                query_tags[key] = value\n            elif state == state_ALIGN_MATCH:\n                match_tags[key] = value\n            else:\n                raise RuntimeError(f'Unexpected state {state!r}, {line!r}')\n        elif state == state_ALIGN_QUERY:\n            query_seq += line.strip()\n        elif state == state_ALIGN_MATCH:\n            match_seq += line.strip()\n        elif state == state_ALIGN_CONS:\n            cons_seq += line.strip('\\n')\n        elif state == state_PREAMBLE:\n            if line.startswith('#'):\n                global_tags['command'] = line[1:].strip()\n            elif line.startswith(' version '):\n                global_tags['version'] = line[9:].strip()\n            elif ' compares a ' in line:\n                global_tags['tool'] = line[:line.find(' compares a ')].strip()\n            elif ' searches a ' in line:\n                global_tags['tool'] = line[:line.find(' searches a ')].strip()\n        else:\n            pass",
            "def FastaM10Iterator(handle, seq_count=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Alignment iterator for the FASTA tool\\'s pairwise alignment output.\\n\\n    This is for reading the pairwise alignments output by Bill Pearson\\'s\\n    FASTA program when called with the -m 10 command line option for machine\\n    readable output.  For more details about the FASTA tools, see the website\\n    http://fasta.bioch.virginia.edu/ and the paper:\\n\\n         W.R. Pearson & D.J. Lipman PNAS (1988) 85:2444-2448\\n\\n    This class is intended to be used via the Bio.AlignIO.parse() function\\n    by specifying the format as \"fasta-m10\" as shown in the following code::\\n\\n        from Bio import AlignIO\\n        handle = ...\\n        for a in AlignIO.parse(handle, \"fasta-m10\"):\\n            assert len(a) == 2, \"Should be pairwise!\"\\n            print(\"Alignment length %i\" % a.get_alignment_length())\\n            for record in a:\\n                print(\"%s %s %s\" % (record.seq, record.name, record.id))\\n\\n    Note that this is not a full blown parser for all the information\\n    in the FASTA output - for example, most of the header and all of the\\n    footer is ignored.  Also, the alignments are not batched according to\\n    the input queries.\\n\\n    Also note that there can be up to about 30 letters of flanking region\\n    included in the raw FASTA output as contextual information.  This is NOT\\n    part of the alignment itself, and is not included in the resulting\\n    MultipleSeqAlignment objects returned.\\n    '\n    state_PREAMBLE = -1\n    state_NONE = 0\n    state_QUERY_HEADER = 1\n    state_ALIGN_HEADER = 2\n    state_ALIGN_QUERY = 3\n    state_ALIGN_MATCH = 4\n    state_ALIGN_CONS = 5\n\n    def build_hsp():\n        if not query_tags and (not match_tags):\n            raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n        assert query_tags, query_tags\n        assert match_tags, match_tags\n        evalue = align_tags.get('fa_expect')\n        tool = global_tags.get('tool', '').upper()\n        q = _extract_alignment_region(query_seq, query_tags)\n        if tool in ['TFASTX'] and len(match_seq) == len(q):\n            m = match_seq\n        else:\n            m = _extract_alignment_region(match_seq, match_tags)\n        if len(q) != len(m):\n            raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n        annotations = {}\n        records = []\n        annotations.update(header_tags)\n        annotations.update(align_tags)\n        record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n        record._al_start = int(query_tags['al_start'])\n        record._al_stop = int(query_tags['al_stop'])\n        if 'sq_type' in query_tags:\n            if query_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif query_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n        record._al_start = int(match_tags['al_start'])\n        record._al_stop = int(match_tags['al_stop'])\n        if 'sq_type' in match_tags:\n            if match_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif match_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        return MultipleSeqAlignment(records, annotations=annotations)\n    state = state_PREAMBLE\n    query_id = None\n    match_id = None\n    query_descr = ''\n    match_descr = ''\n    global_tags = {}\n    header_tags = {}\n    align_tags = {}\n    query_tags = {}\n    match_tags = {}\n    query_seq = ''\n    match_seq = ''\n    cons_seq = ''\n    for line in handle:\n        if '>>>' in line and (not line.startswith('>>>')):\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_descr = line[line.find('>>>') + 3:].strip()\n            query_id = query_descr.split(None, 1)[0]\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('!! No '):\n            assert state == state_NONE\n            assert not header_tags\n            assert not align_tags\n            assert not match_tags\n            assert not query_tags\n            assert match_id is None\n            assert not query_seq\n            assert not match_seq\n            assert not cons_seq\n            query_id = None\n        elif line.strip() in ['>>><<<', '>>>///']:\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_id = None\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('>>>'):\n            assert query_id is not None\n            assert line[3:].split(', ', 1)[0] == query_id, line\n            assert match_id is None\n            assert not header_tags\n            assert not align_tags\n            assert not query_tags\n            assert not match_tags\n            assert not match_seq\n            assert not query_seq\n            assert not cons_seq\n            state = state_QUERY_HEADER\n        elif line.startswith('>>'):\n            if query_id and match_id:\n                yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            match_descr = line[2:].strip()\n            match_id = match_descr.split(None, 1)[0]\n            state = state_ALIGN_HEADER\n        elif line.startswith('>--'):\n            assert query_id and match_id, line\n            yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            state = state_ALIGN_HEADER\n        elif line.startswith('>'):\n            if state == state_ALIGN_HEADER:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert query_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_QUERY\n            elif state == state_ALIGN_QUERY:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert match_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_MATCH\n            elif state == state_NONE:\n                pass\n            else:\n                raise RuntimeError('state %i got %r' % (state, line))\n        elif line.startswith('; al_cons'):\n            assert state == state_ALIGN_MATCH, line\n            state = state_ALIGN_CONS\n        elif line.startswith('; '):\n            if ': ' in line:\n                (key, value) = (s.strip() for s in line[2:].split(': ', 1))\n            else:\n                import warnings\n                from Bio import BiopythonParserWarning\n                warnings.warn(f'Missing colon in line: {line!r}', BiopythonParserWarning)\n                try:\n                    (key, value) = (s.strip() for s in line[2:].split(' ', 1))\n                except ValueError:\n                    raise ValueError(f'Bad line: {line!r}') from None\n            if state == state_QUERY_HEADER:\n                header_tags[key] = value\n            elif state == state_ALIGN_HEADER:\n                align_tags[key] = value\n            elif state == state_ALIGN_QUERY:\n                query_tags[key] = value\n            elif state == state_ALIGN_MATCH:\n                match_tags[key] = value\n            else:\n                raise RuntimeError(f'Unexpected state {state!r}, {line!r}')\n        elif state == state_ALIGN_QUERY:\n            query_seq += line.strip()\n        elif state == state_ALIGN_MATCH:\n            match_seq += line.strip()\n        elif state == state_ALIGN_CONS:\n            cons_seq += line.strip('\\n')\n        elif state == state_PREAMBLE:\n            if line.startswith('#'):\n                global_tags['command'] = line[1:].strip()\n            elif line.startswith(' version '):\n                global_tags['version'] = line[9:].strip()\n            elif ' compares a ' in line:\n                global_tags['tool'] = line[:line.find(' compares a ')].strip()\n            elif ' searches a ' in line:\n                global_tags['tool'] = line[:line.find(' searches a ')].strip()\n        else:\n            pass",
            "def FastaM10Iterator(handle, seq_count=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Alignment iterator for the FASTA tool\\'s pairwise alignment output.\\n\\n    This is for reading the pairwise alignments output by Bill Pearson\\'s\\n    FASTA program when called with the -m 10 command line option for machine\\n    readable output.  For more details about the FASTA tools, see the website\\n    http://fasta.bioch.virginia.edu/ and the paper:\\n\\n         W.R. Pearson & D.J. Lipman PNAS (1988) 85:2444-2448\\n\\n    This class is intended to be used via the Bio.AlignIO.parse() function\\n    by specifying the format as \"fasta-m10\" as shown in the following code::\\n\\n        from Bio import AlignIO\\n        handle = ...\\n        for a in AlignIO.parse(handle, \"fasta-m10\"):\\n            assert len(a) == 2, \"Should be pairwise!\"\\n            print(\"Alignment length %i\" % a.get_alignment_length())\\n            for record in a:\\n                print(\"%s %s %s\" % (record.seq, record.name, record.id))\\n\\n    Note that this is not a full blown parser for all the information\\n    in the FASTA output - for example, most of the header and all of the\\n    footer is ignored.  Also, the alignments are not batched according to\\n    the input queries.\\n\\n    Also note that there can be up to about 30 letters of flanking region\\n    included in the raw FASTA output as contextual information.  This is NOT\\n    part of the alignment itself, and is not included in the resulting\\n    MultipleSeqAlignment objects returned.\\n    '\n    state_PREAMBLE = -1\n    state_NONE = 0\n    state_QUERY_HEADER = 1\n    state_ALIGN_HEADER = 2\n    state_ALIGN_QUERY = 3\n    state_ALIGN_MATCH = 4\n    state_ALIGN_CONS = 5\n\n    def build_hsp():\n        if not query_tags and (not match_tags):\n            raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n        assert query_tags, query_tags\n        assert match_tags, match_tags\n        evalue = align_tags.get('fa_expect')\n        tool = global_tags.get('tool', '').upper()\n        q = _extract_alignment_region(query_seq, query_tags)\n        if tool in ['TFASTX'] and len(match_seq) == len(q):\n            m = match_seq\n        else:\n            m = _extract_alignment_region(match_seq, match_tags)\n        if len(q) != len(m):\n            raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n        annotations = {}\n        records = []\n        annotations.update(header_tags)\n        annotations.update(align_tags)\n        record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n        record._al_start = int(query_tags['al_start'])\n        record._al_stop = int(query_tags['al_stop'])\n        if 'sq_type' in query_tags:\n            if query_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif query_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n        record._al_start = int(match_tags['al_start'])\n        record._al_stop = int(match_tags['al_stop'])\n        if 'sq_type' in match_tags:\n            if match_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif match_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        return MultipleSeqAlignment(records, annotations=annotations)\n    state = state_PREAMBLE\n    query_id = None\n    match_id = None\n    query_descr = ''\n    match_descr = ''\n    global_tags = {}\n    header_tags = {}\n    align_tags = {}\n    query_tags = {}\n    match_tags = {}\n    query_seq = ''\n    match_seq = ''\n    cons_seq = ''\n    for line in handle:\n        if '>>>' in line and (not line.startswith('>>>')):\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_descr = line[line.find('>>>') + 3:].strip()\n            query_id = query_descr.split(None, 1)[0]\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('!! No '):\n            assert state == state_NONE\n            assert not header_tags\n            assert not align_tags\n            assert not match_tags\n            assert not query_tags\n            assert match_id is None\n            assert not query_seq\n            assert not match_seq\n            assert not cons_seq\n            query_id = None\n        elif line.strip() in ['>>><<<', '>>>///']:\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_id = None\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('>>>'):\n            assert query_id is not None\n            assert line[3:].split(', ', 1)[0] == query_id, line\n            assert match_id is None\n            assert not header_tags\n            assert not align_tags\n            assert not query_tags\n            assert not match_tags\n            assert not match_seq\n            assert not query_seq\n            assert not cons_seq\n            state = state_QUERY_HEADER\n        elif line.startswith('>>'):\n            if query_id and match_id:\n                yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            match_descr = line[2:].strip()\n            match_id = match_descr.split(None, 1)[0]\n            state = state_ALIGN_HEADER\n        elif line.startswith('>--'):\n            assert query_id and match_id, line\n            yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            state = state_ALIGN_HEADER\n        elif line.startswith('>'):\n            if state == state_ALIGN_HEADER:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert query_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_QUERY\n            elif state == state_ALIGN_QUERY:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert match_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_MATCH\n            elif state == state_NONE:\n                pass\n            else:\n                raise RuntimeError('state %i got %r' % (state, line))\n        elif line.startswith('; al_cons'):\n            assert state == state_ALIGN_MATCH, line\n            state = state_ALIGN_CONS\n        elif line.startswith('; '):\n            if ': ' in line:\n                (key, value) = (s.strip() for s in line[2:].split(': ', 1))\n            else:\n                import warnings\n                from Bio import BiopythonParserWarning\n                warnings.warn(f'Missing colon in line: {line!r}', BiopythonParserWarning)\n                try:\n                    (key, value) = (s.strip() for s in line[2:].split(' ', 1))\n                except ValueError:\n                    raise ValueError(f'Bad line: {line!r}') from None\n            if state == state_QUERY_HEADER:\n                header_tags[key] = value\n            elif state == state_ALIGN_HEADER:\n                align_tags[key] = value\n            elif state == state_ALIGN_QUERY:\n                query_tags[key] = value\n            elif state == state_ALIGN_MATCH:\n                match_tags[key] = value\n            else:\n                raise RuntimeError(f'Unexpected state {state!r}, {line!r}')\n        elif state == state_ALIGN_QUERY:\n            query_seq += line.strip()\n        elif state == state_ALIGN_MATCH:\n            match_seq += line.strip()\n        elif state == state_ALIGN_CONS:\n            cons_seq += line.strip('\\n')\n        elif state == state_PREAMBLE:\n            if line.startswith('#'):\n                global_tags['command'] = line[1:].strip()\n            elif line.startswith(' version '):\n                global_tags['version'] = line[9:].strip()\n            elif ' compares a ' in line:\n                global_tags['tool'] = line[:line.find(' compares a ')].strip()\n            elif ' searches a ' in line:\n                global_tags['tool'] = line[:line.find(' searches a ')].strip()\n        else:\n            pass",
            "def FastaM10Iterator(handle, seq_count=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Alignment iterator for the FASTA tool\\'s pairwise alignment output.\\n\\n    This is for reading the pairwise alignments output by Bill Pearson\\'s\\n    FASTA program when called with the -m 10 command line option for machine\\n    readable output.  For more details about the FASTA tools, see the website\\n    http://fasta.bioch.virginia.edu/ and the paper:\\n\\n         W.R. Pearson & D.J. Lipman PNAS (1988) 85:2444-2448\\n\\n    This class is intended to be used via the Bio.AlignIO.parse() function\\n    by specifying the format as \"fasta-m10\" as shown in the following code::\\n\\n        from Bio import AlignIO\\n        handle = ...\\n        for a in AlignIO.parse(handle, \"fasta-m10\"):\\n            assert len(a) == 2, \"Should be pairwise!\"\\n            print(\"Alignment length %i\" % a.get_alignment_length())\\n            for record in a:\\n                print(\"%s %s %s\" % (record.seq, record.name, record.id))\\n\\n    Note that this is not a full blown parser for all the information\\n    in the FASTA output - for example, most of the header and all of the\\n    footer is ignored.  Also, the alignments are not batched according to\\n    the input queries.\\n\\n    Also note that there can be up to about 30 letters of flanking region\\n    included in the raw FASTA output as contextual information.  This is NOT\\n    part of the alignment itself, and is not included in the resulting\\n    MultipleSeqAlignment objects returned.\\n    '\n    state_PREAMBLE = -1\n    state_NONE = 0\n    state_QUERY_HEADER = 1\n    state_ALIGN_HEADER = 2\n    state_ALIGN_QUERY = 3\n    state_ALIGN_MATCH = 4\n    state_ALIGN_CONS = 5\n\n    def build_hsp():\n        if not query_tags and (not match_tags):\n            raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n        assert query_tags, query_tags\n        assert match_tags, match_tags\n        evalue = align_tags.get('fa_expect')\n        tool = global_tags.get('tool', '').upper()\n        q = _extract_alignment_region(query_seq, query_tags)\n        if tool in ['TFASTX'] and len(match_seq) == len(q):\n            m = match_seq\n        else:\n            m = _extract_alignment_region(match_seq, match_tags)\n        if len(q) != len(m):\n            raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n        annotations = {}\n        records = []\n        annotations.update(header_tags)\n        annotations.update(align_tags)\n        record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n        record._al_start = int(query_tags['al_start'])\n        record._al_stop = int(query_tags['al_stop'])\n        if 'sq_type' in query_tags:\n            if query_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif query_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n        record._al_start = int(match_tags['al_start'])\n        record._al_stop = int(match_tags['al_stop'])\n        if 'sq_type' in match_tags:\n            if match_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif match_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        return MultipleSeqAlignment(records, annotations=annotations)\n    state = state_PREAMBLE\n    query_id = None\n    match_id = None\n    query_descr = ''\n    match_descr = ''\n    global_tags = {}\n    header_tags = {}\n    align_tags = {}\n    query_tags = {}\n    match_tags = {}\n    query_seq = ''\n    match_seq = ''\n    cons_seq = ''\n    for line in handle:\n        if '>>>' in line and (not line.startswith('>>>')):\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_descr = line[line.find('>>>') + 3:].strip()\n            query_id = query_descr.split(None, 1)[0]\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('!! No '):\n            assert state == state_NONE\n            assert not header_tags\n            assert not align_tags\n            assert not match_tags\n            assert not query_tags\n            assert match_id is None\n            assert not query_seq\n            assert not match_seq\n            assert not cons_seq\n            query_id = None\n        elif line.strip() in ['>>><<<', '>>>///']:\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_id = None\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('>>>'):\n            assert query_id is not None\n            assert line[3:].split(', ', 1)[0] == query_id, line\n            assert match_id is None\n            assert not header_tags\n            assert not align_tags\n            assert not query_tags\n            assert not match_tags\n            assert not match_seq\n            assert not query_seq\n            assert not cons_seq\n            state = state_QUERY_HEADER\n        elif line.startswith('>>'):\n            if query_id and match_id:\n                yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            match_descr = line[2:].strip()\n            match_id = match_descr.split(None, 1)[0]\n            state = state_ALIGN_HEADER\n        elif line.startswith('>--'):\n            assert query_id and match_id, line\n            yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            state = state_ALIGN_HEADER\n        elif line.startswith('>'):\n            if state == state_ALIGN_HEADER:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert query_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_QUERY\n            elif state == state_ALIGN_QUERY:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert match_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_MATCH\n            elif state == state_NONE:\n                pass\n            else:\n                raise RuntimeError('state %i got %r' % (state, line))\n        elif line.startswith('; al_cons'):\n            assert state == state_ALIGN_MATCH, line\n            state = state_ALIGN_CONS\n        elif line.startswith('; '):\n            if ': ' in line:\n                (key, value) = (s.strip() for s in line[2:].split(': ', 1))\n            else:\n                import warnings\n                from Bio import BiopythonParserWarning\n                warnings.warn(f'Missing colon in line: {line!r}', BiopythonParserWarning)\n                try:\n                    (key, value) = (s.strip() for s in line[2:].split(' ', 1))\n                except ValueError:\n                    raise ValueError(f'Bad line: {line!r}') from None\n            if state == state_QUERY_HEADER:\n                header_tags[key] = value\n            elif state == state_ALIGN_HEADER:\n                align_tags[key] = value\n            elif state == state_ALIGN_QUERY:\n                query_tags[key] = value\n            elif state == state_ALIGN_MATCH:\n                match_tags[key] = value\n            else:\n                raise RuntimeError(f'Unexpected state {state!r}, {line!r}')\n        elif state == state_ALIGN_QUERY:\n            query_seq += line.strip()\n        elif state == state_ALIGN_MATCH:\n            match_seq += line.strip()\n        elif state == state_ALIGN_CONS:\n            cons_seq += line.strip('\\n')\n        elif state == state_PREAMBLE:\n            if line.startswith('#'):\n                global_tags['command'] = line[1:].strip()\n            elif line.startswith(' version '):\n                global_tags['version'] = line[9:].strip()\n            elif ' compares a ' in line:\n                global_tags['tool'] = line[:line.find(' compares a ')].strip()\n            elif ' searches a ' in line:\n                global_tags['tool'] = line[:line.find(' searches a ')].strip()\n        else:\n            pass",
            "def FastaM10Iterator(handle, seq_count=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Alignment iterator for the FASTA tool\\'s pairwise alignment output.\\n\\n    This is for reading the pairwise alignments output by Bill Pearson\\'s\\n    FASTA program when called with the -m 10 command line option for machine\\n    readable output.  For more details about the FASTA tools, see the website\\n    http://fasta.bioch.virginia.edu/ and the paper:\\n\\n         W.R. Pearson & D.J. Lipman PNAS (1988) 85:2444-2448\\n\\n    This class is intended to be used via the Bio.AlignIO.parse() function\\n    by specifying the format as \"fasta-m10\" as shown in the following code::\\n\\n        from Bio import AlignIO\\n        handle = ...\\n        for a in AlignIO.parse(handle, \"fasta-m10\"):\\n            assert len(a) == 2, \"Should be pairwise!\"\\n            print(\"Alignment length %i\" % a.get_alignment_length())\\n            for record in a:\\n                print(\"%s %s %s\" % (record.seq, record.name, record.id))\\n\\n    Note that this is not a full blown parser for all the information\\n    in the FASTA output - for example, most of the header and all of the\\n    footer is ignored.  Also, the alignments are not batched according to\\n    the input queries.\\n\\n    Also note that there can be up to about 30 letters of flanking region\\n    included in the raw FASTA output as contextual information.  This is NOT\\n    part of the alignment itself, and is not included in the resulting\\n    MultipleSeqAlignment objects returned.\\n    '\n    state_PREAMBLE = -1\n    state_NONE = 0\n    state_QUERY_HEADER = 1\n    state_ALIGN_HEADER = 2\n    state_ALIGN_QUERY = 3\n    state_ALIGN_MATCH = 4\n    state_ALIGN_CONS = 5\n\n    def build_hsp():\n        if not query_tags and (not match_tags):\n            raise ValueError(f'No data for query {query_id!r}, match {match_id!r}')\n        assert query_tags, query_tags\n        assert match_tags, match_tags\n        evalue = align_tags.get('fa_expect')\n        tool = global_tags.get('tool', '').upper()\n        q = _extract_alignment_region(query_seq, query_tags)\n        if tool in ['TFASTX'] and len(match_seq) == len(q):\n            m = match_seq\n        else:\n            m = _extract_alignment_region(match_seq, match_tags)\n        if len(q) != len(m):\n            raise ValueError(f'Darn... amino acids vs nucleotide coordinates?\\ntool: {tool}\\nquery_seq: {query_seq}\\nquery_tags: {query_tags}\\n{q} length: {len(q)}\\nmatch_seq: {match_seq}\\nmatch_tags: {match_tags}\\n{m} length: {len(m)}\\nhandle.name: {handle.name}\\n')\n        annotations = {}\n        records = []\n        annotations.update(header_tags)\n        annotations.update(align_tags)\n        record = SeqRecord(Seq(q), id=query_id, name='query', description=query_descr, annotations={'original_length': int(query_tags['sq_len'])})\n        record._al_start = int(query_tags['al_start'])\n        record._al_stop = int(query_tags['al_stop'])\n        if 'sq_type' in query_tags:\n            if query_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif query_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        record = SeqRecord(Seq(m), id=match_id, name='match', description=match_descr, annotations={'original_length': int(match_tags['sq_len'])})\n        record._al_start = int(match_tags['al_start'])\n        record._al_stop = int(match_tags['al_stop'])\n        if 'sq_type' in match_tags:\n            if match_tags['sq_type'] == 'D':\n                record.annotations['molecule_type'] = 'DNA'\n            elif match_tags['sq_type'] == 'p':\n                record.annotations['molecule_type'] = 'protein'\n        records.append(record)\n        return MultipleSeqAlignment(records, annotations=annotations)\n    state = state_PREAMBLE\n    query_id = None\n    match_id = None\n    query_descr = ''\n    match_descr = ''\n    global_tags = {}\n    header_tags = {}\n    align_tags = {}\n    query_tags = {}\n    match_tags = {}\n    query_seq = ''\n    match_seq = ''\n    cons_seq = ''\n    for line in handle:\n        if '>>>' in line and (not line.startswith('>>>')):\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_descr = line[line.find('>>>') + 3:].strip()\n            query_id = query_descr.split(None, 1)[0]\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('!! No '):\n            assert state == state_NONE\n            assert not header_tags\n            assert not align_tags\n            assert not match_tags\n            assert not query_tags\n            assert match_id is None\n            assert not query_seq\n            assert not match_seq\n            assert not cons_seq\n            query_id = None\n        elif line.strip() in ['>>><<<', '>>>///']:\n            if query_id and match_id:\n                yield build_hsp()\n            state = state_NONE\n            query_id = None\n            match_id = None\n            header_tags = {}\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n        elif line.startswith('>>>'):\n            assert query_id is not None\n            assert line[3:].split(', ', 1)[0] == query_id, line\n            assert match_id is None\n            assert not header_tags\n            assert not align_tags\n            assert not query_tags\n            assert not match_tags\n            assert not match_seq\n            assert not query_seq\n            assert not cons_seq\n            state = state_QUERY_HEADER\n        elif line.startswith('>>'):\n            if query_id and match_id:\n                yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            match_descr = line[2:].strip()\n            match_id = match_descr.split(None, 1)[0]\n            state = state_ALIGN_HEADER\n        elif line.startswith('>--'):\n            assert query_id and match_id, line\n            yield build_hsp()\n            align_tags = {}\n            query_tags = {}\n            match_tags = {}\n            query_seq = ''\n            match_seq = ''\n            cons_seq = ''\n            state = state_ALIGN_HEADER\n        elif line.startswith('>'):\n            if state == state_ALIGN_HEADER:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert query_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_QUERY\n            elif state == state_ALIGN_QUERY:\n                assert query_id is not None, line\n                assert match_id is not None, line\n                assert match_id.startswith(line[1:].split(None, 1)[0]), line\n                state = state_ALIGN_MATCH\n            elif state == state_NONE:\n                pass\n            else:\n                raise RuntimeError('state %i got %r' % (state, line))\n        elif line.startswith('; al_cons'):\n            assert state == state_ALIGN_MATCH, line\n            state = state_ALIGN_CONS\n        elif line.startswith('; '):\n            if ': ' in line:\n                (key, value) = (s.strip() for s in line[2:].split(': ', 1))\n            else:\n                import warnings\n                from Bio import BiopythonParserWarning\n                warnings.warn(f'Missing colon in line: {line!r}', BiopythonParserWarning)\n                try:\n                    (key, value) = (s.strip() for s in line[2:].split(' ', 1))\n                except ValueError:\n                    raise ValueError(f'Bad line: {line!r}') from None\n            if state == state_QUERY_HEADER:\n                header_tags[key] = value\n            elif state == state_ALIGN_HEADER:\n                align_tags[key] = value\n            elif state == state_ALIGN_QUERY:\n                query_tags[key] = value\n            elif state == state_ALIGN_MATCH:\n                match_tags[key] = value\n            else:\n                raise RuntimeError(f'Unexpected state {state!r}, {line!r}')\n        elif state == state_ALIGN_QUERY:\n            query_seq += line.strip()\n        elif state == state_ALIGN_MATCH:\n            match_seq += line.strip()\n        elif state == state_ALIGN_CONS:\n            cons_seq += line.strip('\\n')\n        elif state == state_PREAMBLE:\n            if line.startswith('#'):\n                global_tags['command'] = line[1:].strip()\n            elif line.startswith(' version '):\n                global_tags['version'] = line[9:].strip()\n            elif ' compares a ' in line:\n                global_tags['tool'] = line[:line.find(' compares a ')].strip()\n            elif ' searches a ' in line:\n                global_tags['tool'] = line[:line.find(' searches a ')].strip()\n        else:\n            pass"
        ]
    }
]