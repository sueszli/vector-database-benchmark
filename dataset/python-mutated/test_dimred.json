[
    {
        "func_name": "test_poisson",
        "original": "def test_poisson():\n    np.random.seed(43242)\n    xmat = np.random.normal(size=(500, 5))\n    xmat[:, 1] = 0.5 * xmat[:, 0] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 1]\n    xmat[:, 3] = 0.5 * xmat[:, 2] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 3]\n    b = np.r_[0, 1, -1, 0, 0.5]\n    lpr = np.dot(xmat, b)\n    ev = np.exp(lpr)\n    y = np.random.poisson(ev)\n    for method in range(6):\n        if method == 0:\n            model = SlicedInverseReg(y, xmat)\n            rslt = model.fit()\n        elif method == 1:\n            model = SAVE(y, xmat)\n            rslt = model.fit(slice_n=100)\n        elif method == 2:\n            model = SAVE(y, xmat, bc=True)\n            rslt = model.fit(slice_n=100)\n        elif method == 3:\n            df = pd.DataFrame({'y': y, 'x0': xmat[:, 0], 'x1': xmat[:, 1], 'x2': xmat[:, 2], 'x3': xmat[:, 3], 'x4': xmat[:, 4]})\n            model = SlicedInverseReg.from_formula('y ~ 0 + x0 + x1 + x2 + x3 + x4', data=df)\n            rslt = model.fit()\n        elif method == 4:\n            model = PHD(y, xmat)\n            rslt = model.fit()\n        elif method == 5:\n            model = PHD(y, xmat)\n            rslt = model.fit(resid=True)\n        assert_equal(np.abs(rslt.eigs[0] / rslt.eigs[1]) > 5, True)\n        params = np.asarray(rslt.params)\n        q = np.dot(params[:, 0], b)\n        q /= np.sqrt(np.sum(params[:, 0] ** 2))\n        q /= np.sqrt(np.sum(b ** 2))\n        assert_equal(np.abs(q) > 0.95, True)",
        "mutated": [
            "def test_poisson():\n    if False:\n        i = 10\n    np.random.seed(43242)\n    xmat = np.random.normal(size=(500, 5))\n    xmat[:, 1] = 0.5 * xmat[:, 0] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 1]\n    xmat[:, 3] = 0.5 * xmat[:, 2] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 3]\n    b = np.r_[0, 1, -1, 0, 0.5]\n    lpr = np.dot(xmat, b)\n    ev = np.exp(lpr)\n    y = np.random.poisson(ev)\n    for method in range(6):\n        if method == 0:\n            model = SlicedInverseReg(y, xmat)\n            rslt = model.fit()\n        elif method == 1:\n            model = SAVE(y, xmat)\n            rslt = model.fit(slice_n=100)\n        elif method == 2:\n            model = SAVE(y, xmat, bc=True)\n            rslt = model.fit(slice_n=100)\n        elif method == 3:\n            df = pd.DataFrame({'y': y, 'x0': xmat[:, 0], 'x1': xmat[:, 1], 'x2': xmat[:, 2], 'x3': xmat[:, 3], 'x4': xmat[:, 4]})\n            model = SlicedInverseReg.from_formula('y ~ 0 + x0 + x1 + x2 + x3 + x4', data=df)\n            rslt = model.fit()\n        elif method == 4:\n            model = PHD(y, xmat)\n            rslt = model.fit()\n        elif method == 5:\n            model = PHD(y, xmat)\n            rslt = model.fit(resid=True)\n        assert_equal(np.abs(rslt.eigs[0] / rslt.eigs[1]) > 5, True)\n        params = np.asarray(rslt.params)\n        q = np.dot(params[:, 0], b)\n        q /= np.sqrt(np.sum(params[:, 0] ** 2))\n        q /= np.sqrt(np.sum(b ** 2))\n        assert_equal(np.abs(q) > 0.95, True)",
            "def test_poisson():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.seed(43242)\n    xmat = np.random.normal(size=(500, 5))\n    xmat[:, 1] = 0.5 * xmat[:, 0] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 1]\n    xmat[:, 3] = 0.5 * xmat[:, 2] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 3]\n    b = np.r_[0, 1, -1, 0, 0.5]\n    lpr = np.dot(xmat, b)\n    ev = np.exp(lpr)\n    y = np.random.poisson(ev)\n    for method in range(6):\n        if method == 0:\n            model = SlicedInverseReg(y, xmat)\n            rslt = model.fit()\n        elif method == 1:\n            model = SAVE(y, xmat)\n            rslt = model.fit(slice_n=100)\n        elif method == 2:\n            model = SAVE(y, xmat, bc=True)\n            rslt = model.fit(slice_n=100)\n        elif method == 3:\n            df = pd.DataFrame({'y': y, 'x0': xmat[:, 0], 'x1': xmat[:, 1], 'x2': xmat[:, 2], 'x3': xmat[:, 3], 'x4': xmat[:, 4]})\n            model = SlicedInverseReg.from_formula('y ~ 0 + x0 + x1 + x2 + x3 + x4', data=df)\n            rslt = model.fit()\n        elif method == 4:\n            model = PHD(y, xmat)\n            rslt = model.fit()\n        elif method == 5:\n            model = PHD(y, xmat)\n            rslt = model.fit(resid=True)\n        assert_equal(np.abs(rslt.eigs[0] / rslt.eigs[1]) > 5, True)\n        params = np.asarray(rslt.params)\n        q = np.dot(params[:, 0], b)\n        q /= np.sqrt(np.sum(params[:, 0] ** 2))\n        q /= np.sqrt(np.sum(b ** 2))\n        assert_equal(np.abs(q) > 0.95, True)",
            "def test_poisson():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.seed(43242)\n    xmat = np.random.normal(size=(500, 5))\n    xmat[:, 1] = 0.5 * xmat[:, 0] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 1]\n    xmat[:, 3] = 0.5 * xmat[:, 2] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 3]\n    b = np.r_[0, 1, -1, 0, 0.5]\n    lpr = np.dot(xmat, b)\n    ev = np.exp(lpr)\n    y = np.random.poisson(ev)\n    for method in range(6):\n        if method == 0:\n            model = SlicedInverseReg(y, xmat)\n            rslt = model.fit()\n        elif method == 1:\n            model = SAVE(y, xmat)\n            rslt = model.fit(slice_n=100)\n        elif method == 2:\n            model = SAVE(y, xmat, bc=True)\n            rslt = model.fit(slice_n=100)\n        elif method == 3:\n            df = pd.DataFrame({'y': y, 'x0': xmat[:, 0], 'x1': xmat[:, 1], 'x2': xmat[:, 2], 'x3': xmat[:, 3], 'x4': xmat[:, 4]})\n            model = SlicedInverseReg.from_formula('y ~ 0 + x0 + x1 + x2 + x3 + x4', data=df)\n            rslt = model.fit()\n        elif method == 4:\n            model = PHD(y, xmat)\n            rslt = model.fit()\n        elif method == 5:\n            model = PHD(y, xmat)\n            rslt = model.fit(resid=True)\n        assert_equal(np.abs(rslt.eigs[0] / rslt.eigs[1]) > 5, True)\n        params = np.asarray(rslt.params)\n        q = np.dot(params[:, 0], b)\n        q /= np.sqrt(np.sum(params[:, 0] ** 2))\n        q /= np.sqrt(np.sum(b ** 2))\n        assert_equal(np.abs(q) > 0.95, True)",
            "def test_poisson():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.seed(43242)\n    xmat = np.random.normal(size=(500, 5))\n    xmat[:, 1] = 0.5 * xmat[:, 0] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 1]\n    xmat[:, 3] = 0.5 * xmat[:, 2] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 3]\n    b = np.r_[0, 1, -1, 0, 0.5]\n    lpr = np.dot(xmat, b)\n    ev = np.exp(lpr)\n    y = np.random.poisson(ev)\n    for method in range(6):\n        if method == 0:\n            model = SlicedInverseReg(y, xmat)\n            rslt = model.fit()\n        elif method == 1:\n            model = SAVE(y, xmat)\n            rslt = model.fit(slice_n=100)\n        elif method == 2:\n            model = SAVE(y, xmat, bc=True)\n            rslt = model.fit(slice_n=100)\n        elif method == 3:\n            df = pd.DataFrame({'y': y, 'x0': xmat[:, 0], 'x1': xmat[:, 1], 'x2': xmat[:, 2], 'x3': xmat[:, 3], 'x4': xmat[:, 4]})\n            model = SlicedInverseReg.from_formula('y ~ 0 + x0 + x1 + x2 + x3 + x4', data=df)\n            rslt = model.fit()\n        elif method == 4:\n            model = PHD(y, xmat)\n            rslt = model.fit()\n        elif method == 5:\n            model = PHD(y, xmat)\n            rslt = model.fit(resid=True)\n        assert_equal(np.abs(rslt.eigs[0] / rslt.eigs[1]) > 5, True)\n        params = np.asarray(rslt.params)\n        q = np.dot(params[:, 0], b)\n        q /= np.sqrt(np.sum(params[:, 0] ** 2))\n        q /= np.sqrt(np.sum(b ** 2))\n        assert_equal(np.abs(q) > 0.95, True)",
            "def test_poisson():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.seed(43242)\n    xmat = np.random.normal(size=(500, 5))\n    xmat[:, 1] = 0.5 * xmat[:, 0] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 1]\n    xmat[:, 3] = 0.5 * xmat[:, 2] + np.sqrt(1 - 0.5 ** 2) * xmat[:, 3]\n    b = np.r_[0, 1, -1, 0, 0.5]\n    lpr = np.dot(xmat, b)\n    ev = np.exp(lpr)\n    y = np.random.poisson(ev)\n    for method in range(6):\n        if method == 0:\n            model = SlicedInverseReg(y, xmat)\n            rslt = model.fit()\n        elif method == 1:\n            model = SAVE(y, xmat)\n            rslt = model.fit(slice_n=100)\n        elif method == 2:\n            model = SAVE(y, xmat, bc=True)\n            rslt = model.fit(slice_n=100)\n        elif method == 3:\n            df = pd.DataFrame({'y': y, 'x0': xmat[:, 0], 'x1': xmat[:, 1], 'x2': xmat[:, 2], 'x3': xmat[:, 3], 'x4': xmat[:, 4]})\n            model = SlicedInverseReg.from_formula('y ~ 0 + x0 + x1 + x2 + x3 + x4', data=df)\n            rslt = model.fit()\n        elif method == 4:\n            model = PHD(y, xmat)\n            rslt = model.fit()\n        elif method == 5:\n            model = PHD(y, xmat)\n            rslt = model.fit(resid=True)\n        assert_equal(np.abs(rslt.eigs[0] / rslt.eigs[1]) > 5, True)\n        params = np.asarray(rslt.params)\n        q = np.dot(params[:, 0], b)\n        q /= np.sqrt(np.sum(params[:, 0] ** 2))\n        q /= np.sqrt(np.sum(b ** 2))\n        assert_equal(np.abs(q) > 0.95, True)"
        ]
    },
    {
        "func_name": "test_sir_regularized_numdiff",
        "original": "def test_sir_regularized_numdiff():\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat, np.linspace(-1, 1, p))\n    y2 = xmat.sum(1)\n    y = y2 / (1 + y1 ** 2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    _ = model.fit()\n    fmat = np.zeros((p - 2, p))\n    for i in range(p - 2):\n        fmat[i, i:i + 3] = [1, -2, 1]\n    with pytest.warns(UserWarning, match='SIR.fit_regularized did not'):\n        _ = model.fit_regularized(2, 3 * fmat)\n    for _ in range(5):\n        pa = np.random.normal(size=(p, 2))\n        (pa, _, _) = np.linalg.svd(pa, 0)\n        gn = approx_fprime(pa.ravel(), model._regularized_objective, 1e-07)\n        gr = model._regularized_grad(pa.ravel())\n        assert_allclose(gn, gr, atol=1e-05, rtol=0.0001)",
        "mutated": [
            "def test_sir_regularized_numdiff():\n    if False:\n        i = 10\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat, np.linspace(-1, 1, p))\n    y2 = xmat.sum(1)\n    y = y2 / (1 + y1 ** 2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    _ = model.fit()\n    fmat = np.zeros((p - 2, p))\n    for i in range(p - 2):\n        fmat[i, i:i + 3] = [1, -2, 1]\n    with pytest.warns(UserWarning, match='SIR.fit_regularized did not'):\n        _ = model.fit_regularized(2, 3 * fmat)\n    for _ in range(5):\n        pa = np.random.normal(size=(p, 2))\n        (pa, _, _) = np.linalg.svd(pa, 0)\n        gn = approx_fprime(pa.ravel(), model._regularized_objective, 1e-07)\n        gr = model._regularized_grad(pa.ravel())\n        assert_allclose(gn, gr, atol=1e-05, rtol=0.0001)",
            "def test_sir_regularized_numdiff():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat, np.linspace(-1, 1, p))\n    y2 = xmat.sum(1)\n    y = y2 / (1 + y1 ** 2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    _ = model.fit()\n    fmat = np.zeros((p - 2, p))\n    for i in range(p - 2):\n        fmat[i, i:i + 3] = [1, -2, 1]\n    with pytest.warns(UserWarning, match='SIR.fit_regularized did not'):\n        _ = model.fit_regularized(2, 3 * fmat)\n    for _ in range(5):\n        pa = np.random.normal(size=(p, 2))\n        (pa, _, _) = np.linalg.svd(pa, 0)\n        gn = approx_fprime(pa.ravel(), model._regularized_objective, 1e-07)\n        gr = model._regularized_grad(pa.ravel())\n        assert_allclose(gn, gr, atol=1e-05, rtol=0.0001)",
            "def test_sir_regularized_numdiff():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat, np.linspace(-1, 1, p))\n    y2 = xmat.sum(1)\n    y = y2 / (1 + y1 ** 2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    _ = model.fit()\n    fmat = np.zeros((p - 2, p))\n    for i in range(p - 2):\n        fmat[i, i:i + 3] = [1, -2, 1]\n    with pytest.warns(UserWarning, match='SIR.fit_regularized did not'):\n        _ = model.fit_regularized(2, 3 * fmat)\n    for _ in range(5):\n        pa = np.random.normal(size=(p, 2))\n        (pa, _, _) = np.linalg.svd(pa, 0)\n        gn = approx_fprime(pa.ravel(), model._regularized_objective, 1e-07)\n        gr = model._regularized_grad(pa.ravel())\n        assert_allclose(gn, gr, atol=1e-05, rtol=0.0001)",
            "def test_sir_regularized_numdiff():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat, np.linspace(-1, 1, p))\n    y2 = xmat.sum(1)\n    y = y2 / (1 + y1 ** 2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    _ = model.fit()\n    fmat = np.zeros((p - 2, p))\n    for i in range(p - 2):\n        fmat[i, i:i + 3] = [1, -2, 1]\n    with pytest.warns(UserWarning, match='SIR.fit_regularized did not'):\n        _ = model.fit_regularized(2, 3 * fmat)\n    for _ in range(5):\n        pa = np.random.normal(size=(p, 2))\n        (pa, _, _) = np.linalg.svd(pa, 0)\n        gn = approx_fprime(pa.ravel(), model._regularized_objective, 1e-07)\n        gr = model._regularized_grad(pa.ravel())\n        assert_allclose(gn, gr, atol=1e-05, rtol=0.0001)",
            "def test_sir_regularized_numdiff():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat, np.linspace(-1, 1, p))\n    y2 = xmat.sum(1)\n    y = y2 / (1 + y1 ** 2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    _ = model.fit()\n    fmat = np.zeros((p - 2, p))\n    for i in range(p - 2):\n        fmat[i, i:i + 3] = [1, -2, 1]\n    with pytest.warns(UserWarning, match='SIR.fit_regularized did not'):\n        _ = model.fit_regularized(2, 3 * fmat)\n    for _ in range(5):\n        pa = np.random.normal(size=(p, 2))\n        (pa, _, _) = np.linalg.svd(pa, 0)\n        gn = approx_fprime(pa.ravel(), model._regularized_objective, 1e-07)\n        gr = model._regularized_grad(pa.ravel())\n        assert_allclose(gn, gr, atol=1e-05, rtol=0.0001)"
        ]
    },
    {
        "func_name": "sim",
        "original": "def sim(x, y):\n    x = x / np.sqrt(np.sum(x * x))\n    y = y / np.sqrt(np.sum(y * y))\n    return 1 - np.abs(np.dot(x, y))",
        "mutated": [
            "def sim(x, y):\n    if False:\n        i = 10\n    x = x / np.sqrt(np.sum(x * x))\n    y = y / np.sqrt(np.sum(y * y))\n    return 1 - np.abs(np.dot(x, y))",
            "def sim(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    x = x / np.sqrt(np.sum(x * x))\n    y = y / np.sqrt(np.sum(y * y))\n    return 1 - np.abs(np.dot(x, y))",
            "def sim(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    x = x / np.sqrt(np.sum(x * x))\n    y = y / np.sqrt(np.sum(y * y))\n    return 1 - np.abs(np.dot(x, y))",
            "def sim(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    x = x / np.sqrt(np.sum(x * x))\n    y = y / np.sqrt(np.sum(y * y))\n    return 1 - np.abs(np.dot(x, y))",
            "def sim(x, y):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    x = x / np.sqrt(np.sum(x * x))\n    y = y / np.sqrt(np.sum(y * y))\n    return 1 - np.abs(np.dot(x, y))"
        ]
    },
    {
        "func_name": "test_sir_regularized_1d",
        "original": "def test_sir_regularized_1d():\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1]) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt = model.fit()\n    fmat = np.zeros((2, p))\n    fmat[0, 0:2] = [1, -1]\n    fmat[1, 2:4] = [1, -1]\n    rslt2 = model.fit_regularized(1, 3 * fmat)\n    pa0 = np.zeros(p)\n    pa0[0:4] = [1, 1, -1, -1]\n    pa1 = rslt.params[:, 0]\n    pa2 = rslt2.params[:, 0:2]\n\n    def sim(x, y):\n        x = x / np.sqrt(np.sum(x * x))\n        y = y / np.sqrt(np.sum(y * y))\n        return 1 - np.abs(np.dot(x, y))\n    assert_equal(sim(pa0, pa1) > sim(pa0, pa2), True)\n    assert_equal(sim(pa0, pa2) < 0.001, True)\n    assert_equal(np.sum(np.dot(fmat, pa1) ** 2) > np.sum(np.dot(fmat, pa2) ** 2), True)",
        "mutated": [
            "def test_sir_regularized_1d():\n    if False:\n        i = 10\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1]) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt = model.fit()\n    fmat = np.zeros((2, p))\n    fmat[0, 0:2] = [1, -1]\n    fmat[1, 2:4] = [1, -1]\n    rslt2 = model.fit_regularized(1, 3 * fmat)\n    pa0 = np.zeros(p)\n    pa0[0:4] = [1, 1, -1, -1]\n    pa1 = rslt.params[:, 0]\n    pa2 = rslt2.params[:, 0:2]\n\n    def sim(x, y):\n        x = x / np.sqrt(np.sum(x * x))\n        y = y / np.sqrt(np.sum(y * y))\n        return 1 - np.abs(np.dot(x, y))\n    assert_equal(sim(pa0, pa1) > sim(pa0, pa2), True)\n    assert_equal(sim(pa0, pa2) < 0.001, True)\n    assert_equal(np.sum(np.dot(fmat, pa1) ** 2) > np.sum(np.dot(fmat, pa2) ** 2), True)",
            "def test_sir_regularized_1d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1]) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt = model.fit()\n    fmat = np.zeros((2, p))\n    fmat[0, 0:2] = [1, -1]\n    fmat[1, 2:4] = [1, -1]\n    rslt2 = model.fit_regularized(1, 3 * fmat)\n    pa0 = np.zeros(p)\n    pa0[0:4] = [1, 1, -1, -1]\n    pa1 = rslt.params[:, 0]\n    pa2 = rslt2.params[:, 0:2]\n\n    def sim(x, y):\n        x = x / np.sqrt(np.sum(x * x))\n        y = y / np.sqrt(np.sum(y * y))\n        return 1 - np.abs(np.dot(x, y))\n    assert_equal(sim(pa0, pa1) > sim(pa0, pa2), True)\n    assert_equal(sim(pa0, pa2) < 0.001, True)\n    assert_equal(np.sum(np.dot(fmat, pa1) ** 2) > np.sum(np.dot(fmat, pa2) ** 2), True)",
            "def test_sir_regularized_1d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1]) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt = model.fit()\n    fmat = np.zeros((2, p))\n    fmat[0, 0:2] = [1, -1]\n    fmat[1, 2:4] = [1, -1]\n    rslt2 = model.fit_regularized(1, 3 * fmat)\n    pa0 = np.zeros(p)\n    pa0[0:4] = [1, 1, -1, -1]\n    pa1 = rslt.params[:, 0]\n    pa2 = rslt2.params[:, 0:2]\n\n    def sim(x, y):\n        x = x / np.sqrt(np.sum(x * x))\n        y = y / np.sqrt(np.sum(y * y))\n        return 1 - np.abs(np.dot(x, y))\n    assert_equal(sim(pa0, pa1) > sim(pa0, pa2), True)\n    assert_equal(sim(pa0, pa2) < 0.001, True)\n    assert_equal(np.sum(np.dot(fmat, pa1) ** 2) > np.sum(np.dot(fmat, pa2) ** 2), True)",
            "def test_sir_regularized_1d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1]) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt = model.fit()\n    fmat = np.zeros((2, p))\n    fmat[0, 0:2] = [1, -1]\n    fmat[1, 2:4] = [1, -1]\n    rslt2 = model.fit_regularized(1, 3 * fmat)\n    pa0 = np.zeros(p)\n    pa0[0:4] = [1, 1, -1, -1]\n    pa1 = rslt.params[:, 0]\n    pa2 = rslt2.params[:, 0:2]\n\n    def sim(x, y):\n        x = x / np.sqrt(np.sum(x * x))\n        y = y / np.sqrt(np.sum(y * y))\n        return 1 - np.abs(np.dot(x, y))\n    assert_equal(sim(pa0, pa1) > sim(pa0, pa2), True)\n    assert_equal(sim(pa0, pa2) < 0.001, True)\n    assert_equal(np.sum(np.dot(fmat, pa1) ** 2) > np.sum(np.dot(fmat, pa2) ** 2), True)",
            "def test_sir_regularized_1d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1]) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt = model.fit()\n    fmat = np.zeros((2, p))\n    fmat[0, 0:2] = [1, -1]\n    fmat[1, 2:4] = [1, -1]\n    rslt2 = model.fit_regularized(1, 3 * fmat)\n    pa0 = np.zeros(p)\n    pa0[0:4] = [1, 1, -1, -1]\n    pa1 = rslt.params[:, 0]\n    pa2 = rslt2.params[:, 0:2]\n\n    def sim(x, y):\n        x = x / np.sqrt(np.sum(x * x))\n        y = y / np.sqrt(np.sum(y * y))\n        return 1 - np.abs(np.dot(x, y))\n    assert_equal(sim(pa0, pa1) > sim(pa0, pa2), True)\n    assert_equal(sim(pa0, pa2) < 0.001, True)\n    assert_equal(np.sum(np.dot(fmat, pa1) ** 2) > np.sum(np.dot(fmat, pa2) ** 2), True)"
        ]
    },
    {
        "func_name": "test_sir_regularized_2d",
        "original": "def test_sir_regularized_2d():\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1])\n    y2 = np.dot(xmat[:, 4:8], np.r_[1, 1, -1, -1])\n    y = y1 + np.arctan(y2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt1 = model.fit()\n    fmat = np.zeros((1, p))\n    for d in (1, 2, 3, 4):\n        if d < 3:\n            rslt2 = model.fit_regularized(d, fmat)\n        else:\n            with pytest.warns(UserWarning, match='SIR.fit_regularized did'):\n                rslt2 = model.fit_regularized(d, fmat)\n        pa1 = rslt1.params[:, 0:d]\n        (pa1, _, _) = np.linalg.svd(pa1, 0)\n        pa2 = rslt2.params\n        (_, s, _) = np.linalg.svd(np.dot(pa1.T, pa2))\n        assert_allclose(np.sum(s), d, atol=0.1, rtol=0.1)",
        "mutated": [
            "def test_sir_regularized_2d():\n    if False:\n        i = 10\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1])\n    y2 = np.dot(xmat[:, 4:8], np.r_[1, 1, -1, -1])\n    y = y1 + np.arctan(y2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt1 = model.fit()\n    fmat = np.zeros((1, p))\n    for d in (1, 2, 3, 4):\n        if d < 3:\n            rslt2 = model.fit_regularized(d, fmat)\n        else:\n            with pytest.warns(UserWarning, match='SIR.fit_regularized did'):\n                rslt2 = model.fit_regularized(d, fmat)\n        pa1 = rslt1.params[:, 0:d]\n        (pa1, _, _) = np.linalg.svd(pa1, 0)\n        pa2 = rslt2.params\n        (_, s, _) = np.linalg.svd(np.dot(pa1.T, pa2))\n        assert_allclose(np.sum(s), d, atol=0.1, rtol=0.1)",
            "def test_sir_regularized_2d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1])\n    y2 = np.dot(xmat[:, 4:8], np.r_[1, 1, -1, -1])\n    y = y1 + np.arctan(y2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt1 = model.fit()\n    fmat = np.zeros((1, p))\n    for d in (1, 2, 3, 4):\n        if d < 3:\n            rslt2 = model.fit_regularized(d, fmat)\n        else:\n            with pytest.warns(UserWarning, match='SIR.fit_regularized did'):\n                rslt2 = model.fit_regularized(d, fmat)\n        pa1 = rslt1.params[:, 0:d]\n        (pa1, _, _) = np.linalg.svd(pa1, 0)\n        pa2 = rslt2.params\n        (_, s, _) = np.linalg.svd(np.dot(pa1.T, pa2))\n        assert_allclose(np.sum(s), d, atol=0.1, rtol=0.1)",
            "def test_sir_regularized_2d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1])\n    y2 = np.dot(xmat[:, 4:8], np.r_[1, 1, -1, -1])\n    y = y1 + np.arctan(y2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt1 = model.fit()\n    fmat = np.zeros((1, p))\n    for d in (1, 2, 3, 4):\n        if d < 3:\n            rslt2 = model.fit_regularized(d, fmat)\n        else:\n            with pytest.warns(UserWarning, match='SIR.fit_regularized did'):\n                rslt2 = model.fit_regularized(d, fmat)\n        pa1 = rslt1.params[:, 0:d]\n        (pa1, _, _) = np.linalg.svd(pa1, 0)\n        pa2 = rslt2.params\n        (_, s, _) = np.linalg.svd(np.dot(pa1.T, pa2))\n        assert_allclose(np.sum(s), d, atol=0.1, rtol=0.1)",
            "def test_sir_regularized_2d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1])\n    y2 = np.dot(xmat[:, 4:8], np.r_[1, 1, -1, -1])\n    y = y1 + np.arctan(y2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt1 = model.fit()\n    fmat = np.zeros((1, p))\n    for d in (1, 2, 3, 4):\n        if d < 3:\n            rslt2 = model.fit_regularized(d, fmat)\n        else:\n            with pytest.warns(UserWarning, match='SIR.fit_regularized did'):\n                rslt2 = model.fit_regularized(d, fmat)\n        pa1 = rslt1.params[:, 0:d]\n        (pa1, _, _) = np.linalg.svd(pa1, 0)\n        pa2 = rslt2.params\n        (_, s, _) = np.linalg.svd(np.dot(pa1.T, pa2))\n        assert_allclose(np.sum(s), d, atol=0.1, rtol=0.1)",
            "def test_sir_regularized_2d():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.seed(93482)\n    n = 1000\n    p = 10\n    xmat = np.random.normal(size=(n, p))\n    y1 = np.dot(xmat[:, 0:4], np.r_[1, 1, -1, -1])\n    y2 = np.dot(xmat[:, 4:8], np.r_[1, 1, -1, -1])\n    y = y1 + np.arctan(y2) + np.random.normal(size=n)\n    model = SlicedInverseReg(y, xmat)\n    rslt1 = model.fit()\n    fmat = np.zeros((1, p))\n    for d in (1, 2, 3, 4):\n        if d < 3:\n            rslt2 = model.fit_regularized(d, fmat)\n        else:\n            with pytest.warns(UserWarning, match='SIR.fit_regularized did'):\n                rslt2 = model.fit_regularized(d, fmat)\n        pa1 = rslt1.params[:, 0:d]\n        (pa1, _, _) = np.linalg.svd(pa1, 0)\n        pa2 = rslt2.params\n        (_, s, _) = np.linalg.svd(np.dot(pa1.T, pa2))\n        assert_allclose(np.sum(s), d, atol=0.1, rtol=0.1)"
        ]
    },
    {
        "func_name": "test_covreduce",
        "original": "def test_covreduce():\n    np.random.seed(34324)\n    p = 4\n    endog = []\n    exog = []\n    for k in range(3):\n        c = np.eye(p)\n        x = np.random.normal(size=(2, 2))\n        c[0:2, 0:2] = np.dot(x.T, x)\n        cr = np.linalg.cholesky(c)\n        m = 1000 * k + 50 * k\n        x = np.random.normal(size=(m, p))\n        x = np.dot(x, cr.T)\n        exog.append(x)\n        endog.append(k * np.ones(m))\n    endog = np.concatenate(endog)\n    exog = np.concatenate(exog, axis=0)\n    for dim in (1, 2, 3):\n        cr = CORE(endog, exog, dim)\n        pt = np.random.normal(size=(p, dim))\n        (pt, _, _) = np.linalg.svd(pt, 0)\n        gn = approx_fprime(pt.ravel(), cr.loglike, 1e-07)\n        g = cr.score(pt.ravel())\n        assert_allclose(g, gn, 1e-05, 1e-05)\n        rslt = cr.fit()\n        proj = rslt.params\n        assert_equal(proj.shape[0], p)\n        assert_equal(proj.shape[1], dim)\n        assert_allclose(np.dot(proj.T, proj), np.eye(dim), 1e-08, 1e-08)\n        if dim == 2:\n            projt = np.zeros((p, 2))\n            projt[0:2, 0:2] = np.eye(2)\n            assert_allclose(np.trace(np.dot(proj.T, projt)), 2, rtol=0.001, atol=0.001)",
        "mutated": [
            "def test_covreduce():\n    if False:\n        i = 10\n    np.random.seed(34324)\n    p = 4\n    endog = []\n    exog = []\n    for k in range(3):\n        c = np.eye(p)\n        x = np.random.normal(size=(2, 2))\n        c[0:2, 0:2] = np.dot(x.T, x)\n        cr = np.linalg.cholesky(c)\n        m = 1000 * k + 50 * k\n        x = np.random.normal(size=(m, p))\n        x = np.dot(x, cr.T)\n        exog.append(x)\n        endog.append(k * np.ones(m))\n    endog = np.concatenate(endog)\n    exog = np.concatenate(exog, axis=0)\n    for dim in (1, 2, 3):\n        cr = CORE(endog, exog, dim)\n        pt = np.random.normal(size=(p, dim))\n        (pt, _, _) = np.linalg.svd(pt, 0)\n        gn = approx_fprime(pt.ravel(), cr.loglike, 1e-07)\n        g = cr.score(pt.ravel())\n        assert_allclose(g, gn, 1e-05, 1e-05)\n        rslt = cr.fit()\n        proj = rslt.params\n        assert_equal(proj.shape[0], p)\n        assert_equal(proj.shape[1], dim)\n        assert_allclose(np.dot(proj.T, proj), np.eye(dim), 1e-08, 1e-08)\n        if dim == 2:\n            projt = np.zeros((p, 2))\n            projt[0:2, 0:2] = np.eye(2)\n            assert_allclose(np.trace(np.dot(proj.T, projt)), 2, rtol=0.001, atol=0.001)",
            "def test_covreduce():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    np.random.seed(34324)\n    p = 4\n    endog = []\n    exog = []\n    for k in range(3):\n        c = np.eye(p)\n        x = np.random.normal(size=(2, 2))\n        c[0:2, 0:2] = np.dot(x.T, x)\n        cr = np.linalg.cholesky(c)\n        m = 1000 * k + 50 * k\n        x = np.random.normal(size=(m, p))\n        x = np.dot(x, cr.T)\n        exog.append(x)\n        endog.append(k * np.ones(m))\n    endog = np.concatenate(endog)\n    exog = np.concatenate(exog, axis=0)\n    for dim in (1, 2, 3):\n        cr = CORE(endog, exog, dim)\n        pt = np.random.normal(size=(p, dim))\n        (pt, _, _) = np.linalg.svd(pt, 0)\n        gn = approx_fprime(pt.ravel(), cr.loglike, 1e-07)\n        g = cr.score(pt.ravel())\n        assert_allclose(g, gn, 1e-05, 1e-05)\n        rslt = cr.fit()\n        proj = rslt.params\n        assert_equal(proj.shape[0], p)\n        assert_equal(proj.shape[1], dim)\n        assert_allclose(np.dot(proj.T, proj), np.eye(dim), 1e-08, 1e-08)\n        if dim == 2:\n            projt = np.zeros((p, 2))\n            projt[0:2, 0:2] = np.eye(2)\n            assert_allclose(np.trace(np.dot(proj.T, projt)), 2, rtol=0.001, atol=0.001)",
            "def test_covreduce():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    np.random.seed(34324)\n    p = 4\n    endog = []\n    exog = []\n    for k in range(3):\n        c = np.eye(p)\n        x = np.random.normal(size=(2, 2))\n        c[0:2, 0:2] = np.dot(x.T, x)\n        cr = np.linalg.cholesky(c)\n        m = 1000 * k + 50 * k\n        x = np.random.normal(size=(m, p))\n        x = np.dot(x, cr.T)\n        exog.append(x)\n        endog.append(k * np.ones(m))\n    endog = np.concatenate(endog)\n    exog = np.concatenate(exog, axis=0)\n    for dim in (1, 2, 3):\n        cr = CORE(endog, exog, dim)\n        pt = np.random.normal(size=(p, dim))\n        (pt, _, _) = np.linalg.svd(pt, 0)\n        gn = approx_fprime(pt.ravel(), cr.loglike, 1e-07)\n        g = cr.score(pt.ravel())\n        assert_allclose(g, gn, 1e-05, 1e-05)\n        rslt = cr.fit()\n        proj = rslt.params\n        assert_equal(proj.shape[0], p)\n        assert_equal(proj.shape[1], dim)\n        assert_allclose(np.dot(proj.T, proj), np.eye(dim), 1e-08, 1e-08)\n        if dim == 2:\n            projt = np.zeros((p, 2))\n            projt[0:2, 0:2] = np.eye(2)\n            assert_allclose(np.trace(np.dot(proj.T, projt)), 2, rtol=0.001, atol=0.001)",
            "def test_covreduce():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    np.random.seed(34324)\n    p = 4\n    endog = []\n    exog = []\n    for k in range(3):\n        c = np.eye(p)\n        x = np.random.normal(size=(2, 2))\n        c[0:2, 0:2] = np.dot(x.T, x)\n        cr = np.linalg.cholesky(c)\n        m = 1000 * k + 50 * k\n        x = np.random.normal(size=(m, p))\n        x = np.dot(x, cr.T)\n        exog.append(x)\n        endog.append(k * np.ones(m))\n    endog = np.concatenate(endog)\n    exog = np.concatenate(exog, axis=0)\n    for dim in (1, 2, 3):\n        cr = CORE(endog, exog, dim)\n        pt = np.random.normal(size=(p, dim))\n        (pt, _, _) = np.linalg.svd(pt, 0)\n        gn = approx_fprime(pt.ravel(), cr.loglike, 1e-07)\n        g = cr.score(pt.ravel())\n        assert_allclose(g, gn, 1e-05, 1e-05)\n        rslt = cr.fit()\n        proj = rslt.params\n        assert_equal(proj.shape[0], p)\n        assert_equal(proj.shape[1], dim)\n        assert_allclose(np.dot(proj.T, proj), np.eye(dim), 1e-08, 1e-08)\n        if dim == 2:\n            projt = np.zeros((p, 2))\n            projt[0:2, 0:2] = np.eye(2)\n            assert_allclose(np.trace(np.dot(proj.T, projt)), 2, rtol=0.001, atol=0.001)",
            "def test_covreduce():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    np.random.seed(34324)\n    p = 4\n    endog = []\n    exog = []\n    for k in range(3):\n        c = np.eye(p)\n        x = np.random.normal(size=(2, 2))\n        c[0:2, 0:2] = np.dot(x.T, x)\n        cr = np.linalg.cholesky(c)\n        m = 1000 * k + 50 * k\n        x = np.random.normal(size=(m, p))\n        x = np.dot(x, cr.T)\n        exog.append(x)\n        endog.append(k * np.ones(m))\n    endog = np.concatenate(endog)\n    exog = np.concatenate(exog, axis=0)\n    for dim in (1, 2, 3):\n        cr = CORE(endog, exog, dim)\n        pt = np.random.normal(size=(p, dim))\n        (pt, _, _) = np.linalg.svd(pt, 0)\n        gn = approx_fprime(pt.ravel(), cr.loglike, 1e-07)\n        g = cr.score(pt.ravel())\n        assert_allclose(g, gn, 1e-05, 1e-05)\n        rslt = cr.fit()\n        proj = rslt.params\n        assert_equal(proj.shape[0], p)\n        assert_equal(proj.shape[1], dim)\n        assert_allclose(np.dot(proj.T, proj), np.eye(dim), 1e-08, 1e-08)\n        if dim == 2:\n            projt = np.zeros((p, 2))\n            projt[0:2, 0:2] = np.eye(2)\n            assert_allclose(np.trace(np.dot(proj.T, projt)), 2, rtol=0.001, atol=0.001)"
        ]
    }
]