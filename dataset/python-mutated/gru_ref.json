[
    {
        "func_name": "__init__",
        "original": "def __init__(self, in_size, hidden_size):\n    \"\"\"\n        This class implements a GRU.\n        \"\"\"\n    self.hidden_size = hidden_size\n    self.in_size = in_size\n    self.Wxc = np.zeros((hidden_size, in_size))\n    self.Wxr = np.zeros((hidden_size, in_size))\n    self.Wxz = np.zeros((hidden_size, in_size))\n    self.Rhc = np.zeros((hidden_size, hidden_size))\n    self.Rhr = np.zeros((hidden_size, hidden_size))\n    self.Rhz = np.zeros((hidden_size, hidden_size))\n    self.bc = np.zeros((hidden_size, 1))\n    self.br = np.zeros((hidden_size, 1))\n    self.bz = np.zeros((hidden_size, 1))\n    self.weights = [self.Wxc, self.Wxr, self.Wxz, self.Rhc, self.Rhr, self.Rhz, self.bc, self.br, self.bz]\n    self.names = ['Wxc', 'Wxr', 'Wxz', 'Rhc', 'Rhr', 'Rhz', 'bc', 'br', 'bz']\n    self.weights_ind_Wxc = 0\n    self.weights_ind_Wxr = 1\n    self.weights_ind_Wxz = 2\n    self.weights_ind_Rhc = 3\n    self.weights_ind_Rhr = 4\n    self.weights_ind_Rhz = 5\n    self.weights_ind_bc = 6\n    self.weights_ind_br = 7\n    self.weights_ind_bz = 8",
        "mutated": [
            "def __init__(self, in_size, hidden_size):\n    if False:\n        i = 10\n    '\\n        This class implements a GRU.\\n        '\n    self.hidden_size = hidden_size\n    self.in_size = in_size\n    self.Wxc = np.zeros((hidden_size, in_size))\n    self.Wxr = np.zeros((hidden_size, in_size))\n    self.Wxz = np.zeros((hidden_size, in_size))\n    self.Rhc = np.zeros((hidden_size, hidden_size))\n    self.Rhr = np.zeros((hidden_size, hidden_size))\n    self.Rhz = np.zeros((hidden_size, hidden_size))\n    self.bc = np.zeros((hidden_size, 1))\n    self.br = np.zeros((hidden_size, 1))\n    self.bz = np.zeros((hidden_size, 1))\n    self.weights = [self.Wxc, self.Wxr, self.Wxz, self.Rhc, self.Rhr, self.Rhz, self.bc, self.br, self.bz]\n    self.names = ['Wxc', 'Wxr', 'Wxz', 'Rhc', 'Rhr', 'Rhz', 'bc', 'br', 'bz']\n    self.weights_ind_Wxc = 0\n    self.weights_ind_Wxr = 1\n    self.weights_ind_Wxz = 2\n    self.weights_ind_Rhc = 3\n    self.weights_ind_Rhr = 4\n    self.weights_ind_Rhz = 5\n    self.weights_ind_bc = 6\n    self.weights_ind_br = 7\n    self.weights_ind_bz = 8",
            "def __init__(self, in_size, hidden_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        This class implements a GRU.\\n        '\n    self.hidden_size = hidden_size\n    self.in_size = in_size\n    self.Wxc = np.zeros((hidden_size, in_size))\n    self.Wxr = np.zeros((hidden_size, in_size))\n    self.Wxz = np.zeros((hidden_size, in_size))\n    self.Rhc = np.zeros((hidden_size, hidden_size))\n    self.Rhr = np.zeros((hidden_size, hidden_size))\n    self.Rhz = np.zeros((hidden_size, hidden_size))\n    self.bc = np.zeros((hidden_size, 1))\n    self.br = np.zeros((hidden_size, 1))\n    self.bz = np.zeros((hidden_size, 1))\n    self.weights = [self.Wxc, self.Wxr, self.Wxz, self.Rhc, self.Rhr, self.Rhz, self.bc, self.br, self.bz]\n    self.names = ['Wxc', 'Wxr', 'Wxz', 'Rhc', 'Rhr', 'Rhz', 'bc', 'br', 'bz']\n    self.weights_ind_Wxc = 0\n    self.weights_ind_Wxr = 1\n    self.weights_ind_Wxz = 2\n    self.weights_ind_Rhc = 3\n    self.weights_ind_Rhr = 4\n    self.weights_ind_Rhz = 5\n    self.weights_ind_bc = 6\n    self.weights_ind_br = 7\n    self.weights_ind_bz = 8",
            "def __init__(self, in_size, hidden_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        This class implements a GRU.\\n        '\n    self.hidden_size = hidden_size\n    self.in_size = in_size\n    self.Wxc = np.zeros((hidden_size, in_size))\n    self.Wxr = np.zeros((hidden_size, in_size))\n    self.Wxz = np.zeros((hidden_size, in_size))\n    self.Rhc = np.zeros((hidden_size, hidden_size))\n    self.Rhr = np.zeros((hidden_size, hidden_size))\n    self.Rhz = np.zeros((hidden_size, hidden_size))\n    self.bc = np.zeros((hidden_size, 1))\n    self.br = np.zeros((hidden_size, 1))\n    self.bz = np.zeros((hidden_size, 1))\n    self.weights = [self.Wxc, self.Wxr, self.Wxz, self.Rhc, self.Rhr, self.Rhz, self.bc, self.br, self.bz]\n    self.names = ['Wxc', 'Wxr', 'Wxz', 'Rhc', 'Rhr', 'Rhz', 'bc', 'br', 'bz']\n    self.weights_ind_Wxc = 0\n    self.weights_ind_Wxr = 1\n    self.weights_ind_Wxz = 2\n    self.weights_ind_Rhc = 3\n    self.weights_ind_Rhr = 4\n    self.weights_ind_Rhz = 5\n    self.weights_ind_bc = 6\n    self.weights_ind_br = 7\n    self.weights_ind_bz = 8",
            "def __init__(self, in_size, hidden_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        This class implements a GRU.\\n        '\n    self.hidden_size = hidden_size\n    self.in_size = in_size\n    self.Wxc = np.zeros((hidden_size, in_size))\n    self.Wxr = np.zeros((hidden_size, in_size))\n    self.Wxz = np.zeros((hidden_size, in_size))\n    self.Rhc = np.zeros((hidden_size, hidden_size))\n    self.Rhr = np.zeros((hidden_size, hidden_size))\n    self.Rhz = np.zeros((hidden_size, hidden_size))\n    self.bc = np.zeros((hidden_size, 1))\n    self.br = np.zeros((hidden_size, 1))\n    self.bz = np.zeros((hidden_size, 1))\n    self.weights = [self.Wxc, self.Wxr, self.Wxz, self.Rhc, self.Rhr, self.Rhz, self.bc, self.br, self.bz]\n    self.names = ['Wxc', 'Wxr', 'Wxz', 'Rhc', 'Rhr', 'Rhz', 'bc', 'br', 'bz']\n    self.weights_ind_Wxc = 0\n    self.weights_ind_Wxr = 1\n    self.weights_ind_Wxz = 2\n    self.weights_ind_Rhc = 3\n    self.weights_ind_Rhr = 4\n    self.weights_ind_Rhz = 5\n    self.weights_ind_bc = 6\n    self.weights_ind_br = 7\n    self.weights_ind_bz = 8",
            "def __init__(self, in_size, hidden_size):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        This class implements a GRU.\\n        '\n    self.hidden_size = hidden_size\n    self.in_size = in_size\n    self.Wxc = np.zeros((hidden_size, in_size))\n    self.Wxr = np.zeros((hidden_size, in_size))\n    self.Wxz = np.zeros((hidden_size, in_size))\n    self.Rhc = np.zeros((hidden_size, hidden_size))\n    self.Rhr = np.zeros((hidden_size, hidden_size))\n    self.Rhz = np.zeros((hidden_size, hidden_size))\n    self.bc = np.zeros((hidden_size, 1))\n    self.br = np.zeros((hidden_size, 1))\n    self.bz = np.zeros((hidden_size, 1))\n    self.weights = [self.Wxc, self.Wxr, self.Wxz, self.Rhc, self.Rhr, self.Rhz, self.bc, self.br, self.bz]\n    self.names = ['Wxc', 'Wxr', 'Wxz', 'Rhc', 'Rhr', 'Rhz', 'bc', 'br', 'bz']\n    self.weights_ind_Wxc = 0\n    self.weights_ind_Wxr = 1\n    self.weights_ind_Wxz = 2\n    self.weights_ind_Rhc = 3\n    self.weights_ind_Rhr = 4\n    self.weights_ind_Rhz = 5\n    self.weights_ind_bc = 6\n    self.weights_ind_br = 7\n    self.weights_ind_bz = 8"
        ]
    },
    {
        "func_name": "lossFun",
        "original": "def lossFun(self, inputs, errors, init_state=None):\n    \"\"\"\n        Does a forward and backward pass on the network using (inputs, errors)\n        inputs is a bit-vector of seq-length\n        errors is a bit-vector of seq-length\n        \"\"\"\n    (xs, rbars, rs, zbars, zs, cbars, cs, hs) = ({}, {}, {}, {}, {}, {}, {}, {})\n    if init_state is None:\n        hs[-1] = np.zeros((self.hidden_size, 1))\n    else:\n        hs[-1] = init_state\n    seq_len = len(inputs)\n    hs_list = np.zeros((self.hidden_size, seq_len))\n    for t in range(seq_len):\n        xs[t] = np.matrix(inputs[t])\n        rbars[t] = np.dot(self.Wxr, xs[t]) + np.dot(self.Rhr, hs[t - 1]) + self.br\n        rs[t] = 1.0 / (1 + np.exp(-rbars[t]))\n        zbars[t] = np.dot(self.Wxz, xs[t]) + np.dot(self.Rhz, hs[t - 1]) + self.bz\n        zs[t] = 1.0 / (1 + np.exp(-zbars[t]))\n        cbars[t] = np.dot(self.Wxc, xs[t]) + np.dot(self.Rhc, np.multiply(rs[t], hs[t - 1])) + self.bc\n        cs[t] = np.tanh(cbars[t])\n        ones = np.ones_like(zs[t])\n        hs[t] = np.multiply(cs[t], zs[t]) + np.multiply(hs[t - 1], ones - zs[t])\n        hs_list[:, t] = hs[t].flatten()\n    dWxc = np.zeros_like(self.Wxc)\n    dWxr = np.zeros_like(self.Wxr)\n    dWxz = np.zeros_like(self.Wxz)\n    dRhc = np.zeros_like(self.Rhc)\n    dRhr = np.zeros_like(self.Rhr)\n    dRhz = np.zeros_like(self.Rhz)\n    dbc = np.zeros_like(self.bc)\n    dbr = np.zeros_like(self.br)\n    dbz = np.zeros_like(self.bz)\n    dhnext = np.zeros_like(hs[0])\n    drbarnext = np.zeros_like(rbars[0])\n    dzbarnext = np.zeros_like(zbars[0])\n    dcbarnext = np.zeros_like(cbars[0])\n    zs[len(inputs)] = np.zeros_like(zs[0])\n    rs[len(inputs)] = np.zeros_like(rs[0])\n    dh_list = errors\n    dh_list_out = np.zeros_like(dh_list)\n    dr_list = np.zeros((self.hidden_size, seq_len))\n    dz_list = np.zeros((self.hidden_size, seq_len))\n    dc_list = np.zeros((self.hidden_size, seq_len))\n    for t in reversed(range(seq_len)):\n        dha = np.multiply(dhnext, ones - zs[t + 1])\n        dhb = np.dot(self.Rhr.T, drbarnext)\n        dhc = np.dot(self.Rhz.T, dzbarnext)\n        dhd = np.multiply(rs[t + 1], np.dot(self.Rhc.T, dcbarnext))\n        dhe = dh_list[t]\n        dh = dha + dhb + dhc + dhd + dhe\n        dh_list_out[t] = dh\n        dc = np.multiply(dh, zs[t])\n        dcbar = np.multiply(dc, ones - np.square(cs[t]))\n        dr = np.multiply(hs[t - 1], np.dot(self.Rhc.T, dcbar))\n        dz = np.multiply(dh, cs[t] - hs[t - 1])\n        drbar = np.multiply(dr, np.multiply(rs[t], ones - rs[t]))\n        dzbar = np.multiply(dz, np.multiply(zs[t], ones - zs[t]))\n        dWxr += np.dot(drbar, xs[t].T)\n        dWxz += np.dot(dzbar, xs[t].T)\n        dWxc += np.dot(dcbar, xs[t].T)\n        dRhr += np.dot(drbar, hs[t - 1].T)\n        dRhz += np.dot(dzbar, hs[t - 1].T)\n        dRhc += np.dot(dcbar, np.multiply(rs[t], hs[t - 1]).T)\n        dbr += drbar\n        dbc += dcbar\n        dbz += dzbar\n        dhnext = dh\n        drbarnext = drbar\n        dzbarnext = dzbar\n        dcbarnext = dcbar\n        dr_list[:, t] = drbar.flatten()\n        dz_list[:, t] = dzbar.flatten()\n        dc_list[:, t] = dcbar.flatten()\n    dw = [dWxc, dWxr, dWxz, dRhc, dRhr, dRhz, dbc, dbr, dbz]\n    self.dW_ind_Wxc = 0\n    self.dW_ind_Wxr = 1\n    self.dW_ind_Wxz = 2\n    self.dW_ind_Rhc = 3\n    self.dW_ind_Rhr = 4\n    self.dW_ind_Rhz = 5\n    self.dW_ind_bc = 6\n    self.dW_ind_br = 7\n    self.dW_ind_bz = 8\n    return (dw, hs_list, dh_list_out, dr_list, dz_list, dc_list)",
        "mutated": [
            "def lossFun(self, inputs, errors, init_state=None):\n    if False:\n        i = 10\n    '\\n        Does a forward and backward pass on the network using (inputs, errors)\\n        inputs is a bit-vector of seq-length\\n        errors is a bit-vector of seq-length\\n        '\n    (xs, rbars, rs, zbars, zs, cbars, cs, hs) = ({}, {}, {}, {}, {}, {}, {}, {})\n    if init_state is None:\n        hs[-1] = np.zeros((self.hidden_size, 1))\n    else:\n        hs[-1] = init_state\n    seq_len = len(inputs)\n    hs_list = np.zeros((self.hidden_size, seq_len))\n    for t in range(seq_len):\n        xs[t] = np.matrix(inputs[t])\n        rbars[t] = np.dot(self.Wxr, xs[t]) + np.dot(self.Rhr, hs[t - 1]) + self.br\n        rs[t] = 1.0 / (1 + np.exp(-rbars[t]))\n        zbars[t] = np.dot(self.Wxz, xs[t]) + np.dot(self.Rhz, hs[t - 1]) + self.bz\n        zs[t] = 1.0 / (1 + np.exp(-zbars[t]))\n        cbars[t] = np.dot(self.Wxc, xs[t]) + np.dot(self.Rhc, np.multiply(rs[t], hs[t - 1])) + self.bc\n        cs[t] = np.tanh(cbars[t])\n        ones = np.ones_like(zs[t])\n        hs[t] = np.multiply(cs[t], zs[t]) + np.multiply(hs[t - 1], ones - zs[t])\n        hs_list[:, t] = hs[t].flatten()\n    dWxc = np.zeros_like(self.Wxc)\n    dWxr = np.zeros_like(self.Wxr)\n    dWxz = np.zeros_like(self.Wxz)\n    dRhc = np.zeros_like(self.Rhc)\n    dRhr = np.zeros_like(self.Rhr)\n    dRhz = np.zeros_like(self.Rhz)\n    dbc = np.zeros_like(self.bc)\n    dbr = np.zeros_like(self.br)\n    dbz = np.zeros_like(self.bz)\n    dhnext = np.zeros_like(hs[0])\n    drbarnext = np.zeros_like(rbars[0])\n    dzbarnext = np.zeros_like(zbars[0])\n    dcbarnext = np.zeros_like(cbars[0])\n    zs[len(inputs)] = np.zeros_like(zs[0])\n    rs[len(inputs)] = np.zeros_like(rs[0])\n    dh_list = errors\n    dh_list_out = np.zeros_like(dh_list)\n    dr_list = np.zeros((self.hidden_size, seq_len))\n    dz_list = np.zeros((self.hidden_size, seq_len))\n    dc_list = np.zeros((self.hidden_size, seq_len))\n    for t in reversed(range(seq_len)):\n        dha = np.multiply(dhnext, ones - zs[t + 1])\n        dhb = np.dot(self.Rhr.T, drbarnext)\n        dhc = np.dot(self.Rhz.T, dzbarnext)\n        dhd = np.multiply(rs[t + 1], np.dot(self.Rhc.T, dcbarnext))\n        dhe = dh_list[t]\n        dh = dha + dhb + dhc + dhd + dhe\n        dh_list_out[t] = dh\n        dc = np.multiply(dh, zs[t])\n        dcbar = np.multiply(dc, ones - np.square(cs[t]))\n        dr = np.multiply(hs[t - 1], np.dot(self.Rhc.T, dcbar))\n        dz = np.multiply(dh, cs[t] - hs[t - 1])\n        drbar = np.multiply(dr, np.multiply(rs[t], ones - rs[t]))\n        dzbar = np.multiply(dz, np.multiply(zs[t], ones - zs[t]))\n        dWxr += np.dot(drbar, xs[t].T)\n        dWxz += np.dot(dzbar, xs[t].T)\n        dWxc += np.dot(dcbar, xs[t].T)\n        dRhr += np.dot(drbar, hs[t - 1].T)\n        dRhz += np.dot(dzbar, hs[t - 1].T)\n        dRhc += np.dot(dcbar, np.multiply(rs[t], hs[t - 1]).T)\n        dbr += drbar\n        dbc += dcbar\n        dbz += dzbar\n        dhnext = dh\n        drbarnext = drbar\n        dzbarnext = dzbar\n        dcbarnext = dcbar\n        dr_list[:, t] = drbar.flatten()\n        dz_list[:, t] = dzbar.flatten()\n        dc_list[:, t] = dcbar.flatten()\n    dw = [dWxc, dWxr, dWxz, dRhc, dRhr, dRhz, dbc, dbr, dbz]\n    self.dW_ind_Wxc = 0\n    self.dW_ind_Wxr = 1\n    self.dW_ind_Wxz = 2\n    self.dW_ind_Rhc = 3\n    self.dW_ind_Rhr = 4\n    self.dW_ind_Rhz = 5\n    self.dW_ind_bc = 6\n    self.dW_ind_br = 7\n    self.dW_ind_bz = 8\n    return (dw, hs_list, dh_list_out, dr_list, dz_list, dc_list)",
            "def lossFun(self, inputs, errors, init_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Does a forward and backward pass on the network using (inputs, errors)\\n        inputs is a bit-vector of seq-length\\n        errors is a bit-vector of seq-length\\n        '\n    (xs, rbars, rs, zbars, zs, cbars, cs, hs) = ({}, {}, {}, {}, {}, {}, {}, {})\n    if init_state is None:\n        hs[-1] = np.zeros((self.hidden_size, 1))\n    else:\n        hs[-1] = init_state\n    seq_len = len(inputs)\n    hs_list = np.zeros((self.hidden_size, seq_len))\n    for t in range(seq_len):\n        xs[t] = np.matrix(inputs[t])\n        rbars[t] = np.dot(self.Wxr, xs[t]) + np.dot(self.Rhr, hs[t - 1]) + self.br\n        rs[t] = 1.0 / (1 + np.exp(-rbars[t]))\n        zbars[t] = np.dot(self.Wxz, xs[t]) + np.dot(self.Rhz, hs[t - 1]) + self.bz\n        zs[t] = 1.0 / (1 + np.exp(-zbars[t]))\n        cbars[t] = np.dot(self.Wxc, xs[t]) + np.dot(self.Rhc, np.multiply(rs[t], hs[t - 1])) + self.bc\n        cs[t] = np.tanh(cbars[t])\n        ones = np.ones_like(zs[t])\n        hs[t] = np.multiply(cs[t], zs[t]) + np.multiply(hs[t - 1], ones - zs[t])\n        hs_list[:, t] = hs[t].flatten()\n    dWxc = np.zeros_like(self.Wxc)\n    dWxr = np.zeros_like(self.Wxr)\n    dWxz = np.zeros_like(self.Wxz)\n    dRhc = np.zeros_like(self.Rhc)\n    dRhr = np.zeros_like(self.Rhr)\n    dRhz = np.zeros_like(self.Rhz)\n    dbc = np.zeros_like(self.bc)\n    dbr = np.zeros_like(self.br)\n    dbz = np.zeros_like(self.bz)\n    dhnext = np.zeros_like(hs[0])\n    drbarnext = np.zeros_like(rbars[0])\n    dzbarnext = np.zeros_like(zbars[0])\n    dcbarnext = np.zeros_like(cbars[0])\n    zs[len(inputs)] = np.zeros_like(zs[0])\n    rs[len(inputs)] = np.zeros_like(rs[0])\n    dh_list = errors\n    dh_list_out = np.zeros_like(dh_list)\n    dr_list = np.zeros((self.hidden_size, seq_len))\n    dz_list = np.zeros((self.hidden_size, seq_len))\n    dc_list = np.zeros((self.hidden_size, seq_len))\n    for t in reversed(range(seq_len)):\n        dha = np.multiply(dhnext, ones - zs[t + 1])\n        dhb = np.dot(self.Rhr.T, drbarnext)\n        dhc = np.dot(self.Rhz.T, dzbarnext)\n        dhd = np.multiply(rs[t + 1], np.dot(self.Rhc.T, dcbarnext))\n        dhe = dh_list[t]\n        dh = dha + dhb + dhc + dhd + dhe\n        dh_list_out[t] = dh\n        dc = np.multiply(dh, zs[t])\n        dcbar = np.multiply(dc, ones - np.square(cs[t]))\n        dr = np.multiply(hs[t - 1], np.dot(self.Rhc.T, dcbar))\n        dz = np.multiply(dh, cs[t] - hs[t - 1])\n        drbar = np.multiply(dr, np.multiply(rs[t], ones - rs[t]))\n        dzbar = np.multiply(dz, np.multiply(zs[t], ones - zs[t]))\n        dWxr += np.dot(drbar, xs[t].T)\n        dWxz += np.dot(dzbar, xs[t].T)\n        dWxc += np.dot(dcbar, xs[t].T)\n        dRhr += np.dot(drbar, hs[t - 1].T)\n        dRhz += np.dot(dzbar, hs[t - 1].T)\n        dRhc += np.dot(dcbar, np.multiply(rs[t], hs[t - 1]).T)\n        dbr += drbar\n        dbc += dcbar\n        dbz += dzbar\n        dhnext = dh\n        drbarnext = drbar\n        dzbarnext = dzbar\n        dcbarnext = dcbar\n        dr_list[:, t] = drbar.flatten()\n        dz_list[:, t] = dzbar.flatten()\n        dc_list[:, t] = dcbar.flatten()\n    dw = [dWxc, dWxr, dWxz, dRhc, dRhr, dRhz, dbc, dbr, dbz]\n    self.dW_ind_Wxc = 0\n    self.dW_ind_Wxr = 1\n    self.dW_ind_Wxz = 2\n    self.dW_ind_Rhc = 3\n    self.dW_ind_Rhr = 4\n    self.dW_ind_Rhz = 5\n    self.dW_ind_bc = 6\n    self.dW_ind_br = 7\n    self.dW_ind_bz = 8\n    return (dw, hs_list, dh_list_out, dr_list, dz_list, dc_list)",
            "def lossFun(self, inputs, errors, init_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Does a forward and backward pass on the network using (inputs, errors)\\n        inputs is a bit-vector of seq-length\\n        errors is a bit-vector of seq-length\\n        '\n    (xs, rbars, rs, zbars, zs, cbars, cs, hs) = ({}, {}, {}, {}, {}, {}, {}, {})\n    if init_state is None:\n        hs[-1] = np.zeros((self.hidden_size, 1))\n    else:\n        hs[-1] = init_state\n    seq_len = len(inputs)\n    hs_list = np.zeros((self.hidden_size, seq_len))\n    for t in range(seq_len):\n        xs[t] = np.matrix(inputs[t])\n        rbars[t] = np.dot(self.Wxr, xs[t]) + np.dot(self.Rhr, hs[t - 1]) + self.br\n        rs[t] = 1.0 / (1 + np.exp(-rbars[t]))\n        zbars[t] = np.dot(self.Wxz, xs[t]) + np.dot(self.Rhz, hs[t - 1]) + self.bz\n        zs[t] = 1.0 / (1 + np.exp(-zbars[t]))\n        cbars[t] = np.dot(self.Wxc, xs[t]) + np.dot(self.Rhc, np.multiply(rs[t], hs[t - 1])) + self.bc\n        cs[t] = np.tanh(cbars[t])\n        ones = np.ones_like(zs[t])\n        hs[t] = np.multiply(cs[t], zs[t]) + np.multiply(hs[t - 1], ones - zs[t])\n        hs_list[:, t] = hs[t].flatten()\n    dWxc = np.zeros_like(self.Wxc)\n    dWxr = np.zeros_like(self.Wxr)\n    dWxz = np.zeros_like(self.Wxz)\n    dRhc = np.zeros_like(self.Rhc)\n    dRhr = np.zeros_like(self.Rhr)\n    dRhz = np.zeros_like(self.Rhz)\n    dbc = np.zeros_like(self.bc)\n    dbr = np.zeros_like(self.br)\n    dbz = np.zeros_like(self.bz)\n    dhnext = np.zeros_like(hs[0])\n    drbarnext = np.zeros_like(rbars[0])\n    dzbarnext = np.zeros_like(zbars[0])\n    dcbarnext = np.zeros_like(cbars[0])\n    zs[len(inputs)] = np.zeros_like(zs[0])\n    rs[len(inputs)] = np.zeros_like(rs[0])\n    dh_list = errors\n    dh_list_out = np.zeros_like(dh_list)\n    dr_list = np.zeros((self.hidden_size, seq_len))\n    dz_list = np.zeros((self.hidden_size, seq_len))\n    dc_list = np.zeros((self.hidden_size, seq_len))\n    for t in reversed(range(seq_len)):\n        dha = np.multiply(dhnext, ones - zs[t + 1])\n        dhb = np.dot(self.Rhr.T, drbarnext)\n        dhc = np.dot(self.Rhz.T, dzbarnext)\n        dhd = np.multiply(rs[t + 1], np.dot(self.Rhc.T, dcbarnext))\n        dhe = dh_list[t]\n        dh = dha + dhb + dhc + dhd + dhe\n        dh_list_out[t] = dh\n        dc = np.multiply(dh, zs[t])\n        dcbar = np.multiply(dc, ones - np.square(cs[t]))\n        dr = np.multiply(hs[t - 1], np.dot(self.Rhc.T, dcbar))\n        dz = np.multiply(dh, cs[t] - hs[t - 1])\n        drbar = np.multiply(dr, np.multiply(rs[t], ones - rs[t]))\n        dzbar = np.multiply(dz, np.multiply(zs[t], ones - zs[t]))\n        dWxr += np.dot(drbar, xs[t].T)\n        dWxz += np.dot(dzbar, xs[t].T)\n        dWxc += np.dot(dcbar, xs[t].T)\n        dRhr += np.dot(drbar, hs[t - 1].T)\n        dRhz += np.dot(dzbar, hs[t - 1].T)\n        dRhc += np.dot(dcbar, np.multiply(rs[t], hs[t - 1]).T)\n        dbr += drbar\n        dbc += dcbar\n        dbz += dzbar\n        dhnext = dh\n        drbarnext = drbar\n        dzbarnext = dzbar\n        dcbarnext = dcbar\n        dr_list[:, t] = drbar.flatten()\n        dz_list[:, t] = dzbar.flatten()\n        dc_list[:, t] = dcbar.flatten()\n    dw = [dWxc, dWxr, dWxz, dRhc, dRhr, dRhz, dbc, dbr, dbz]\n    self.dW_ind_Wxc = 0\n    self.dW_ind_Wxr = 1\n    self.dW_ind_Wxz = 2\n    self.dW_ind_Rhc = 3\n    self.dW_ind_Rhr = 4\n    self.dW_ind_Rhz = 5\n    self.dW_ind_bc = 6\n    self.dW_ind_br = 7\n    self.dW_ind_bz = 8\n    return (dw, hs_list, dh_list_out, dr_list, dz_list, dc_list)",
            "def lossFun(self, inputs, errors, init_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Does a forward and backward pass on the network using (inputs, errors)\\n        inputs is a bit-vector of seq-length\\n        errors is a bit-vector of seq-length\\n        '\n    (xs, rbars, rs, zbars, zs, cbars, cs, hs) = ({}, {}, {}, {}, {}, {}, {}, {})\n    if init_state is None:\n        hs[-1] = np.zeros((self.hidden_size, 1))\n    else:\n        hs[-1] = init_state\n    seq_len = len(inputs)\n    hs_list = np.zeros((self.hidden_size, seq_len))\n    for t in range(seq_len):\n        xs[t] = np.matrix(inputs[t])\n        rbars[t] = np.dot(self.Wxr, xs[t]) + np.dot(self.Rhr, hs[t - 1]) + self.br\n        rs[t] = 1.0 / (1 + np.exp(-rbars[t]))\n        zbars[t] = np.dot(self.Wxz, xs[t]) + np.dot(self.Rhz, hs[t - 1]) + self.bz\n        zs[t] = 1.0 / (1 + np.exp(-zbars[t]))\n        cbars[t] = np.dot(self.Wxc, xs[t]) + np.dot(self.Rhc, np.multiply(rs[t], hs[t - 1])) + self.bc\n        cs[t] = np.tanh(cbars[t])\n        ones = np.ones_like(zs[t])\n        hs[t] = np.multiply(cs[t], zs[t]) + np.multiply(hs[t - 1], ones - zs[t])\n        hs_list[:, t] = hs[t].flatten()\n    dWxc = np.zeros_like(self.Wxc)\n    dWxr = np.zeros_like(self.Wxr)\n    dWxz = np.zeros_like(self.Wxz)\n    dRhc = np.zeros_like(self.Rhc)\n    dRhr = np.zeros_like(self.Rhr)\n    dRhz = np.zeros_like(self.Rhz)\n    dbc = np.zeros_like(self.bc)\n    dbr = np.zeros_like(self.br)\n    dbz = np.zeros_like(self.bz)\n    dhnext = np.zeros_like(hs[0])\n    drbarnext = np.zeros_like(rbars[0])\n    dzbarnext = np.zeros_like(zbars[0])\n    dcbarnext = np.zeros_like(cbars[0])\n    zs[len(inputs)] = np.zeros_like(zs[0])\n    rs[len(inputs)] = np.zeros_like(rs[0])\n    dh_list = errors\n    dh_list_out = np.zeros_like(dh_list)\n    dr_list = np.zeros((self.hidden_size, seq_len))\n    dz_list = np.zeros((self.hidden_size, seq_len))\n    dc_list = np.zeros((self.hidden_size, seq_len))\n    for t in reversed(range(seq_len)):\n        dha = np.multiply(dhnext, ones - zs[t + 1])\n        dhb = np.dot(self.Rhr.T, drbarnext)\n        dhc = np.dot(self.Rhz.T, dzbarnext)\n        dhd = np.multiply(rs[t + 1], np.dot(self.Rhc.T, dcbarnext))\n        dhe = dh_list[t]\n        dh = dha + dhb + dhc + dhd + dhe\n        dh_list_out[t] = dh\n        dc = np.multiply(dh, zs[t])\n        dcbar = np.multiply(dc, ones - np.square(cs[t]))\n        dr = np.multiply(hs[t - 1], np.dot(self.Rhc.T, dcbar))\n        dz = np.multiply(dh, cs[t] - hs[t - 1])\n        drbar = np.multiply(dr, np.multiply(rs[t], ones - rs[t]))\n        dzbar = np.multiply(dz, np.multiply(zs[t], ones - zs[t]))\n        dWxr += np.dot(drbar, xs[t].T)\n        dWxz += np.dot(dzbar, xs[t].T)\n        dWxc += np.dot(dcbar, xs[t].T)\n        dRhr += np.dot(drbar, hs[t - 1].T)\n        dRhz += np.dot(dzbar, hs[t - 1].T)\n        dRhc += np.dot(dcbar, np.multiply(rs[t], hs[t - 1]).T)\n        dbr += drbar\n        dbc += dcbar\n        dbz += dzbar\n        dhnext = dh\n        drbarnext = drbar\n        dzbarnext = dzbar\n        dcbarnext = dcbar\n        dr_list[:, t] = drbar.flatten()\n        dz_list[:, t] = dzbar.flatten()\n        dc_list[:, t] = dcbar.flatten()\n    dw = [dWxc, dWxr, dWxz, dRhc, dRhr, dRhz, dbc, dbr, dbz]\n    self.dW_ind_Wxc = 0\n    self.dW_ind_Wxr = 1\n    self.dW_ind_Wxz = 2\n    self.dW_ind_Rhc = 3\n    self.dW_ind_Rhr = 4\n    self.dW_ind_Rhz = 5\n    self.dW_ind_bc = 6\n    self.dW_ind_br = 7\n    self.dW_ind_bz = 8\n    return (dw, hs_list, dh_list_out, dr_list, dz_list, dc_list)",
            "def lossFun(self, inputs, errors, init_state=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Does a forward and backward pass on the network using (inputs, errors)\\n        inputs is a bit-vector of seq-length\\n        errors is a bit-vector of seq-length\\n        '\n    (xs, rbars, rs, zbars, zs, cbars, cs, hs) = ({}, {}, {}, {}, {}, {}, {}, {})\n    if init_state is None:\n        hs[-1] = np.zeros((self.hidden_size, 1))\n    else:\n        hs[-1] = init_state\n    seq_len = len(inputs)\n    hs_list = np.zeros((self.hidden_size, seq_len))\n    for t in range(seq_len):\n        xs[t] = np.matrix(inputs[t])\n        rbars[t] = np.dot(self.Wxr, xs[t]) + np.dot(self.Rhr, hs[t - 1]) + self.br\n        rs[t] = 1.0 / (1 + np.exp(-rbars[t]))\n        zbars[t] = np.dot(self.Wxz, xs[t]) + np.dot(self.Rhz, hs[t - 1]) + self.bz\n        zs[t] = 1.0 / (1 + np.exp(-zbars[t]))\n        cbars[t] = np.dot(self.Wxc, xs[t]) + np.dot(self.Rhc, np.multiply(rs[t], hs[t - 1])) + self.bc\n        cs[t] = np.tanh(cbars[t])\n        ones = np.ones_like(zs[t])\n        hs[t] = np.multiply(cs[t], zs[t]) + np.multiply(hs[t - 1], ones - zs[t])\n        hs_list[:, t] = hs[t].flatten()\n    dWxc = np.zeros_like(self.Wxc)\n    dWxr = np.zeros_like(self.Wxr)\n    dWxz = np.zeros_like(self.Wxz)\n    dRhc = np.zeros_like(self.Rhc)\n    dRhr = np.zeros_like(self.Rhr)\n    dRhz = np.zeros_like(self.Rhz)\n    dbc = np.zeros_like(self.bc)\n    dbr = np.zeros_like(self.br)\n    dbz = np.zeros_like(self.bz)\n    dhnext = np.zeros_like(hs[0])\n    drbarnext = np.zeros_like(rbars[0])\n    dzbarnext = np.zeros_like(zbars[0])\n    dcbarnext = np.zeros_like(cbars[0])\n    zs[len(inputs)] = np.zeros_like(zs[0])\n    rs[len(inputs)] = np.zeros_like(rs[0])\n    dh_list = errors\n    dh_list_out = np.zeros_like(dh_list)\n    dr_list = np.zeros((self.hidden_size, seq_len))\n    dz_list = np.zeros((self.hidden_size, seq_len))\n    dc_list = np.zeros((self.hidden_size, seq_len))\n    for t in reversed(range(seq_len)):\n        dha = np.multiply(dhnext, ones - zs[t + 1])\n        dhb = np.dot(self.Rhr.T, drbarnext)\n        dhc = np.dot(self.Rhz.T, dzbarnext)\n        dhd = np.multiply(rs[t + 1], np.dot(self.Rhc.T, dcbarnext))\n        dhe = dh_list[t]\n        dh = dha + dhb + dhc + dhd + dhe\n        dh_list_out[t] = dh\n        dc = np.multiply(dh, zs[t])\n        dcbar = np.multiply(dc, ones - np.square(cs[t]))\n        dr = np.multiply(hs[t - 1], np.dot(self.Rhc.T, dcbar))\n        dz = np.multiply(dh, cs[t] - hs[t - 1])\n        drbar = np.multiply(dr, np.multiply(rs[t], ones - rs[t]))\n        dzbar = np.multiply(dz, np.multiply(zs[t], ones - zs[t]))\n        dWxr += np.dot(drbar, xs[t].T)\n        dWxz += np.dot(dzbar, xs[t].T)\n        dWxc += np.dot(dcbar, xs[t].T)\n        dRhr += np.dot(drbar, hs[t - 1].T)\n        dRhz += np.dot(dzbar, hs[t - 1].T)\n        dRhc += np.dot(dcbar, np.multiply(rs[t], hs[t - 1]).T)\n        dbr += drbar\n        dbc += dcbar\n        dbz += dzbar\n        dhnext = dh\n        drbarnext = drbar\n        dzbarnext = dzbar\n        dcbarnext = dcbar\n        dr_list[:, t] = drbar.flatten()\n        dz_list[:, t] = dzbar.flatten()\n        dc_list[:, t] = dcbar.flatten()\n    dw = [dWxc, dWxr, dWxz, dRhc, dRhr, dRhz, dbc, dbr, dbz]\n    self.dW_ind_Wxc = 0\n    self.dW_ind_Wxr = 1\n    self.dW_ind_Wxz = 2\n    self.dW_ind_Rhc = 3\n    self.dW_ind_Rhr = 4\n    self.dW_ind_Rhz = 5\n    self.dW_ind_bc = 6\n    self.dW_ind_br = 7\n    self.dW_ind_bz = 8\n    return (dw, hs_list, dh_list_out, dr_list, dz_list, dc_list)"
        ]
    }
]