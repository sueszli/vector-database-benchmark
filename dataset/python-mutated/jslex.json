[
    {
        "func_name": "__init__",
        "original": "def __init__(self, name, regex, next=None):\n    self.id = Tok.num\n    Tok.num += 1\n    self.name = name\n    self.regex = regex\n    self.next = next",
        "mutated": [
            "def __init__(self, name, regex, next=None):\n    if False:\n        i = 10\n    self.id = Tok.num\n    Tok.num += 1\n    self.name = name\n    self.regex = regex\n    self.next = next",
            "def __init__(self, name, regex, next=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.id = Tok.num\n    Tok.num += 1\n    self.name = name\n    self.regex = regex\n    self.next = next",
            "def __init__(self, name, regex, next=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.id = Tok.num\n    Tok.num += 1\n    self.name = name\n    self.regex = regex\n    self.next = next",
            "def __init__(self, name, regex, next=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.id = Tok.num\n    Tok.num += 1\n    self.name = name\n    self.regex = regex\n    self.next = next",
            "def __init__(self, name, regex, next=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.id = Tok.num\n    Tok.num += 1\n    self.name = name\n    self.regex = regex\n    self.next = next"
        ]
    },
    {
        "func_name": "literals",
        "original": "def literals(choices, prefix='', suffix=''):\n    \"\"\"\n    Create a regex from a space-separated list of literal `choices`.\n\n    If provided, `prefix` and `suffix` will be attached to each choice\n    individually.\n    \"\"\"\n    return '|'.join((prefix + re.escape(c) + suffix for c in choices.split()))",
        "mutated": [
            "def literals(choices, prefix='', suffix=''):\n    if False:\n        i = 10\n    '\\n    Create a regex from a space-separated list of literal `choices`.\\n\\n    If provided, `prefix` and `suffix` will be attached to each choice\\n    individually.\\n    '\n    return '|'.join((prefix + re.escape(c) + suffix for c in choices.split()))",
            "def literals(choices, prefix='', suffix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create a regex from a space-separated list of literal `choices`.\\n\\n    If provided, `prefix` and `suffix` will be attached to each choice\\n    individually.\\n    '\n    return '|'.join((prefix + re.escape(c) + suffix for c in choices.split()))",
            "def literals(choices, prefix='', suffix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create a regex from a space-separated list of literal `choices`.\\n\\n    If provided, `prefix` and `suffix` will be attached to each choice\\n    individually.\\n    '\n    return '|'.join((prefix + re.escape(c) + suffix for c in choices.split()))",
            "def literals(choices, prefix='', suffix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create a regex from a space-separated list of literal `choices`.\\n\\n    If provided, `prefix` and `suffix` will be attached to each choice\\n    individually.\\n    '\n    return '|'.join((prefix + re.escape(c) + suffix for c in choices.split()))",
            "def literals(choices, prefix='', suffix=''):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create a regex from a space-separated list of literal `choices`.\\n\\n    If provided, `prefix` and `suffix` will be attached to each choice\\n    individually.\\n    '\n    return '|'.join((prefix + re.escape(c) + suffix for c in choices.split()))"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, states, first):\n    self.regexes = {}\n    self.toks = {}\n    for (state, rules) in states.items():\n        parts = []\n        for tok in rules:\n            groupid = 't%d' % tok.id\n            self.toks[groupid] = tok\n            parts.append('(?P<%s>%s)' % (groupid, tok.regex))\n        self.regexes[state] = re.compile('|'.join(parts), re.MULTILINE | re.VERBOSE)\n    self.state = first",
        "mutated": [
            "def __init__(self, states, first):\n    if False:\n        i = 10\n    self.regexes = {}\n    self.toks = {}\n    for (state, rules) in states.items():\n        parts = []\n        for tok in rules:\n            groupid = 't%d' % tok.id\n            self.toks[groupid] = tok\n            parts.append('(?P<%s>%s)' % (groupid, tok.regex))\n        self.regexes[state] = re.compile('|'.join(parts), re.MULTILINE | re.VERBOSE)\n    self.state = first",
            "def __init__(self, states, first):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.regexes = {}\n    self.toks = {}\n    for (state, rules) in states.items():\n        parts = []\n        for tok in rules:\n            groupid = 't%d' % tok.id\n            self.toks[groupid] = tok\n            parts.append('(?P<%s>%s)' % (groupid, tok.regex))\n        self.regexes[state] = re.compile('|'.join(parts), re.MULTILINE | re.VERBOSE)\n    self.state = first",
            "def __init__(self, states, first):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.regexes = {}\n    self.toks = {}\n    for (state, rules) in states.items():\n        parts = []\n        for tok in rules:\n            groupid = 't%d' % tok.id\n            self.toks[groupid] = tok\n            parts.append('(?P<%s>%s)' % (groupid, tok.regex))\n        self.regexes[state] = re.compile('|'.join(parts), re.MULTILINE | re.VERBOSE)\n    self.state = first",
            "def __init__(self, states, first):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.regexes = {}\n    self.toks = {}\n    for (state, rules) in states.items():\n        parts = []\n        for tok in rules:\n            groupid = 't%d' % tok.id\n            self.toks[groupid] = tok\n            parts.append('(?P<%s>%s)' % (groupid, tok.regex))\n        self.regexes[state] = re.compile('|'.join(parts), re.MULTILINE | re.VERBOSE)\n    self.state = first",
            "def __init__(self, states, first):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.regexes = {}\n    self.toks = {}\n    for (state, rules) in states.items():\n        parts = []\n        for tok in rules:\n            groupid = 't%d' % tok.id\n            self.toks[groupid] = tok\n            parts.append('(?P<%s>%s)' % (groupid, tok.regex))\n        self.regexes[state] = re.compile('|'.join(parts), re.MULTILINE | re.VERBOSE)\n    self.state = first"
        ]
    },
    {
        "func_name": "lex",
        "original": "def lex(self, text):\n    \"\"\"\n        Lexically analyze `text`.\n\n        Yield pairs (`name`, `tokentext`).\n        \"\"\"\n    end = len(text)\n    state = self.state\n    regexes = self.regexes\n    toks = self.toks\n    start = 0\n    while start < end:\n        for match in regexes[state].finditer(text, start):\n            name = match.lastgroup\n            tok = toks[name]\n            toktext = match[name]\n            start += len(toktext)\n            yield (tok.name, toktext)\n            if tok.next:\n                state = tok.next\n                break\n    self.state = state",
        "mutated": [
            "def lex(self, text):\n    if False:\n        i = 10\n    '\\n        Lexically analyze `text`.\\n\\n        Yield pairs (`name`, `tokentext`).\\n        '\n    end = len(text)\n    state = self.state\n    regexes = self.regexes\n    toks = self.toks\n    start = 0\n    while start < end:\n        for match in regexes[state].finditer(text, start):\n            name = match.lastgroup\n            tok = toks[name]\n            toktext = match[name]\n            start += len(toktext)\n            yield (tok.name, toktext)\n            if tok.next:\n                state = tok.next\n                break\n    self.state = state",
            "def lex(self, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n        Lexically analyze `text`.\\n\\n        Yield pairs (`name`, `tokentext`).\\n        '\n    end = len(text)\n    state = self.state\n    regexes = self.regexes\n    toks = self.toks\n    start = 0\n    while start < end:\n        for match in regexes[state].finditer(text, start):\n            name = match.lastgroup\n            tok = toks[name]\n            toktext = match[name]\n            start += len(toktext)\n            yield (tok.name, toktext)\n            if tok.next:\n                state = tok.next\n                break\n    self.state = state",
            "def lex(self, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n        Lexically analyze `text`.\\n\\n        Yield pairs (`name`, `tokentext`).\\n        '\n    end = len(text)\n    state = self.state\n    regexes = self.regexes\n    toks = self.toks\n    start = 0\n    while start < end:\n        for match in regexes[state].finditer(text, start):\n            name = match.lastgroup\n            tok = toks[name]\n            toktext = match[name]\n            start += len(toktext)\n            yield (tok.name, toktext)\n            if tok.next:\n                state = tok.next\n                break\n    self.state = state",
            "def lex(self, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n        Lexically analyze `text`.\\n\\n        Yield pairs (`name`, `tokentext`).\\n        '\n    end = len(text)\n    state = self.state\n    regexes = self.regexes\n    toks = self.toks\n    start = 0\n    while start < end:\n        for match in regexes[state].finditer(text, start):\n            name = match.lastgroup\n            tok = toks[name]\n            toktext = match[name]\n            start += len(toktext)\n            yield (tok.name, toktext)\n            if tok.next:\n                state = tok.next\n                break\n    self.state = state",
            "def lex(self, text):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n        Lexically analyze `text`.\\n\\n        Yield pairs (`name`, `tokentext`).\\n        '\n    end = len(text)\n    state = self.state\n    regexes = self.regexes\n    toks = self.toks\n    start = 0\n    while start < end:\n        for match in regexes[state].finditer(text, start):\n            name = match.lastgroup\n            tok = toks[name]\n            toktext = match[name]\n            start += len(toktext)\n            yield (tok.name, toktext)\n            if tok.next:\n                state = tok.next\n                break\n    self.state = state"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self):\n    super().__init__(self.states, 'reg')",
        "mutated": [
            "def __init__(self):\n    if False:\n        i = 10\n    super().__init__(self.states, 'reg')",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    super().__init__(self.states, 'reg')",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    super().__init__(self.states, 'reg')",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    super().__init__(self.states, 'reg')",
            "def __init__(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    super().__init__(self.states, 'reg')"
        ]
    },
    {
        "func_name": "escape_quotes",
        "original": "def escape_quotes(m):\n    \"\"\"Used in a regex to properly escape double quotes.\"\"\"\n    s = m[0]\n    if s == '\"':\n        return '\\\\\"'\n    else:\n        return s",
        "mutated": [
            "def escape_quotes(m):\n    if False:\n        i = 10\n    'Used in a regex to properly escape double quotes.'\n    s = m[0]\n    if s == '\"':\n        return '\\\\\"'\n    else:\n        return s",
            "def escape_quotes(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Used in a regex to properly escape double quotes.'\n    s = m[0]\n    if s == '\"':\n        return '\\\\\"'\n    else:\n        return s",
            "def escape_quotes(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Used in a regex to properly escape double quotes.'\n    s = m[0]\n    if s == '\"':\n        return '\\\\\"'\n    else:\n        return s",
            "def escape_quotes(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Used in a regex to properly escape double quotes.'\n    s = m[0]\n    if s == '\"':\n        return '\\\\\"'\n    else:\n        return s",
            "def escape_quotes(m):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Used in a regex to properly escape double quotes.'\n    s = m[0]\n    if s == '\"':\n        return '\\\\\"'\n    else:\n        return s"
        ]
    },
    {
        "func_name": "prepare_js_for_gettext",
        "original": "def prepare_js_for_gettext(js):\n    \"\"\"\n    Convert the JavaScript source `js` into something resembling C for\n    xgettext.\n\n    What actually happens is that all the regex literals are replaced with\n    \"REGEX\".\n    \"\"\"\n\n    def escape_quotes(m):\n        \"\"\"Used in a regex to properly escape double quotes.\"\"\"\n        s = m[0]\n        if s == '\"':\n            return '\\\\\"'\n        else:\n            return s\n    lexer = JsLexer()\n    c = []\n    for (name, tok) in lexer.lex(js):\n        if name == 'regex':\n            tok = '\"REGEX\"'\n        elif name == 'string':\n            if tok.startswith(\"'\"):\n                guts = re.sub('\\\\\\\\.|.', escape_quotes, tok[1:-1])\n                tok = '\"' + guts + '\"'\n        elif name == 'id':\n            tok = tok.replace('\\\\', 'U')\n        c.append(tok)\n    return ''.join(c)",
        "mutated": [
            "def prepare_js_for_gettext(js):\n    if False:\n        i = 10\n    '\\n    Convert the JavaScript source `js` into something resembling C for\\n    xgettext.\\n\\n    What actually happens is that all the regex literals are replaced with\\n    \"REGEX\".\\n    '\n\n    def escape_quotes(m):\n        \"\"\"Used in a regex to properly escape double quotes.\"\"\"\n        s = m[0]\n        if s == '\"':\n            return '\\\\\"'\n        else:\n            return s\n    lexer = JsLexer()\n    c = []\n    for (name, tok) in lexer.lex(js):\n        if name == 'regex':\n            tok = '\"REGEX\"'\n        elif name == 'string':\n            if tok.startswith(\"'\"):\n                guts = re.sub('\\\\\\\\.|.', escape_quotes, tok[1:-1])\n                tok = '\"' + guts + '\"'\n        elif name == 'id':\n            tok = tok.replace('\\\\', 'U')\n        c.append(tok)\n    return ''.join(c)",
            "def prepare_js_for_gettext(js):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Convert the JavaScript source `js` into something resembling C for\\n    xgettext.\\n\\n    What actually happens is that all the regex literals are replaced with\\n    \"REGEX\".\\n    '\n\n    def escape_quotes(m):\n        \"\"\"Used in a regex to properly escape double quotes.\"\"\"\n        s = m[0]\n        if s == '\"':\n            return '\\\\\"'\n        else:\n            return s\n    lexer = JsLexer()\n    c = []\n    for (name, tok) in lexer.lex(js):\n        if name == 'regex':\n            tok = '\"REGEX\"'\n        elif name == 'string':\n            if tok.startswith(\"'\"):\n                guts = re.sub('\\\\\\\\.|.', escape_quotes, tok[1:-1])\n                tok = '\"' + guts + '\"'\n        elif name == 'id':\n            tok = tok.replace('\\\\', 'U')\n        c.append(tok)\n    return ''.join(c)",
            "def prepare_js_for_gettext(js):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Convert the JavaScript source `js` into something resembling C for\\n    xgettext.\\n\\n    What actually happens is that all the regex literals are replaced with\\n    \"REGEX\".\\n    '\n\n    def escape_quotes(m):\n        \"\"\"Used in a regex to properly escape double quotes.\"\"\"\n        s = m[0]\n        if s == '\"':\n            return '\\\\\"'\n        else:\n            return s\n    lexer = JsLexer()\n    c = []\n    for (name, tok) in lexer.lex(js):\n        if name == 'regex':\n            tok = '\"REGEX\"'\n        elif name == 'string':\n            if tok.startswith(\"'\"):\n                guts = re.sub('\\\\\\\\.|.', escape_quotes, tok[1:-1])\n                tok = '\"' + guts + '\"'\n        elif name == 'id':\n            tok = tok.replace('\\\\', 'U')\n        c.append(tok)\n    return ''.join(c)",
            "def prepare_js_for_gettext(js):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Convert the JavaScript source `js` into something resembling C for\\n    xgettext.\\n\\n    What actually happens is that all the regex literals are replaced with\\n    \"REGEX\".\\n    '\n\n    def escape_quotes(m):\n        \"\"\"Used in a regex to properly escape double quotes.\"\"\"\n        s = m[0]\n        if s == '\"':\n            return '\\\\\"'\n        else:\n            return s\n    lexer = JsLexer()\n    c = []\n    for (name, tok) in lexer.lex(js):\n        if name == 'regex':\n            tok = '\"REGEX\"'\n        elif name == 'string':\n            if tok.startswith(\"'\"):\n                guts = re.sub('\\\\\\\\.|.', escape_quotes, tok[1:-1])\n                tok = '\"' + guts + '\"'\n        elif name == 'id':\n            tok = tok.replace('\\\\', 'U')\n        c.append(tok)\n    return ''.join(c)",
            "def prepare_js_for_gettext(js):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Convert the JavaScript source `js` into something resembling C for\\n    xgettext.\\n\\n    What actually happens is that all the regex literals are replaced with\\n    \"REGEX\".\\n    '\n\n    def escape_quotes(m):\n        \"\"\"Used in a regex to properly escape double quotes.\"\"\"\n        s = m[0]\n        if s == '\"':\n            return '\\\\\"'\n        else:\n            return s\n    lexer = JsLexer()\n    c = []\n    for (name, tok) in lexer.lex(js):\n        if name == 'regex':\n            tok = '\"REGEX\"'\n        elif name == 'string':\n            if tok.startswith(\"'\"):\n                guts = re.sub('\\\\\\\\.|.', escape_quotes, tok[1:-1])\n                tok = '\"' + guts + '\"'\n        elif name == 'id':\n            tok = tok.replace('\\\\', 'U')\n        c.append(tok)\n    return ''.join(c)"
        ]
    }
]