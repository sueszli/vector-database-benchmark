[
    {
        "func_name": "__init__",
        "original": "def __init__(self, settlement_date, fixing_date, fixed_rate, notional=1.0, daycount_convention=None, rate_term=None, maturity_date=None, dtype=None, name=None):\n    \"\"\"Initialize the batch of FRA contracts.\n\n    Args:\n      settlement_date: A rank 1 `DateTensor` specifying the dates on which\n        cashflows are settled. The shape of the input correspond to the number\n        of instruments being created.\n      fixing_date: A rank 1 `DateTensor` specifying the dates on which forward\n        rate will be fixed. The shape of the inout should be the same as that of\n        `settlement_date`.\n      fixed_rate: A rank 1 `Tensor` of real dtype specifying the fixed rate\n        payment agreed at the initiation of the individual contracts. The shape\n        should be the same as that of `settlement_date`.\n      notional: A scalar or a rank 1 `Tensor` of real dtype specifying the\n        notional amount for each contract. When the notional is specified as a\n        scalar, it is assumed that all contracts have the same notional. If the\n        notional is in the form of a `Tensor`, then the shape must be the same\n        as `settlement_date`.\n        Default value: 1.0\n      daycount_convention: An optional `DayCountConvention` to determine\n        how cashflows are accrued for each contract. Daycount is assumed to be\n        the same for all contracts in a given batch.\n        Default value: None in which case the daycount convention will default\n        to DayCountConvention.ACTUAL_360 for all contracts.\n      rate_term: An optional rank 1 `PeriodTensor` specifying the term (or the\n        tenor) of the Libor rate that determines the floating cashflow. The\n        shape of the input should be the same as `settlement_date`.\n        Default value: `None` in which case the the forward rate is determined\n        for the period [settlement_date, maturity_date].\n      maturity_date: An optional rank 1 `DateTensor` specifying the maturity of\n        the underlying forward rate for each contract. This input is only used\n        if the input `rate_term` is `None`.\n        Default value: `None`\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\n        either supplied to the FRA object or created by the FRA object.\n        Default value: None which maps to the default dtype inferred by\n        TensorFlow.\n      name: Python str. The name to give to the ops created by this class.\n        Default value: `None` which maps to 'forward_rate_agreement'.\n\n    Raises:\n      ValueError: If both `maturity_date` and `rate_term` are unspecified.\n    \"\"\"\n    self._name = name or 'forward_rate_agreement'\n    if rate_term is None and maturity_date is None:\n        raise ValueError('Error creating FRA. Either rate_term or maturity_date is required.')\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._notional = tf.convert_to_tensor(notional, dtype=self._dtype)\n        self._fixing_date = dates.convert_to_date_tensor(fixing_date)\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._accrual_start_date = dates.convert_to_date_tensor(settlement_date)\n        if rate_term is None:\n            self._accrual_end_date = dates.convert_to_date_tensor(maturity_date)\n        else:\n            self._accrual_end_date = self._accrual_start_date + rate_term\n        if daycount_convention is None:\n            daycount_convention = rc.DayCountConvention.ACTUAL_360\n        self._fixed_rate = tf.convert_to_tensor(fixed_rate, dtype=self._dtype, name='fixed_rate')\n        self._daycount_convention = daycount_convention\n        self._daycount_fraction = rc.get_daycount_fraction(self._accrual_start_date, self._accrual_end_date, self._daycount_convention, self._dtype)",
        "mutated": [
            "def __init__(self, settlement_date, fixing_date, fixed_rate, notional=1.0, daycount_convention=None, rate_term=None, maturity_date=None, dtype=None, name=None):\n    if False:\n        i = 10\n    \"Initialize the batch of FRA contracts.\\n\\n    Args:\\n      settlement_date: A rank 1 `DateTensor` specifying the dates on which\\n        cashflows are settled. The shape of the input correspond to the number\\n        of instruments being created.\\n      fixing_date: A rank 1 `DateTensor` specifying the dates on which forward\\n        rate will be fixed. The shape of the inout should be the same as that of\\n        `settlement_date`.\\n      fixed_rate: A rank 1 `Tensor` of real dtype specifying the fixed rate\\n        payment agreed at the initiation of the individual contracts. The shape\\n        should be the same as that of `settlement_date`.\\n      notional: A scalar or a rank 1 `Tensor` of real dtype specifying the\\n        notional amount for each contract. When the notional is specified as a\\n        scalar, it is assumed that all contracts have the same notional. If the\\n        notional is in the form of a `Tensor`, then the shape must be the same\\n        as `settlement_date`.\\n        Default value: 1.0\\n      daycount_convention: An optional `DayCountConvention` to determine\\n        how cashflows are accrued for each contract. Daycount is assumed to be\\n        the same for all contracts in a given batch.\\n        Default value: None in which case the daycount convention will default\\n        to DayCountConvention.ACTUAL_360 for all contracts.\\n      rate_term: An optional rank 1 `PeriodTensor` specifying the term (or the\\n        tenor) of the Libor rate that determines the floating cashflow. The\\n        shape of the input should be the same as `settlement_date`.\\n        Default value: `None` in which case the the forward rate is determined\\n        for the period [settlement_date, maturity_date].\\n      maturity_date: An optional rank 1 `DateTensor` specifying the maturity of\\n        the underlying forward rate for each contract. This input is only used\\n        if the input `rate_term` is `None`.\\n        Default value: `None`\\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\\n        either supplied to the FRA object or created by the FRA object.\\n        Default value: None which maps to the default dtype inferred by\\n        TensorFlow.\\n      name: Python str. The name to give to the ops created by this class.\\n        Default value: `None` which maps to 'forward_rate_agreement'.\\n\\n    Raises:\\n      ValueError: If both `maturity_date` and `rate_term` are unspecified.\\n    \"\n    self._name = name or 'forward_rate_agreement'\n    if rate_term is None and maturity_date is None:\n        raise ValueError('Error creating FRA. Either rate_term or maturity_date is required.')\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._notional = tf.convert_to_tensor(notional, dtype=self._dtype)\n        self._fixing_date = dates.convert_to_date_tensor(fixing_date)\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._accrual_start_date = dates.convert_to_date_tensor(settlement_date)\n        if rate_term is None:\n            self._accrual_end_date = dates.convert_to_date_tensor(maturity_date)\n        else:\n            self._accrual_end_date = self._accrual_start_date + rate_term\n        if daycount_convention is None:\n            daycount_convention = rc.DayCountConvention.ACTUAL_360\n        self._fixed_rate = tf.convert_to_tensor(fixed_rate, dtype=self._dtype, name='fixed_rate')\n        self._daycount_convention = daycount_convention\n        self._daycount_fraction = rc.get_daycount_fraction(self._accrual_start_date, self._accrual_end_date, self._daycount_convention, self._dtype)",
            "def __init__(self, settlement_date, fixing_date, fixed_rate, notional=1.0, daycount_convention=None, rate_term=None, maturity_date=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"Initialize the batch of FRA contracts.\\n\\n    Args:\\n      settlement_date: A rank 1 `DateTensor` specifying the dates on which\\n        cashflows are settled. The shape of the input correspond to the number\\n        of instruments being created.\\n      fixing_date: A rank 1 `DateTensor` specifying the dates on which forward\\n        rate will be fixed. The shape of the inout should be the same as that of\\n        `settlement_date`.\\n      fixed_rate: A rank 1 `Tensor` of real dtype specifying the fixed rate\\n        payment agreed at the initiation of the individual contracts. The shape\\n        should be the same as that of `settlement_date`.\\n      notional: A scalar or a rank 1 `Tensor` of real dtype specifying the\\n        notional amount for each contract. When the notional is specified as a\\n        scalar, it is assumed that all contracts have the same notional. If the\\n        notional is in the form of a `Tensor`, then the shape must be the same\\n        as `settlement_date`.\\n        Default value: 1.0\\n      daycount_convention: An optional `DayCountConvention` to determine\\n        how cashflows are accrued for each contract. Daycount is assumed to be\\n        the same for all contracts in a given batch.\\n        Default value: None in which case the daycount convention will default\\n        to DayCountConvention.ACTUAL_360 for all contracts.\\n      rate_term: An optional rank 1 `PeriodTensor` specifying the term (or the\\n        tenor) of the Libor rate that determines the floating cashflow. The\\n        shape of the input should be the same as `settlement_date`.\\n        Default value: `None` in which case the the forward rate is determined\\n        for the period [settlement_date, maturity_date].\\n      maturity_date: An optional rank 1 `DateTensor` specifying the maturity of\\n        the underlying forward rate for each contract. This input is only used\\n        if the input `rate_term` is `None`.\\n        Default value: `None`\\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\\n        either supplied to the FRA object or created by the FRA object.\\n        Default value: None which maps to the default dtype inferred by\\n        TensorFlow.\\n      name: Python str. The name to give to the ops created by this class.\\n        Default value: `None` which maps to 'forward_rate_agreement'.\\n\\n    Raises:\\n      ValueError: If both `maturity_date` and `rate_term` are unspecified.\\n    \"\n    self._name = name or 'forward_rate_agreement'\n    if rate_term is None and maturity_date is None:\n        raise ValueError('Error creating FRA. Either rate_term or maturity_date is required.')\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._notional = tf.convert_to_tensor(notional, dtype=self._dtype)\n        self._fixing_date = dates.convert_to_date_tensor(fixing_date)\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._accrual_start_date = dates.convert_to_date_tensor(settlement_date)\n        if rate_term is None:\n            self._accrual_end_date = dates.convert_to_date_tensor(maturity_date)\n        else:\n            self._accrual_end_date = self._accrual_start_date + rate_term\n        if daycount_convention is None:\n            daycount_convention = rc.DayCountConvention.ACTUAL_360\n        self._fixed_rate = tf.convert_to_tensor(fixed_rate, dtype=self._dtype, name='fixed_rate')\n        self._daycount_convention = daycount_convention\n        self._daycount_fraction = rc.get_daycount_fraction(self._accrual_start_date, self._accrual_end_date, self._daycount_convention, self._dtype)",
            "def __init__(self, settlement_date, fixing_date, fixed_rate, notional=1.0, daycount_convention=None, rate_term=None, maturity_date=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"Initialize the batch of FRA contracts.\\n\\n    Args:\\n      settlement_date: A rank 1 `DateTensor` specifying the dates on which\\n        cashflows are settled. The shape of the input correspond to the number\\n        of instruments being created.\\n      fixing_date: A rank 1 `DateTensor` specifying the dates on which forward\\n        rate will be fixed. The shape of the inout should be the same as that of\\n        `settlement_date`.\\n      fixed_rate: A rank 1 `Tensor` of real dtype specifying the fixed rate\\n        payment agreed at the initiation of the individual contracts. The shape\\n        should be the same as that of `settlement_date`.\\n      notional: A scalar or a rank 1 `Tensor` of real dtype specifying the\\n        notional amount for each contract. When the notional is specified as a\\n        scalar, it is assumed that all contracts have the same notional. If the\\n        notional is in the form of a `Tensor`, then the shape must be the same\\n        as `settlement_date`.\\n        Default value: 1.0\\n      daycount_convention: An optional `DayCountConvention` to determine\\n        how cashflows are accrued for each contract. Daycount is assumed to be\\n        the same for all contracts in a given batch.\\n        Default value: None in which case the daycount convention will default\\n        to DayCountConvention.ACTUAL_360 for all contracts.\\n      rate_term: An optional rank 1 `PeriodTensor` specifying the term (or the\\n        tenor) of the Libor rate that determines the floating cashflow. The\\n        shape of the input should be the same as `settlement_date`.\\n        Default value: `None` in which case the the forward rate is determined\\n        for the period [settlement_date, maturity_date].\\n      maturity_date: An optional rank 1 `DateTensor` specifying the maturity of\\n        the underlying forward rate for each contract. This input is only used\\n        if the input `rate_term` is `None`.\\n        Default value: `None`\\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\\n        either supplied to the FRA object or created by the FRA object.\\n        Default value: None which maps to the default dtype inferred by\\n        TensorFlow.\\n      name: Python str. The name to give to the ops created by this class.\\n        Default value: `None` which maps to 'forward_rate_agreement'.\\n\\n    Raises:\\n      ValueError: If both `maturity_date` and `rate_term` are unspecified.\\n    \"\n    self._name = name or 'forward_rate_agreement'\n    if rate_term is None and maturity_date is None:\n        raise ValueError('Error creating FRA. Either rate_term or maturity_date is required.')\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._notional = tf.convert_to_tensor(notional, dtype=self._dtype)\n        self._fixing_date = dates.convert_to_date_tensor(fixing_date)\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._accrual_start_date = dates.convert_to_date_tensor(settlement_date)\n        if rate_term is None:\n            self._accrual_end_date = dates.convert_to_date_tensor(maturity_date)\n        else:\n            self._accrual_end_date = self._accrual_start_date + rate_term\n        if daycount_convention is None:\n            daycount_convention = rc.DayCountConvention.ACTUAL_360\n        self._fixed_rate = tf.convert_to_tensor(fixed_rate, dtype=self._dtype, name='fixed_rate')\n        self._daycount_convention = daycount_convention\n        self._daycount_fraction = rc.get_daycount_fraction(self._accrual_start_date, self._accrual_end_date, self._daycount_convention, self._dtype)",
            "def __init__(self, settlement_date, fixing_date, fixed_rate, notional=1.0, daycount_convention=None, rate_term=None, maturity_date=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"Initialize the batch of FRA contracts.\\n\\n    Args:\\n      settlement_date: A rank 1 `DateTensor` specifying the dates on which\\n        cashflows are settled. The shape of the input correspond to the number\\n        of instruments being created.\\n      fixing_date: A rank 1 `DateTensor` specifying the dates on which forward\\n        rate will be fixed. The shape of the inout should be the same as that of\\n        `settlement_date`.\\n      fixed_rate: A rank 1 `Tensor` of real dtype specifying the fixed rate\\n        payment agreed at the initiation of the individual contracts. The shape\\n        should be the same as that of `settlement_date`.\\n      notional: A scalar or a rank 1 `Tensor` of real dtype specifying the\\n        notional amount for each contract. When the notional is specified as a\\n        scalar, it is assumed that all contracts have the same notional. If the\\n        notional is in the form of a `Tensor`, then the shape must be the same\\n        as `settlement_date`.\\n        Default value: 1.0\\n      daycount_convention: An optional `DayCountConvention` to determine\\n        how cashflows are accrued for each contract. Daycount is assumed to be\\n        the same for all contracts in a given batch.\\n        Default value: None in which case the daycount convention will default\\n        to DayCountConvention.ACTUAL_360 for all contracts.\\n      rate_term: An optional rank 1 `PeriodTensor` specifying the term (or the\\n        tenor) of the Libor rate that determines the floating cashflow. The\\n        shape of the input should be the same as `settlement_date`.\\n        Default value: `None` in which case the the forward rate is determined\\n        for the period [settlement_date, maturity_date].\\n      maturity_date: An optional rank 1 `DateTensor` specifying the maturity of\\n        the underlying forward rate for each contract. This input is only used\\n        if the input `rate_term` is `None`.\\n        Default value: `None`\\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\\n        either supplied to the FRA object or created by the FRA object.\\n        Default value: None which maps to the default dtype inferred by\\n        TensorFlow.\\n      name: Python str. The name to give to the ops created by this class.\\n        Default value: `None` which maps to 'forward_rate_agreement'.\\n\\n    Raises:\\n      ValueError: If both `maturity_date` and `rate_term` are unspecified.\\n    \"\n    self._name = name or 'forward_rate_agreement'\n    if rate_term is None and maturity_date is None:\n        raise ValueError('Error creating FRA. Either rate_term or maturity_date is required.')\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._notional = tf.convert_to_tensor(notional, dtype=self._dtype)\n        self._fixing_date = dates.convert_to_date_tensor(fixing_date)\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._accrual_start_date = dates.convert_to_date_tensor(settlement_date)\n        if rate_term is None:\n            self._accrual_end_date = dates.convert_to_date_tensor(maturity_date)\n        else:\n            self._accrual_end_date = self._accrual_start_date + rate_term\n        if daycount_convention is None:\n            daycount_convention = rc.DayCountConvention.ACTUAL_360\n        self._fixed_rate = tf.convert_to_tensor(fixed_rate, dtype=self._dtype, name='fixed_rate')\n        self._daycount_convention = daycount_convention\n        self._daycount_fraction = rc.get_daycount_fraction(self._accrual_start_date, self._accrual_end_date, self._daycount_convention, self._dtype)",
            "def __init__(self, settlement_date, fixing_date, fixed_rate, notional=1.0, daycount_convention=None, rate_term=None, maturity_date=None, dtype=None, name=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"Initialize the batch of FRA contracts.\\n\\n    Args:\\n      settlement_date: A rank 1 `DateTensor` specifying the dates on which\\n        cashflows are settled. The shape of the input correspond to the number\\n        of instruments being created.\\n      fixing_date: A rank 1 `DateTensor` specifying the dates on which forward\\n        rate will be fixed. The shape of the inout should be the same as that of\\n        `settlement_date`.\\n      fixed_rate: A rank 1 `Tensor` of real dtype specifying the fixed rate\\n        payment agreed at the initiation of the individual contracts. The shape\\n        should be the same as that of `settlement_date`.\\n      notional: A scalar or a rank 1 `Tensor` of real dtype specifying the\\n        notional amount for each contract. When the notional is specified as a\\n        scalar, it is assumed that all contracts have the same notional. If the\\n        notional is in the form of a `Tensor`, then the shape must be the same\\n        as `settlement_date`.\\n        Default value: 1.0\\n      daycount_convention: An optional `DayCountConvention` to determine\\n        how cashflows are accrued for each contract. Daycount is assumed to be\\n        the same for all contracts in a given batch.\\n        Default value: None in which case the daycount convention will default\\n        to DayCountConvention.ACTUAL_360 for all contracts.\\n      rate_term: An optional rank 1 `PeriodTensor` specifying the term (or the\\n        tenor) of the Libor rate that determines the floating cashflow. The\\n        shape of the input should be the same as `settlement_date`.\\n        Default value: `None` in which case the the forward rate is determined\\n        for the period [settlement_date, maturity_date].\\n      maturity_date: An optional rank 1 `DateTensor` specifying the maturity of\\n        the underlying forward rate for each contract. This input is only used\\n        if the input `rate_term` is `None`.\\n        Default value: `None`\\n      dtype: `tf.Dtype`. If supplied the dtype for the real variables or ops\\n        either supplied to the FRA object or created by the FRA object.\\n        Default value: None which maps to the default dtype inferred by\\n        TensorFlow.\\n      name: Python str. The name to give to the ops created by this class.\\n        Default value: `None` which maps to 'forward_rate_agreement'.\\n\\n    Raises:\\n      ValueError: If both `maturity_date` and `rate_term` are unspecified.\\n    \"\n    self._name = name or 'forward_rate_agreement'\n    if rate_term is None and maturity_date is None:\n        raise ValueError('Error creating FRA. Either rate_term or maturity_date is required.')\n    with tf.name_scope(self._name):\n        self._dtype = dtype\n        self._notional = tf.convert_to_tensor(notional, dtype=self._dtype)\n        self._fixing_date = dates.convert_to_date_tensor(fixing_date)\n        self._settlement_date = dates.convert_to_date_tensor(settlement_date)\n        self._accrual_start_date = dates.convert_to_date_tensor(settlement_date)\n        if rate_term is None:\n            self._accrual_end_date = dates.convert_to_date_tensor(maturity_date)\n        else:\n            self._accrual_end_date = self._accrual_start_date + rate_term\n        if daycount_convention is None:\n            daycount_convention = rc.DayCountConvention.ACTUAL_360\n        self._fixed_rate = tf.convert_to_tensor(fixed_rate, dtype=self._dtype, name='fixed_rate')\n        self._daycount_convention = daycount_convention\n        self._daycount_fraction = rc.get_daycount_fraction(self._accrual_start_date, self._accrual_end_date, self._daycount_convention, self._dtype)"
        ]
    },
    {
        "func_name": "price",
        "original": "def price(self, valuation_date, market, model=None):\n    \"\"\"Returns the present value of the instrument on the valuation date.\n\n    Args:\n      valuation_date: A scalar `DateTensor` specifying the date on which\n        valuation is being desired.\n      market: A namedtuple of type `InterestRateMarket` which contains the\n        necessary information for pricing the FRA instrument.\n      model: Reserved for future use.\n\n    Returns:\n      A Rank 1 `Tensor` of real type containing the modeled price of each FRA\n      contract based on the input market data.\n    \"\"\"\n    del model, valuation_date\n    reference_curve = market.reference_curve\n    discount_curve = market.discount_curve\n    fwd_rate = reference_curve.get_forward_rate(self._accrual_start_date, self._accrual_end_date, self._daycount_fraction)\n    discount_at_settlement = discount_curve.get_discount_factor(self._settlement_date)\n    return discount_at_settlement * self._notional * (fwd_rate - self._fixed_rate) * self._daycount_fraction / (1.0 + self._daycount_fraction * fwd_rate)",
        "mutated": [
            "def price(self, valuation_date, market, model=None):\n    if False:\n        i = 10\n    'Returns the present value of the instrument on the valuation date.\\n\\n    Args:\\n      valuation_date: A scalar `DateTensor` specifying the date on which\\n        valuation is being desired.\\n      market: A namedtuple of type `InterestRateMarket` which contains the\\n        necessary information for pricing the FRA instrument.\\n      model: Reserved for future use.\\n\\n    Returns:\\n      A Rank 1 `Tensor` of real type containing the modeled price of each FRA\\n      contract based on the input market data.\\n    '\n    del model, valuation_date\n    reference_curve = market.reference_curve\n    discount_curve = market.discount_curve\n    fwd_rate = reference_curve.get_forward_rate(self._accrual_start_date, self._accrual_end_date, self._daycount_fraction)\n    discount_at_settlement = discount_curve.get_discount_factor(self._settlement_date)\n    return discount_at_settlement * self._notional * (fwd_rate - self._fixed_rate) * self._daycount_fraction / (1.0 + self._daycount_fraction * fwd_rate)",
            "def price(self, valuation_date, market, model=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    'Returns the present value of the instrument on the valuation date.\\n\\n    Args:\\n      valuation_date: A scalar `DateTensor` specifying the date on which\\n        valuation is being desired.\\n      market: A namedtuple of type `InterestRateMarket` which contains the\\n        necessary information for pricing the FRA instrument.\\n      model: Reserved for future use.\\n\\n    Returns:\\n      A Rank 1 `Tensor` of real type containing the modeled price of each FRA\\n      contract based on the input market data.\\n    '\n    del model, valuation_date\n    reference_curve = market.reference_curve\n    discount_curve = market.discount_curve\n    fwd_rate = reference_curve.get_forward_rate(self._accrual_start_date, self._accrual_end_date, self._daycount_fraction)\n    discount_at_settlement = discount_curve.get_discount_factor(self._settlement_date)\n    return discount_at_settlement * self._notional * (fwd_rate - self._fixed_rate) * self._daycount_fraction / (1.0 + self._daycount_fraction * fwd_rate)",
            "def price(self, valuation_date, market, model=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    'Returns the present value of the instrument on the valuation date.\\n\\n    Args:\\n      valuation_date: A scalar `DateTensor` specifying the date on which\\n        valuation is being desired.\\n      market: A namedtuple of type `InterestRateMarket` which contains the\\n        necessary information for pricing the FRA instrument.\\n      model: Reserved for future use.\\n\\n    Returns:\\n      A Rank 1 `Tensor` of real type containing the modeled price of each FRA\\n      contract based on the input market data.\\n    '\n    del model, valuation_date\n    reference_curve = market.reference_curve\n    discount_curve = market.discount_curve\n    fwd_rate = reference_curve.get_forward_rate(self._accrual_start_date, self._accrual_end_date, self._daycount_fraction)\n    discount_at_settlement = discount_curve.get_discount_factor(self._settlement_date)\n    return discount_at_settlement * self._notional * (fwd_rate - self._fixed_rate) * self._daycount_fraction / (1.0 + self._daycount_fraction * fwd_rate)",
            "def price(self, valuation_date, market, model=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    'Returns the present value of the instrument on the valuation date.\\n\\n    Args:\\n      valuation_date: A scalar `DateTensor` specifying the date on which\\n        valuation is being desired.\\n      market: A namedtuple of type `InterestRateMarket` which contains the\\n        necessary information for pricing the FRA instrument.\\n      model: Reserved for future use.\\n\\n    Returns:\\n      A Rank 1 `Tensor` of real type containing the modeled price of each FRA\\n      contract based on the input market data.\\n    '\n    del model, valuation_date\n    reference_curve = market.reference_curve\n    discount_curve = market.discount_curve\n    fwd_rate = reference_curve.get_forward_rate(self._accrual_start_date, self._accrual_end_date, self._daycount_fraction)\n    discount_at_settlement = discount_curve.get_discount_factor(self._settlement_date)\n    return discount_at_settlement * self._notional * (fwd_rate - self._fixed_rate) * self._daycount_fraction / (1.0 + self._daycount_fraction * fwd_rate)",
            "def price(self, valuation_date, market, model=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    'Returns the present value of the instrument on the valuation date.\\n\\n    Args:\\n      valuation_date: A scalar `DateTensor` specifying the date on which\\n        valuation is being desired.\\n      market: A namedtuple of type `InterestRateMarket` which contains the\\n        necessary information for pricing the FRA instrument.\\n      model: Reserved for future use.\\n\\n    Returns:\\n      A Rank 1 `Tensor` of real type containing the modeled price of each FRA\\n      contract based on the input market data.\\n    '\n    del model, valuation_date\n    reference_curve = market.reference_curve\n    discount_curve = market.discount_curve\n    fwd_rate = reference_curve.get_forward_rate(self._accrual_start_date, self._accrual_end_date, self._daycount_fraction)\n    discount_at_settlement = discount_curve.get_discount_factor(self._settlement_date)\n    return discount_at_settlement * self._notional * (fwd_rate - self._fixed_rate) * self._daycount_fraction / (1.0 + self._daycount_fraction * fwd_rate)"
        ]
    }
]