[
    {
        "func_name": "getModuleMetaPathLoaderEntryCode",
        "original": "def getModuleMetaPathLoaderEntryCode(module, bytecode_accessor):\n    module_c_name = encodePythonStringToC(Plugins.encodeDataComposerName(module.getFullName().asString()))\n    flags = ['NUITKA_TRANSLATED_FLAG']\n    if not Options.isStandaloneMode() and (not Options.shallMakeModule()) and (Options.getFileReferenceMode() == 'original') and (python_version >= 880):\n        if Options.isWin32Windows():\n            file_path = encodePythonUnicodeToC(module.getCompileTimeFilename())\n        else:\n            file_path = encodePythonStringToC(module.getCompileTimeFilename().encode(sys.getfilesystemencoding()))\n    else:\n        file_path = 'NULL'\n    if module.isUncompiledPythonModule():\n        code_data = module.getByteCode()\n        is_package = module.isUncompiledPythonPackage()\n        flags.append('NUITKA_BYTECODE_FLAG')\n        if is_package:\n            flags.append('NUITKA_PACKAGE_FLAG')\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % module.getFullName())\n        return template_metapath_loader_bytecode_module_entry % {'module_name': module_c_name, 'bytecode': accessor_code[accessor_code.find('[') + 1:-1], 'size': len(code_data), 'flags': ' | '.join(flags), 'file_path': file_path}\n    elif module.isPythonExtensionModule():\n        flags.append('NUITKA_EXTENSION_MODULE_FLAG')\n        return template_metapath_loader_extension_module_entry % {'module_name': module_c_name, 'flags': ' | '.join(flags), 'file_path': file_path}\n    else:\n        if module.isCompiledPythonPackage():\n            flags.append('NUITKA_PACKAGE_FLAG')\n        return template_metapath_loader_compiled_module_entry % {'module_name': module_c_name, 'module_identifier': module.getCodeName(), 'flags': ' | '.join(flags), 'file_path': file_path}",
        "mutated": [
            "def getModuleMetaPathLoaderEntryCode(module, bytecode_accessor):\n    if False:\n        i = 10\n    module_c_name = encodePythonStringToC(Plugins.encodeDataComposerName(module.getFullName().asString()))\n    flags = ['NUITKA_TRANSLATED_FLAG']\n    if not Options.isStandaloneMode() and (not Options.shallMakeModule()) and (Options.getFileReferenceMode() == 'original') and (python_version >= 880):\n        if Options.isWin32Windows():\n            file_path = encodePythonUnicodeToC(module.getCompileTimeFilename())\n        else:\n            file_path = encodePythonStringToC(module.getCompileTimeFilename().encode(sys.getfilesystemencoding()))\n    else:\n        file_path = 'NULL'\n    if module.isUncompiledPythonModule():\n        code_data = module.getByteCode()\n        is_package = module.isUncompiledPythonPackage()\n        flags.append('NUITKA_BYTECODE_FLAG')\n        if is_package:\n            flags.append('NUITKA_PACKAGE_FLAG')\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % module.getFullName())\n        return template_metapath_loader_bytecode_module_entry % {'module_name': module_c_name, 'bytecode': accessor_code[accessor_code.find('[') + 1:-1], 'size': len(code_data), 'flags': ' | '.join(flags), 'file_path': file_path}\n    elif module.isPythonExtensionModule():\n        flags.append('NUITKA_EXTENSION_MODULE_FLAG')\n        return template_metapath_loader_extension_module_entry % {'module_name': module_c_name, 'flags': ' | '.join(flags), 'file_path': file_path}\n    else:\n        if module.isCompiledPythonPackage():\n            flags.append('NUITKA_PACKAGE_FLAG')\n        return template_metapath_loader_compiled_module_entry % {'module_name': module_c_name, 'module_identifier': module.getCodeName(), 'flags': ' | '.join(flags), 'file_path': file_path}",
            "def getModuleMetaPathLoaderEntryCode(module, bytecode_accessor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    module_c_name = encodePythonStringToC(Plugins.encodeDataComposerName(module.getFullName().asString()))\n    flags = ['NUITKA_TRANSLATED_FLAG']\n    if not Options.isStandaloneMode() and (not Options.shallMakeModule()) and (Options.getFileReferenceMode() == 'original') and (python_version >= 880):\n        if Options.isWin32Windows():\n            file_path = encodePythonUnicodeToC(module.getCompileTimeFilename())\n        else:\n            file_path = encodePythonStringToC(module.getCompileTimeFilename().encode(sys.getfilesystemencoding()))\n    else:\n        file_path = 'NULL'\n    if module.isUncompiledPythonModule():\n        code_data = module.getByteCode()\n        is_package = module.isUncompiledPythonPackage()\n        flags.append('NUITKA_BYTECODE_FLAG')\n        if is_package:\n            flags.append('NUITKA_PACKAGE_FLAG')\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % module.getFullName())\n        return template_metapath_loader_bytecode_module_entry % {'module_name': module_c_name, 'bytecode': accessor_code[accessor_code.find('[') + 1:-1], 'size': len(code_data), 'flags': ' | '.join(flags), 'file_path': file_path}\n    elif module.isPythonExtensionModule():\n        flags.append('NUITKA_EXTENSION_MODULE_FLAG')\n        return template_metapath_loader_extension_module_entry % {'module_name': module_c_name, 'flags': ' | '.join(flags), 'file_path': file_path}\n    else:\n        if module.isCompiledPythonPackage():\n            flags.append('NUITKA_PACKAGE_FLAG')\n        return template_metapath_loader_compiled_module_entry % {'module_name': module_c_name, 'module_identifier': module.getCodeName(), 'flags': ' | '.join(flags), 'file_path': file_path}",
            "def getModuleMetaPathLoaderEntryCode(module, bytecode_accessor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    module_c_name = encodePythonStringToC(Plugins.encodeDataComposerName(module.getFullName().asString()))\n    flags = ['NUITKA_TRANSLATED_FLAG']\n    if not Options.isStandaloneMode() and (not Options.shallMakeModule()) and (Options.getFileReferenceMode() == 'original') and (python_version >= 880):\n        if Options.isWin32Windows():\n            file_path = encodePythonUnicodeToC(module.getCompileTimeFilename())\n        else:\n            file_path = encodePythonStringToC(module.getCompileTimeFilename().encode(sys.getfilesystemencoding()))\n    else:\n        file_path = 'NULL'\n    if module.isUncompiledPythonModule():\n        code_data = module.getByteCode()\n        is_package = module.isUncompiledPythonPackage()\n        flags.append('NUITKA_BYTECODE_FLAG')\n        if is_package:\n            flags.append('NUITKA_PACKAGE_FLAG')\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % module.getFullName())\n        return template_metapath_loader_bytecode_module_entry % {'module_name': module_c_name, 'bytecode': accessor_code[accessor_code.find('[') + 1:-1], 'size': len(code_data), 'flags': ' | '.join(flags), 'file_path': file_path}\n    elif module.isPythonExtensionModule():\n        flags.append('NUITKA_EXTENSION_MODULE_FLAG')\n        return template_metapath_loader_extension_module_entry % {'module_name': module_c_name, 'flags': ' | '.join(flags), 'file_path': file_path}\n    else:\n        if module.isCompiledPythonPackage():\n            flags.append('NUITKA_PACKAGE_FLAG')\n        return template_metapath_loader_compiled_module_entry % {'module_name': module_c_name, 'module_identifier': module.getCodeName(), 'flags': ' | '.join(flags), 'file_path': file_path}",
            "def getModuleMetaPathLoaderEntryCode(module, bytecode_accessor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    module_c_name = encodePythonStringToC(Plugins.encodeDataComposerName(module.getFullName().asString()))\n    flags = ['NUITKA_TRANSLATED_FLAG']\n    if not Options.isStandaloneMode() and (not Options.shallMakeModule()) and (Options.getFileReferenceMode() == 'original') and (python_version >= 880):\n        if Options.isWin32Windows():\n            file_path = encodePythonUnicodeToC(module.getCompileTimeFilename())\n        else:\n            file_path = encodePythonStringToC(module.getCompileTimeFilename().encode(sys.getfilesystemencoding()))\n    else:\n        file_path = 'NULL'\n    if module.isUncompiledPythonModule():\n        code_data = module.getByteCode()\n        is_package = module.isUncompiledPythonPackage()\n        flags.append('NUITKA_BYTECODE_FLAG')\n        if is_package:\n            flags.append('NUITKA_PACKAGE_FLAG')\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % module.getFullName())\n        return template_metapath_loader_bytecode_module_entry % {'module_name': module_c_name, 'bytecode': accessor_code[accessor_code.find('[') + 1:-1], 'size': len(code_data), 'flags': ' | '.join(flags), 'file_path': file_path}\n    elif module.isPythonExtensionModule():\n        flags.append('NUITKA_EXTENSION_MODULE_FLAG')\n        return template_metapath_loader_extension_module_entry % {'module_name': module_c_name, 'flags': ' | '.join(flags), 'file_path': file_path}\n    else:\n        if module.isCompiledPythonPackage():\n            flags.append('NUITKA_PACKAGE_FLAG')\n        return template_metapath_loader_compiled_module_entry % {'module_name': module_c_name, 'module_identifier': module.getCodeName(), 'flags': ' | '.join(flags), 'file_path': file_path}",
            "def getModuleMetaPathLoaderEntryCode(module, bytecode_accessor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    module_c_name = encodePythonStringToC(Plugins.encodeDataComposerName(module.getFullName().asString()))\n    flags = ['NUITKA_TRANSLATED_FLAG']\n    if not Options.isStandaloneMode() and (not Options.shallMakeModule()) and (Options.getFileReferenceMode() == 'original') and (python_version >= 880):\n        if Options.isWin32Windows():\n            file_path = encodePythonUnicodeToC(module.getCompileTimeFilename())\n        else:\n            file_path = encodePythonStringToC(module.getCompileTimeFilename().encode(sys.getfilesystemencoding()))\n    else:\n        file_path = 'NULL'\n    if module.isUncompiledPythonModule():\n        code_data = module.getByteCode()\n        is_package = module.isUncompiledPythonPackage()\n        flags.append('NUITKA_BYTECODE_FLAG')\n        if is_package:\n            flags.append('NUITKA_PACKAGE_FLAG')\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % module.getFullName())\n        return template_metapath_loader_bytecode_module_entry % {'module_name': module_c_name, 'bytecode': accessor_code[accessor_code.find('[') + 1:-1], 'size': len(code_data), 'flags': ' | '.join(flags), 'file_path': file_path}\n    elif module.isPythonExtensionModule():\n        flags.append('NUITKA_EXTENSION_MODULE_FLAG')\n        return template_metapath_loader_extension_module_entry % {'module_name': module_c_name, 'flags': ' | '.join(flags), 'file_path': file_path}\n    else:\n        if module.isCompiledPythonPackage():\n            flags.append('NUITKA_PACKAGE_FLAG')\n        return template_metapath_loader_compiled_module_entry % {'module_name': module_c_name, 'module_identifier': module.getCodeName(), 'flags': ' | '.join(flags), 'file_path': file_path}"
        ]
    },
    {
        "func_name": "getMetaPathLoaderBodyCode",
        "original": "def getMetaPathLoaderBodyCode(bytecode_accessor):\n    metapath_loader_inittab = []\n    metapath_module_decls = []\n    uncompiled_modules = getUncompiledModules()\n    for other_module in getDoneModules():\n        if other_module in uncompiled_modules:\n            continue\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=other_module, bytecode_accessor=bytecode_accessor))\n        if other_module.isCompiledPythonModule():\n            metapath_module_decls.append('extern PyObject *modulecode_%(module_identifier)s(PyThreadState *tstate, PyObject *, struct Nuitka_MetaPathBasedLoaderEntry const *);' % {'module_identifier': other_module.getCodeName()})\n    for uncompiled_module in uncompiled_modules:\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=uncompiled_module, bytecode_accessor=bytecode_accessor))\n    frozen_defs = []\n    for uncompiled_module in getUncompiledTechnicalModules():\n        module_name = uncompiled_module.getFullName()\n        code_data = uncompiled_module.getByteCode()\n        is_package = uncompiled_module.isUncompiledPythonPackage()\n        size = len(code_data)\n        if is_package:\n            size = -size\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % uncompiled_module.getFullName())\n        frozen_defs.append('{{\"{module_name}\", {start}, {size}}},'.format(module_name=module_name, start=accessor_code[accessor_code.find('[') + 1:-1], size=size))\n        if Options.isShowInclusion():\n            inclusion_logger.info(\"Embedded as frozen module '%s'.\" % module_name)\n    return template_metapath_loader_body % {'metapath_module_decls': indented(metapath_module_decls, 0), 'metapath_loader_inittab': indented(metapath_loader_inittab), 'bytecode_count': bytecode_accessor.getConstantsCount(), 'frozen_modules': indented(frozen_defs)}",
        "mutated": [
            "def getMetaPathLoaderBodyCode(bytecode_accessor):\n    if False:\n        i = 10\n    metapath_loader_inittab = []\n    metapath_module_decls = []\n    uncompiled_modules = getUncompiledModules()\n    for other_module in getDoneModules():\n        if other_module in uncompiled_modules:\n            continue\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=other_module, bytecode_accessor=bytecode_accessor))\n        if other_module.isCompiledPythonModule():\n            metapath_module_decls.append('extern PyObject *modulecode_%(module_identifier)s(PyThreadState *tstate, PyObject *, struct Nuitka_MetaPathBasedLoaderEntry const *);' % {'module_identifier': other_module.getCodeName()})\n    for uncompiled_module in uncompiled_modules:\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=uncompiled_module, bytecode_accessor=bytecode_accessor))\n    frozen_defs = []\n    for uncompiled_module in getUncompiledTechnicalModules():\n        module_name = uncompiled_module.getFullName()\n        code_data = uncompiled_module.getByteCode()\n        is_package = uncompiled_module.isUncompiledPythonPackage()\n        size = len(code_data)\n        if is_package:\n            size = -size\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % uncompiled_module.getFullName())\n        frozen_defs.append('{{\"{module_name}\", {start}, {size}}},'.format(module_name=module_name, start=accessor_code[accessor_code.find('[') + 1:-1], size=size))\n        if Options.isShowInclusion():\n            inclusion_logger.info(\"Embedded as frozen module '%s'.\" % module_name)\n    return template_metapath_loader_body % {'metapath_module_decls': indented(metapath_module_decls, 0), 'metapath_loader_inittab': indented(metapath_loader_inittab), 'bytecode_count': bytecode_accessor.getConstantsCount(), 'frozen_modules': indented(frozen_defs)}",
            "def getMetaPathLoaderBodyCode(bytecode_accessor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    metapath_loader_inittab = []\n    metapath_module_decls = []\n    uncompiled_modules = getUncompiledModules()\n    for other_module in getDoneModules():\n        if other_module in uncompiled_modules:\n            continue\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=other_module, bytecode_accessor=bytecode_accessor))\n        if other_module.isCompiledPythonModule():\n            metapath_module_decls.append('extern PyObject *modulecode_%(module_identifier)s(PyThreadState *tstate, PyObject *, struct Nuitka_MetaPathBasedLoaderEntry const *);' % {'module_identifier': other_module.getCodeName()})\n    for uncompiled_module in uncompiled_modules:\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=uncompiled_module, bytecode_accessor=bytecode_accessor))\n    frozen_defs = []\n    for uncompiled_module in getUncompiledTechnicalModules():\n        module_name = uncompiled_module.getFullName()\n        code_data = uncompiled_module.getByteCode()\n        is_package = uncompiled_module.isUncompiledPythonPackage()\n        size = len(code_data)\n        if is_package:\n            size = -size\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % uncompiled_module.getFullName())\n        frozen_defs.append('{{\"{module_name}\", {start}, {size}}},'.format(module_name=module_name, start=accessor_code[accessor_code.find('[') + 1:-1], size=size))\n        if Options.isShowInclusion():\n            inclusion_logger.info(\"Embedded as frozen module '%s'.\" % module_name)\n    return template_metapath_loader_body % {'metapath_module_decls': indented(metapath_module_decls, 0), 'metapath_loader_inittab': indented(metapath_loader_inittab), 'bytecode_count': bytecode_accessor.getConstantsCount(), 'frozen_modules': indented(frozen_defs)}",
            "def getMetaPathLoaderBodyCode(bytecode_accessor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    metapath_loader_inittab = []\n    metapath_module_decls = []\n    uncompiled_modules = getUncompiledModules()\n    for other_module in getDoneModules():\n        if other_module in uncompiled_modules:\n            continue\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=other_module, bytecode_accessor=bytecode_accessor))\n        if other_module.isCompiledPythonModule():\n            metapath_module_decls.append('extern PyObject *modulecode_%(module_identifier)s(PyThreadState *tstate, PyObject *, struct Nuitka_MetaPathBasedLoaderEntry const *);' % {'module_identifier': other_module.getCodeName()})\n    for uncompiled_module in uncompiled_modules:\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=uncompiled_module, bytecode_accessor=bytecode_accessor))\n    frozen_defs = []\n    for uncompiled_module in getUncompiledTechnicalModules():\n        module_name = uncompiled_module.getFullName()\n        code_data = uncompiled_module.getByteCode()\n        is_package = uncompiled_module.isUncompiledPythonPackage()\n        size = len(code_data)\n        if is_package:\n            size = -size\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % uncompiled_module.getFullName())\n        frozen_defs.append('{{\"{module_name}\", {start}, {size}}},'.format(module_name=module_name, start=accessor_code[accessor_code.find('[') + 1:-1], size=size))\n        if Options.isShowInclusion():\n            inclusion_logger.info(\"Embedded as frozen module '%s'.\" % module_name)\n    return template_metapath_loader_body % {'metapath_module_decls': indented(metapath_module_decls, 0), 'metapath_loader_inittab': indented(metapath_loader_inittab), 'bytecode_count': bytecode_accessor.getConstantsCount(), 'frozen_modules': indented(frozen_defs)}",
            "def getMetaPathLoaderBodyCode(bytecode_accessor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    metapath_loader_inittab = []\n    metapath_module_decls = []\n    uncompiled_modules = getUncompiledModules()\n    for other_module in getDoneModules():\n        if other_module in uncompiled_modules:\n            continue\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=other_module, bytecode_accessor=bytecode_accessor))\n        if other_module.isCompiledPythonModule():\n            metapath_module_decls.append('extern PyObject *modulecode_%(module_identifier)s(PyThreadState *tstate, PyObject *, struct Nuitka_MetaPathBasedLoaderEntry const *);' % {'module_identifier': other_module.getCodeName()})\n    for uncompiled_module in uncompiled_modules:\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=uncompiled_module, bytecode_accessor=bytecode_accessor))\n    frozen_defs = []\n    for uncompiled_module in getUncompiledTechnicalModules():\n        module_name = uncompiled_module.getFullName()\n        code_data = uncompiled_module.getByteCode()\n        is_package = uncompiled_module.isUncompiledPythonPackage()\n        size = len(code_data)\n        if is_package:\n            size = -size\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % uncompiled_module.getFullName())\n        frozen_defs.append('{{\"{module_name}\", {start}, {size}}},'.format(module_name=module_name, start=accessor_code[accessor_code.find('[') + 1:-1], size=size))\n        if Options.isShowInclusion():\n            inclusion_logger.info(\"Embedded as frozen module '%s'.\" % module_name)\n    return template_metapath_loader_body % {'metapath_module_decls': indented(metapath_module_decls, 0), 'metapath_loader_inittab': indented(metapath_loader_inittab), 'bytecode_count': bytecode_accessor.getConstantsCount(), 'frozen_modules': indented(frozen_defs)}",
            "def getMetaPathLoaderBodyCode(bytecode_accessor):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    metapath_loader_inittab = []\n    metapath_module_decls = []\n    uncompiled_modules = getUncompiledModules()\n    for other_module in getDoneModules():\n        if other_module in uncompiled_modules:\n            continue\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=other_module, bytecode_accessor=bytecode_accessor))\n        if other_module.isCompiledPythonModule():\n            metapath_module_decls.append('extern PyObject *modulecode_%(module_identifier)s(PyThreadState *tstate, PyObject *, struct Nuitka_MetaPathBasedLoaderEntry const *);' % {'module_identifier': other_module.getCodeName()})\n    for uncompiled_module in uncompiled_modules:\n        metapath_loader_inittab.append(getModuleMetaPathLoaderEntryCode(module=uncompiled_module, bytecode_accessor=bytecode_accessor))\n    frozen_defs = []\n    for uncompiled_module in getUncompiledTechnicalModules():\n        module_name = uncompiled_module.getFullName()\n        code_data = uncompiled_module.getByteCode()\n        is_package = uncompiled_module.isUncompiledPythonPackage()\n        size = len(code_data)\n        if is_package:\n            size = -size\n        accessor_code = bytecode_accessor.getBlobDataCode(data=code_data, name=\"bytecode of module '%s'\" % uncompiled_module.getFullName())\n        frozen_defs.append('{{\"{module_name}\", {start}, {size}}},'.format(module_name=module_name, start=accessor_code[accessor_code.find('[') + 1:-1], size=size))\n        if Options.isShowInclusion():\n            inclusion_logger.info(\"Embedded as frozen module '%s'.\" % module_name)\n    return template_metapath_loader_body % {'metapath_module_decls': indented(metapath_module_decls, 0), 'metapath_loader_inittab': indented(metapath_loader_inittab), 'bytecode_count': bytecode_accessor.getConstantsCount(), 'frozen_modules': indented(frozen_defs)}"
        ]
    }
]