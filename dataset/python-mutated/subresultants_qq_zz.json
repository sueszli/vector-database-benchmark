[
    {
        "func_name": "sylvester",
        "original": "def sylvester(f, g, x, method=1):\n    \"\"\"\n      The input polynomials f, g are in Z[x] or in Q[x]. Let m = degree(f, x),\n      n = degree(g, x) and mx = max(m, n).\n\n      a. If method = 1 (default), computes sylvester1, Sylvester's matrix of 1840\n          of dimension (m + n) x (m + n). The determinants of properly chosen\n          submatrices of this matrix (a.k.a. subresultants) can be\n          used to compute the coefficients of the Euclidean PRS of f, g.\n\n      b. If method = 2, computes sylvester2, Sylvester's matrix of 1853\n          of dimension (2*mx) x (2*mx). The determinants of properly chosen\n          submatrices of this matrix (a.k.a. ``modified'' subresultants) can be\n          used to compute the coefficients of the Sturmian PRS of f, g.\n\n      Applications of these Matrices can be found in the references below.\n      Especially, for applications of sylvester2, see the first reference!!\n\n      References\n      ==========\n      1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\n      by Van Vleck Regarding Sturm Sequences. Serdica Journal of Computing,\n      Vol. 7, No 4, 101-134, 2013.\n\n      2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\n      and Modified Subresultant Polynomial Remainder Sequences.''\n      Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\n\n    \"\"\"\n    (m, n) = (degree(Poly(f, x), x), degree(Poly(g, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    fp = Poly(f, x).all_coeffs()\n    gp = Poly(g, x).all_coeffs()\n    if method <= 1:\n        M = zeros(m + n)\n        k = 0\n        for i in range(n):\n            j = k\n            for coeff in fp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        k = 0\n        for i in range(n, m + n):\n            j = k\n            for coeff in gp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M\n    if method >= 2:\n        if len(fp) < len(gp):\n            h = []\n            for i in range(len(gp) - len(fp)):\n                h.append(0)\n            fp[:0] = h\n        else:\n            h = []\n            for i in range(len(fp) - len(gp)):\n                h.append(0)\n            gp[:0] = h\n        mx = max(m, n)\n        dim = 2 * mx\n        M = zeros(dim)\n        k = 0\n        for i in range(mx):\n            j = k\n            for coeff in fp:\n                M[2 * i, j] = coeff\n                j = j + 1\n            j = k\n            for coeff in gp:\n                M[2 * i + 1, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M",
        "mutated": [
            "def sylvester(f, g, x, method=1):\n    if False:\n        i = 10\n    \"\\n      The input polynomials f, g are in Z[x] or in Q[x]. Let m = degree(f, x),\\n      n = degree(g, x) and mx = max(m, n).\\n\\n      a. If method = 1 (default), computes sylvester1, Sylvester's matrix of 1840\\n          of dimension (m + n) x (m + n). The determinants of properly chosen\\n          submatrices of this matrix (a.k.a. subresultants) can be\\n          used to compute the coefficients of the Euclidean PRS of f, g.\\n\\n      b. If method = 2, computes sylvester2, Sylvester's matrix of 1853\\n          of dimension (2*mx) x (2*mx). The determinants of properly chosen\\n          submatrices of this matrix (a.k.a. ``modified'' subresultants) can be\\n          used to compute the coefficients of the Sturmian PRS of f, g.\\n\\n      Applications of these Matrices can be found in the references below.\\n      Especially, for applications of sylvester2, see the first reference!!\\n\\n      References\\n      ==========\\n      1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n      by Van Vleck Regarding Sturm Sequences. Serdica Journal of Computing,\\n      Vol. 7, No 4, 101-134, 2013.\\n\\n      2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n      and Modified Subresultant Polynomial Remainder Sequences.''\\n      Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    (m, n) = (degree(Poly(f, x), x), degree(Poly(g, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    fp = Poly(f, x).all_coeffs()\n    gp = Poly(g, x).all_coeffs()\n    if method <= 1:\n        M = zeros(m + n)\n        k = 0\n        for i in range(n):\n            j = k\n            for coeff in fp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        k = 0\n        for i in range(n, m + n):\n            j = k\n            for coeff in gp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M\n    if method >= 2:\n        if len(fp) < len(gp):\n            h = []\n            for i in range(len(gp) - len(fp)):\n                h.append(0)\n            fp[:0] = h\n        else:\n            h = []\n            for i in range(len(fp) - len(gp)):\n                h.append(0)\n            gp[:0] = h\n        mx = max(m, n)\n        dim = 2 * mx\n        M = zeros(dim)\n        k = 0\n        for i in range(mx):\n            j = k\n            for coeff in fp:\n                M[2 * i, j] = coeff\n                j = j + 1\n            j = k\n            for coeff in gp:\n                M[2 * i + 1, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M",
            "def sylvester(f, g, x, method=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n      The input polynomials f, g are in Z[x] or in Q[x]. Let m = degree(f, x),\\n      n = degree(g, x) and mx = max(m, n).\\n\\n      a. If method = 1 (default), computes sylvester1, Sylvester's matrix of 1840\\n          of dimension (m + n) x (m + n). The determinants of properly chosen\\n          submatrices of this matrix (a.k.a. subresultants) can be\\n          used to compute the coefficients of the Euclidean PRS of f, g.\\n\\n      b. If method = 2, computes sylvester2, Sylvester's matrix of 1853\\n          of dimension (2*mx) x (2*mx). The determinants of properly chosen\\n          submatrices of this matrix (a.k.a. ``modified'' subresultants) can be\\n          used to compute the coefficients of the Sturmian PRS of f, g.\\n\\n      Applications of these Matrices can be found in the references below.\\n      Especially, for applications of sylvester2, see the first reference!!\\n\\n      References\\n      ==========\\n      1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n      by Van Vleck Regarding Sturm Sequences. Serdica Journal of Computing,\\n      Vol. 7, No 4, 101-134, 2013.\\n\\n      2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n      and Modified Subresultant Polynomial Remainder Sequences.''\\n      Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    (m, n) = (degree(Poly(f, x), x), degree(Poly(g, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    fp = Poly(f, x).all_coeffs()\n    gp = Poly(g, x).all_coeffs()\n    if method <= 1:\n        M = zeros(m + n)\n        k = 0\n        for i in range(n):\n            j = k\n            for coeff in fp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        k = 0\n        for i in range(n, m + n):\n            j = k\n            for coeff in gp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M\n    if method >= 2:\n        if len(fp) < len(gp):\n            h = []\n            for i in range(len(gp) - len(fp)):\n                h.append(0)\n            fp[:0] = h\n        else:\n            h = []\n            for i in range(len(fp) - len(gp)):\n                h.append(0)\n            gp[:0] = h\n        mx = max(m, n)\n        dim = 2 * mx\n        M = zeros(dim)\n        k = 0\n        for i in range(mx):\n            j = k\n            for coeff in fp:\n                M[2 * i, j] = coeff\n                j = j + 1\n            j = k\n            for coeff in gp:\n                M[2 * i + 1, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M",
            "def sylvester(f, g, x, method=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n      The input polynomials f, g are in Z[x] or in Q[x]. Let m = degree(f, x),\\n      n = degree(g, x) and mx = max(m, n).\\n\\n      a. If method = 1 (default), computes sylvester1, Sylvester's matrix of 1840\\n          of dimension (m + n) x (m + n). The determinants of properly chosen\\n          submatrices of this matrix (a.k.a. subresultants) can be\\n          used to compute the coefficients of the Euclidean PRS of f, g.\\n\\n      b. If method = 2, computes sylvester2, Sylvester's matrix of 1853\\n          of dimension (2*mx) x (2*mx). The determinants of properly chosen\\n          submatrices of this matrix (a.k.a. ``modified'' subresultants) can be\\n          used to compute the coefficients of the Sturmian PRS of f, g.\\n\\n      Applications of these Matrices can be found in the references below.\\n      Especially, for applications of sylvester2, see the first reference!!\\n\\n      References\\n      ==========\\n      1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n      by Van Vleck Regarding Sturm Sequences. Serdica Journal of Computing,\\n      Vol. 7, No 4, 101-134, 2013.\\n\\n      2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n      and Modified Subresultant Polynomial Remainder Sequences.''\\n      Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    (m, n) = (degree(Poly(f, x), x), degree(Poly(g, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    fp = Poly(f, x).all_coeffs()\n    gp = Poly(g, x).all_coeffs()\n    if method <= 1:\n        M = zeros(m + n)\n        k = 0\n        for i in range(n):\n            j = k\n            for coeff in fp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        k = 0\n        for i in range(n, m + n):\n            j = k\n            for coeff in gp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M\n    if method >= 2:\n        if len(fp) < len(gp):\n            h = []\n            for i in range(len(gp) - len(fp)):\n                h.append(0)\n            fp[:0] = h\n        else:\n            h = []\n            for i in range(len(fp) - len(gp)):\n                h.append(0)\n            gp[:0] = h\n        mx = max(m, n)\n        dim = 2 * mx\n        M = zeros(dim)\n        k = 0\n        for i in range(mx):\n            j = k\n            for coeff in fp:\n                M[2 * i, j] = coeff\n                j = j + 1\n            j = k\n            for coeff in gp:\n                M[2 * i + 1, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M",
            "def sylvester(f, g, x, method=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n      The input polynomials f, g are in Z[x] or in Q[x]. Let m = degree(f, x),\\n      n = degree(g, x) and mx = max(m, n).\\n\\n      a. If method = 1 (default), computes sylvester1, Sylvester's matrix of 1840\\n          of dimension (m + n) x (m + n). The determinants of properly chosen\\n          submatrices of this matrix (a.k.a. subresultants) can be\\n          used to compute the coefficients of the Euclidean PRS of f, g.\\n\\n      b. If method = 2, computes sylvester2, Sylvester's matrix of 1853\\n          of dimension (2*mx) x (2*mx). The determinants of properly chosen\\n          submatrices of this matrix (a.k.a. ``modified'' subresultants) can be\\n          used to compute the coefficients of the Sturmian PRS of f, g.\\n\\n      Applications of these Matrices can be found in the references below.\\n      Especially, for applications of sylvester2, see the first reference!!\\n\\n      References\\n      ==========\\n      1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n      by Van Vleck Regarding Sturm Sequences. Serdica Journal of Computing,\\n      Vol. 7, No 4, 101-134, 2013.\\n\\n      2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n      and Modified Subresultant Polynomial Remainder Sequences.''\\n      Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    (m, n) = (degree(Poly(f, x), x), degree(Poly(g, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    fp = Poly(f, x).all_coeffs()\n    gp = Poly(g, x).all_coeffs()\n    if method <= 1:\n        M = zeros(m + n)\n        k = 0\n        for i in range(n):\n            j = k\n            for coeff in fp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        k = 0\n        for i in range(n, m + n):\n            j = k\n            for coeff in gp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M\n    if method >= 2:\n        if len(fp) < len(gp):\n            h = []\n            for i in range(len(gp) - len(fp)):\n                h.append(0)\n            fp[:0] = h\n        else:\n            h = []\n            for i in range(len(fp) - len(gp)):\n                h.append(0)\n            gp[:0] = h\n        mx = max(m, n)\n        dim = 2 * mx\n        M = zeros(dim)\n        k = 0\n        for i in range(mx):\n            j = k\n            for coeff in fp:\n                M[2 * i, j] = coeff\n                j = j + 1\n            j = k\n            for coeff in gp:\n                M[2 * i + 1, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M",
            "def sylvester(f, g, x, method=1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n      The input polynomials f, g are in Z[x] or in Q[x]. Let m = degree(f, x),\\n      n = degree(g, x) and mx = max(m, n).\\n\\n      a. If method = 1 (default), computes sylvester1, Sylvester's matrix of 1840\\n          of dimension (m + n) x (m + n). The determinants of properly chosen\\n          submatrices of this matrix (a.k.a. subresultants) can be\\n          used to compute the coefficients of the Euclidean PRS of f, g.\\n\\n      b. If method = 2, computes sylvester2, Sylvester's matrix of 1853\\n          of dimension (2*mx) x (2*mx). The determinants of properly chosen\\n          submatrices of this matrix (a.k.a. ``modified'' subresultants) can be\\n          used to compute the coefficients of the Sturmian PRS of f, g.\\n\\n      Applications of these Matrices can be found in the references below.\\n      Especially, for applications of sylvester2, see the first reference!!\\n\\n      References\\n      ==========\\n      1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n      by Van Vleck Regarding Sturm Sequences. Serdica Journal of Computing,\\n      Vol. 7, No 4, 101-134, 2013.\\n\\n      2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n      and Modified Subresultant Polynomial Remainder Sequences.''\\n      Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    (m, n) = (degree(Poly(f, x), x), degree(Poly(g, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    fp = Poly(f, x).all_coeffs()\n    gp = Poly(g, x).all_coeffs()\n    if method <= 1:\n        M = zeros(m + n)\n        k = 0\n        for i in range(n):\n            j = k\n            for coeff in fp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        k = 0\n        for i in range(n, m + n):\n            j = k\n            for coeff in gp:\n                M[i, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M\n    if method >= 2:\n        if len(fp) < len(gp):\n            h = []\n            for i in range(len(gp) - len(fp)):\n                h.append(0)\n            fp[:0] = h\n        else:\n            h = []\n            for i in range(len(fp) - len(gp)):\n                h.append(0)\n            gp[:0] = h\n        mx = max(m, n)\n        dim = 2 * mx\n        M = zeros(dim)\n        k = 0\n        for i in range(mx):\n            j = k\n            for coeff in fp:\n                M[2 * i, j] = coeff\n                j = j + 1\n            j = k\n            for coeff in gp:\n                M[2 * i + 1, j] = coeff\n                j = j + 1\n            k = k + 1\n        return M"
        ]
    },
    {
        "func_name": "process_matrix_output",
        "original": "def process_matrix_output(poly_seq, x):\n    \"\"\"\n    poly_seq is a polynomial remainder sequence computed either by\n    (modified_)subresultants_bezout or by (modified_)subresultants_sylv.\n\n    This function removes from poly_seq all zero polynomials as well\n    as all those whose degree is equal to the degree of a preceding\n    polynomial in poly_seq, as we scan it from left to right.\n\n    \"\"\"\n    L = poly_seq[:]\n    d = degree(L[1], x)\n    i = 2\n    while i < len(L):\n        d_i = degree(L[i], x)\n        if d_i < 0:\n            L.remove(L[i])\n            i = i - 1\n        if d == d_i:\n            L.remove(L[i])\n            i = i - 1\n        if d_i >= 0:\n            d = d_i\n        i = i + 1\n    return L",
        "mutated": [
            "def process_matrix_output(poly_seq, x):\n    if False:\n        i = 10\n    '\\n    poly_seq is a polynomial remainder sequence computed either by\\n    (modified_)subresultants_bezout or by (modified_)subresultants_sylv.\\n\\n    This function removes from poly_seq all zero polynomials as well\\n    as all those whose degree is equal to the degree of a preceding\\n    polynomial in poly_seq, as we scan it from left to right.\\n\\n    '\n    L = poly_seq[:]\n    d = degree(L[1], x)\n    i = 2\n    while i < len(L):\n        d_i = degree(L[i], x)\n        if d_i < 0:\n            L.remove(L[i])\n            i = i - 1\n        if d == d_i:\n            L.remove(L[i])\n            i = i - 1\n        if d_i >= 0:\n            d = d_i\n        i = i + 1\n    return L",
            "def process_matrix_output(poly_seq, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    poly_seq is a polynomial remainder sequence computed either by\\n    (modified_)subresultants_bezout or by (modified_)subresultants_sylv.\\n\\n    This function removes from poly_seq all zero polynomials as well\\n    as all those whose degree is equal to the degree of a preceding\\n    polynomial in poly_seq, as we scan it from left to right.\\n\\n    '\n    L = poly_seq[:]\n    d = degree(L[1], x)\n    i = 2\n    while i < len(L):\n        d_i = degree(L[i], x)\n        if d_i < 0:\n            L.remove(L[i])\n            i = i - 1\n        if d == d_i:\n            L.remove(L[i])\n            i = i - 1\n        if d_i >= 0:\n            d = d_i\n        i = i + 1\n    return L",
            "def process_matrix_output(poly_seq, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    poly_seq is a polynomial remainder sequence computed either by\\n    (modified_)subresultants_bezout or by (modified_)subresultants_sylv.\\n\\n    This function removes from poly_seq all zero polynomials as well\\n    as all those whose degree is equal to the degree of a preceding\\n    polynomial in poly_seq, as we scan it from left to right.\\n\\n    '\n    L = poly_seq[:]\n    d = degree(L[1], x)\n    i = 2\n    while i < len(L):\n        d_i = degree(L[i], x)\n        if d_i < 0:\n            L.remove(L[i])\n            i = i - 1\n        if d == d_i:\n            L.remove(L[i])\n            i = i - 1\n        if d_i >= 0:\n            d = d_i\n        i = i + 1\n    return L",
            "def process_matrix_output(poly_seq, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    poly_seq is a polynomial remainder sequence computed either by\\n    (modified_)subresultants_bezout or by (modified_)subresultants_sylv.\\n\\n    This function removes from poly_seq all zero polynomials as well\\n    as all those whose degree is equal to the degree of a preceding\\n    polynomial in poly_seq, as we scan it from left to right.\\n\\n    '\n    L = poly_seq[:]\n    d = degree(L[1], x)\n    i = 2\n    while i < len(L):\n        d_i = degree(L[i], x)\n        if d_i < 0:\n            L.remove(L[i])\n            i = i - 1\n        if d == d_i:\n            L.remove(L[i])\n            i = i - 1\n        if d_i >= 0:\n            d = d_i\n        i = i + 1\n    return L",
            "def process_matrix_output(poly_seq, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    poly_seq is a polynomial remainder sequence computed either by\\n    (modified_)subresultants_bezout or by (modified_)subresultants_sylv.\\n\\n    This function removes from poly_seq all zero polynomials as well\\n    as all those whose degree is equal to the degree of a preceding\\n    polynomial in poly_seq, as we scan it from left to right.\\n\\n    '\n    L = poly_seq[:]\n    d = degree(L[1], x)\n    i = 2\n    while i < len(L):\n        d_i = degree(L[i], x)\n        if d_i < 0:\n            L.remove(L[i])\n            i = i - 1\n        if d == d_i:\n            L.remove(L[i])\n            i = i - 1\n        if d_i >= 0:\n            d = d_i\n        i = i + 1\n    return L"
        ]
    },
    {
        "func_name": "subresultants_sylv",
        "original": "def subresultants_sylv(f, g, x):\n    \"\"\"\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\n    that deg(f) >= deg(g).\n\n    Computes the subresultant polynomial remainder sequence (prs)\n    of f, g by evaluating determinants of appropriately selected\n    submatrices of sylvester(f, g, x, 1). The dimensions of the\n    latter are (deg(f) + deg(g)) x (deg(f) + deg(g)).\n\n    Each coefficient is computed by evaluating the determinant of the\n    corresponding submatrix of sylvester(f, g, x, 1).\n\n    If the subresultant prs is complete, then the output coincides\n    with the Euclidean sequence of the polynomials f, g.\n\n    References:\n    ===========\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\n    Vol. 15, 233-266, 2004.\n\n    \"\"\"\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 1)\n    j = m - 1\n    while j > 0:\n        Sp = S[:, :]\n        for ind in range(m + n - j, m + n):\n            Sp.row_del(m + n - j)\n        for ind in range(m - j, m):\n            Sp.row_del(m - j)\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)",
        "mutated": [
            "def subresultants_sylv(f, g, x):\n    if False:\n        i = 10\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\\n    that deg(f) >= deg(g).\\n\\n    Computes the subresultant polynomial remainder sequence (prs)\\n    of f, g by evaluating determinants of appropriately selected\\n    submatrices of sylvester(f, g, x, 1). The dimensions of the\\n    latter are (deg(f) + deg(g)) x (deg(f) + deg(g)).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of sylvester(f, g, x, 1).\\n\\n    If the subresultant prs is complete, then the output coincides\\n    with the Euclidean sequence of the polynomials f, g.\\n\\n    References:\\n    ===========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    '\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 1)\n    j = m - 1\n    while j > 0:\n        Sp = S[:, :]\n        for ind in range(m + n - j, m + n):\n            Sp.row_del(m + n - j)\n        for ind in range(m - j, m):\n            Sp.row_del(m - j)\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)",
            "def subresultants_sylv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\\n    that deg(f) >= deg(g).\\n\\n    Computes the subresultant polynomial remainder sequence (prs)\\n    of f, g by evaluating determinants of appropriately selected\\n    submatrices of sylvester(f, g, x, 1). The dimensions of the\\n    latter are (deg(f) + deg(g)) x (deg(f) + deg(g)).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of sylvester(f, g, x, 1).\\n\\n    If the subresultant prs is complete, then the output coincides\\n    with the Euclidean sequence of the polynomials f, g.\\n\\n    References:\\n    ===========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    '\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 1)\n    j = m - 1\n    while j > 0:\n        Sp = S[:, :]\n        for ind in range(m + n - j, m + n):\n            Sp.row_del(m + n - j)\n        for ind in range(m - j, m):\n            Sp.row_del(m - j)\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)",
            "def subresultants_sylv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\\n    that deg(f) >= deg(g).\\n\\n    Computes the subresultant polynomial remainder sequence (prs)\\n    of f, g by evaluating determinants of appropriately selected\\n    submatrices of sylvester(f, g, x, 1). The dimensions of the\\n    latter are (deg(f) + deg(g)) x (deg(f) + deg(g)).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of sylvester(f, g, x, 1).\\n\\n    If the subresultant prs is complete, then the output coincides\\n    with the Euclidean sequence of the polynomials f, g.\\n\\n    References:\\n    ===========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    '\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 1)\n    j = m - 1\n    while j > 0:\n        Sp = S[:, :]\n        for ind in range(m + n - j, m + n):\n            Sp.row_del(m + n - j)\n        for ind in range(m - j, m):\n            Sp.row_del(m - j)\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)",
            "def subresultants_sylv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\\n    that deg(f) >= deg(g).\\n\\n    Computes the subresultant polynomial remainder sequence (prs)\\n    of f, g by evaluating determinants of appropriately selected\\n    submatrices of sylvester(f, g, x, 1). The dimensions of the\\n    latter are (deg(f) + deg(g)) x (deg(f) + deg(g)).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of sylvester(f, g, x, 1).\\n\\n    If the subresultant prs is complete, then the output coincides\\n    with the Euclidean sequence of the polynomials f, g.\\n\\n    References:\\n    ===========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    '\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 1)\n    j = m - 1\n    while j > 0:\n        Sp = S[:, :]\n        for ind in range(m + n - j, m + n):\n            Sp.row_del(m + n - j)\n        for ind in range(m - j, m):\n            Sp.row_del(m - j)\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)",
            "def subresultants_sylv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\\n    that deg(f) >= deg(g).\\n\\n    Computes the subresultant polynomial remainder sequence (prs)\\n    of f, g by evaluating determinants of appropriately selected\\n    submatrices of sylvester(f, g, x, 1). The dimensions of the\\n    latter are (deg(f) + deg(g)) x (deg(f) + deg(g)).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of sylvester(f, g, x, 1).\\n\\n    If the subresultant prs is complete, then the output coincides\\n    with the Euclidean sequence of the polynomials f, g.\\n\\n    References:\\n    ===========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    '\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 1)\n    j = m - 1\n    while j > 0:\n        Sp = S[:, :]\n        for ind in range(m + n - j, m + n):\n            Sp.row_del(m + n - j)\n        for ind in range(m - j, m):\n            Sp.row_del(m - j)\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)"
        ]
    },
    {
        "func_name": "modified_subresultants_sylv",
        "original": "def modified_subresultants_sylv(f, g, x):\n    \"\"\"\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\n    that deg(f) >= deg(g).\n\n    Computes the modified subresultant polynomial remainder sequence (prs)\n    of f, g by evaluating determinants of appropriately selected\n    submatrices of sylvester(f, g, x, 2). The dimensions of the\n    latter are (2*deg(f)) x (2*deg(f)).\n\n    Each coefficient is computed by evaluating the determinant of the\n    corresponding submatrix of sylvester(f, g, x, 2).\n\n    If the modified subresultant prs is complete, then the output coincides\n    with the Sturmian sequence of the polynomials f, g.\n\n    References:\n    ===========\n    1. A. G. Akritas,G.I. Malaschonok and P.S. Vigklas:\n    Sturm Sequences and Modified Subresultant Polynomial Remainder\n    Sequences. Serdica Journal of Computing, Vol. 8, No 1, 29--46, 2014.\n\n    \"\"\"\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 2)\n    j = m - 1\n    while j > 0:\n        Sp = S[0:2 * n - 2 * j, :]\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)",
        "mutated": [
            "def modified_subresultants_sylv(f, g, x):\n    if False:\n        i = 10\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\\n    that deg(f) >= deg(g).\\n\\n    Computes the modified subresultant polynomial remainder sequence (prs)\\n    of f, g by evaluating determinants of appropriately selected\\n    submatrices of sylvester(f, g, x, 2). The dimensions of the\\n    latter are (2*deg(f)) x (2*deg(f)).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of sylvester(f, g, x, 2).\\n\\n    If the modified subresultant prs is complete, then the output coincides\\n    with the Sturmian sequence of the polynomials f, g.\\n\\n    References:\\n    ===========\\n    1. A. G. Akritas,G.I. Malaschonok and P.S. Vigklas:\\n    Sturm Sequences and Modified Subresultant Polynomial Remainder\\n    Sequences. Serdica Journal of Computing, Vol. 8, No 1, 29--46, 2014.\\n\\n    '\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 2)\n    j = m - 1\n    while j > 0:\n        Sp = S[0:2 * n - 2 * j, :]\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)",
            "def modified_subresultants_sylv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\\n    that deg(f) >= deg(g).\\n\\n    Computes the modified subresultant polynomial remainder sequence (prs)\\n    of f, g by evaluating determinants of appropriately selected\\n    submatrices of sylvester(f, g, x, 2). The dimensions of the\\n    latter are (2*deg(f)) x (2*deg(f)).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of sylvester(f, g, x, 2).\\n\\n    If the modified subresultant prs is complete, then the output coincides\\n    with the Sturmian sequence of the polynomials f, g.\\n\\n    References:\\n    ===========\\n    1. A. G. Akritas,G.I. Malaschonok and P.S. Vigklas:\\n    Sturm Sequences and Modified Subresultant Polynomial Remainder\\n    Sequences. Serdica Journal of Computing, Vol. 8, No 1, 29--46, 2014.\\n\\n    '\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 2)\n    j = m - 1\n    while j > 0:\n        Sp = S[0:2 * n - 2 * j, :]\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)",
            "def modified_subresultants_sylv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\\n    that deg(f) >= deg(g).\\n\\n    Computes the modified subresultant polynomial remainder sequence (prs)\\n    of f, g by evaluating determinants of appropriately selected\\n    submatrices of sylvester(f, g, x, 2). The dimensions of the\\n    latter are (2*deg(f)) x (2*deg(f)).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of sylvester(f, g, x, 2).\\n\\n    If the modified subresultant prs is complete, then the output coincides\\n    with the Sturmian sequence of the polynomials f, g.\\n\\n    References:\\n    ===========\\n    1. A. G. Akritas,G.I. Malaschonok and P.S. Vigklas:\\n    Sturm Sequences and Modified Subresultant Polynomial Remainder\\n    Sequences. Serdica Journal of Computing, Vol. 8, No 1, 29--46, 2014.\\n\\n    '\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 2)\n    j = m - 1\n    while j > 0:\n        Sp = S[0:2 * n - 2 * j, :]\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)",
            "def modified_subresultants_sylv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\\n    that deg(f) >= deg(g).\\n\\n    Computes the modified subresultant polynomial remainder sequence (prs)\\n    of f, g by evaluating determinants of appropriately selected\\n    submatrices of sylvester(f, g, x, 2). The dimensions of the\\n    latter are (2*deg(f)) x (2*deg(f)).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of sylvester(f, g, x, 2).\\n\\n    If the modified subresultant prs is complete, then the output coincides\\n    with the Sturmian sequence of the polynomials f, g.\\n\\n    References:\\n    ===========\\n    1. A. G. Akritas,G.I. Malaschonok and P.S. Vigklas:\\n    Sturm Sequences and Modified Subresultant Polynomial Remainder\\n    Sequences. Serdica Journal of Computing, Vol. 8, No 1, 29--46, 2014.\\n\\n    '\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 2)\n    j = m - 1\n    while j > 0:\n        Sp = S[0:2 * n - 2 * j, :]\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)",
            "def modified_subresultants_sylv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x]. It is assumed\\n    that deg(f) >= deg(g).\\n\\n    Computes the modified subresultant polynomial remainder sequence (prs)\\n    of f, g by evaluating determinants of appropriately selected\\n    submatrices of sylvester(f, g, x, 2). The dimensions of the\\n    latter are (2*deg(f)) x (2*deg(f)).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of sylvester(f, g, x, 2).\\n\\n    If the modified subresultant prs is complete, then the output coincides\\n    with the Sturmian sequence of the polynomials f, g.\\n\\n    References:\\n    ===========\\n    1. A. G. Akritas,G.I. Malaschonok and P.S. Vigklas:\\n    Sturm Sequences and Modified Subresultant Polynomial Remainder\\n    Sequences. Serdica Journal of Computing, Vol. 8, No 1, 29--46, 2014.\\n\\n    '\n    if f == 0 or g == 0:\n        return [f, g]\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    S = sylvester(f, g, x, 2)\n    j = m - 1\n    while j > 0:\n        Sp = S[0:2 * n - 2 * j, :]\n        (coeff_L, k, l) = ([], Sp.rows, 0)\n        while l <= j:\n            coeff_L.append(Sp[:, 0:k].det())\n            Sp.col_swap(k - 1, k + l)\n            l += 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j -= 1\n    SR_L.append(S.det())\n    return process_matrix_output(SR_L, x)"
        ]
    },
    {
        "func_name": "res",
        "original": "def res(f, g, x):\n    \"\"\"\n    The input polynomials f, g are in Z[x] or in Q[x].\n\n    The output is the resultant of f, g computed by evaluating\n    the determinant of the matrix sylvester(f, g, x, 1).\n\n    References:\n    ===========\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\n     - Mathematical Methods. A. K. Peters, 2003.\n\n    \"\"\"\n    if f == 0 or g == 0:\n        raise PolynomialError('The resultant of %s and %s is not defined' % (f, g))\n    else:\n        return sylvester(f, g, x, 1).det()",
        "mutated": [
            "def res(f, g, x):\n    if False:\n        i = 10\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed by evaluating\\n    the determinant of the matrix sylvester(f, g, x, 1).\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n\\n    '\n    if f == 0 or g == 0:\n        raise PolynomialError('The resultant of %s and %s is not defined' % (f, g))\n    else:\n        return sylvester(f, g, x, 1).det()",
            "def res(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed by evaluating\\n    the determinant of the matrix sylvester(f, g, x, 1).\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n\\n    '\n    if f == 0 or g == 0:\n        raise PolynomialError('The resultant of %s and %s is not defined' % (f, g))\n    else:\n        return sylvester(f, g, x, 1).det()",
            "def res(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed by evaluating\\n    the determinant of the matrix sylvester(f, g, x, 1).\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n\\n    '\n    if f == 0 or g == 0:\n        raise PolynomialError('The resultant of %s and %s is not defined' % (f, g))\n    else:\n        return sylvester(f, g, x, 1).det()",
            "def res(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed by evaluating\\n    the determinant of the matrix sylvester(f, g, x, 1).\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n\\n    '\n    if f == 0 or g == 0:\n        raise PolynomialError('The resultant of %s and %s is not defined' % (f, g))\n    else:\n        return sylvester(f, g, x, 1).det()",
            "def res(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed by evaluating\\n    the determinant of the matrix sylvester(f, g, x, 1).\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n\\n    '\n    if f == 0 or g == 0:\n        raise PolynomialError('The resultant of %s and %s is not defined' % (f, g))\n    else:\n        return sylvester(f, g, x, 1).det()"
        ]
    },
    {
        "func_name": "res_q",
        "original": "def res_q(f, g, x):\n    \"\"\"\n    The input polynomials f, g are in Z[x] or in Q[x].\n\n    The output is the resultant of f, g computed recursively\n    by polynomial divisions in Q[x], using the function rem.\n    See Cohen's book p. 281.\n\n    References:\n    ===========\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\n     - Mathematical Methods. A. K. Peters, 2003.\n    \"\"\"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_q(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = rem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            s = degree(r, x)\n            l = LC(g, x)\n            return (-1) ** (m * n) * l ** (m - s) * res_q(g, r, x)",
        "mutated": [
            "def res_q(f, g, x):\n    if False:\n        i = 10\n    \"\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed recursively\\n    by polynomial divisions in Q[x], using the function rem.\\n    See Cohen's book p. 281.\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n    \"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_q(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = rem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            s = degree(r, x)\n            l = LC(g, x)\n            return (-1) ** (m * n) * l ** (m - s) * res_q(g, r, x)",
            "def res_q(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed recursively\\n    by polynomial divisions in Q[x], using the function rem.\\n    See Cohen's book p. 281.\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n    \"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_q(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = rem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            s = degree(r, x)\n            l = LC(g, x)\n            return (-1) ** (m * n) * l ** (m - s) * res_q(g, r, x)",
            "def res_q(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed recursively\\n    by polynomial divisions in Q[x], using the function rem.\\n    See Cohen's book p. 281.\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n    \"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_q(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = rem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            s = degree(r, x)\n            l = LC(g, x)\n            return (-1) ** (m * n) * l ** (m - s) * res_q(g, r, x)",
            "def res_q(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed recursively\\n    by polynomial divisions in Q[x], using the function rem.\\n    See Cohen's book p. 281.\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n    \"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_q(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = rem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            s = degree(r, x)\n            l = LC(g, x)\n            return (-1) ** (m * n) * l ** (m - s) * res_q(g, r, x)",
            "def res_q(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed recursively\\n    by polynomial divisions in Q[x], using the function rem.\\n    See Cohen's book p. 281.\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n    \"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_q(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = rem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            s = degree(r, x)\n            l = LC(g, x)\n            return (-1) ** (m * n) * l ** (m - s) * res_q(g, r, x)"
        ]
    },
    {
        "func_name": "res_z",
        "original": "def res_z(f, g, x):\n    \"\"\"\n    The input polynomials f, g are in Z[x] or in Q[x].\n\n    The output is the resultant of f, g computed recursively\n    by polynomial divisions in Z[x], using the function prem().\n    See Cohen's book p. 283.\n\n    References:\n    ===========\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\n     - Mathematical Methods. A. K. Peters, 2003.\n    \"\"\"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_z(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = prem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            delta = m - n + 1\n            w = (-1) ** (m * n) * res_z(g, r, x)\n            s = degree(r, x)\n            l = LC(g, x)\n            k = delta * n - m + s\n            return quo(w, l ** k, x)",
        "mutated": [
            "def res_z(f, g, x):\n    if False:\n        i = 10\n    \"\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed recursively\\n    by polynomial divisions in Z[x], using the function prem().\\n    See Cohen's book p. 283.\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n    \"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_z(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = prem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            delta = m - n + 1\n            w = (-1) ** (m * n) * res_z(g, r, x)\n            s = degree(r, x)\n            l = LC(g, x)\n            k = delta * n - m + s\n            return quo(w, l ** k, x)",
            "def res_z(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed recursively\\n    by polynomial divisions in Z[x], using the function prem().\\n    See Cohen's book p. 283.\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n    \"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_z(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = prem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            delta = m - n + 1\n            w = (-1) ** (m * n) * res_z(g, r, x)\n            s = degree(r, x)\n            l = LC(g, x)\n            k = delta * n - m + s\n            return quo(w, l ** k, x)",
            "def res_z(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed recursively\\n    by polynomial divisions in Z[x], using the function prem().\\n    See Cohen's book p. 283.\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n    \"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_z(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = prem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            delta = m - n + 1\n            w = (-1) ** (m * n) * res_z(g, r, x)\n            s = degree(r, x)\n            l = LC(g, x)\n            k = delta * n - m + s\n            return quo(w, l ** k, x)",
            "def res_z(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed recursively\\n    by polynomial divisions in Z[x], using the function prem().\\n    See Cohen's book p. 283.\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n    \"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_z(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = prem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            delta = m - n + 1\n            w = (-1) ** (m * n) * res_z(g, r, x)\n            s = degree(r, x)\n            l = LC(g, x)\n            k = delta * n - m + s\n            return quo(w, l ** k, x)",
            "def res_z(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    The input polynomials f, g are in Z[x] or in Q[x].\\n\\n    The output is the resultant of f, g computed recursively\\n    by polynomial divisions in Z[x], using the function prem().\\n    See Cohen's book p. 283.\\n\\n    References:\\n    ===========\\n    1. J. S. Cohen: Computer Algebra and Symbolic Computation\\n     - Mathematical Methods. A. K. Peters, 2003.\\n    \"\n    m = degree(f, x)\n    n = degree(g, x)\n    if m < n:\n        return (-1) ** (m * n) * res_z(g, f, x)\n    elif n == 0:\n        return g ** m\n    else:\n        r = prem(f, g, x)\n        if r == 0:\n            return 0\n        else:\n            delta = m - n + 1\n            w = (-1) ** (m * n) * res_z(g, r, x)\n            s = degree(r, x)\n            l = LC(g, x)\n            k = delta * n - m + s\n            return quo(w, l ** k, x)"
        ]
    },
    {
        "func_name": "sign_seq",
        "original": "def sign_seq(poly_seq, x):\n    \"\"\"\n    Given a sequence of polynomials poly_seq, it returns\n    the sequence of signs of the leading coefficients of\n    the polynomials in poly_seq.\n\n    \"\"\"\n    return [sign(LC(poly_seq[i], x)) for i in range(len(poly_seq))]",
        "mutated": [
            "def sign_seq(poly_seq, x):\n    if False:\n        i = 10\n    '\\n    Given a sequence of polynomials poly_seq, it returns\\n    the sequence of signs of the leading coefficients of\\n    the polynomials in poly_seq.\\n\\n    '\n    return [sign(LC(poly_seq[i], x)) for i in range(len(poly_seq))]",
            "def sign_seq(poly_seq, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Given a sequence of polynomials poly_seq, it returns\\n    the sequence of signs of the leading coefficients of\\n    the polynomials in poly_seq.\\n\\n    '\n    return [sign(LC(poly_seq[i], x)) for i in range(len(poly_seq))]",
            "def sign_seq(poly_seq, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Given a sequence of polynomials poly_seq, it returns\\n    the sequence of signs of the leading coefficients of\\n    the polynomials in poly_seq.\\n\\n    '\n    return [sign(LC(poly_seq[i], x)) for i in range(len(poly_seq))]",
            "def sign_seq(poly_seq, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Given a sequence of polynomials poly_seq, it returns\\n    the sequence of signs of the leading coefficients of\\n    the polynomials in poly_seq.\\n\\n    '\n    return [sign(LC(poly_seq[i], x)) for i in range(len(poly_seq))]",
            "def sign_seq(poly_seq, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Given a sequence of polynomials poly_seq, it returns\\n    the sequence of signs of the leading coefficients of\\n    the polynomials in poly_seq.\\n\\n    '\n    return [sign(LC(poly_seq[i], x)) for i in range(len(poly_seq))]"
        ]
    },
    {
        "func_name": "bezout",
        "original": "def bezout(p, q, x, method='bz'):\n    \"\"\"\n    The input polynomials p, q are in Z[x] or in Q[x]. Let\n    mx = max(degree(p, x), degree(q, x)).\n\n    The default option bezout(p, q, x, method='bz') returns Bezout's\n    symmetric matrix of p and q, of dimensions (mx) x (mx). The\n    determinant of this matrix is equal to the determinant of sylvester2,\n    Sylvester's matrix of 1853, whose dimensions are (2*mx) x (2*mx);\n    however the subresultants of these two matrices may differ.\n\n    The other option, bezout(p, q, x, 'prs'), is of interest to us\n    in this module because it returns a matrix equivalent to sylvester2.\n    In this case all subresultants of the two matrices are identical.\n\n    Both the subresultant polynomial remainder sequence (prs) and\n    the modified subresultant prs of p and q can be computed by\n    evaluating determinants of appropriately selected submatrices of\n    bezout(p, q, x, 'prs') --- one determinant per coefficient of the\n    remainder polynomials.\n\n    The matrices bezout(p, q, x, 'bz') and bezout(p, q, x, 'prs')\n    are related by the formula\n\n    bezout(p, q, x, 'prs') =\n    backward_eye(deg(p)) * bezout(p, q, x, 'bz') * backward_eye(deg(p)),\n\n    where backward_eye() is the backward identity function.\n\n    References\n    ==========\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\n    Vol. 15, 233-266, 2004.\n\n    \"\"\"\n    (m, n) = (degree(Poly(p, x), x), degree(Poly(q, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    y = var('y')\n    expr = p * q.subs({x: y}) - p.subs({x: y}) * q\n    poly = Poly(quo(expr, x - y), x, y)\n    mx = max(m, n)\n    B = zeros(mx)\n    for i in range(mx):\n        for j in range(mx):\n            if method == 'prs':\n                B[mx - 1 - i, mx - 1 - j] = poly.nth(i, j)\n            else:\n                B[i, j] = poly.nth(i, j)\n    return B",
        "mutated": [
            "def bezout(p, q, x, method='bz'):\n    if False:\n        i = 10\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. Let\\n    mx = max(degree(p, x), degree(q, x)).\\n\\n    The default option bezout(p, q, x, method='bz') returns Bezout's\\n    symmetric matrix of p and q, of dimensions (mx) x (mx). The\\n    determinant of this matrix is equal to the determinant of sylvester2,\\n    Sylvester's matrix of 1853, whose dimensions are (2*mx) x (2*mx);\\n    however the subresultants of these two matrices may differ.\\n\\n    The other option, bezout(p, q, x, 'prs'), is of interest to us\\n    in this module because it returns a matrix equivalent to sylvester2.\\n    In this case all subresultants of the two matrices are identical.\\n\\n    Both the subresultant polynomial remainder sequence (prs) and\\n    the modified subresultant prs of p and q can be computed by\\n    evaluating determinants of appropriately selected submatrices of\\n    bezout(p, q, x, 'prs') --- one determinant per coefficient of the\\n    remainder polynomials.\\n\\n    The matrices bezout(p, q, x, 'bz') and bezout(p, q, x, 'prs')\\n    are related by the formula\\n\\n    bezout(p, q, x, 'prs') =\\n    backward_eye(deg(p)) * bezout(p, q, x, 'bz') * backward_eye(deg(p)),\\n\\n    where backward_eye() is the backward identity function.\\n\\n    References\\n    ==========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    \"\n    (m, n) = (degree(Poly(p, x), x), degree(Poly(q, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    y = var('y')\n    expr = p * q.subs({x: y}) - p.subs({x: y}) * q\n    poly = Poly(quo(expr, x - y), x, y)\n    mx = max(m, n)\n    B = zeros(mx)\n    for i in range(mx):\n        for j in range(mx):\n            if method == 'prs':\n                B[mx - 1 - i, mx - 1 - j] = poly.nth(i, j)\n            else:\n                B[i, j] = poly.nth(i, j)\n    return B",
            "def bezout(p, q, x, method='bz'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. Let\\n    mx = max(degree(p, x), degree(q, x)).\\n\\n    The default option bezout(p, q, x, method='bz') returns Bezout's\\n    symmetric matrix of p and q, of dimensions (mx) x (mx). The\\n    determinant of this matrix is equal to the determinant of sylvester2,\\n    Sylvester's matrix of 1853, whose dimensions are (2*mx) x (2*mx);\\n    however the subresultants of these two matrices may differ.\\n\\n    The other option, bezout(p, q, x, 'prs'), is of interest to us\\n    in this module because it returns a matrix equivalent to sylvester2.\\n    In this case all subresultants of the two matrices are identical.\\n\\n    Both the subresultant polynomial remainder sequence (prs) and\\n    the modified subresultant prs of p and q can be computed by\\n    evaluating determinants of appropriately selected submatrices of\\n    bezout(p, q, x, 'prs') --- one determinant per coefficient of the\\n    remainder polynomials.\\n\\n    The matrices bezout(p, q, x, 'bz') and bezout(p, q, x, 'prs')\\n    are related by the formula\\n\\n    bezout(p, q, x, 'prs') =\\n    backward_eye(deg(p)) * bezout(p, q, x, 'bz') * backward_eye(deg(p)),\\n\\n    where backward_eye() is the backward identity function.\\n\\n    References\\n    ==========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    \"\n    (m, n) = (degree(Poly(p, x), x), degree(Poly(q, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    y = var('y')\n    expr = p * q.subs({x: y}) - p.subs({x: y}) * q\n    poly = Poly(quo(expr, x - y), x, y)\n    mx = max(m, n)\n    B = zeros(mx)\n    for i in range(mx):\n        for j in range(mx):\n            if method == 'prs':\n                B[mx - 1 - i, mx - 1 - j] = poly.nth(i, j)\n            else:\n                B[i, j] = poly.nth(i, j)\n    return B",
            "def bezout(p, q, x, method='bz'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. Let\\n    mx = max(degree(p, x), degree(q, x)).\\n\\n    The default option bezout(p, q, x, method='bz') returns Bezout's\\n    symmetric matrix of p and q, of dimensions (mx) x (mx). The\\n    determinant of this matrix is equal to the determinant of sylvester2,\\n    Sylvester's matrix of 1853, whose dimensions are (2*mx) x (2*mx);\\n    however the subresultants of these two matrices may differ.\\n\\n    The other option, bezout(p, q, x, 'prs'), is of interest to us\\n    in this module because it returns a matrix equivalent to sylvester2.\\n    In this case all subresultants of the two matrices are identical.\\n\\n    Both the subresultant polynomial remainder sequence (prs) and\\n    the modified subresultant prs of p and q can be computed by\\n    evaluating determinants of appropriately selected submatrices of\\n    bezout(p, q, x, 'prs') --- one determinant per coefficient of the\\n    remainder polynomials.\\n\\n    The matrices bezout(p, q, x, 'bz') and bezout(p, q, x, 'prs')\\n    are related by the formula\\n\\n    bezout(p, q, x, 'prs') =\\n    backward_eye(deg(p)) * bezout(p, q, x, 'bz') * backward_eye(deg(p)),\\n\\n    where backward_eye() is the backward identity function.\\n\\n    References\\n    ==========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    \"\n    (m, n) = (degree(Poly(p, x), x), degree(Poly(q, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    y = var('y')\n    expr = p * q.subs({x: y}) - p.subs({x: y}) * q\n    poly = Poly(quo(expr, x - y), x, y)\n    mx = max(m, n)\n    B = zeros(mx)\n    for i in range(mx):\n        for j in range(mx):\n            if method == 'prs':\n                B[mx - 1 - i, mx - 1 - j] = poly.nth(i, j)\n            else:\n                B[i, j] = poly.nth(i, j)\n    return B",
            "def bezout(p, q, x, method='bz'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. Let\\n    mx = max(degree(p, x), degree(q, x)).\\n\\n    The default option bezout(p, q, x, method='bz') returns Bezout's\\n    symmetric matrix of p and q, of dimensions (mx) x (mx). The\\n    determinant of this matrix is equal to the determinant of sylvester2,\\n    Sylvester's matrix of 1853, whose dimensions are (2*mx) x (2*mx);\\n    however the subresultants of these two matrices may differ.\\n\\n    The other option, bezout(p, q, x, 'prs'), is of interest to us\\n    in this module because it returns a matrix equivalent to sylvester2.\\n    In this case all subresultants of the two matrices are identical.\\n\\n    Both the subresultant polynomial remainder sequence (prs) and\\n    the modified subresultant prs of p and q can be computed by\\n    evaluating determinants of appropriately selected submatrices of\\n    bezout(p, q, x, 'prs') --- one determinant per coefficient of the\\n    remainder polynomials.\\n\\n    The matrices bezout(p, q, x, 'bz') and bezout(p, q, x, 'prs')\\n    are related by the formula\\n\\n    bezout(p, q, x, 'prs') =\\n    backward_eye(deg(p)) * bezout(p, q, x, 'bz') * backward_eye(deg(p)),\\n\\n    where backward_eye() is the backward identity function.\\n\\n    References\\n    ==========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    \"\n    (m, n) = (degree(Poly(p, x), x), degree(Poly(q, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    y = var('y')\n    expr = p * q.subs({x: y}) - p.subs({x: y}) * q\n    poly = Poly(quo(expr, x - y), x, y)\n    mx = max(m, n)\n    B = zeros(mx)\n    for i in range(mx):\n        for j in range(mx):\n            if method == 'prs':\n                B[mx - 1 - i, mx - 1 - j] = poly.nth(i, j)\n            else:\n                B[i, j] = poly.nth(i, j)\n    return B",
            "def bezout(p, q, x, method='bz'):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. Let\\n    mx = max(degree(p, x), degree(q, x)).\\n\\n    The default option bezout(p, q, x, method='bz') returns Bezout's\\n    symmetric matrix of p and q, of dimensions (mx) x (mx). The\\n    determinant of this matrix is equal to the determinant of sylvester2,\\n    Sylvester's matrix of 1853, whose dimensions are (2*mx) x (2*mx);\\n    however the subresultants of these two matrices may differ.\\n\\n    The other option, bezout(p, q, x, 'prs'), is of interest to us\\n    in this module because it returns a matrix equivalent to sylvester2.\\n    In this case all subresultants of the two matrices are identical.\\n\\n    Both the subresultant polynomial remainder sequence (prs) and\\n    the modified subresultant prs of p and q can be computed by\\n    evaluating determinants of appropriately selected submatrices of\\n    bezout(p, q, x, 'prs') --- one determinant per coefficient of the\\n    remainder polynomials.\\n\\n    The matrices bezout(p, q, x, 'bz') and bezout(p, q, x, 'prs')\\n    are related by the formula\\n\\n    bezout(p, q, x, 'prs') =\\n    backward_eye(deg(p)) * bezout(p, q, x, 'bz') * backward_eye(deg(p)),\\n\\n    where backward_eye() is the backward identity function.\\n\\n    References\\n    ==========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    \"\n    (m, n) = (degree(Poly(p, x), x), degree(Poly(q, x), x))\n    if m == n and n < 0:\n        return Matrix([])\n    if m == n and n == 0:\n        return Matrix([])\n    if m == 0 and n < 0:\n        return Matrix([])\n    elif m < 0 and n == 0:\n        return Matrix([])\n    if m >= 1 and n < 0:\n        return Matrix([0])\n    elif m < 0 and n >= 1:\n        return Matrix([0])\n    y = var('y')\n    expr = p * q.subs({x: y}) - p.subs({x: y}) * q\n    poly = Poly(quo(expr, x - y), x, y)\n    mx = max(m, n)\n    B = zeros(mx)\n    for i in range(mx):\n        for j in range(mx):\n            if method == 'prs':\n                B[mx - 1 - i, mx - 1 - j] = poly.nth(i, j)\n            else:\n                B[i, j] = poly.nth(i, j)\n    return B"
        ]
    },
    {
        "func_name": "backward_eye",
        "original": "def backward_eye(n):\n    \"\"\"\n    Returns the backward identity matrix of dimensions n x n.\n\n    Needed to \"turn\" the Bezout matrices\n    so that the leading coefficients are first.\n    See docstring of the function bezout(p, q, x, method='bz').\n    \"\"\"\n    M = eye(n)\n    for i in range(int(M.rows / 2)):\n        M.row_swap(0 + i, M.rows - 1 - i)\n    return M",
        "mutated": [
            "def backward_eye(n):\n    if False:\n        i = 10\n    '\\n    Returns the backward identity matrix of dimensions n x n.\\n\\n    Needed to \"turn\" the Bezout matrices\\n    so that the leading coefficients are first.\\n    See docstring of the function bezout(p, q, x, method=\\'bz\\').\\n    '\n    M = eye(n)\n    for i in range(int(M.rows / 2)):\n        M.row_swap(0 + i, M.rows - 1 - i)\n    return M",
            "def backward_eye(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns the backward identity matrix of dimensions n x n.\\n\\n    Needed to \"turn\" the Bezout matrices\\n    so that the leading coefficients are first.\\n    See docstring of the function bezout(p, q, x, method=\\'bz\\').\\n    '\n    M = eye(n)\n    for i in range(int(M.rows / 2)):\n        M.row_swap(0 + i, M.rows - 1 - i)\n    return M",
            "def backward_eye(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns the backward identity matrix of dimensions n x n.\\n\\n    Needed to \"turn\" the Bezout matrices\\n    so that the leading coefficients are first.\\n    See docstring of the function bezout(p, q, x, method=\\'bz\\').\\n    '\n    M = eye(n)\n    for i in range(int(M.rows / 2)):\n        M.row_swap(0 + i, M.rows - 1 - i)\n    return M",
            "def backward_eye(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns the backward identity matrix of dimensions n x n.\\n\\n    Needed to \"turn\" the Bezout matrices\\n    so that the leading coefficients are first.\\n    See docstring of the function bezout(p, q, x, method=\\'bz\\').\\n    '\n    M = eye(n)\n    for i in range(int(M.rows / 2)):\n        M.row_swap(0 + i, M.rows - 1 - i)\n    return M",
            "def backward_eye(n):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns the backward identity matrix of dimensions n x n.\\n\\n    Needed to \"turn\" the Bezout matrices\\n    so that the leading coefficients are first.\\n    See docstring of the function bezout(p, q, x, method=\\'bz\\').\\n    '\n    M = eye(n)\n    for i in range(int(M.rows / 2)):\n        M.row_swap(0 + i, M.rows - 1 - i)\n    return M"
        ]
    },
    {
        "func_name": "subresultants_bezout",
        "original": "def subresultants_bezout(p, q, x):\n    \"\"\"\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the subresultant polynomial remainder sequence\n    of p, q by evaluating determinants of appropriately selected\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\n    latter are deg(p) x deg(p).\n\n    Each coefficient is computed by evaluating the determinant of the\n    corresponding submatrix of bezout(p, q, x, 'prs').\n\n    bezout(p, q, x, 'prs) is used instead of sylvester(p, q, x, 1),\n    Sylvester's matrix of 1840, because the dimensions of the latter\n    are (deg(p) + deg(q)) x (deg(p) + deg(q)).\n\n    If the subresultant prs is complete, then the output coincides\n    with the Euclidean sequence of the polynomials p, q.\n\n    References\n    ==========\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\n    Vol. 15, 233-266, 2004.\n\n    \"\"\"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    F = LC(f, x) ** (degF - degG)\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(int((-1) ** (j * (j - 1) / 2)) * (Poly(coeff_L, x) / F).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)",
        "mutated": [
            "def subresultants_bezout(p, q, x):\n    if False:\n        i = 10\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant polynomial remainder sequence\\n    of p, q by evaluating determinants of appropriately selected\\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\\n    latter are deg(p) x deg(p).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of bezout(p, q, x, 'prs').\\n\\n    bezout(p, q, x, 'prs) is used instead of sylvester(p, q, x, 1),\\n    Sylvester's matrix of 1840, because the dimensions of the latter\\n    are (deg(p) + deg(q)) x (deg(p) + deg(q)).\\n\\n    If the subresultant prs is complete, then the output coincides\\n    with the Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    F = LC(f, x) ** (degF - degG)\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(int((-1) ** (j * (j - 1) / 2)) * (Poly(coeff_L, x) / F).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)",
            "def subresultants_bezout(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant polynomial remainder sequence\\n    of p, q by evaluating determinants of appropriately selected\\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\\n    latter are deg(p) x deg(p).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of bezout(p, q, x, 'prs').\\n\\n    bezout(p, q, x, 'prs) is used instead of sylvester(p, q, x, 1),\\n    Sylvester's matrix of 1840, because the dimensions of the latter\\n    are (deg(p) + deg(q)) x (deg(p) + deg(q)).\\n\\n    If the subresultant prs is complete, then the output coincides\\n    with the Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    F = LC(f, x) ** (degF - degG)\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(int((-1) ** (j * (j - 1) / 2)) * (Poly(coeff_L, x) / F).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)",
            "def subresultants_bezout(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant polynomial remainder sequence\\n    of p, q by evaluating determinants of appropriately selected\\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\\n    latter are deg(p) x deg(p).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of bezout(p, q, x, 'prs').\\n\\n    bezout(p, q, x, 'prs) is used instead of sylvester(p, q, x, 1),\\n    Sylvester's matrix of 1840, because the dimensions of the latter\\n    are (deg(p) + deg(q)) x (deg(p) + deg(q)).\\n\\n    If the subresultant prs is complete, then the output coincides\\n    with the Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    F = LC(f, x) ** (degF - degG)\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(int((-1) ** (j * (j - 1) / 2)) * (Poly(coeff_L, x) / F).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)",
            "def subresultants_bezout(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant polynomial remainder sequence\\n    of p, q by evaluating determinants of appropriately selected\\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\\n    latter are deg(p) x deg(p).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of bezout(p, q, x, 'prs').\\n\\n    bezout(p, q, x, 'prs) is used instead of sylvester(p, q, x, 1),\\n    Sylvester's matrix of 1840, because the dimensions of the latter\\n    are (deg(p) + deg(q)) x (deg(p) + deg(q)).\\n\\n    If the subresultant prs is complete, then the output coincides\\n    with the Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    F = LC(f, x) ** (degF - degG)\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(int((-1) ** (j * (j - 1) / 2)) * (Poly(coeff_L, x) / F).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)",
            "def subresultants_bezout(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant polynomial remainder sequence\\n    of p, q by evaluating determinants of appropriately selected\\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\\n    latter are deg(p) x deg(p).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of bezout(p, q, x, 'prs').\\n\\n    bezout(p, q, x, 'prs) is used instead of sylvester(p, q, x, 1),\\n    Sylvester's matrix of 1840, because the dimensions of the latter\\n    are (deg(p) + deg(q)) x (deg(p) + deg(q)).\\n\\n    If the subresultant prs is complete, then the output coincides\\n    with the Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    F = LC(f, x) ** (degF - degG)\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(int((-1) ** (j * (j - 1) / 2)) * (Poly(coeff_L, x) / F).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)"
        ]
    },
    {
        "func_name": "modified_subresultants_bezout",
        "original": "def modified_subresultants_bezout(p, q, x):\n    \"\"\"\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the modified subresultant polynomial remainder sequence\n    of p, q by evaluating determinants of appropriately selected\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\n    latter are deg(p) x deg(p).\n\n    Each coefficient is computed by evaluating the determinant of the\n    corresponding submatrix of bezout(p, q, x, 'prs').\n\n    bezout(p, q, x, 'prs') is used instead of sylvester(p, q, x, 2),\n    Sylvester's matrix of 1853, because the dimensions of the latter\n    are 2*deg(p) x 2*deg(p).\n\n    If the modified subresultant prs is complete, and LC( p ) > 0, the output\n    coincides with the (generalized) Sturm's sequence of the polynomials p, q.\n\n    References\n    ==========\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\n    and Modified Subresultant Polynomial Remainder Sequences.''\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\n\n    2. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\n    Vol. 15, 233-266, 2004.\n\n\n    \"\"\"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)",
        "mutated": [
            "def modified_subresultants_bezout(p, q, x):\n    if False:\n        i = 10\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the modified subresultant polynomial remainder sequence\\n    of p, q by evaluating determinants of appropriately selected\\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\\n    latter are deg(p) x deg(p).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of bezout(p, q, x, 'prs').\\n\\n    bezout(p, q, x, 'prs') is used instead of sylvester(p, q, x, 2),\\n    Sylvester's matrix of 1853, because the dimensions of the latter\\n    are 2*deg(p) x 2*deg(p).\\n\\n    If the modified subresultant prs is complete, and LC( p ) > 0, the output\\n    coincides with the (generalized) Sturm's sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    2. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)",
            "def modified_subresultants_bezout(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the modified subresultant polynomial remainder sequence\\n    of p, q by evaluating determinants of appropriately selected\\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\\n    latter are deg(p) x deg(p).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of bezout(p, q, x, 'prs').\\n\\n    bezout(p, q, x, 'prs') is used instead of sylvester(p, q, x, 2),\\n    Sylvester's matrix of 1853, because the dimensions of the latter\\n    are 2*deg(p) x 2*deg(p).\\n\\n    If the modified subresultant prs is complete, and LC( p ) > 0, the output\\n    coincides with the (generalized) Sturm's sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    2. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)",
            "def modified_subresultants_bezout(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the modified subresultant polynomial remainder sequence\\n    of p, q by evaluating determinants of appropriately selected\\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\\n    latter are deg(p) x deg(p).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of bezout(p, q, x, 'prs').\\n\\n    bezout(p, q, x, 'prs') is used instead of sylvester(p, q, x, 2),\\n    Sylvester's matrix of 1853, because the dimensions of the latter\\n    are 2*deg(p) x 2*deg(p).\\n\\n    If the modified subresultant prs is complete, and LC( p ) > 0, the output\\n    coincides with the (generalized) Sturm's sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    2. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)",
            "def modified_subresultants_bezout(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the modified subresultant polynomial remainder sequence\\n    of p, q by evaluating determinants of appropriately selected\\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\\n    latter are deg(p) x deg(p).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of bezout(p, q, x, 'prs').\\n\\n    bezout(p, q, x, 'prs') is used instead of sylvester(p, q, x, 2),\\n    Sylvester's matrix of 1853, because the dimensions of the latter\\n    are 2*deg(p) x 2*deg(p).\\n\\n    If the modified subresultant prs is complete, and LC( p ) > 0, the output\\n    coincides with the (generalized) Sturm's sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    2. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)",
            "def modified_subresultants_bezout(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    The input polynomials p, q are in Z[x] or in Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the modified subresultant polynomial remainder sequence\\n    of p, q by evaluating determinants of appropriately selected\\n    submatrices of bezout(p, q, x, 'prs'). The dimensions of the\\n    latter are deg(p) x deg(p).\\n\\n    Each coefficient is computed by evaluating the determinant of the\\n    corresponding submatrix of bezout(p, q, x, 'prs').\\n\\n    bezout(p, q, x, 'prs') is used instead of sylvester(p, q, x, 2),\\n    Sylvester's matrix of 1853, because the dimensions of the latter\\n    are 2*deg(p) x 2*deg(p).\\n\\n    If the modified subresultant prs is complete, and LC( p ) > 0, the output\\n    coincides with the (generalized) Sturm's sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    2. G.M.Diaz-Toca,L.Gonzalez-Vega: Various New Expressions for Subresultants\\n    and Their Applications. Appl. Algebra in Engin., Communic. and Comp.,\\n    Vol. 15, 233-266, 2004.\\n\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = degF = degree(f, x)\n    m = degG = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, degF, degG, f, g) = (m, n, degG, degF, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    SR_L = [f, g]\n    B = bezout(f, g, x, 'prs')\n    if degF > degG:\n        j = 2\n    if degF == degG:\n        j = 1\n    while j <= degF:\n        M = B[0:j, :]\n        (k, coeff_L) = (j - 1, [])\n        while k <= degF - 1:\n            coeff_L.append(M[:, 0:j].det())\n            if k < degF - 1:\n                M.col_swap(j - 1, k + 1)\n            k = k + 1\n        SR_L.append(Poly(coeff_L, x).as_expr())\n        j = j + 1\n    return process_matrix_output(SR_L, x)"
        ]
    },
    {
        "func_name": "sturm_pg",
        "original": "def sturm_pg(p, q, x, method=0):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\n\n    A. If method == 0, default, the remainder coefficients of the sequence\n       are (in absolute value) ``modified'' subresultants, which for non-monic\n       polynomials are greater than the coefficients of the corresponding\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\n\n    B. If method == 1, the remainder coefficients of the sequence are (in\n       absolute value) subresultants, which for non-monic polynomials are\n       smaller than the coefficients of the corresponding ``modified''\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\n\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, the coefficients\n    of the polynomials in the sequence are ``modified'' subresultants.\n    That is, they are  determinants of appropriately selected submatrices of\n    sylvester2, Sylvester's matrix of 1853. In this case the Sturm sequence\n    coincides with the ``modified'' subresultant prs, of the polynomials\n    p, q.\n\n    If the Sturm sequence is incomplete and method=0 then the signs of the\n    coefficients of the polynomials in the sequence may differ from the signs\n    of the coefficients of the corresponding polynomials in the ``modified''\n    subresultant prs; however, the absolute values are the same.\n\n    To compute the coefficients, no determinant evaluation takes place. Instead,\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\n    the coefficients of the remainders computed this way become (``modified'')\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\n    See also the function euclid_pg(p, q, x).\n\n    References\n    ==========\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\n    Second Series, 18 (1917), No. 4, 188-193.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\n    and Modified Subresultant Polynomial Remainder Sequences.''\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\n\n    \"\"\"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    lcf = LC(p, x) ** (d0 - d1)\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    del0 = d0 - d1\n    rho1 = LC(a1, x)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    if method == 0:\n        sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n    else:\n        sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        if method == 0:\n            sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n        else:\n            sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq",
        "mutated": [
            "def sturm_pg(p, q, x, method=0):\n    if False:\n        i = 10\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\\n\\n    A. If method == 0, default, the remainder coefficients of the sequence\\n       are (in absolute value) ``modified'' subresultants, which for non-monic\\n       polynomials are greater than the coefficients of the corresponding\\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    B. If method == 1, the remainder coefficients of the sequence are (in\\n       absolute value) subresultants, which for non-monic polynomials are\\n       smaller than the coefficients of the corresponding ``modified''\\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, the coefficients\\n    of the polynomials in the sequence are ``modified'' subresultants.\\n    That is, they are  determinants of appropriately selected submatrices of\\n    sylvester2, Sylvester's matrix of 1853. In this case the Sturm sequence\\n    coincides with the ``modified'' subresultant prs, of the polynomials\\n    p, q.\\n\\n    If the Sturm sequence is incomplete and method=0 then the signs of the\\n    coefficients of the polynomials in the sequence may differ from the signs\\n    of the coefficients of the corresponding polynomials in the ``modified''\\n    subresultant prs; however, the absolute values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place. Instead,\\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\\n    the coefficients of the remainders computed this way become (``modified'')\\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\\n    See also the function euclid_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    lcf = LC(p, x) ** (d0 - d1)\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    del0 = d0 - d1\n    rho1 = LC(a1, x)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    if method == 0:\n        sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n    else:\n        sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        if method == 0:\n            sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n        else:\n            sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq",
            "def sturm_pg(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\\n\\n    A. If method == 0, default, the remainder coefficients of the sequence\\n       are (in absolute value) ``modified'' subresultants, which for non-monic\\n       polynomials are greater than the coefficients of the corresponding\\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    B. If method == 1, the remainder coefficients of the sequence are (in\\n       absolute value) subresultants, which for non-monic polynomials are\\n       smaller than the coefficients of the corresponding ``modified''\\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, the coefficients\\n    of the polynomials in the sequence are ``modified'' subresultants.\\n    That is, they are  determinants of appropriately selected submatrices of\\n    sylvester2, Sylvester's matrix of 1853. In this case the Sturm sequence\\n    coincides with the ``modified'' subresultant prs, of the polynomials\\n    p, q.\\n\\n    If the Sturm sequence is incomplete and method=0 then the signs of the\\n    coefficients of the polynomials in the sequence may differ from the signs\\n    of the coefficients of the corresponding polynomials in the ``modified''\\n    subresultant prs; however, the absolute values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place. Instead,\\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\\n    the coefficients of the remainders computed this way become (``modified'')\\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\\n    See also the function euclid_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    lcf = LC(p, x) ** (d0 - d1)\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    del0 = d0 - d1\n    rho1 = LC(a1, x)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    if method == 0:\n        sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n    else:\n        sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        if method == 0:\n            sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n        else:\n            sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq",
            "def sturm_pg(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\\n\\n    A. If method == 0, default, the remainder coefficients of the sequence\\n       are (in absolute value) ``modified'' subresultants, which for non-monic\\n       polynomials are greater than the coefficients of the corresponding\\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    B. If method == 1, the remainder coefficients of the sequence are (in\\n       absolute value) subresultants, which for non-monic polynomials are\\n       smaller than the coefficients of the corresponding ``modified''\\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, the coefficients\\n    of the polynomials in the sequence are ``modified'' subresultants.\\n    That is, they are  determinants of appropriately selected submatrices of\\n    sylvester2, Sylvester's matrix of 1853. In this case the Sturm sequence\\n    coincides with the ``modified'' subresultant prs, of the polynomials\\n    p, q.\\n\\n    If the Sturm sequence is incomplete and method=0 then the signs of the\\n    coefficients of the polynomials in the sequence may differ from the signs\\n    of the coefficients of the corresponding polynomials in the ``modified''\\n    subresultant prs; however, the absolute values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place. Instead,\\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\\n    the coefficients of the remainders computed this way become (``modified'')\\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\\n    See also the function euclid_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    lcf = LC(p, x) ** (d0 - d1)\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    del0 = d0 - d1\n    rho1 = LC(a1, x)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    if method == 0:\n        sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n    else:\n        sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        if method == 0:\n            sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n        else:\n            sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq",
            "def sturm_pg(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\\n\\n    A. If method == 0, default, the remainder coefficients of the sequence\\n       are (in absolute value) ``modified'' subresultants, which for non-monic\\n       polynomials are greater than the coefficients of the corresponding\\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    B. If method == 1, the remainder coefficients of the sequence are (in\\n       absolute value) subresultants, which for non-monic polynomials are\\n       smaller than the coefficients of the corresponding ``modified''\\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, the coefficients\\n    of the polynomials in the sequence are ``modified'' subresultants.\\n    That is, they are  determinants of appropriately selected submatrices of\\n    sylvester2, Sylvester's matrix of 1853. In this case the Sturm sequence\\n    coincides with the ``modified'' subresultant prs, of the polynomials\\n    p, q.\\n\\n    If the Sturm sequence is incomplete and method=0 then the signs of the\\n    coefficients of the polynomials in the sequence may differ from the signs\\n    of the coefficients of the corresponding polynomials in the ``modified''\\n    subresultant prs; however, the absolute values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place. Instead,\\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\\n    the coefficients of the remainders computed this way become (``modified'')\\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\\n    See also the function euclid_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    lcf = LC(p, x) ** (d0 - d1)\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    del0 = d0 - d1\n    rho1 = LC(a1, x)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    if method == 0:\n        sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n    else:\n        sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        if method == 0:\n            sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n        else:\n            sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq",
            "def sturm_pg(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\\n\\n    A. If method == 0, default, the remainder coefficients of the sequence\\n       are (in absolute value) ``modified'' subresultants, which for non-monic\\n       polynomials are greater than the coefficients of the corresponding\\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    B. If method == 1, the remainder coefficients of the sequence are (in\\n       absolute value) subresultants, which for non-monic polynomials are\\n       smaller than the coefficients of the corresponding ``modified''\\n       subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, the coefficients\\n    of the polynomials in the sequence are ``modified'' subresultants.\\n    That is, they are  determinants of appropriately selected submatrices of\\n    sylvester2, Sylvester's matrix of 1853. In this case the Sturm sequence\\n    coincides with the ``modified'' subresultant prs, of the polynomials\\n    p, q.\\n\\n    If the Sturm sequence is incomplete and method=0 then the signs of the\\n    coefficients of the polynomials in the sequence may differ from the signs\\n    of the coefficients of the corresponding polynomials in the ``modified''\\n    subresultant prs; however, the absolute values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place. Instead,\\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\\n    the coefficients of the remainders computed this way become (``modified'')\\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\\n    See also the function euclid_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    lcf = LC(p, x) ** (d0 - d1)\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    del0 = d0 - d1\n    rho1 = LC(a1, x)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    if method == 0:\n        sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n    else:\n        sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        if method == 0:\n            sturm_seq.append(simplify(lcf * a2 * Abs(mul_fac_old)))\n        else:\n            sturm_seq.append(simplify(a2 * Abs(mul_fac_old)))\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq"
        ]
    },
    {
        "func_name": "sturm_q",
        "original": "def sturm_q(p, q, x):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the (generalized) Sturm sequence of p and q in Q[x].\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\n\n    The coefficients of the polynomials in the Sturm sequence can be uniquely\n    determined from the corresponding coefficients of the polynomials found\n    either in:\n\n        (a) the ``modified'' subresultant prs, (references 1, 2)\n\n    or in\n\n        (b) the subresultant prs (reference 3).\n\n    References\n    ==========\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\n    Second Series, 18 (1917), No. 4, 188-193.\n\n    2 Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\n    and Modified Subresultant Polynomial Remainder Sequences.''\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\n\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\n\n    \"\"\"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    a2 = -rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    sturm_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = -rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        sturm_seq.append(a2)\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq",
        "mutated": [
            "def sturm_q(p, q, x):\n    if False:\n        i = 10\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Q[x].\\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\\n\\n    The coefficients of the polynomials in the Sturm sequence can be uniquely\\n    determined from the corresponding coefficients of the polynomials found\\n    either in:\\n\\n        (a) the ``modified'' subresultant prs, (references 1, 2)\\n\\n    or in\\n\\n        (b) the subresultant prs (reference 3).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2 Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    a2 = -rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    sturm_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = -rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        sturm_seq.append(a2)\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq",
            "def sturm_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Q[x].\\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\\n\\n    The coefficients of the polynomials in the Sturm sequence can be uniquely\\n    determined from the corresponding coefficients of the polynomials found\\n    either in:\\n\\n        (a) the ``modified'' subresultant prs, (references 1, 2)\\n\\n    or in\\n\\n        (b) the subresultant prs (reference 3).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2 Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    a2 = -rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    sturm_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = -rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        sturm_seq.append(a2)\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq",
            "def sturm_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Q[x].\\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\\n\\n    The coefficients of the polynomials in the Sturm sequence can be uniquely\\n    determined from the corresponding coefficients of the polynomials found\\n    either in:\\n\\n        (a) the ``modified'' subresultant prs, (references 1, 2)\\n\\n    or in\\n\\n        (b) the subresultant prs (reference 3).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2 Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    a2 = -rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    sturm_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = -rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        sturm_seq.append(a2)\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq",
            "def sturm_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Q[x].\\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\\n\\n    The coefficients of the polynomials in the Sturm sequence can be uniquely\\n    determined from the corresponding coefficients of the polynomials found\\n    either in:\\n\\n        (a) the ``modified'' subresultant prs, (references 1, 2)\\n\\n    or in\\n\\n        (b) the subresultant prs (reference 3).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2 Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    a2 = -rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    sturm_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = -rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        sturm_seq.append(a2)\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq",
            "def sturm_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Q[x].\\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\\n\\n    The coefficients of the polynomials in the Sturm sequence can be uniquely\\n    determined from the corresponding coefficients of the polynomials found\\n    either in:\\n\\n        (a) the ``modified'' subresultant prs, (references 1, 2)\\n\\n    or in\\n\\n        (b) the subresultant prs (reference 3).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2 Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    sturm_seq = [a0, a1]\n    a2 = -rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    sturm_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = -rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        sturm_seq.append(a2)\n    if flag:\n        sturm_seq = [-i for i in sturm_seq]\n    m = len(sturm_seq)\n    if sturm_seq[m - 1] == nan or sturm_seq[m - 1] == 0:\n        sturm_seq.pop(m - 1)\n    return sturm_seq"
        ]
    },
    {
        "func_name": "sturm_amv",
        "original": "def sturm_amv(p, q, x, method=0):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\n\n    A. If method == 0, default, the remainder coefficients of the\n       sequence are (in absolute value) ``modified'' subresultants, which\n       for non-monic polynomials are greater than the coefficients of the\n       corresponding subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\n\n    B. If method == 1, the remainder coefficients of the sequence are (in\n       absolute value) subresultants, which for non-monic polynomials are\n       smaller than the coefficients of the corresponding ``modified''\n       subresultants by the factor Abs( LC(p)**( deg(p)- deg(q)) ).\n\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, then the\n    coefficients of the polynomials in the sequence are ``modified'' subresultants.\n    That is, they are  determinants of appropriately selected submatrices of\n    sylvester2, Sylvester's matrix of 1853. In this case the Sturm sequence\n    coincides with the ``modified'' subresultant prs, of the polynomials\n    p, q.\n\n    If the Sturm sequence is incomplete and method=0 then the signs of the\n    coefficients of the polynomials in the sequence may differ from the signs\n    of the coefficients of the corresponding polynomials in the ``modified''\n    subresultant prs; however, the absolute values are the same.\n\n    To compute the coefficients, no determinant evaluation takes place.\n    Instead, we first compute the euclidean sequence  of p and q using\n    euclid_amv(p, q, x) and then: (a) change the signs of the remainders in the\n    Euclidean sequence according to the pattern \"-, -, +, +, -, -, +, +,...\"\n    (see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference)\n    and (b) if method=0, assuming deg(p) > deg(q), we multiply the remainder\n    coefficients of the Euclidean sequence times the factor\n    Abs( LC(p)**( deg(p)- deg(q)) ) to make them modified subresultants.\n    See also the function sturm_pg(p, q, x).\n\n    References\n    ==========\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.'' Serdica\n    Journal of Computing 9(2) (2015), 123-138.\n\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\n\n    \"\"\"\n    prs = euclid_amv(p, q, x)\n    if prs == [] or len(prs) == 2:\n        return prs\n    lcf = Abs(LC(prs[0]) ** (degree(prs[0], x) - degree(prs[1], x)))\n    sturm_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            sturm_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    if method == 0 and lcf > 1:\n        aux_seq = [sturm_seq[0], sturm_seq[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(sturm_seq[i] * lcf))\n        sturm_seq = aux_seq\n    return sturm_seq",
        "mutated": [
            "def sturm_amv(p, q, x, method=0):\n    if False:\n        i = 10\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\\n\\n    A. If method == 0, default, the remainder coefficients of the\\n       sequence are (in absolute value) ``modified\\'\\' subresultants, which\\n       for non-monic polynomials are greater than the coefficients of the\\n       corresponding subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    B. If method == 1, the remainder coefficients of the sequence are (in\\n       absolute value) subresultants, which for non-monic polynomials are\\n       smaller than the coefficients of the corresponding ``modified\\'\\'\\n       subresultants by the factor Abs( LC(p)**( deg(p)- deg(q)) ).\\n\\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, then the\\n    coefficients of the polynomials in the sequence are ``modified\\'\\' subresultants.\\n    That is, they are  determinants of appropriately selected submatrices of\\n    sylvester2, Sylvester\\'s matrix of 1853. In this case the Sturm sequence\\n    coincides with the ``modified\\'\\' subresultant prs, of the polynomials\\n    p, q.\\n\\n    If the Sturm sequence is incomplete and method=0 then the signs of the\\n    coefficients of the polynomials in the sequence may differ from the signs\\n    of the coefficients of the corresponding polynomials in the ``modified\\'\\'\\n    subresultant prs; however, the absolute values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, we first compute the euclidean sequence  of p and q using\\n    euclid_amv(p, q, x) and then: (a) change the signs of the remainders in the\\n    Euclidean sequence according to the pattern \"-, -, +, +, -, -, +, +,...\"\\n    (see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference)\\n    and (b) if method=0, assuming deg(p) > deg(q), we multiply the remainder\\n    coefficients of the Euclidean sequence times the factor\\n    Abs( LC(p)**( deg(p)- deg(q)) ) to make them modified subresultants.\\n    See also the function sturm_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.\\'\\' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\\'\\' Serdica\\n    Journal of Computing 9(2) (2015), 123-138.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].\\'\\'\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    '\n    prs = euclid_amv(p, q, x)\n    if prs == [] or len(prs) == 2:\n        return prs\n    lcf = Abs(LC(prs[0]) ** (degree(prs[0], x) - degree(prs[1], x)))\n    sturm_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            sturm_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    if method == 0 and lcf > 1:\n        aux_seq = [sturm_seq[0], sturm_seq[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(sturm_seq[i] * lcf))\n        sturm_seq = aux_seq\n    return sturm_seq",
            "def sturm_amv(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\\n\\n    A. If method == 0, default, the remainder coefficients of the\\n       sequence are (in absolute value) ``modified\\'\\' subresultants, which\\n       for non-monic polynomials are greater than the coefficients of the\\n       corresponding subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    B. If method == 1, the remainder coefficients of the sequence are (in\\n       absolute value) subresultants, which for non-monic polynomials are\\n       smaller than the coefficients of the corresponding ``modified\\'\\'\\n       subresultants by the factor Abs( LC(p)**( deg(p)- deg(q)) ).\\n\\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, then the\\n    coefficients of the polynomials in the sequence are ``modified\\'\\' subresultants.\\n    That is, they are  determinants of appropriately selected submatrices of\\n    sylvester2, Sylvester\\'s matrix of 1853. In this case the Sturm sequence\\n    coincides with the ``modified\\'\\' subresultant prs, of the polynomials\\n    p, q.\\n\\n    If the Sturm sequence is incomplete and method=0 then the signs of the\\n    coefficients of the polynomials in the sequence may differ from the signs\\n    of the coefficients of the corresponding polynomials in the ``modified\\'\\'\\n    subresultant prs; however, the absolute values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, we first compute the euclidean sequence  of p and q using\\n    euclid_amv(p, q, x) and then: (a) change the signs of the remainders in the\\n    Euclidean sequence according to the pattern \"-, -, +, +, -, -, +, +,...\"\\n    (see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference)\\n    and (b) if method=0, assuming deg(p) > deg(q), we multiply the remainder\\n    coefficients of the Euclidean sequence times the factor\\n    Abs( LC(p)**( deg(p)- deg(q)) ) to make them modified subresultants.\\n    See also the function sturm_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.\\'\\' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\\'\\' Serdica\\n    Journal of Computing 9(2) (2015), 123-138.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].\\'\\'\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    '\n    prs = euclid_amv(p, q, x)\n    if prs == [] or len(prs) == 2:\n        return prs\n    lcf = Abs(LC(prs[0]) ** (degree(prs[0], x) - degree(prs[1], x)))\n    sturm_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            sturm_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    if method == 0 and lcf > 1:\n        aux_seq = [sturm_seq[0], sturm_seq[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(sturm_seq[i] * lcf))\n        sturm_seq = aux_seq\n    return sturm_seq",
            "def sturm_amv(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\\n\\n    A. If method == 0, default, the remainder coefficients of the\\n       sequence are (in absolute value) ``modified\\'\\' subresultants, which\\n       for non-monic polynomials are greater than the coefficients of the\\n       corresponding subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    B. If method == 1, the remainder coefficients of the sequence are (in\\n       absolute value) subresultants, which for non-monic polynomials are\\n       smaller than the coefficients of the corresponding ``modified\\'\\'\\n       subresultants by the factor Abs( LC(p)**( deg(p)- deg(q)) ).\\n\\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, then the\\n    coefficients of the polynomials in the sequence are ``modified\\'\\' subresultants.\\n    That is, they are  determinants of appropriately selected submatrices of\\n    sylvester2, Sylvester\\'s matrix of 1853. In this case the Sturm sequence\\n    coincides with the ``modified\\'\\' subresultant prs, of the polynomials\\n    p, q.\\n\\n    If the Sturm sequence is incomplete and method=0 then the signs of the\\n    coefficients of the polynomials in the sequence may differ from the signs\\n    of the coefficients of the corresponding polynomials in the ``modified\\'\\'\\n    subresultant prs; however, the absolute values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, we first compute the euclidean sequence  of p and q using\\n    euclid_amv(p, q, x) and then: (a) change the signs of the remainders in the\\n    Euclidean sequence according to the pattern \"-, -, +, +, -, -, +, +,...\"\\n    (see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference)\\n    and (b) if method=0, assuming deg(p) > deg(q), we multiply the remainder\\n    coefficients of the Euclidean sequence times the factor\\n    Abs( LC(p)**( deg(p)- deg(q)) ) to make them modified subresultants.\\n    See also the function sturm_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.\\'\\' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\\'\\' Serdica\\n    Journal of Computing 9(2) (2015), 123-138.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].\\'\\'\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    '\n    prs = euclid_amv(p, q, x)\n    if prs == [] or len(prs) == 2:\n        return prs\n    lcf = Abs(LC(prs[0]) ** (degree(prs[0], x) - degree(prs[1], x)))\n    sturm_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            sturm_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    if method == 0 and lcf > 1:\n        aux_seq = [sturm_seq[0], sturm_seq[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(sturm_seq[i] * lcf))\n        sturm_seq = aux_seq\n    return sturm_seq",
            "def sturm_amv(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\\n\\n    A. If method == 0, default, the remainder coefficients of the\\n       sequence are (in absolute value) ``modified\\'\\' subresultants, which\\n       for non-monic polynomials are greater than the coefficients of the\\n       corresponding subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    B. If method == 1, the remainder coefficients of the sequence are (in\\n       absolute value) subresultants, which for non-monic polynomials are\\n       smaller than the coefficients of the corresponding ``modified\\'\\'\\n       subresultants by the factor Abs( LC(p)**( deg(p)- deg(q)) ).\\n\\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, then the\\n    coefficients of the polynomials in the sequence are ``modified\\'\\' subresultants.\\n    That is, they are  determinants of appropriately selected submatrices of\\n    sylvester2, Sylvester\\'s matrix of 1853. In this case the Sturm sequence\\n    coincides with the ``modified\\'\\' subresultant prs, of the polynomials\\n    p, q.\\n\\n    If the Sturm sequence is incomplete and method=0 then the signs of the\\n    coefficients of the polynomials in the sequence may differ from the signs\\n    of the coefficients of the corresponding polynomials in the ``modified\\'\\'\\n    subresultant prs; however, the absolute values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, we first compute the euclidean sequence  of p and q using\\n    euclid_amv(p, q, x) and then: (a) change the signs of the remainders in the\\n    Euclidean sequence according to the pattern \"-, -, +, +, -, -, +, +,...\"\\n    (see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference)\\n    and (b) if method=0, assuming deg(p) > deg(q), we multiply the remainder\\n    coefficients of the Euclidean sequence times the factor\\n    Abs( LC(p)**( deg(p)- deg(q)) ) to make them modified subresultants.\\n    See also the function sturm_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.\\'\\' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\\'\\' Serdica\\n    Journal of Computing 9(2) (2015), 123-138.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].\\'\\'\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    '\n    prs = euclid_amv(p, q, x)\n    if prs == [] or len(prs) == 2:\n        return prs\n    lcf = Abs(LC(prs[0]) ** (degree(prs[0], x) - degree(prs[1], x)))\n    sturm_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            sturm_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    if method == 0 and lcf > 1:\n        aux_seq = [sturm_seq[0], sturm_seq[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(sturm_seq[i] * lcf))\n        sturm_seq = aux_seq\n    return sturm_seq",
            "def sturm_amv(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the (generalized) Sturm sequence of p and q in Z[x] or Q[x].\\n    If q = diff(p, x, 1) it is the usual Sturm sequence.\\n\\n    A. If method == 0, default, the remainder coefficients of the\\n       sequence are (in absolute value) ``modified\\'\\' subresultants, which\\n       for non-monic polynomials are greater than the coefficients of the\\n       corresponding subresultants by the factor Abs(LC(p)**( deg(p)- deg(q))).\\n\\n    B. If method == 1, the remainder coefficients of the sequence are (in\\n       absolute value) subresultants, which for non-monic polynomials are\\n       smaller than the coefficients of the corresponding ``modified\\'\\'\\n       subresultants by the factor Abs( LC(p)**( deg(p)- deg(q)) ).\\n\\n    If the Sturm sequence is complete, method=0 and LC( p ) > 0, then the\\n    coefficients of the polynomials in the sequence are ``modified\\'\\' subresultants.\\n    That is, they are  determinants of appropriately selected submatrices of\\n    sylvester2, Sylvester\\'s matrix of 1853. In this case the Sturm sequence\\n    coincides with the ``modified\\'\\' subresultant prs, of the polynomials\\n    p, q.\\n\\n    If the Sturm sequence is incomplete and method=0 then the signs of the\\n    coefficients of the polynomials in the sequence may differ from the signs\\n    of the coefficients of the corresponding polynomials in the ``modified\\'\\'\\n    subresultant prs; however, the absolute values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, we first compute the euclidean sequence  of p and q using\\n    euclid_amv(p, q, x) and then: (a) change the signs of the remainders in the\\n    Euclidean sequence according to the pattern \"-, -, +, +, -, -, +, +,...\"\\n    (see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference)\\n    and (b) if method=0, assuming deg(p) > deg(q), we multiply the remainder\\n    coefficients of the Euclidean sequence times the factor\\n    Abs( LC(p)**( deg(p)- deg(q)) ) to make them modified subresultants.\\n    See also the function sturm_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.\\'\\' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\\'\\' Serdica\\n    Journal of Computing 9(2) (2015), 123-138.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].\\'\\'\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    '\n    prs = euclid_amv(p, q, x)\n    if prs == [] or len(prs) == 2:\n        return prs\n    lcf = Abs(LC(prs[0]) ** (degree(prs[0], x) - degree(prs[1], x)))\n    sturm_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            sturm_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            sturm_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    if method == 0 and lcf > 1:\n        aux_seq = [sturm_seq[0], sturm_seq[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(sturm_seq[i] * lcf))\n        sturm_seq = aux_seq\n    return sturm_seq"
        ]
    },
    {
        "func_name": "euclid_pg",
        "original": "def euclid_pg(p, q, x):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\n\n    If the Euclidean sequence is complete the coefficients of the polynomials\n    in the sequence are subresultants. That is, they are  determinants of\n    appropriately selected submatrices of sylvester1, Sylvester's matrix of 1840.\n    In this case the Euclidean sequence coincides with the subresultant prs\n    of the polynomials p, q.\n\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\n    polynomials in the sequence may differ from the signs of the coefficients of\n    the corresponding polynomials in the subresultant prs; however, the absolute\n    values are the same.\n\n    To compute the Euclidean sequence, no determinant evaluation takes place.\n    We first compute the (generalized) Sturm sequence  of p and q using\n    sturm_pg(p, q, x, 1), in which case the coefficients are (in absolute value)\n    equal to subresultants. Then we change the signs of the remainders in the\n    Sturm sequence according to the pattern \"-, -, +, +, -, -, +, +,...\" ;\n    see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference as well as\n    the function sturm_pg(p, q, x).\n\n    References\n    ==========\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.'' Serdica\n    Journal of Computing 9(2) (2015), 123-138.\n\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\n    \"\"\"\n    prs = sturm_pg(p, q, x, 1)\n    if prs == [] or len(prs) == 2:\n        return prs\n    euclid_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            euclid_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    return euclid_seq",
        "mutated": [
            "def euclid_pg(p, q, x):\n    if False:\n        i = 10\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\\n\\n    If the Euclidean sequence is complete the coefficients of the polynomials\\n    in the sequence are subresultants. That is, they are  determinants of\\n    appropriately selected submatrices of sylvester1, Sylvester\\'s matrix of 1840.\\n    In this case the Euclidean sequence coincides with the subresultant prs\\n    of the polynomials p, q.\\n\\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\\n    polynomials in the sequence may differ from the signs of the coefficients of\\n    the corresponding polynomials in the subresultant prs; however, the absolute\\n    values are the same.\\n\\n    To compute the Euclidean sequence, no determinant evaluation takes place.\\n    We first compute the (generalized) Sturm sequence  of p and q using\\n    sturm_pg(p, q, x, 1), in which case the coefficients are (in absolute value)\\n    equal to subresultants. Then we change the signs of the remainders in the\\n    Sturm sequence according to the pattern \"-, -, +, +, -, -, +, +,...\" ;\\n    see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference as well as\\n    the function sturm_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.\\'\\' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\\'\\' Serdica\\n    Journal of Computing 9(2) (2015), 123-138.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].\\'\\'\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n    '\n    prs = sturm_pg(p, q, x, 1)\n    if prs == [] or len(prs) == 2:\n        return prs\n    euclid_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            euclid_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    return euclid_seq",
            "def euclid_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\\n\\n    If the Euclidean sequence is complete the coefficients of the polynomials\\n    in the sequence are subresultants. That is, they are  determinants of\\n    appropriately selected submatrices of sylvester1, Sylvester\\'s matrix of 1840.\\n    In this case the Euclidean sequence coincides with the subresultant prs\\n    of the polynomials p, q.\\n\\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\\n    polynomials in the sequence may differ from the signs of the coefficients of\\n    the corresponding polynomials in the subresultant prs; however, the absolute\\n    values are the same.\\n\\n    To compute the Euclidean sequence, no determinant evaluation takes place.\\n    We first compute the (generalized) Sturm sequence  of p and q using\\n    sturm_pg(p, q, x, 1), in which case the coefficients are (in absolute value)\\n    equal to subresultants. Then we change the signs of the remainders in the\\n    Sturm sequence according to the pattern \"-, -, +, +, -, -, +, +,...\" ;\\n    see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference as well as\\n    the function sturm_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.\\'\\' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\\'\\' Serdica\\n    Journal of Computing 9(2) (2015), 123-138.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].\\'\\'\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n    '\n    prs = sturm_pg(p, q, x, 1)\n    if prs == [] or len(prs) == 2:\n        return prs\n    euclid_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            euclid_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    return euclid_seq",
            "def euclid_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\\n\\n    If the Euclidean sequence is complete the coefficients of the polynomials\\n    in the sequence are subresultants. That is, they are  determinants of\\n    appropriately selected submatrices of sylvester1, Sylvester\\'s matrix of 1840.\\n    In this case the Euclidean sequence coincides with the subresultant prs\\n    of the polynomials p, q.\\n\\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\\n    polynomials in the sequence may differ from the signs of the coefficients of\\n    the corresponding polynomials in the subresultant prs; however, the absolute\\n    values are the same.\\n\\n    To compute the Euclidean sequence, no determinant evaluation takes place.\\n    We first compute the (generalized) Sturm sequence  of p and q using\\n    sturm_pg(p, q, x, 1), in which case the coefficients are (in absolute value)\\n    equal to subresultants. Then we change the signs of the remainders in the\\n    Sturm sequence according to the pattern \"-, -, +, +, -, -, +, +,...\" ;\\n    see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference as well as\\n    the function sturm_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.\\'\\' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\\'\\' Serdica\\n    Journal of Computing 9(2) (2015), 123-138.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].\\'\\'\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n    '\n    prs = sturm_pg(p, q, x, 1)\n    if prs == [] or len(prs) == 2:\n        return prs\n    euclid_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            euclid_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    return euclid_seq",
            "def euclid_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\\n\\n    If the Euclidean sequence is complete the coefficients of the polynomials\\n    in the sequence are subresultants. That is, they are  determinants of\\n    appropriately selected submatrices of sylvester1, Sylvester\\'s matrix of 1840.\\n    In this case the Euclidean sequence coincides with the subresultant prs\\n    of the polynomials p, q.\\n\\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\\n    polynomials in the sequence may differ from the signs of the coefficients of\\n    the corresponding polynomials in the subresultant prs; however, the absolute\\n    values are the same.\\n\\n    To compute the Euclidean sequence, no determinant evaluation takes place.\\n    We first compute the (generalized) Sturm sequence  of p and q using\\n    sturm_pg(p, q, x, 1), in which case the coefficients are (in absolute value)\\n    equal to subresultants. Then we change the signs of the remainders in the\\n    Sturm sequence according to the pattern \"-, -, +, +, -, -, +, +,...\" ;\\n    see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference as well as\\n    the function sturm_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.\\'\\' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\\'\\' Serdica\\n    Journal of Computing 9(2) (2015), 123-138.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].\\'\\'\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n    '\n    prs = sturm_pg(p, q, x, 1)\n    if prs == [] or len(prs) == 2:\n        return prs\n    euclid_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            euclid_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    return euclid_seq",
            "def euclid_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\\n\\n    If the Euclidean sequence is complete the coefficients of the polynomials\\n    in the sequence are subresultants. That is, they are  determinants of\\n    appropriately selected submatrices of sylvester1, Sylvester\\'s matrix of 1840.\\n    In this case the Euclidean sequence coincides with the subresultant prs\\n    of the polynomials p, q.\\n\\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\\n    polynomials in the sequence may differ from the signs of the coefficients of\\n    the corresponding polynomials in the subresultant prs; however, the absolute\\n    values are the same.\\n\\n    To compute the Euclidean sequence, no determinant evaluation takes place.\\n    We first compute the (generalized) Sturm sequence  of p and q using\\n    sturm_pg(p, q, x, 1), in which case the coefficients are (in absolute value)\\n    equal to subresultants. Then we change the signs of the remainders in the\\n    Sturm sequence according to the pattern \"-, -, +, +, -, -, +, +,...\" ;\\n    see Lemma 1 in the 1st reference or Theorem 3 in the 2nd reference as well as\\n    the function sturm_pg(p, q, x).\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.\\'\\' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\\'\\' Serdica\\n    Journal of Computing 9(2) (2015), 123-138.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    Remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].\\'\\'\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n    '\n    prs = sturm_pg(p, q, x, 1)\n    if prs == [] or len(prs) == 2:\n        return prs\n    euclid_seq = [prs[0], prs[1]]\n    flag = 0\n    m = len(prs)\n    i = 2\n    while i <= m - 1:\n        if flag == 0:\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(-prs[i])\n            i = i + 1\n            flag = 1\n        elif flag == 1:\n            euclid_seq.append(prs[i])\n            i = i + 1\n            if i == m:\n                break\n            euclid_seq.append(prs[i])\n            i = i + 1\n            flag = 0\n    return euclid_seq"
        ]
    },
    {
        "func_name": "euclid_q",
        "original": "def euclid_q(p, q, x):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the Euclidean sequence of p and q in Q[x].\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\n\n    The coefficients of the polynomials in the Euclidean sequence can be uniquely\n    determined from the corresponding coefficients of the polynomials found\n    either in:\n\n        (a) the ``modified'' subresultant polynomial remainder sequence,\n    (references 1, 2)\n\n    or in\n\n        (b) the subresultant polynomial remainder sequence (references 3).\n\n    References\n    ==========\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\n    Second Series, 18 (1917), No. 4, 188-193.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\n    and Modified Subresultant Polynomial Remainder Sequences.''\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\n\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\n\n    \"\"\"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    euclid_seq = [a0, a1]\n    a2 = rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    euclid_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        euclid_seq.append(a2)\n    if flag:\n        euclid_seq = [-i for i in euclid_seq]\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq",
        "mutated": [
            "def euclid_q(p, q, x):\n    if False:\n        i = 10\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the Euclidean sequence of p and q in Q[x].\\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\\n\\n    The coefficients of the polynomials in the Euclidean sequence can be uniquely\\n    determined from the corresponding coefficients of the polynomials found\\n    either in:\\n\\n        (a) the ``modified'' subresultant polynomial remainder sequence,\\n    (references 1, 2)\\n\\n    or in\\n\\n        (b) the subresultant polynomial remainder sequence (references 3).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    euclid_seq = [a0, a1]\n    a2 = rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    euclid_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        euclid_seq.append(a2)\n    if flag:\n        euclid_seq = [-i for i in euclid_seq]\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq",
            "def euclid_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the Euclidean sequence of p and q in Q[x].\\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\\n\\n    The coefficients of the polynomials in the Euclidean sequence can be uniquely\\n    determined from the corresponding coefficients of the polynomials found\\n    either in:\\n\\n        (a) the ``modified'' subresultant polynomial remainder sequence,\\n    (references 1, 2)\\n\\n    or in\\n\\n        (b) the subresultant polynomial remainder sequence (references 3).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    euclid_seq = [a0, a1]\n    a2 = rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    euclid_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        euclid_seq.append(a2)\n    if flag:\n        euclid_seq = [-i for i in euclid_seq]\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq",
            "def euclid_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the Euclidean sequence of p and q in Q[x].\\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\\n\\n    The coefficients of the polynomials in the Euclidean sequence can be uniquely\\n    determined from the corresponding coefficients of the polynomials found\\n    either in:\\n\\n        (a) the ``modified'' subresultant polynomial remainder sequence,\\n    (references 1, 2)\\n\\n    or in\\n\\n        (b) the subresultant polynomial remainder sequence (references 3).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    euclid_seq = [a0, a1]\n    a2 = rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    euclid_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        euclid_seq.append(a2)\n    if flag:\n        euclid_seq = [-i for i in euclid_seq]\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq",
            "def euclid_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the Euclidean sequence of p and q in Q[x].\\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\\n\\n    The coefficients of the polynomials in the Euclidean sequence can be uniquely\\n    determined from the corresponding coefficients of the polynomials found\\n    either in:\\n\\n        (a) the ``modified'' subresultant polynomial remainder sequence,\\n    (references 1, 2)\\n\\n    or in\\n\\n        (b) the subresultant polynomial remainder sequence (references 3).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    euclid_seq = [a0, a1]\n    a2 = rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    euclid_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        euclid_seq.append(a2)\n    if flag:\n        euclid_seq = [-i for i in euclid_seq]\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq",
            "def euclid_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the Euclidean sequence of p and q in Q[x].\\n    Polynomial divisions in Q[x] are performed, using the function rem(p, q, x).\\n\\n    The coefficients of the polynomials in the Euclidean sequence can be uniquely\\n    determined from the corresponding coefficients of the polynomials found\\n    either in:\\n\\n        (a) the ``modified'' subresultant polynomial remainder sequence,\\n    (references 1, 2)\\n\\n    or in\\n\\n        (b) the subresultant polynomial remainder sequence (references 3).\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    flag = 0\n    if LC(p, x) < 0:\n        flag = 1\n        p = -p\n        q = -q\n    (a0, a1) = (p, q)\n    euclid_seq = [a0, a1]\n    a2 = rem(a0, a1, domain=QQ)\n    d2 = degree(a2, x)\n    euclid_seq.append(a2)\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        a2 = rem(a0, a1, domain=QQ)\n        d2 = degree(a2, x)\n        euclid_seq.append(a2)\n    if flag:\n        euclid_seq = [-i for i in euclid_seq]\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq"
        ]
    },
    {
        "func_name": "euclid_amv",
        "original": "def euclid_amv(f, g, x):\n    \"\"\"\n    f, g are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(f, x) >= degree(g, x).\n\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\n\n    If the Euclidean sequence is complete the coefficients of the polynomials\n    in the sequence are subresultants. That is, they are  determinants of\n    appropriately selected submatrices of sylvester1, Sylvester's matrix of 1840.\n    In this case the Euclidean sequence coincides with the subresultant prs,\n    of the polynomials p, q.\n\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\n    polynomials in the sequence may differ from the signs of the coefficients of\n    the corresponding polynomials in the subresultant prs; however, the absolute\n    values are the same.\n\n    To compute the coefficients, no determinant evaluation takes place.\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\n    the function rem_z(f, g, x);  the coefficients of the remainders\n    computed this way become subresultants with the help of the\n    Collins-Brown-Traub formula for coefficient reduction.\n\n    References\n    ==========\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\n\n    \"\"\"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    euclid_seq = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    i = 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    euclid_seq.append(a2)\n    d2 = degree(a2, x)\n    while d2 >= 1:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        euclid_seq.append(a2)\n        d2 = degree(a2, x)\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq",
        "mutated": [
            "def euclid_amv(f, g, x):\n    if False:\n        i = 10\n    \"\\n    f, g are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(f, x) >= degree(g, x).\\n\\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\\n\\n    If the Euclidean sequence is complete the coefficients of the polynomials\\n    in the sequence are subresultants. That is, they are  determinants of\\n    appropriately selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n    In this case the Euclidean sequence coincides with the subresultant prs,\\n    of the polynomials p, q.\\n\\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\\n    polynomials in the sequence may differ from the signs of the coefficients of\\n    the corresponding polynomials in the subresultant prs; however, the absolute\\n    values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\\n    the function rem_z(f, g, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Collins-Brown-Traub formula for coefficient reduction.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    euclid_seq = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    i = 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    euclid_seq.append(a2)\n    d2 = degree(a2, x)\n    while d2 >= 1:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        euclid_seq.append(a2)\n        d2 = degree(a2, x)\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq",
            "def euclid_amv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    f, g are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(f, x) >= degree(g, x).\\n\\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\\n\\n    If the Euclidean sequence is complete the coefficients of the polynomials\\n    in the sequence are subresultants. That is, they are  determinants of\\n    appropriately selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n    In this case the Euclidean sequence coincides with the subresultant prs,\\n    of the polynomials p, q.\\n\\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\\n    polynomials in the sequence may differ from the signs of the coefficients of\\n    the corresponding polynomials in the subresultant prs; however, the absolute\\n    values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\\n    the function rem_z(f, g, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Collins-Brown-Traub formula for coefficient reduction.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    euclid_seq = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    i = 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    euclid_seq.append(a2)\n    d2 = degree(a2, x)\n    while d2 >= 1:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        euclid_seq.append(a2)\n        d2 = degree(a2, x)\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq",
            "def euclid_amv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    f, g are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(f, x) >= degree(g, x).\\n\\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\\n\\n    If the Euclidean sequence is complete the coefficients of the polynomials\\n    in the sequence are subresultants. That is, they are  determinants of\\n    appropriately selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n    In this case the Euclidean sequence coincides with the subresultant prs,\\n    of the polynomials p, q.\\n\\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\\n    polynomials in the sequence may differ from the signs of the coefficients of\\n    the corresponding polynomials in the subresultant prs; however, the absolute\\n    values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\\n    the function rem_z(f, g, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Collins-Brown-Traub formula for coefficient reduction.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    euclid_seq = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    i = 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    euclid_seq.append(a2)\n    d2 = degree(a2, x)\n    while d2 >= 1:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        euclid_seq.append(a2)\n        d2 = degree(a2, x)\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq",
            "def euclid_amv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    f, g are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(f, x) >= degree(g, x).\\n\\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\\n\\n    If the Euclidean sequence is complete the coefficients of the polynomials\\n    in the sequence are subresultants. That is, they are  determinants of\\n    appropriately selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n    In this case the Euclidean sequence coincides with the subresultant prs,\\n    of the polynomials p, q.\\n\\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\\n    polynomials in the sequence may differ from the signs of the coefficients of\\n    the corresponding polynomials in the subresultant prs; however, the absolute\\n    values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\\n    the function rem_z(f, g, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Collins-Brown-Traub formula for coefficient reduction.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    euclid_seq = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    i = 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    euclid_seq.append(a2)\n    d2 = degree(a2, x)\n    while d2 >= 1:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        euclid_seq.append(a2)\n        d2 = degree(a2, x)\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq",
            "def euclid_amv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    f, g are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(f, x) >= degree(g, x).\\n\\n    Computes the Euclidean sequence of p and q in Z[x] or Q[x].\\n\\n    If the Euclidean sequence is complete the coefficients of the polynomials\\n    in the sequence are subresultants. That is, they are  determinants of\\n    appropriately selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n    In this case the Euclidean sequence coincides with the subresultant prs,\\n    of the polynomials p, q.\\n\\n    If the Euclidean sequence is incomplete the signs of the coefficients of the\\n    polynomials in the sequence may differ from the signs of the coefficients of\\n    the corresponding polynomials in the subresultant prs; however, the absolute\\n    values are the same.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\\n    the function rem_z(f, g, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Collins-Brown-Traub formula for coefficient reduction.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    euclid_seq = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    i = 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    euclid_seq.append(a2)\n    d2 = degree(a2, x)\n    while d2 >= 1:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        euclid_seq.append(a2)\n        d2 = degree(a2, x)\n    m = len(euclid_seq)\n    if euclid_seq[m - 1] == nan or euclid_seq[m - 1] == 0:\n        euclid_seq.pop(m - 1)\n    return euclid_seq"
        ]
    },
    {
        "func_name": "modified_subresultants_pg",
        "original": "def modified_subresultants_pg(p, q, x):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the ``modified'' subresultant prs of p and q in Z[x] or Q[x];\n    the coefficients of the polynomials in the sequence are\n    ``modified'' subresultants. That is, they are  determinants of appropriately\n    selected submatrices of sylvester2, Sylvester's matrix of 1853.\n\n    To compute the coefficients, no determinant evaluation takes place. Instead,\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\n    the coefficients of the remainders computed this way become ``modified''\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\n\n    If the ``modified'' subresultant prs is complete, and LC( p ) > 0, it coincides\n    with the (generalized) Sturm sequence of the polynomials p, q.\n\n    References\n    ==========\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\n    Second Series, 18 (1917), No. 4, 188-193.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\n    and Modified Subresultant Polynomial Remainder Sequences.''\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\n\n    \"\"\"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    k = var('k')\n    u_list = []\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    del0 = d0 - d1\n    degdif = del0\n    rho_1 = LC(a0)\n    rho_list_minus_1 = sign(LC(a0, x))\n    rho1 = LC(a1, x)\n    rho_list = [sign(rho1)]\n    p_list = [del0]\n    u = summation(k, (k, 1, p_list[0]))\n    u_list.append(u)\n    v = sum(p_list)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    p_list.append(1 + deg_diff_new)\n    num = 1\n    for u in u_list:\n        num *= (-1) ** u\n    num = num * (-1) ** v\n    if deg_diff_new == 0:\n        den = 1\n        for k in range(len(rho_list)):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n    else:\n        den = 1\n        for k in range(len(rho_list) - 1):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n        expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n        den = den * rho_list[len(rho_list) - 1] ** expo\n    if sign(num / den) > 0:\n        subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    else:\n        subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    k = var('k')\n    rho_list.append(sign(rho2))\n    u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n    u_list.append(u)\n    v = sum(p_list)\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        p_list.append(1 + deg_diff_new)\n        num = 1\n        for u in u_list:\n            num *= (-1) ** u\n        num = num * (-1) ** v\n        if deg_diff_new == 0:\n            den = 1\n            for k in range(len(rho_list)):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n        else:\n            den = 1\n            for k in range(len(rho_list) - 1):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n            expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n            den = den * rho_list[len(rho_list) - 1] ** expo\n        if sign(num / den) > 0:\n            subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        else:\n            subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        k = var('k')\n        rho_list.append(sign(rho2))\n        u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n        u_list.append(u)\n        v = sum(p_list)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    m = len(subres_l)\n    if LC(p) < 0:\n        aux_seq = [subres_l[0], subres_l[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(subres_l[i] * -1))\n        subres_l = aux_seq\n    return subres_l",
        "mutated": [
            "def modified_subresultants_pg(p, q, x):\n    if False:\n        i = 10\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the ``modified'' subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    ``modified'' subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester2, Sylvester's matrix of 1853.\\n\\n    To compute the coefficients, no determinant evaluation takes place. Instead,\\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\\n    the coefficients of the remainders computed this way become ``modified''\\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\\n\\n    If the ``modified'' subresultant prs is complete, and LC( p ) > 0, it coincides\\n    with the (generalized) Sturm sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    k = var('k')\n    u_list = []\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    del0 = d0 - d1\n    degdif = del0\n    rho_1 = LC(a0)\n    rho_list_minus_1 = sign(LC(a0, x))\n    rho1 = LC(a1, x)\n    rho_list = [sign(rho1)]\n    p_list = [del0]\n    u = summation(k, (k, 1, p_list[0]))\n    u_list.append(u)\n    v = sum(p_list)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    p_list.append(1 + deg_diff_new)\n    num = 1\n    for u in u_list:\n        num *= (-1) ** u\n    num = num * (-1) ** v\n    if deg_diff_new == 0:\n        den = 1\n        for k in range(len(rho_list)):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n    else:\n        den = 1\n        for k in range(len(rho_list) - 1):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n        expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n        den = den * rho_list[len(rho_list) - 1] ** expo\n    if sign(num / den) > 0:\n        subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    else:\n        subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    k = var('k')\n    rho_list.append(sign(rho2))\n    u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n    u_list.append(u)\n    v = sum(p_list)\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        p_list.append(1 + deg_diff_new)\n        num = 1\n        for u in u_list:\n            num *= (-1) ** u\n        num = num * (-1) ** v\n        if deg_diff_new == 0:\n            den = 1\n            for k in range(len(rho_list)):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n        else:\n            den = 1\n            for k in range(len(rho_list) - 1):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n            expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n            den = den * rho_list[len(rho_list) - 1] ** expo\n        if sign(num / den) > 0:\n            subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        else:\n            subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        k = var('k')\n        rho_list.append(sign(rho2))\n        u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n        u_list.append(u)\n        v = sum(p_list)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    m = len(subres_l)\n    if LC(p) < 0:\n        aux_seq = [subres_l[0], subres_l[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(subres_l[i] * -1))\n        subres_l = aux_seq\n    return subres_l",
            "def modified_subresultants_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the ``modified'' subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    ``modified'' subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester2, Sylvester's matrix of 1853.\\n\\n    To compute the coefficients, no determinant evaluation takes place. Instead,\\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\\n    the coefficients of the remainders computed this way become ``modified''\\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\\n\\n    If the ``modified'' subresultant prs is complete, and LC( p ) > 0, it coincides\\n    with the (generalized) Sturm sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    k = var('k')\n    u_list = []\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    del0 = d0 - d1\n    degdif = del0\n    rho_1 = LC(a0)\n    rho_list_minus_1 = sign(LC(a0, x))\n    rho1 = LC(a1, x)\n    rho_list = [sign(rho1)]\n    p_list = [del0]\n    u = summation(k, (k, 1, p_list[0]))\n    u_list.append(u)\n    v = sum(p_list)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    p_list.append(1 + deg_diff_new)\n    num = 1\n    for u in u_list:\n        num *= (-1) ** u\n    num = num * (-1) ** v\n    if deg_diff_new == 0:\n        den = 1\n        for k in range(len(rho_list)):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n    else:\n        den = 1\n        for k in range(len(rho_list) - 1):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n        expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n        den = den * rho_list[len(rho_list) - 1] ** expo\n    if sign(num / den) > 0:\n        subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    else:\n        subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    k = var('k')\n    rho_list.append(sign(rho2))\n    u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n    u_list.append(u)\n    v = sum(p_list)\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        p_list.append(1 + deg_diff_new)\n        num = 1\n        for u in u_list:\n            num *= (-1) ** u\n        num = num * (-1) ** v\n        if deg_diff_new == 0:\n            den = 1\n            for k in range(len(rho_list)):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n        else:\n            den = 1\n            for k in range(len(rho_list) - 1):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n            expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n            den = den * rho_list[len(rho_list) - 1] ** expo\n        if sign(num / den) > 0:\n            subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        else:\n            subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        k = var('k')\n        rho_list.append(sign(rho2))\n        u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n        u_list.append(u)\n        v = sum(p_list)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    m = len(subres_l)\n    if LC(p) < 0:\n        aux_seq = [subres_l[0], subres_l[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(subres_l[i] * -1))\n        subres_l = aux_seq\n    return subres_l",
            "def modified_subresultants_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the ``modified'' subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    ``modified'' subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester2, Sylvester's matrix of 1853.\\n\\n    To compute the coefficients, no determinant evaluation takes place. Instead,\\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\\n    the coefficients of the remainders computed this way become ``modified''\\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\\n\\n    If the ``modified'' subresultant prs is complete, and LC( p ) > 0, it coincides\\n    with the (generalized) Sturm sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    k = var('k')\n    u_list = []\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    del0 = d0 - d1\n    degdif = del0\n    rho_1 = LC(a0)\n    rho_list_minus_1 = sign(LC(a0, x))\n    rho1 = LC(a1, x)\n    rho_list = [sign(rho1)]\n    p_list = [del0]\n    u = summation(k, (k, 1, p_list[0]))\n    u_list.append(u)\n    v = sum(p_list)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    p_list.append(1 + deg_diff_new)\n    num = 1\n    for u in u_list:\n        num *= (-1) ** u\n    num = num * (-1) ** v\n    if deg_diff_new == 0:\n        den = 1\n        for k in range(len(rho_list)):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n    else:\n        den = 1\n        for k in range(len(rho_list) - 1):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n        expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n        den = den * rho_list[len(rho_list) - 1] ** expo\n    if sign(num / den) > 0:\n        subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    else:\n        subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    k = var('k')\n    rho_list.append(sign(rho2))\n    u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n    u_list.append(u)\n    v = sum(p_list)\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        p_list.append(1 + deg_diff_new)\n        num = 1\n        for u in u_list:\n            num *= (-1) ** u\n        num = num * (-1) ** v\n        if deg_diff_new == 0:\n            den = 1\n            for k in range(len(rho_list)):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n        else:\n            den = 1\n            for k in range(len(rho_list) - 1):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n            expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n            den = den * rho_list[len(rho_list) - 1] ** expo\n        if sign(num / den) > 0:\n            subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        else:\n            subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        k = var('k')\n        rho_list.append(sign(rho2))\n        u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n        u_list.append(u)\n        v = sum(p_list)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    m = len(subres_l)\n    if LC(p) < 0:\n        aux_seq = [subres_l[0], subres_l[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(subres_l[i] * -1))\n        subres_l = aux_seq\n    return subres_l",
            "def modified_subresultants_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the ``modified'' subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    ``modified'' subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester2, Sylvester's matrix of 1853.\\n\\n    To compute the coefficients, no determinant evaluation takes place. Instead,\\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\\n    the coefficients of the remainders computed this way become ``modified''\\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\\n\\n    If the ``modified'' subresultant prs is complete, and LC( p ) > 0, it coincides\\n    with the (generalized) Sturm sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    k = var('k')\n    u_list = []\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    del0 = d0 - d1\n    degdif = del0\n    rho_1 = LC(a0)\n    rho_list_minus_1 = sign(LC(a0, x))\n    rho1 = LC(a1, x)\n    rho_list = [sign(rho1)]\n    p_list = [del0]\n    u = summation(k, (k, 1, p_list[0]))\n    u_list.append(u)\n    v = sum(p_list)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    p_list.append(1 + deg_diff_new)\n    num = 1\n    for u in u_list:\n        num *= (-1) ** u\n    num = num * (-1) ** v\n    if deg_diff_new == 0:\n        den = 1\n        for k in range(len(rho_list)):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n    else:\n        den = 1\n        for k in range(len(rho_list) - 1):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n        expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n        den = den * rho_list[len(rho_list) - 1] ** expo\n    if sign(num / den) > 0:\n        subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    else:\n        subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    k = var('k')\n    rho_list.append(sign(rho2))\n    u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n    u_list.append(u)\n    v = sum(p_list)\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        p_list.append(1 + deg_diff_new)\n        num = 1\n        for u in u_list:\n            num *= (-1) ** u\n        num = num * (-1) ** v\n        if deg_diff_new == 0:\n            den = 1\n            for k in range(len(rho_list)):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n        else:\n            den = 1\n            for k in range(len(rho_list) - 1):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n            expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n            den = den * rho_list[len(rho_list) - 1] ** expo\n        if sign(num / den) > 0:\n            subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        else:\n            subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        k = var('k')\n        rho_list.append(sign(rho2))\n        u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n        u_list.append(u)\n        v = sum(p_list)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    m = len(subres_l)\n    if LC(p) < 0:\n        aux_seq = [subres_l[0], subres_l[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(subres_l[i] * -1))\n        subres_l = aux_seq\n    return subres_l",
            "def modified_subresultants_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the ``modified'' subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    ``modified'' subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester2, Sylvester's matrix of 1853.\\n\\n    To compute the coefficients, no determinant evaluation takes place. Instead,\\n    polynomial divisions in Q[x] are performed, using the function rem(p, q, x);\\n    the coefficients of the remainders computed this way become ``modified''\\n    subresultants with the help of the Pell-Gordon Theorem of 1917.\\n\\n    If the ``modified'' subresultant prs is complete, and LC( p ) > 0, it coincides\\n    with the (generalized) Sturm sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Pell A. J., R. L. Gordon. The Modified Remainders Obtained in Finding\\n    the Highest Common Factor of Two Polynomials. Annals of MatheMatics,\\n    Second Series, 18 (1917), No. 4, 188-193.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    k = var('k')\n    u_list = []\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    del0 = d0 - d1\n    degdif = del0\n    rho_1 = LC(a0)\n    rho_list_minus_1 = sign(LC(a0, x))\n    rho1 = LC(a1, x)\n    rho_list = [sign(rho1)]\n    p_list = [del0]\n    u = summation(k, (k, 1, p_list[0]))\n    u_list.append(u)\n    v = sum(p_list)\n    exp_deg = d1 - 1\n    a2 = -rem(a0, a1, domain=QQ)\n    rho2 = LC(a2, x)\n    d2 = degree(a2, x)\n    deg_diff_new = exp_deg - d2\n    del1 = d1 - d2\n    mul_fac_old = rho1 ** (del0 + del1 - deg_diff_new)\n    p_list.append(1 + deg_diff_new)\n    num = 1\n    for u in u_list:\n        num *= (-1) ** u\n    num = num * (-1) ** v\n    if deg_diff_new == 0:\n        den = 1\n        for k in range(len(rho_list)):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n    else:\n        den = 1\n        for k in range(len(rho_list) - 1):\n            den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n        den = den * rho_list_minus_1\n        expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n        den = den * rho_list[len(rho_list) - 1] ** expo\n    if sign(num / den) > 0:\n        subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    else:\n        subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n    k = var('k')\n    rho_list.append(sign(rho2))\n    u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n    u_list.append(u)\n    v = sum(p_list)\n    deg_diff_old = deg_diff_new\n    while d2 > 0:\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        del0 = del1\n        exp_deg = d1 - 1\n        a2 = -rem(a0, a1, domain=QQ)\n        rho3 = LC(a2, x)\n        d2 = degree(a2, x)\n        deg_diff_new = exp_deg - d2\n        del1 = d1 - d2\n        expo_old = deg_diff_old\n        expo_new = del0 + del1 - deg_diff_new\n        mul_fac_new = rho2 ** expo_new * rho1 ** expo_old * mul_fac_old\n        (deg_diff_old, mul_fac_old) = (deg_diff_new, mul_fac_new)\n        (rho1, rho2) = (rho2, rho3)\n        p_list.append(1 + deg_diff_new)\n        num = 1\n        for u in u_list:\n            num *= (-1) ** u\n        num = num * (-1) ** v\n        if deg_diff_new == 0:\n            den = 1\n            for k in range(len(rho_list)):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n        else:\n            den = 1\n            for k in range(len(rho_list) - 1):\n                den *= rho_list[k] ** (p_list[k] + p_list[k + 1])\n            den = den * rho_list_minus_1\n            expo = p_list[len(rho_list) - 1] + p_list[len(rho_list)] - deg_diff_new\n            den = den * rho_list[len(rho_list) - 1] ** expo\n        if sign(num / den) > 0:\n            subres_l.append(simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        else:\n            subres_l.append(-simplify(rho_1 ** degdif * a2 * Abs(mul_fac_old)))\n        k = var('k')\n        rho_list.append(sign(rho2))\n        u = summation(k, (k, 1, p_list[len(p_list) - 1]))\n        u_list.append(u)\n        v = sum(p_list)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    m = len(subres_l)\n    if LC(p) < 0:\n        aux_seq = [subres_l[0], subres_l[1]]\n        for i in range(2, m):\n            aux_seq.append(simplify(subres_l[i] * -1))\n        subres_l = aux_seq\n    return subres_l"
        ]
    },
    {
        "func_name": "subresultants_pg",
        "original": "def subresultants_pg(p, q, x):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the subresultant prs of p and q in Z[x] or Q[x], from\n    the modified subresultant prs of p and q.\n\n    The coefficients of the polynomials in these two sequences differ only\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\n    Theorem 2 of the reference.\n\n    The coefficients of the polynomials in the output sequence are\n    subresultants. That is, they are  determinants of appropriately\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\n\n    If the subresultant prs is complete, then it coincides with the\n    Euclidean sequence of the polynomials p, q.\n\n    References\n    ==========\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\n    Serdica Journal of Computing 9(2) (2015), 123-138.\n\n    \"\"\"\n    lst = modified_subresultants_pg(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(-lst_s[k] / lcf)\n        else:\n            subr_seq.append(lst_s[k] / lcf)\n    return subr_seq",
        "mutated": [
            "def subresultants_pg(p, q, x):\n    if False:\n        i = 10\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x], from\\n    the modified subresultant prs of p and q.\\n\\n    The coefficients of the polynomials in these two sequences differ only\\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\\n    Theorem 2 of the reference.\\n\\n    The coefficients of the polynomials in the output sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester\\'s matrix of 1840.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\\n    Serdica Journal of Computing 9(2) (2015), 123-138.\\n\\n    '\n    lst = modified_subresultants_pg(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(-lst_s[k] / lcf)\n        else:\n            subr_seq.append(lst_s[k] / lcf)\n    return subr_seq",
            "def subresultants_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x], from\\n    the modified subresultant prs of p and q.\\n\\n    The coefficients of the polynomials in these two sequences differ only\\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\\n    Theorem 2 of the reference.\\n\\n    The coefficients of the polynomials in the output sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester\\'s matrix of 1840.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\\n    Serdica Journal of Computing 9(2) (2015), 123-138.\\n\\n    '\n    lst = modified_subresultants_pg(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(-lst_s[k] / lcf)\n        else:\n            subr_seq.append(lst_s[k] / lcf)\n    return subr_seq",
            "def subresultants_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x], from\\n    the modified subresultant prs of p and q.\\n\\n    The coefficients of the polynomials in these two sequences differ only\\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\\n    Theorem 2 of the reference.\\n\\n    The coefficients of the polynomials in the output sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester\\'s matrix of 1840.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\\n    Serdica Journal of Computing 9(2) (2015), 123-138.\\n\\n    '\n    lst = modified_subresultants_pg(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(-lst_s[k] / lcf)\n        else:\n            subr_seq.append(lst_s[k] / lcf)\n    return subr_seq",
            "def subresultants_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x], from\\n    the modified subresultant prs of p and q.\\n\\n    The coefficients of the polynomials in these two sequences differ only\\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\\n    Theorem 2 of the reference.\\n\\n    The coefficients of the polynomials in the output sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester\\'s matrix of 1840.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\\n    Serdica Journal of Computing 9(2) (2015), 123-138.\\n\\n    '\n    lst = modified_subresultants_pg(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(-lst_s[k] / lcf)\n        else:\n            subr_seq.append(lst_s[k] / lcf)\n    return subr_seq",
            "def subresultants_pg(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x], from\\n    the modified subresultant prs of p and q.\\n\\n    The coefficients of the polynomials in these two sequences differ only\\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\\n    Theorem 2 of the reference.\\n\\n    The coefficients of the polynomials in the output sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester\\'s matrix of 1840.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\\n    Serdica Journal of Computing 9(2) (2015), 123-138.\\n\\n    '\n    lst = modified_subresultants_pg(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(-lst_s[k] / lcf)\n        else:\n            subr_seq.append(lst_s[k] / lcf)\n    return subr_seq"
        ]
    },
    {
        "func_name": "subresultants_amv_q",
        "original": "def subresultants_amv_q(p, q, x):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the subresultant prs of p and q in Q[x];\n    the coefficients of the polynomials in the sequence are\n    subresultants. That is, they are  determinants of appropriately\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\n\n    To compute the coefficients, no determinant evaluation takes place.\n    Instead, polynomial divisions in Q[x] are performed, using the\n    function rem(p, q, x);  the coefficients of the remainders\n    computed this way become subresultants with the help of the\n    Akritas-Malaschonok-Vigklas Theorem of 2015.\n\n    If the subresultant prs is complete, then it coincides with the\n    Euclidean sequence of the polynomials p, q.\n\n    References\n    ==========\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\n\n    \"\"\"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    sigma1 = LC(a1, x)\n    p0 = d0 - d1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    mul_fac = 1\n    d2 = d1\n    while d2 > 0:\n        i += 1\n        a2 = rem(a0, a1, domain=QQ)\n        if i == 1:\n            sigma2 = LC(a2, x)\n        else:\n            sigma3 = LC(a2, x)\n            (sigma1, sigma2) = (sigma2, sigma3)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        mul_fac = sigma1 ** (p0 + 1) * mul_fac\n        num = (-1) ** psi\n        den = sign(mul_fac)\n        if sign(num / den) > 0:\n            subres_l.append(simplify(expand(a2 * Abs(mul_fac))))\n        else:\n            subres_l.append(-simplify(expand(a2 * Abs(mul_fac))))\n        if p1 - 1 > 0:\n            mul_fac = mul_fac * sigma1 ** (p1 - 1)\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        if p0 % 2 == 1:\n            s += 1\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p0\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l",
        "mutated": [
            "def subresultants_amv_q(p, q, x):\n    if False:\n        i = 10\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Q[x] are performed, using the\\n    function rem(p, q, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Akritas-Malaschonok-Vigklas Theorem of 2015.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    sigma1 = LC(a1, x)\n    p0 = d0 - d1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    mul_fac = 1\n    d2 = d1\n    while d2 > 0:\n        i += 1\n        a2 = rem(a0, a1, domain=QQ)\n        if i == 1:\n            sigma2 = LC(a2, x)\n        else:\n            sigma3 = LC(a2, x)\n            (sigma1, sigma2) = (sigma2, sigma3)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        mul_fac = sigma1 ** (p0 + 1) * mul_fac\n        num = (-1) ** psi\n        den = sign(mul_fac)\n        if sign(num / den) > 0:\n            subres_l.append(simplify(expand(a2 * Abs(mul_fac))))\n        else:\n            subres_l.append(-simplify(expand(a2 * Abs(mul_fac))))\n        if p1 - 1 > 0:\n            mul_fac = mul_fac * sigma1 ** (p1 - 1)\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        if p0 % 2 == 1:\n            s += 1\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p0\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l",
            "def subresultants_amv_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Q[x] are performed, using the\\n    function rem(p, q, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Akritas-Malaschonok-Vigklas Theorem of 2015.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    sigma1 = LC(a1, x)\n    p0 = d0 - d1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    mul_fac = 1\n    d2 = d1\n    while d2 > 0:\n        i += 1\n        a2 = rem(a0, a1, domain=QQ)\n        if i == 1:\n            sigma2 = LC(a2, x)\n        else:\n            sigma3 = LC(a2, x)\n            (sigma1, sigma2) = (sigma2, sigma3)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        mul_fac = sigma1 ** (p0 + 1) * mul_fac\n        num = (-1) ** psi\n        den = sign(mul_fac)\n        if sign(num / den) > 0:\n            subres_l.append(simplify(expand(a2 * Abs(mul_fac))))\n        else:\n            subres_l.append(-simplify(expand(a2 * Abs(mul_fac))))\n        if p1 - 1 > 0:\n            mul_fac = mul_fac * sigma1 ** (p1 - 1)\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        if p0 % 2 == 1:\n            s += 1\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p0\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l",
            "def subresultants_amv_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Q[x] are performed, using the\\n    function rem(p, q, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Akritas-Malaschonok-Vigklas Theorem of 2015.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    sigma1 = LC(a1, x)\n    p0 = d0 - d1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    mul_fac = 1\n    d2 = d1\n    while d2 > 0:\n        i += 1\n        a2 = rem(a0, a1, domain=QQ)\n        if i == 1:\n            sigma2 = LC(a2, x)\n        else:\n            sigma3 = LC(a2, x)\n            (sigma1, sigma2) = (sigma2, sigma3)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        mul_fac = sigma1 ** (p0 + 1) * mul_fac\n        num = (-1) ** psi\n        den = sign(mul_fac)\n        if sign(num / den) > 0:\n            subres_l.append(simplify(expand(a2 * Abs(mul_fac))))\n        else:\n            subres_l.append(-simplify(expand(a2 * Abs(mul_fac))))\n        if p1 - 1 > 0:\n            mul_fac = mul_fac * sigma1 ** (p1 - 1)\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        if p0 % 2 == 1:\n            s += 1\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p0\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l",
            "def subresultants_amv_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Q[x] are performed, using the\\n    function rem(p, q, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Akritas-Malaschonok-Vigklas Theorem of 2015.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    sigma1 = LC(a1, x)\n    p0 = d0 - d1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    mul_fac = 1\n    d2 = d1\n    while d2 > 0:\n        i += 1\n        a2 = rem(a0, a1, domain=QQ)\n        if i == 1:\n            sigma2 = LC(a2, x)\n        else:\n            sigma3 = LC(a2, x)\n            (sigma1, sigma2) = (sigma2, sigma3)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        mul_fac = sigma1 ** (p0 + 1) * mul_fac\n        num = (-1) ** psi\n        den = sign(mul_fac)\n        if sign(num / den) > 0:\n            subres_l.append(simplify(expand(a2 * Abs(mul_fac))))\n        else:\n            subres_l.append(-simplify(expand(a2 * Abs(mul_fac))))\n        if p1 - 1 > 0:\n            mul_fac = mul_fac * sigma1 ** (p1 - 1)\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        if p0 % 2 == 1:\n            s += 1\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p0\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l",
            "def subresultants_amv_q(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Q[x] are performed, using the\\n    function rem(p, q, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Akritas-Malaschonok-Vigklas Theorem of 2015.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    d0 = degree(p, x)\n    d1 = degree(q, x)\n    if d0 == 0 and d1 == 0:\n        return [p, q]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (p, q) = (q, p)\n    if d0 > 0 and d1 == 0:\n        return [p, q]\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    subres_l = [p, q]\n    (a0, a1) = (p, q)\n    sigma1 = LC(a1, x)\n    p0 = d0 - d1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    mul_fac = 1\n    d2 = d1\n    while d2 > 0:\n        i += 1\n        a2 = rem(a0, a1, domain=QQ)\n        if i == 1:\n            sigma2 = LC(a2, x)\n        else:\n            sigma3 = LC(a2, x)\n            (sigma1, sigma2) = (sigma2, sigma3)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        mul_fac = sigma1 ** (p0 + 1) * mul_fac\n        num = (-1) ** psi\n        den = sign(mul_fac)\n        if sign(num / den) > 0:\n            subres_l.append(simplify(expand(a2 * Abs(mul_fac))))\n        else:\n            subres_l.append(-simplify(expand(a2 * Abs(mul_fac))))\n        if p1 - 1 > 0:\n            mul_fac = mul_fac * sigma1 ** (p1 - 1)\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        if p0 % 2 == 1:\n            s += 1\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p0\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l"
        ]
    },
    {
        "func_name": "compute_sign",
        "original": "def compute_sign(base, expo):\n    \"\"\"\n    base != 0 and expo >= 0 are integers;\n\n    returns the sign of base**expo without\n    evaluating the power itself!\n    \"\"\"\n    sb = sign(base)\n    if sb == 1:\n        return 1\n    pe = expo % 2\n    if pe == 0:\n        return -sb\n    else:\n        return sb",
        "mutated": [
            "def compute_sign(base, expo):\n    if False:\n        i = 10\n    '\\n    base != 0 and expo >= 0 are integers;\\n\\n    returns the sign of base**expo without\\n    evaluating the power itself!\\n    '\n    sb = sign(base)\n    if sb == 1:\n        return 1\n    pe = expo % 2\n    if pe == 0:\n        return -sb\n    else:\n        return sb",
            "def compute_sign(base, expo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    base != 0 and expo >= 0 are integers;\\n\\n    returns the sign of base**expo without\\n    evaluating the power itself!\\n    '\n    sb = sign(base)\n    if sb == 1:\n        return 1\n    pe = expo % 2\n    if pe == 0:\n        return -sb\n    else:\n        return sb",
            "def compute_sign(base, expo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    base != 0 and expo >= 0 are integers;\\n\\n    returns the sign of base**expo without\\n    evaluating the power itself!\\n    '\n    sb = sign(base)\n    if sb == 1:\n        return 1\n    pe = expo % 2\n    if pe == 0:\n        return -sb\n    else:\n        return sb",
            "def compute_sign(base, expo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    base != 0 and expo >= 0 are integers;\\n\\n    returns the sign of base**expo without\\n    evaluating the power itself!\\n    '\n    sb = sign(base)\n    if sb == 1:\n        return 1\n    pe = expo % 2\n    if pe == 0:\n        return -sb\n    else:\n        return sb",
            "def compute_sign(base, expo):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    base != 0 and expo >= 0 are integers;\\n\\n    returns the sign of base**expo without\\n    evaluating the power itself!\\n    '\n    sb = sign(base)\n    if sb == 1:\n        return 1\n    pe = expo % 2\n    if pe == 0:\n        return -sb\n    else:\n        return sb"
        ]
    },
    {
        "func_name": "rem_z",
        "original": "def rem_z(p, q, x):\n    \"\"\"\n    Intended mainly for p, q polynomials in Z[x] so that,\n    on dividing p by q, the remainder will also be in Z[x]. (However,\n    it also works fine for polynomials in Q[x].) It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    It premultiplies p by the _absolute_ value of the leading coefficient\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\n    polynomial division in Q[x], using the function rem(p, q, x).\n\n    By contrast the function prem(p, q, x) does _not_ use the absolute\n    value of the leading coefficient of q.\n    This results not only in ``messing up the signs'' of the Euclidean and\n    Sturmian prs's as mentioned in the second reference,\n    but also in violation of the main results of the first and third\n    references --- Theorem 4 and Theorem 1 respectively. Theorems 4 and 1\n    establish a one-to-one correspondence between the Euclidean and the\n    Sturmian prs of p, q, on one hand, and the subresultant prs of p, q,\n    on the other.\n\n    References\n    ==========\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.''\n    Serdica Journal of Computing, 9(2) (2015), 123-138.\n\n    2. https://planetMath.org/sturmstheorem\n\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result on\n    the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\n\n    \"\"\"\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return rem(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return prem(p, q, x)",
        "mutated": [
            "def rem_z(p, q, x):\n    if False:\n        i = 10\n    \"\\n    Intended mainly for p, q polynomials in Z[x] so that,\\n    on dividing p by q, the remainder will also be in Z[x]. (However,\\n    it also works fine for polynomials in Q[x].) It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    It premultiplies p by the _absolute_ value of the leading coefficient\\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\\n    polynomial division in Q[x], using the function rem(p, q, x).\\n\\n    By contrast the function prem(p, q, x) does _not_ use the absolute\\n    value of the leading coefficient of q.\\n    This results not only in ``messing up the signs'' of the Euclidean and\\n    Sturmian prs's as mentioned in the second reference,\\n    but also in violation of the main results of the first and third\\n    references --- Theorem 4 and Theorem 1 respectively. Theorems 4 and 1\\n    establish a one-to-one correspondence between the Euclidean and the\\n    Sturmian prs of p, q, on one hand, and the subresultant prs of p, q,\\n    on the other.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.''\\n    Serdica Journal of Computing, 9(2) (2015), 123-138.\\n\\n    2. https://planetMath.org/sturmstheorem\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result on\\n    the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return rem(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return prem(p, q, x)",
            "def rem_z(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Intended mainly for p, q polynomials in Z[x] so that,\\n    on dividing p by q, the remainder will also be in Z[x]. (However,\\n    it also works fine for polynomials in Q[x].) It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    It premultiplies p by the _absolute_ value of the leading coefficient\\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\\n    polynomial division in Q[x], using the function rem(p, q, x).\\n\\n    By contrast the function prem(p, q, x) does _not_ use the absolute\\n    value of the leading coefficient of q.\\n    This results not only in ``messing up the signs'' of the Euclidean and\\n    Sturmian prs's as mentioned in the second reference,\\n    but also in violation of the main results of the first and third\\n    references --- Theorem 4 and Theorem 1 respectively. Theorems 4 and 1\\n    establish a one-to-one correspondence between the Euclidean and the\\n    Sturmian prs of p, q, on one hand, and the subresultant prs of p, q,\\n    on the other.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.''\\n    Serdica Journal of Computing, 9(2) (2015), 123-138.\\n\\n    2. https://planetMath.org/sturmstheorem\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result on\\n    the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return rem(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return prem(p, q, x)",
            "def rem_z(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Intended mainly for p, q polynomials in Z[x] so that,\\n    on dividing p by q, the remainder will also be in Z[x]. (However,\\n    it also works fine for polynomials in Q[x].) It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    It premultiplies p by the _absolute_ value of the leading coefficient\\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\\n    polynomial division in Q[x], using the function rem(p, q, x).\\n\\n    By contrast the function prem(p, q, x) does _not_ use the absolute\\n    value of the leading coefficient of q.\\n    This results not only in ``messing up the signs'' of the Euclidean and\\n    Sturmian prs's as mentioned in the second reference,\\n    but also in violation of the main results of the first and third\\n    references --- Theorem 4 and Theorem 1 respectively. Theorems 4 and 1\\n    establish a one-to-one correspondence between the Euclidean and the\\n    Sturmian prs of p, q, on one hand, and the subresultant prs of p, q,\\n    on the other.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.''\\n    Serdica Journal of Computing, 9(2) (2015), 123-138.\\n\\n    2. https://planetMath.org/sturmstheorem\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result on\\n    the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return rem(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return prem(p, q, x)",
            "def rem_z(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Intended mainly for p, q polynomials in Z[x] so that,\\n    on dividing p by q, the remainder will also be in Z[x]. (However,\\n    it also works fine for polynomials in Q[x].) It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    It premultiplies p by the _absolute_ value of the leading coefficient\\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\\n    polynomial division in Q[x], using the function rem(p, q, x).\\n\\n    By contrast the function prem(p, q, x) does _not_ use the absolute\\n    value of the leading coefficient of q.\\n    This results not only in ``messing up the signs'' of the Euclidean and\\n    Sturmian prs's as mentioned in the second reference,\\n    but also in violation of the main results of the first and third\\n    references --- Theorem 4 and Theorem 1 respectively. Theorems 4 and 1\\n    establish a one-to-one correspondence between the Euclidean and the\\n    Sturmian prs of p, q, on one hand, and the subresultant prs of p, q,\\n    on the other.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.''\\n    Serdica Journal of Computing, 9(2) (2015), 123-138.\\n\\n    2. https://planetMath.org/sturmstheorem\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result on\\n    the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return rem(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return prem(p, q, x)",
            "def rem_z(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Intended mainly for p, q polynomials in Z[x] so that,\\n    on dividing p by q, the remainder will also be in Z[x]. (However,\\n    it also works fine for polynomials in Q[x].) It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    It premultiplies p by the _absolute_ value of the leading coefficient\\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\\n    polynomial division in Q[x], using the function rem(p, q, x).\\n\\n    By contrast the function prem(p, q, x) does _not_ use the absolute\\n    value of the leading coefficient of q.\\n    This results not only in ``messing up the signs'' of the Euclidean and\\n    Sturmian prs's as mentioned in the second reference,\\n    but also in violation of the main results of the first and third\\n    references --- Theorem 4 and Theorem 1 respectively. Theorems 4 and 1\\n    establish a one-to-one correspondence between the Euclidean and the\\n    Sturmian prs of p, q, on one hand, and the subresultant prs of p, q,\\n    on the other.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.''\\n    Serdica Journal of Computing, 9(2) (2015), 123-138.\\n\\n    2. https://planetMath.org/sturmstheorem\\n\\n    3. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result on\\n    the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    \"\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return rem(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return prem(p, q, x)"
        ]
    },
    {
        "func_name": "quo_z",
        "original": "def quo_z(p, q, x):\n    \"\"\"\n    Intended mainly for p, q polynomials in Z[x] so that,\n    on dividing p by q, the quotient will also be in Z[x]. (However,\n    it also works fine for polynomials in Q[x].) It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    It premultiplies p by the _absolute_ value of the leading coefficient\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\n    polynomial division in Q[x], using the function quo(p, q, x).\n\n    By contrast the function pquo(p, q, x) does _not_ use the absolute\n    value of the leading coefficient of q.\n\n    See also function rem_z(p, q, x) for additional comments and references.\n\n    \"\"\"\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return quo(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return pquo(p, q, x)",
        "mutated": [
            "def quo_z(p, q, x):\n    if False:\n        i = 10\n    '\\n    Intended mainly for p, q polynomials in Z[x] so that,\\n    on dividing p by q, the quotient will also be in Z[x]. (However,\\n    it also works fine for polynomials in Q[x].) It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    It premultiplies p by the _absolute_ value of the leading coefficient\\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\\n    polynomial division in Q[x], using the function quo(p, q, x).\\n\\n    By contrast the function pquo(p, q, x) does _not_ use the absolute\\n    value of the leading coefficient of q.\\n\\n    See also function rem_z(p, q, x) for additional comments and references.\\n\\n    '\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return quo(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return pquo(p, q, x)",
            "def quo_z(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Intended mainly for p, q polynomials in Z[x] so that,\\n    on dividing p by q, the quotient will also be in Z[x]. (However,\\n    it also works fine for polynomials in Q[x].) It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    It premultiplies p by the _absolute_ value of the leading coefficient\\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\\n    polynomial division in Q[x], using the function quo(p, q, x).\\n\\n    By contrast the function pquo(p, q, x) does _not_ use the absolute\\n    value of the leading coefficient of q.\\n\\n    See also function rem_z(p, q, x) for additional comments and references.\\n\\n    '\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return quo(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return pquo(p, q, x)",
            "def quo_z(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Intended mainly for p, q polynomials in Z[x] so that,\\n    on dividing p by q, the quotient will also be in Z[x]. (However,\\n    it also works fine for polynomials in Q[x].) It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    It premultiplies p by the _absolute_ value of the leading coefficient\\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\\n    polynomial division in Q[x], using the function quo(p, q, x).\\n\\n    By contrast the function pquo(p, q, x) does _not_ use the absolute\\n    value of the leading coefficient of q.\\n\\n    See also function rem_z(p, q, x) for additional comments and references.\\n\\n    '\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return quo(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return pquo(p, q, x)",
            "def quo_z(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Intended mainly for p, q polynomials in Z[x] so that,\\n    on dividing p by q, the quotient will also be in Z[x]. (However,\\n    it also works fine for polynomials in Q[x].) It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    It premultiplies p by the _absolute_ value of the leading coefficient\\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\\n    polynomial division in Q[x], using the function quo(p, q, x).\\n\\n    By contrast the function pquo(p, q, x) does _not_ use the absolute\\n    value of the leading coefficient of q.\\n\\n    See also function rem_z(p, q, x) for additional comments and references.\\n\\n    '\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return quo(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return pquo(p, q, x)",
            "def quo_z(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Intended mainly for p, q polynomials in Z[x] so that,\\n    on dividing p by q, the quotient will also be in Z[x]. (However,\\n    it also works fine for polynomials in Q[x].) It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    It premultiplies p by the _absolute_ value of the leading coefficient\\n    of q, raised to the power deg(p) - deg(q) + 1 and then performs\\n    polynomial division in Q[x], using the function quo(p, q, x).\\n\\n    By contrast the function pquo(p, q, x) does _not_ use the absolute\\n    value of the leading coefficient of q.\\n\\n    See also function rem_z(p, q, x) for additional comments and references.\\n\\n    '\n    if p.as_poly().is_univariate and q.as_poly().is_univariate and (p.as_poly().gens == q.as_poly().gens):\n        delta = degree(p, x) - degree(q, x) + 1\n        return quo(Abs(LC(q, x)) ** delta * p, q, x)\n    else:\n        return pquo(p, q, x)"
        ]
    },
    {
        "func_name": "subresultants_amv",
        "original": "def subresultants_amv(f, g, x):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(f, x) >= degree(g, x).\n\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\n    the coefficients of the polynomials in the sequence are\n    subresultants. That is, they are  determinants of appropriately\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\n\n    To compute the coefficients, no determinant evaluation takes place.\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\n    the function rem_z(p, q, x);  the coefficients of the remainders\n    computed this way become subresultants with the help of the\n    Akritas-Malaschonok-Vigklas Theorem of 2015 and the Collins-Brown-\n    Traub formula for coefficient reduction.\n\n    If the subresultant prs is complete, then it coincides with the\n    Euclidean sequence of the polynomials p, q.\n\n    References\n    ==========\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\n\n    \"\"\"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    subres_l = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    sigma1 = LC(a1, x)\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    p0 = deg_dif_p1 - 1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    i += 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    sigma2 = LC(a2, x)\n    d2 = degree(a2, x)\n    p1 = d1 - d2\n    sgn_den = compute_sign(sigma1, p0 + 1)\n    psi = i + phi + p_odd_index_sum\n    num = (-1) ** psi\n    den = sgn_den\n    if sign(num / den) > 0:\n        subres_l.append(a2)\n    else:\n        subres_l.append(-a2)\n    if p1 % 2 == 1:\n        s += 1\n    if p1 - 1 > 0:\n        sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    while d2 >= 1:\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p1\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        sigma3 = LC(a2, x)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        (sigma1, sigma2) = (sigma2, sigma3)\n        sgn_den = compute_sign(sigma1, p0 + 1) * sgn_den\n        num = (-1) ** psi\n        den = sgn_den\n        if sign(num / den) > 0:\n            subres_l.append(a2)\n        else:\n            subres_l.append(-a2)\n        if p1 % 2 == 1:\n            s += 1\n        if p1 - 1 > 0:\n            sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l",
        "mutated": [
            "def subresultants_amv(f, g, x):\n    if False:\n        i = 10\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(f, x) >= degree(g, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\\n    the function rem_z(p, q, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Akritas-Malaschonok-Vigklas Theorem of 2015 and the Collins-Brown-\\n    Traub formula for coefficient reduction.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    subres_l = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    sigma1 = LC(a1, x)\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    p0 = deg_dif_p1 - 1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    i += 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    sigma2 = LC(a2, x)\n    d2 = degree(a2, x)\n    p1 = d1 - d2\n    sgn_den = compute_sign(sigma1, p0 + 1)\n    psi = i + phi + p_odd_index_sum\n    num = (-1) ** psi\n    den = sgn_den\n    if sign(num / den) > 0:\n        subres_l.append(a2)\n    else:\n        subres_l.append(-a2)\n    if p1 % 2 == 1:\n        s += 1\n    if p1 - 1 > 0:\n        sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    while d2 >= 1:\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p1\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        sigma3 = LC(a2, x)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        (sigma1, sigma2) = (sigma2, sigma3)\n        sgn_den = compute_sign(sigma1, p0 + 1) * sgn_den\n        num = (-1) ** psi\n        den = sgn_den\n        if sign(num / den) > 0:\n            subres_l.append(a2)\n        else:\n            subres_l.append(-a2)\n        if p1 % 2 == 1:\n            s += 1\n        if p1 - 1 > 0:\n            sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l",
            "def subresultants_amv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(f, x) >= degree(g, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\\n    the function rem_z(p, q, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Akritas-Malaschonok-Vigklas Theorem of 2015 and the Collins-Brown-\\n    Traub formula for coefficient reduction.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    subres_l = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    sigma1 = LC(a1, x)\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    p0 = deg_dif_p1 - 1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    i += 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    sigma2 = LC(a2, x)\n    d2 = degree(a2, x)\n    p1 = d1 - d2\n    sgn_den = compute_sign(sigma1, p0 + 1)\n    psi = i + phi + p_odd_index_sum\n    num = (-1) ** psi\n    den = sgn_den\n    if sign(num / den) > 0:\n        subres_l.append(a2)\n    else:\n        subres_l.append(-a2)\n    if p1 % 2 == 1:\n        s += 1\n    if p1 - 1 > 0:\n        sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    while d2 >= 1:\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p1\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        sigma3 = LC(a2, x)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        (sigma1, sigma2) = (sigma2, sigma3)\n        sgn_den = compute_sign(sigma1, p0 + 1) * sgn_den\n        num = (-1) ** psi\n        den = sgn_den\n        if sign(num / den) > 0:\n            subres_l.append(a2)\n        else:\n            subres_l.append(-a2)\n        if p1 % 2 == 1:\n            s += 1\n        if p1 - 1 > 0:\n            sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l",
            "def subresultants_amv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(f, x) >= degree(g, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\\n    the function rem_z(p, q, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Akritas-Malaschonok-Vigklas Theorem of 2015 and the Collins-Brown-\\n    Traub formula for coefficient reduction.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    subres_l = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    sigma1 = LC(a1, x)\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    p0 = deg_dif_p1 - 1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    i += 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    sigma2 = LC(a2, x)\n    d2 = degree(a2, x)\n    p1 = d1 - d2\n    sgn_den = compute_sign(sigma1, p0 + 1)\n    psi = i + phi + p_odd_index_sum\n    num = (-1) ** psi\n    den = sgn_den\n    if sign(num / den) > 0:\n        subres_l.append(a2)\n    else:\n        subres_l.append(-a2)\n    if p1 % 2 == 1:\n        s += 1\n    if p1 - 1 > 0:\n        sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    while d2 >= 1:\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p1\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        sigma3 = LC(a2, x)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        (sigma1, sigma2) = (sigma2, sigma3)\n        sgn_den = compute_sign(sigma1, p0 + 1) * sgn_den\n        num = (-1) ** psi\n        den = sgn_den\n        if sign(num / den) > 0:\n            subres_l.append(a2)\n        else:\n            subres_l.append(-a2)\n        if p1 % 2 == 1:\n            s += 1\n        if p1 - 1 > 0:\n            sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l",
            "def subresultants_amv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(f, x) >= degree(g, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\\n    the function rem_z(p, q, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Akritas-Malaschonok-Vigklas Theorem of 2015 and the Collins-Brown-\\n    Traub formula for coefficient reduction.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    subres_l = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    sigma1 = LC(a1, x)\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    p0 = deg_dif_p1 - 1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    i += 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    sigma2 = LC(a2, x)\n    d2 = degree(a2, x)\n    p1 = d1 - d2\n    sgn_den = compute_sign(sigma1, p0 + 1)\n    psi = i + phi + p_odd_index_sum\n    num = (-1) ** psi\n    den = sgn_den\n    if sign(num / den) > 0:\n        subres_l.append(a2)\n    else:\n        subres_l.append(-a2)\n    if p1 % 2 == 1:\n        s += 1\n    if p1 - 1 > 0:\n        sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    while d2 >= 1:\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p1\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        sigma3 = LC(a2, x)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        (sigma1, sigma2) = (sigma2, sigma3)\n        sgn_den = compute_sign(sigma1, p0 + 1) * sgn_den\n        num = (-1) ** psi\n        den = sgn_den\n        if sign(num / den) > 0:\n            subres_l.append(a2)\n        else:\n            subres_l.append(-a2)\n        if p1 % 2 == 1:\n            s += 1\n        if p1 - 1 > 0:\n            sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l",
            "def subresultants_amv(f, g, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(f, x) >= degree(g, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients, no determinant evaluation takes place.\\n    Instead, polynomial divisions in Z[x] or Q[x] are performed, using\\n    the function rem_z(p, q, x);  the coefficients of the remainders\\n    computed this way become subresultants with the help of the\\n    Akritas-Malaschonok-Vigklas Theorem of 2015 and the Collins-Brown-\\n    Traub formula for coefficient reduction.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``A Basic Result\\n    on the Theory of Subresultants.'' Serdica Journal of Computing 10 (2016), No.1, 31-48.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Subresultant Polynomial\\n    remainder Sequences Obtained by Polynomial Divisions in Q[x] or in Z[x].''\\n    Serdica Journal of Computing 10 (2016), No.3-4, 197-217.\\n\\n    \"\n    if f == 0 or g == 0:\n        return [f, g]\n    d0 = degree(f, x)\n    d1 = degree(g, x)\n    if d0 == 0 and d1 == 0:\n        return [f, g]\n    if d1 > d0:\n        (d0, d1) = (d1, d0)\n        (f, g) = (g, f)\n    if d0 > 0 and d1 == 0:\n        return [f, g]\n    a0 = f\n    a1 = g\n    subres_l = [a0, a1]\n    (deg_dif_p1, c) = (degree(a0, x) - degree(a1, x) + 1, -1)\n    sigma1 = LC(a1, x)\n    (i, s) = (0, 0)\n    p_odd_index_sum = 0\n    p0 = deg_dif_p1 - 1\n    if p0 % 2 == 1:\n        s += 1\n    phi = floor((s + 1) / 2)\n    i += 1\n    a2 = rem_z(a0, a1, x) / Abs((-1) ** deg_dif_p1)\n    sigma2 = LC(a2, x)\n    d2 = degree(a2, x)\n    p1 = d1 - d2\n    sgn_den = compute_sign(sigma1, p0 + 1)\n    psi = i + phi + p_odd_index_sum\n    num = (-1) ** psi\n    den = sgn_den\n    if sign(num / den) > 0:\n        subres_l.append(a2)\n    else:\n        subres_l.append(-a2)\n    if p1 % 2 == 1:\n        s += 1\n    if p1 - 1 > 0:\n        sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    while d2 >= 1:\n        phi = floor((s + 1) / 2)\n        if i % 2 == 1:\n            p_odd_index_sum += p1\n        (a0, a1, d0, d1) = (a1, a2, d1, d2)\n        p0 = p1\n        i += 1\n        sigma0 = -LC(a0)\n        c = sigma0 ** (deg_dif_p1 - 1) / c ** (deg_dif_p1 - 2)\n        deg_dif_p1 = degree(a0, x) - d2 + 1\n        a2 = rem_z(a0, a1, x) / Abs(c ** (deg_dif_p1 - 1) * sigma0)\n        sigma3 = LC(a2, x)\n        d2 = degree(a2, x)\n        p1 = d1 - d2\n        psi = i + phi + p_odd_index_sum\n        (sigma1, sigma2) = (sigma2, sigma3)\n        sgn_den = compute_sign(sigma1, p0 + 1) * sgn_den\n        num = (-1) ** psi\n        den = sgn_den\n        if sign(num / den) > 0:\n            subres_l.append(a2)\n        else:\n            subres_l.append(-a2)\n        if p1 % 2 == 1:\n            s += 1\n        if p1 - 1 > 0:\n            sgn_den = sgn_den * compute_sign(sigma1, p1 - 1)\n    m = len(subres_l)\n    if subres_l[m - 1] == nan or subres_l[m - 1] == 0:\n        subres_l.pop(m - 1)\n    return subres_l"
        ]
    },
    {
        "func_name": "modified_subresultants_amv",
        "original": "def modified_subresultants_amv(p, q, x):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the modified subresultant prs of p and q in Z[x] or Q[x],\n    from the subresultant prs of p and q.\n    The coefficients of the polynomials in the two sequences differ only\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\n    Theorem 2 of the reference.\n\n    The coefficients of the polynomials in the output sequence are\n    modified subresultants. That is, they are  determinants of appropriately\n    selected submatrices of sylvester2, Sylvester's matrix of 1853.\n\n    If the modified subresultant prs is complete, and LC( p ) > 0, it coincides\n    with the (generalized) Sturm's sequence of the polynomials p, q.\n\n    References\n    ==========\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\n    Serdica Journal of Computing, Serdica Journal of Computing, 9(2) (2015), 123-138.\n\n    \"\"\"\n    lst = subresultants_amv(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(simplify(-lst_s[k] * lcf))\n        else:\n            subr_seq.append(simplify(lst_s[k] * lcf))\n    return subr_seq",
        "mutated": [
            "def modified_subresultants_amv(p, q, x):\n    if False:\n        i = 10\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the modified subresultant prs of p and q in Z[x] or Q[x],\\n    from the subresultant prs of p and q.\\n    The coefficients of the polynomials in the two sequences differ only\\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\\n    Theorem 2 of the reference.\\n\\n    The coefficients of the polynomials in the output sequence are\\n    modified subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester2, Sylvester\\'s matrix of 1853.\\n\\n    If the modified subresultant prs is complete, and LC( p ) > 0, it coincides\\n    with the (generalized) Sturm\\'s sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\\n    Serdica Journal of Computing, Serdica Journal of Computing, 9(2) (2015), 123-138.\\n\\n    '\n    lst = subresultants_amv(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(simplify(-lst_s[k] * lcf))\n        else:\n            subr_seq.append(simplify(lst_s[k] * lcf))\n    return subr_seq",
            "def modified_subresultants_amv(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the modified subresultant prs of p and q in Z[x] or Q[x],\\n    from the subresultant prs of p and q.\\n    The coefficients of the polynomials in the two sequences differ only\\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\\n    Theorem 2 of the reference.\\n\\n    The coefficients of the polynomials in the output sequence are\\n    modified subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester2, Sylvester\\'s matrix of 1853.\\n\\n    If the modified subresultant prs is complete, and LC( p ) > 0, it coincides\\n    with the (generalized) Sturm\\'s sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\\n    Serdica Journal of Computing, Serdica Journal of Computing, 9(2) (2015), 123-138.\\n\\n    '\n    lst = subresultants_amv(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(simplify(-lst_s[k] * lcf))\n        else:\n            subr_seq.append(simplify(lst_s[k] * lcf))\n    return subr_seq",
            "def modified_subresultants_amv(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the modified subresultant prs of p and q in Z[x] or Q[x],\\n    from the subresultant prs of p and q.\\n    The coefficients of the polynomials in the two sequences differ only\\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\\n    Theorem 2 of the reference.\\n\\n    The coefficients of the polynomials in the output sequence are\\n    modified subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester2, Sylvester\\'s matrix of 1853.\\n\\n    If the modified subresultant prs is complete, and LC( p ) > 0, it coincides\\n    with the (generalized) Sturm\\'s sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\\n    Serdica Journal of Computing, Serdica Journal of Computing, 9(2) (2015), 123-138.\\n\\n    '\n    lst = subresultants_amv(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(simplify(-lst_s[k] * lcf))\n        else:\n            subr_seq.append(simplify(lst_s[k] * lcf))\n    return subr_seq",
            "def modified_subresultants_amv(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the modified subresultant prs of p and q in Z[x] or Q[x],\\n    from the subresultant prs of p and q.\\n    The coefficients of the polynomials in the two sequences differ only\\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\\n    Theorem 2 of the reference.\\n\\n    The coefficients of the polynomials in the output sequence are\\n    modified subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester2, Sylvester\\'s matrix of 1853.\\n\\n    If the modified subresultant prs is complete, and LC( p ) > 0, it coincides\\n    with the (generalized) Sturm\\'s sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\\n    Serdica Journal of Computing, Serdica Journal of Computing, 9(2) (2015), 123-138.\\n\\n    '\n    lst = subresultants_amv(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(simplify(-lst_s[k] * lcf))\n        else:\n            subr_seq.append(simplify(lst_s[k] * lcf))\n    return subr_seq",
            "def modified_subresultants_amv(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the modified subresultant prs of p and q in Z[x] or Q[x],\\n    from the subresultant prs of p and q.\\n    The coefficients of the polynomials in the two sequences differ only\\n    in sign and the factor LC(p)**( deg(p)- deg(q)) as stated in\\n    Theorem 2 of the reference.\\n\\n    The coefficients of the polynomials in the output sequence are\\n    modified subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester2, Sylvester\\'s matrix of 1853.\\n\\n    If the modified subresultant prs is complete, and LC( p ) > 0, it coincides\\n    with the (generalized) Sturm\\'s sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: \"On the Remainders\\n    Obtained in Finding the Greatest Common Divisor of Two Polynomials.\"\\n    Serdica Journal of Computing, Serdica Journal of Computing, 9(2) (2015), 123-138.\\n\\n    '\n    lst = subresultants_amv(p, q, x)\n    if lst == [] or len(lst) == 2:\n        return lst\n    lcf = LC(lst[0]) ** (degree(lst[0], x) - degree(lst[1], x))\n    subr_seq = [lst[0], lst[1]]\n    deg_seq = [degree(Poly(poly, x), x) for poly in lst]\n    deg = deg_seq[0]\n    deg_seq_s = deg_seq[1:-1]\n    m_seq = [m - 1 for m in deg_seq_s]\n    j_seq = [deg - m for m in m_seq]\n    fact = [(-1) ** (j * (j - 1) / S(2)) for j in j_seq]\n    lst_s = lst[2:]\n    m = len(fact)\n    for k in range(m):\n        if sign(fact[k]) == -1:\n            subr_seq.append(simplify(-lst_s[k] * lcf))\n        else:\n            subr_seq.append(simplify(lst_s[k] * lcf))\n    return subr_seq"
        ]
    },
    {
        "func_name": "correct_sign",
        "original": "def correct_sign(deg_f, deg_g, s1, rdel, cdel):\n    \"\"\"\n    Used in various subresultant prs algorithms.\n\n    Evaluates the determinant, (a.k.a. subresultant) of a properly selected\n    submatrix of s1, Sylvester's matrix of 1840, to get the correct sign\n    and value of the leading coefficient of a given polynomial remainder.\n\n    deg_f, deg_g are the degrees of the original polynomials p, q for which the\n    matrix s1 = sylvester(p, q, x, 1) was constructed.\n\n    rdel denotes the expected degree of the remainder; it is the number of\n    rows to be deleted from each group of rows in s1 as described in the\n    reference below.\n\n    cdel denotes the expected degree minus the actual degree of the remainder;\n    it is the number of columns to be deleted --- starting with the last column\n    forming the square matrix --- from the matrix resulting after the row deletions.\n\n    References\n    ==========\n    Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\n    and Modified Subresultant Polynomial Remainder Sequences.''\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\n\n    \"\"\"\n    M = s1[:, :]\n    for i in range(M.rows - deg_f - 1, M.rows - deg_f - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(M.rows - 1, M.rows - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(cdel):\n        M.col_del(M.rows - 1)\n    Md = M[:, 0:M.rows]\n    return Md.det()",
        "mutated": [
            "def correct_sign(deg_f, deg_g, s1, rdel, cdel):\n    if False:\n        i = 10\n    \"\\n    Used in various subresultant prs algorithms.\\n\\n    Evaluates the determinant, (a.k.a. subresultant) of a properly selected\\n    submatrix of s1, Sylvester's matrix of 1840, to get the correct sign\\n    and value of the leading coefficient of a given polynomial remainder.\\n\\n    deg_f, deg_g are the degrees of the original polynomials p, q for which the\\n    matrix s1 = sylvester(p, q, x, 1) was constructed.\\n\\n    rdel denotes the expected degree of the remainder; it is the number of\\n    rows to be deleted from each group of rows in s1 as described in the\\n    reference below.\\n\\n    cdel denotes the expected degree minus the actual degree of the remainder;\\n    it is the number of columns to be deleted --- starting with the last column\\n    forming the square matrix --- from the matrix resulting after the row deletions.\\n\\n    References\\n    ==========\\n    Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    M = s1[:, :]\n    for i in range(M.rows - deg_f - 1, M.rows - deg_f - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(M.rows - 1, M.rows - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(cdel):\n        M.col_del(M.rows - 1)\n    Md = M[:, 0:M.rows]\n    return Md.det()",
            "def correct_sign(deg_f, deg_g, s1, rdel, cdel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Used in various subresultant prs algorithms.\\n\\n    Evaluates the determinant, (a.k.a. subresultant) of a properly selected\\n    submatrix of s1, Sylvester's matrix of 1840, to get the correct sign\\n    and value of the leading coefficient of a given polynomial remainder.\\n\\n    deg_f, deg_g are the degrees of the original polynomials p, q for which the\\n    matrix s1 = sylvester(p, q, x, 1) was constructed.\\n\\n    rdel denotes the expected degree of the remainder; it is the number of\\n    rows to be deleted from each group of rows in s1 as described in the\\n    reference below.\\n\\n    cdel denotes the expected degree minus the actual degree of the remainder;\\n    it is the number of columns to be deleted --- starting with the last column\\n    forming the square matrix --- from the matrix resulting after the row deletions.\\n\\n    References\\n    ==========\\n    Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    M = s1[:, :]\n    for i in range(M.rows - deg_f - 1, M.rows - deg_f - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(M.rows - 1, M.rows - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(cdel):\n        M.col_del(M.rows - 1)\n    Md = M[:, 0:M.rows]\n    return Md.det()",
            "def correct_sign(deg_f, deg_g, s1, rdel, cdel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Used in various subresultant prs algorithms.\\n\\n    Evaluates the determinant, (a.k.a. subresultant) of a properly selected\\n    submatrix of s1, Sylvester's matrix of 1840, to get the correct sign\\n    and value of the leading coefficient of a given polynomial remainder.\\n\\n    deg_f, deg_g are the degrees of the original polynomials p, q for which the\\n    matrix s1 = sylvester(p, q, x, 1) was constructed.\\n\\n    rdel denotes the expected degree of the remainder; it is the number of\\n    rows to be deleted from each group of rows in s1 as described in the\\n    reference below.\\n\\n    cdel denotes the expected degree minus the actual degree of the remainder;\\n    it is the number of columns to be deleted --- starting with the last column\\n    forming the square matrix --- from the matrix resulting after the row deletions.\\n\\n    References\\n    ==========\\n    Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    M = s1[:, :]\n    for i in range(M.rows - deg_f - 1, M.rows - deg_f - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(M.rows - 1, M.rows - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(cdel):\n        M.col_del(M.rows - 1)\n    Md = M[:, 0:M.rows]\n    return Md.det()",
            "def correct_sign(deg_f, deg_g, s1, rdel, cdel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Used in various subresultant prs algorithms.\\n\\n    Evaluates the determinant, (a.k.a. subresultant) of a properly selected\\n    submatrix of s1, Sylvester's matrix of 1840, to get the correct sign\\n    and value of the leading coefficient of a given polynomial remainder.\\n\\n    deg_f, deg_g are the degrees of the original polynomials p, q for which the\\n    matrix s1 = sylvester(p, q, x, 1) was constructed.\\n\\n    rdel denotes the expected degree of the remainder; it is the number of\\n    rows to be deleted from each group of rows in s1 as described in the\\n    reference below.\\n\\n    cdel denotes the expected degree minus the actual degree of the remainder;\\n    it is the number of columns to be deleted --- starting with the last column\\n    forming the square matrix --- from the matrix resulting after the row deletions.\\n\\n    References\\n    ==========\\n    Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    M = s1[:, :]\n    for i in range(M.rows - deg_f - 1, M.rows - deg_f - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(M.rows - 1, M.rows - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(cdel):\n        M.col_del(M.rows - 1)\n    Md = M[:, 0:M.rows]\n    return Md.det()",
            "def correct_sign(deg_f, deg_g, s1, rdel, cdel):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Used in various subresultant prs algorithms.\\n\\n    Evaluates the determinant, (a.k.a. subresultant) of a properly selected\\n    submatrix of s1, Sylvester's matrix of 1840, to get the correct sign\\n    and value of the leading coefficient of a given polynomial remainder.\\n\\n    deg_f, deg_g are the degrees of the original polynomials p, q for which the\\n    matrix s1 = sylvester(p, q, x, 1) was constructed.\\n\\n    rdel denotes the expected degree of the remainder; it is the number of\\n    rows to be deleted from each group of rows in s1 as described in the\\n    reference below.\\n\\n    cdel denotes the expected degree minus the actual degree of the remainder;\\n    it is the number of columns to be deleted --- starting with the last column\\n    forming the square matrix --- from the matrix resulting after the row deletions.\\n\\n    References\\n    ==========\\n    Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``Sturm Sequences\\n    and Modified Subresultant Polynomial Remainder Sequences.''\\n    Serdica Journal of Computing, Vol. 8, No 1, 29-46, 2014.\\n\\n    \"\n    M = s1[:, :]\n    for i in range(M.rows - deg_f - 1, M.rows - deg_f - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(M.rows - 1, M.rows - rdel - 1, -1):\n        M.row_del(i)\n    for i in range(cdel):\n        M.col_del(M.rows - 1)\n    Md = M[:, 0:M.rows]\n    return Md.det()"
        ]
    },
    {
        "func_name": "subresultants_rem",
        "original": "def subresultants_rem(p, q, x):\n    \"\"\"\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\n    the coefficients of the polynomials in the sequence are\n    subresultants. That is, they are  determinants of appropriately\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\n\n    To compute the coefficients polynomial divisions in Q[x] are\n    performed, using the function rem(p, q, x). The coefficients\n    of the remainders computed this way become subresultants by evaluating\n    one subresultant per remainder --- that of the leading coefficient.\n    This way we obtain the correct sign and value of the leading coefficient\n    of the remainder and we easily ``force'' the rest of the coefficients\n    to become subresultants.\n\n    If the subresultant prs is complete, then it coincides with the\n    Euclidean sequence of the polynomials p, q.\n\n    References\n    ==========\n    1. Akritas, A. G.:``Three New Methods for Computing Subresultant\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\n\n    \"\"\"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    while deg_g > 0:\n        r = rem(p, q, x)\n        d = degree(r, x)\n        if d < 0:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        r = simplify(r / LC(r, x) * sign_value)\n        sr_list.append(r)\n        (deg_f, deg_g) = (deg_g, d)\n        (p, q) = (q, r)\n    m = len(sr_list)\n    if sr_list[m - 1] == nan or sr_list[m - 1] == 0:\n        sr_list.pop(m - 1)\n    return sr_list",
        "mutated": [
            "def subresultants_rem(p, q, x):\n    if False:\n        i = 10\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients polynomial divisions in Q[x] are\\n    performed, using the function rem(p, q, x). The coefficients\\n    of the remainders computed this way become subresultants by evaluating\\n    one subresultant per remainder --- that of the leading coefficient.\\n    This way we obtain the correct sign and value of the leading coefficient\\n    of the remainder and we easily ``force'' the rest of the coefficients\\n    to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    while deg_g > 0:\n        r = rem(p, q, x)\n        d = degree(r, x)\n        if d < 0:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        r = simplify(r / LC(r, x) * sign_value)\n        sr_list.append(r)\n        (deg_f, deg_g) = (deg_g, d)\n        (p, q) = (q, r)\n    m = len(sr_list)\n    if sr_list[m - 1] == nan or sr_list[m - 1] == 0:\n        sr_list.pop(m - 1)\n    return sr_list",
            "def subresultants_rem(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients polynomial divisions in Q[x] are\\n    performed, using the function rem(p, q, x). The coefficients\\n    of the remainders computed this way become subresultants by evaluating\\n    one subresultant per remainder --- that of the leading coefficient.\\n    This way we obtain the correct sign and value of the leading coefficient\\n    of the remainder and we easily ``force'' the rest of the coefficients\\n    to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    while deg_g > 0:\n        r = rem(p, q, x)\n        d = degree(r, x)\n        if d < 0:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        r = simplify(r / LC(r, x) * sign_value)\n        sr_list.append(r)\n        (deg_f, deg_g) = (deg_g, d)\n        (p, q) = (q, r)\n    m = len(sr_list)\n    if sr_list[m - 1] == nan or sr_list[m - 1] == 0:\n        sr_list.pop(m - 1)\n    return sr_list",
            "def subresultants_rem(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients polynomial divisions in Q[x] are\\n    performed, using the function rem(p, q, x). The coefficients\\n    of the remainders computed this way become subresultants by evaluating\\n    one subresultant per remainder --- that of the leading coefficient.\\n    This way we obtain the correct sign and value of the leading coefficient\\n    of the remainder and we easily ``force'' the rest of the coefficients\\n    to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    while deg_g > 0:\n        r = rem(p, q, x)\n        d = degree(r, x)\n        if d < 0:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        r = simplify(r / LC(r, x) * sign_value)\n        sr_list.append(r)\n        (deg_f, deg_g) = (deg_g, d)\n        (p, q) = (q, r)\n    m = len(sr_list)\n    if sr_list[m - 1] == nan or sr_list[m - 1] == 0:\n        sr_list.pop(m - 1)\n    return sr_list",
            "def subresultants_rem(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients polynomial divisions in Q[x] are\\n    performed, using the function rem(p, q, x). The coefficients\\n    of the remainders computed this way become subresultants by evaluating\\n    one subresultant per remainder --- that of the leading coefficient.\\n    This way we obtain the correct sign and value of the leading coefficient\\n    of the remainder and we easily ``force'' the rest of the coefficients\\n    to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    while deg_g > 0:\n        r = rem(p, q, x)\n        d = degree(r, x)\n        if d < 0:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        r = simplify(r / LC(r, x) * sign_value)\n        sr_list.append(r)\n        (deg_f, deg_g) = (deg_g, d)\n        (p, q) = (q, r)\n    m = len(sr_list)\n    if sr_list[m - 1] == nan or sr_list[m - 1] == 0:\n        sr_list.pop(m - 1)\n    return sr_list",
            "def subresultants_rem(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    p, q are polynomials in Z[x] or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p and q in Z[x] or Q[x];\\n    the coefficients of the polynomials in the sequence are\\n    subresultants. That is, they are  determinants of appropriately\\n    selected submatrices of sylvester1, Sylvester's matrix of 1840.\\n\\n    To compute the coefficients polynomial divisions in Q[x] are\\n    performed, using the function rem(p, q, x). The coefficients\\n    of the remainders computed this way become subresultants by evaluating\\n    one subresultant per remainder --- that of the leading coefficient.\\n    This way we obtain the correct sign and value of the leading coefficient\\n    of the remainder and we easily ``force'' the rest of the coefficients\\n    to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    while deg_g > 0:\n        r = rem(p, q, x)\n        d = degree(r, x)\n        if d < 0:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        r = simplify(r / LC(r, x) * sign_value)\n        sr_list.append(r)\n        (deg_f, deg_g) = (deg_g, d)\n        (p, q) = (q, r)\n    m = len(sr_list)\n    if sr_list[m - 1] == nan or sr_list[m - 1] == 0:\n        sr_list.pop(m - 1)\n    return sr_list"
        ]
    },
    {
        "func_name": "pivot",
        "original": "def pivot(M, i, j):\n    \"\"\"\n    M is a matrix, and M[i, j] specifies the pivot element.\n\n    All elements below M[i, j], in the j-th column, will\n    be zeroed, if they are not already 0, according to\n    Dodgson-Bareiss' integer preserving transformations.\n\n    References\n    ==========\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\n    common divisors and polynomial remainder sequences.''\n    Numerische MatheMatik 52, 119-127, 1988.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\n    by Van Vleck Regarding Sturm Sequences.''\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\n\n    \"\"\"\n    ma = M[:, :]\n    rs = ma.rows\n    cs = ma.cols\n    for r in range(i + 1, rs):\n        if ma[r, j] != 0:\n            for c in range(j + 1, cs):\n                ma[r, c] = ma[i, j] * ma[r, c] - ma[i, c] * ma[r, j]\n            ma[r, j] = 0\n    return ma",
        "mutated": [
            "def pivot(M, i, j):\n    if False:\n        i = 10\n    \"\\n    M is a matrix, and M[i, j] specifies the pivot element.\\n\\n    All elements below M[i, j], in the j-th column, will\\n    be zeroed, if they are not already 0, according to\\n    Dodgson-Bareiss' integer preserving transformations.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    \"\n    ma = M[:, :]\n    rs = ma.rows\n    cs = ma.cols\n    for r in range(i + 1, rs):\n        if ma[r, j] != 0:\n            for c in range(j + 1, cs):\n                ma[r, c] = ma[i, j] * ma[r, c] - ma[i, c] * ma[r, j]\n            ma[r, j] = 0\n    return ma",
            "def pivot(M, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    M is a matrix, and M[i, j] specifies the pivot element.\\n\\n    All elements below M[i, j], in the j-th column, will\\n    be zeroed, if they are not already 0, according to\\n    Dodgson-Bareiss' integer preserving transformations.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    \"\n    ma = M[:, :]\n    rs = ma.rows\n    cs = ma.cols\n    for r in range(i + 1, rs):\n        if ma[r, j] != 0:\n            for c in range(j + 1, cs):\n                ma[r, c] = ma[i, j] * ma[r, c] - ma[i, c] * ma[r, j]\n            ma[r, j] = 0\n    return ma",
            "def pivot(M, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    M is a matrix, and M[i, j] specifies the pivot element.\\n\\n    All elements below M[i, j], in the j-th column, will\\n    be zeroed, if they are not already 0, according to\\n    Dodgson-Bareiss' integer preserving transformations.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    \"\n    ma = M[:, :]\n    rs = ma.rows\n    cs = ma.cols\n    for r in range(i + 1, rs):\n        if ma[r, j] != 0:\n            for c in range(j + 1, cs):\n                ma[r, c] = ma[i, j] * ma[r, c] - ma[i, c] * ma[r, j]\n            ma[r, j] = 0\n    return ma",
            "def pivot(M, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    M is a matrix, and M[i, j] specifies the pivot element.\\n\\n    All elements below M[i, j], in the j-th column, will\\n    be zeroed, if they are not already 0, according to\\n    Dodgson-Bareiss' integer preserving transformations.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    \"\n    ma = M[:, :]\n    rs = ma.rows\n    cs = ma.cols\n    for r in range(i + 1, rs):\n        if ma[r, j] != 0:\n            for c in range(j + 1, cs):\n                ma[r, c] = ma[i, j] * ma[r, c] - ma[i, c] * ma[r, j]\n            ma[r, j] = 0\n    return ma",
            "def pivot(M, i, j):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    M is a matrix, and M[i, j] specifies the pivot element.\\n\\n    All elements below M[i, j], in the j-th column, will\\n    be zeroed, if they are not already 0, according to\\n    Dodgson-Bareiss' integer preserving transformations.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    \"\n    ma = M[:, :]\n    rs = ma.rows\n    cs = ma.cols\n    for r in range(i + 1, rs):\n        if ma[r, j] != 0:\n            for c in range(j + 1, cs):\n                ma[r, c] = ma[i, j] * ma[r, c] - ma[i, c] * ma[r, j]\n            ma[r, j] = 0\n    return ma"
        ]
    },
    {
        "func_name": "rotate_r",
        "original": "def rotate_r(L, k):\n    \"\"\"\n    Rotates right by k. L is a row of a matrix or a list.\n\n    \"\"\"\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(len(ll) - 1)\n        ll.insert(0, el)\n    return ll if isinstance(L, list) else Matrix([ll])",
        "mutated": [
            "def rotate_r(L, k):\n    if False:\n        i = 10\n    '\\n    Rotates right by k. L is a row of a matrix or a list.\\n\\n    '\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(len(ll) - 1)\n        ll.insert(0, el)\n    return ll if isinstance(L, list) else Matrix([ll])",
            "def rotate_r(L, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Rotates right by k. L is a row of a matrix or a list.\\n\\n    '\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(len(ll) - 1)\n        ll.insert(0, el)\n    return ll if isinstance(L, list) else Matrix([ll])",
            "def rotate_r(L, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Rotates right by k. L is a row of a matrix or a list.\\n\\n    '\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(len(ll) - 1)\n        ll.insert(0, el)\n    return ll if isinstance(L, list) else Matrix([ll])",
            "def rotate_r(L, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Rotates right by k. L is a row of a matrix or a list.\\n\\n    '\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(len(ll) - 1)\n        ll.insert(0, el)\n    return ll if isinstance(L, list) else Matrix([ll])",
            "def rotate_r(L, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Rotates right by k. L is a row of a matrix or a list.\\n\\n    '\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(len(ll) - 1)\n        ll.insert(0, el)\n    return ll if isinstance(L, list) else Matrix([ll])"
        ]
    },
    {
        "func_name": "rotate_l",
        "original": "def rotate_l(L, k):\n    \"\"\"\n    Rotates left by k. L is a row of a matrix or a list.\n\n    \"\"\"\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(0)\n        ll.insert(len(ll) - 1, el)\n    return ll if isinstance(L, list) else Matrix([ll])",
        "mutated": [
            "def rotate_l(L, k):\n    if False:\n        i = 10\n    '\\n    Rotates left by k. L is a row of a matrix or a list.\\n\\n    '\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(0)\n        ll.insert(len(ll) - 1, el)\n    return ll if isinstance(L, list) else Matrix([ll])",
            "def rotate_l(L, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Rotates left by k. L is a row of a matrix or a list.\\n\\n    '\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(0)\n        ll.insert(len(ll) - 1, el)\n    return ll if isinstance(L, list) else Matrix([ll])",
            "def rotate_l(L, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Rotates left by k. L is a row of a matrix or a list.\\n\\n    '\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(0)\n        ll.insert(len(ll) - 1, el)\n    return ll if isinstance(L, list) else Matrix([ll])",
            "def rotate_l(L, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Rotates left by k. L is a row of a matrix or a list.\\n\\n    '\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(0)\n        ll.insert(len(ll) - 1, el)\n    return ll if isinstance(L, list) else Matrix([ll])",
            "def rotate_l(L, k):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Rotates left by k. L is a row of a matrix or a list.\\n\\n    '\n    ll = list(L)\n    if ll == []:\n        return []\n    for i in range(k):\n        el = ll.pop(0)\n        ll.insert(len(ll) - 1, el)\n    return ll if isinstance(L, list) else Matrix([ll])"
        ]
    },
    {
        "func_name": "row2poly",
        "original": "def row2poly(row, deg, x):\n    \"\"\"\n    Converts the row of a matrix to a poly of degree deg and variable x.\n    Some entries at the beginning and/or at the end of the row may be zero.\n\n    \"\"\"\n    k = 0\n    poly = []\n    leng = len(row)\n    while row[k] == 0:\n        k = k + 1\n    for j in range(deg + 1):\n        if k + j <= leng:\n            poly.append(row[k + j])\n    return Poly(poly, x)",
        "mutated": [
            "def row2poly(row, deg, x):\n    if False:\n        i = 10\n    '\\n    Converts the row of a matrix to a poly of degree deg and variable x.\\n    Some entries at the beginning and/or at the end of the row may be zero.\\n\\n    '\n    k = 0\n    poly = []\n    leng = len(row)\n    while row[k] == 0:\n        k = k + 1\n    for j in range(deg + 1):\n        if k + j <= leng:\n            poly.append(row[k + j])\n    return Poly(poly, x)",
            "def row2poly(row, deg, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Converts the row of a matrix to a poly of degree deg and variable x.\\n    Some entries at the beginning and/or at the end of the row may be zero.\\n\\n    '\n    k = 0\n    poly = []\n    leng = len(row)\n    while row[k] == 0:\n        k = k + 1\n    for j in range(deg + 1):\n        if k + j <= leng:\n            poly.append(row[k + j])\n    return Poly(poly, x)",
            "def row2poly(row, deg, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Converts the row of a matrix to a poly of degree deg and variable x.\\n    Some entries at the beginning and/or at the end of the row may be zero.\\n\\n    '\n    k = 0\n    poly = []\n    leng = len(row)\n    while row[k] == 0:\n        k = k + 1\n    for j in range(deg + 1):\n        if k + j <= leng:\n            poly.append(row[k + j])\n    return Poly(poly, x)",
            "def row2poly(row, deg, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Converts the row of a matrix to a poly of degree deg and variable x.\\n    Some entries at the beginning and/or at the end of the row may be zero.\\n\\n    '\n    k = 0\n    poly = []\n    leng = len(row)\n    while row[k] == 0:\n        k = k + 1\n    for j in range(deg + 1):\n        if k + j <= leng:\n            poly.append(row[k + j])\n    return Poly(poly, x)",
            "def row2poly(row, deg, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Converts the row of a matrix to a poly of degree deg and variable x.\\n    Some entries at the beginning and/or at the end of the row may be zero.\\n\\n    '\n    k = 0\n    poly = []\n    leng = len(row)\n    while row[k] == 0:\n        k = k + 1\n    for j in range(deg + 1):\n        if k + j <= leng:\n            poly.append(row[k + j])\n    return Poly(poly, x)"
        ]
    },
    {
        "func_name": "create_ma",
        "original": "def create_ma(deg_f, deg_g, row1, row2, col_num):\n    \"\"\"\n    Creates a ``small'' matrix M to be triangularized.\n\n    deg_f, deg_g are the degrees of the divident and of the\n    divisor polynomials respectively, deg_g > deg_f.\n\n    The coefficients of the divident poly are the elements\n    in row2 and those of the divisor poly are the elements\n    in row1.\n\n    col_num defines the number of columns of the matrix M.\n\n    \"\"\"\n    if deg_g - deg_f >= 1:\n        print('Reverse degrees')\n        return\n    m = zeros(deg_f - deg_g + 2, col_num)\n    for i in range(deg_f - deg_g + 1):\n        m[i, :] = rotate_r(row1, i)\n    m[deg_f - deg_g + 1, :] = row2\n    return m",
        "mutated": [
            "def create_ma(deg_f, deg_g, row1, row2, col_num):\n    if False:\n        i = 10\n    \"\\n    Creates a ``small'' matrix M to be triangularized.\\n\\n    deg_f, deg_g are the degrees of the divident and of the\\n    divisor polynomials respectively, deg_g > deg_f.\\n\\n    The coefficients of the divident poly are the elements\\n    in row2 and those of the divisor poly are the elements\\n    in row1.\\n\\n    col_num defines the number of columns of the matrix M.\\n\\n    \"\n    if deg_g - deg_f >= 1:\n        print('Reverse degrees')\n        return\n    m = zeros(deg_f - deg_g + 2, col_num)\n    for i in range(deg_f - deg_g + 1):\n        m[i, :] = rotate_r(row1, i)\n    m[deg_f - deg_g + 1, :] = row2\n    return m",
            "def create_ma(deg_f, deg_g, row1, row2, col_num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Creates a ``small'' matrix M to be triangularized.\\n\\n    deg_f, deg_g are the degrees of the divident and of the\\n    divisor polynomials respectively, deg_g > deg_f.\\n\\n    The coefficients of the divident poly are the elements\\n    in row2 and those of the divisor poly are the elements\\n    in row1.\\n\\n    col_num defines the number of columns of the matrix M.\\n\\n    \"\n    if deg_g - deg_f >= 1:\n        print('Reverse degrees')\n        return\n    m = zeros(deg_f - deg_g + 2, col_num)\n    for i in range(deg_f - deg_g + 1):\n        m[i, :] = rotate_r(row1, i)\n    m[deg_f - deg_g + 1, :] = row2\n    return m",
            "def create_ma(deg_f, deg_g, row1, row2, col_num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Creates a ``small'' matrix M to be triangularized.\\n\\n    deg_f, deg_g are the degrees of the divident and of the\\n    divisor polynomials respectively, deg_g > deg_f.\\n\\n    The coefficients of the divident poly are the elements\\n    in row2 and those of the divisor poly are the elements\\n    in row1.\\n\\n    col_num defines the number of columns of the matrix M.\\n\\n    \"\n    if deg_g - deg_f >= 1:\n        print('Reverse degrees')\n        return\n    m = zeros(deg_f - deg_g + 2, col_num)\n    for i in range(deg_f - deg_g + 1):\n        m[i, :] = rotate_r(row1, i)\n    m[deg_f - deg_g + 1, :] = row2\n    return m",
            "def create_ma(deg_f, deg_g, row1, row2, col_num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Creates a ``small'' matrix M to be triangularized.\\n\\n    deg_f, deg_g are the degrees of the divident and of the\\n    divisor polynomials respectively, deg_g > deg_f.\\n\\n    The coefficients of the divident poly are the elements\\n    in row2 and those of the divisor poly are the elements\\n    in row1.\\n\\n    col_num defines the number of columns of the matrix M.\\n\\n    \"\n    if deg_g - deg_f >= 1:\n        print('Reverse degrees')\n        return\n    m = zeros(deg_f - deg_g + 2, col_num)\n    for i in range(deg_f - deg_g + 1):\n        m[i, :] = rotate_r(row1, i)\n    m[deg_f - deg_g + 1, :] = row2\n    return m",
            "def create_ma(deg_f, deg_g, row1, row2, col_num):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Creates a ``small'' matrix M to be triangularized.\\n\\n    deg_f, deg_g are the degrees of the divident and of the\\n    divisor polynomials respectively, deg_g > deg_f.\\n\\n    The coefficients of the divident poly are the elements\\n    in row2 and those of the divisor poly are the elements\\n    in row1.\\n\\n    col_num defines the number of columns of the matrix M.\\n\\n    \"\n    if deg_g - deg_f >= 1:\n        print('Reverse degrees')\n        return\n    m = zeros(deg_f - deg_g + 2, col_num)\n    for i in range(deg_f - deg_g + 1):\n        m[i, :] = rotate_r(row1, i)\n    m[deg_f - deg_g + 1, :] = row2\n    return m"
        ]
    },
    {
        "func_name": "find_degree",
        "original": "def find_degree(M, deg_f):\n    \"\"\"\n    Finds the degree of the poly corresponding (after triangularization)\n    to the _last_ row of the ``small'' matrix M, created by create_ma().\n\n    deg_f is the degree of the divident poly.\n    If _last_ row is all 0's returns None.\n\n    \"\"\"\n    j = deg_f\n    for i in range(0, M.cols):\n        if M[M.rows - 1, i] == 0:\n            j = j - 1\n        else:\n            return j if j >= 0 else 0",
        "mutated": [
            "def find_degree(M, deg_f):\n    if False:\n        i = 10\n    \"\\n    Finds the degree of the poly corresponding (after triangularization)\\n    to the _last_ row of the ``small'' matrix M, created by create_ma().\\n\\n    deg_f is the degree of the divident poly.\\n    If _last_ row is all 0's returns None.\\n\\n    \"\n    j = deg_f\n    for i in range(0, M.cols):\n        if M[M.rows - 1, i] == 0:\n            j = j - 1\n        else:\n            return j if j >= 0 else 0",
            "def find_degree(M, deg_f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Finds the degree of the poly corresponding (after triangularization)\\n    to the _last_ row of the ``small'' matrix M, created by create_ma().\\n\\n    deg_f is the degree of the divident poly.\\n    If _last_ row is all 0's returns None.\\n\\n    \"\n    j = deg_f\n    for i in range(0, M.cols):\n        if M[M.rows - 1, i] == 0:\n            j = j - 1\n        else:\n            return j if j >= 0 else 0",
            "def find_degree(M, deg_f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Finds the degree of the poly corresponding (after triangularization)\\n    to the _last_ row of the ``small'' matrix M, created by create_ma().\\n\\n    deg_f is the degree of the divident poly.\\n    If _last_ row is all 0's returns None.\\n\\n    \"\n    j = deg_f\n    for i in range(0, M.cols):\n        if M[M.rows - 1, i] == 0:\n            j = j - 1\n        else:\n            return j if j >= 0 else 0",
            "def find_degree(M, deg_f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Finds the degree of the poly corresponding (after triangularization)\\n    to the _last_ row of the ``small'' matrix M, created by create_ma().\\n\\n    deg_f is the degree of the divident poly.\\n    If _last_ row is all 0's returns None.\\n\\n    \"\n    j = deg_f\n    for i in range(0, M.cols):\n        if M[M.rows - 1, i] == 0:\n            j = j - 1\n        else:\n            return j if j >= 0 else 0",
            "def find_degree(M, deg_f):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Finds the degree of the poly corresponding (after triangularization)\\n    to the _last_ row of the ``small'' matrix M, created by create_ma().\\n\\n    deg_f is the degree of the divident poly.\\n    If _last_ row is all 0's returns None.\\n\\n    \"\n    j = deg_f\n    for i in range(0, M.cols):\n        if M[M.rows - 1, i] == 0:\n            j = j - 1\n        else:\n            return j if j >= 0 else 0"
        ]
    },
    {
        "func_name": "final_touches",
        "original": "def final_touches(s2, r, deg_g):\n    \"\"\"\n    s2 is sylvester2, r is the row pointer in s2,\n    deg_g is the degree of the poly last inserted in s2.\n\n    After a gcd of degree > 0 has been found with Van Vleck's\n    method, and was inserted into s2, if its last term is not\n    in the last column of s2, then it is inserted as many\n    times as needed, rotated right by one each time, until\n    the condition is met.\n\n    \"\"\"\n    R = s2.row(r - 1)\n    for i in range(s2.cols):\n        if R[0, i] == 0:\n            continue\n        else:\n            break\n    mr = s2.cols - (i + deg_g + 1)\n    i = 0\n    while mr != 0 and r + i < s2.rows:\n        s2[r + i, :] = rotate_r(R, i + 1)\n        i += 1\n        mr -= 1\n    return s2",
        "mutated": [
            "def final_touches(s2, r, deg_g):\n    if False:\n        i = 10\n    \"\\n    s2 is sylvester2, r is the row pointer in s2,\\n    deg_g is the degree of the poly last inserted in s2.\\n\\n    After a gcd of degree > 0 has been found with Van Vleck's\\n    method, and was inserted into s2, if its last term is not\\n    in the last column of s2, then it is inserted as many\\n    times as needed, rotated right by one each time, until\\n    the condition is met.\\n\\n    \"\n    R = s2.row(r - 1)\n    for i in range(s2.cols):\n        if R[0, i] == 0:\n            continue\n        else:\n            break\n    mr = s2.cols - (i + deg_g + 1)\n    i = 0\n    while mr != 0 and r + i < s2.rows:\n        s2[r + i, :] = rotate_r(R, i + 1)\n        i += 1\n        mr -= 1\n    return s2",
            "def final_touches(s2, r, deg_g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    s2 is sylvester2, r is the row pointer in s2,\\n    deg_g is the degree of the poly last inserted in s2.\\n\\n    After a gcd of degree > 0 has been found with Van Vleck's\\n    method, and was inserted into s2, if its last term is not\\n    in the last column of s2, then it is inserted as many\\n    times as needed, rotated right by one each time, until\\n    the condition is met.\\n\\n    \"\n    R = s2.row(r - 1)\n    for i in range(s2.cols):\n        if R[0, i] == 0:\n            continue\n        else:\n            break\n    mr = s2.cols - (i + deg_g + 1)\n    i = 0\n    while mr != 0 and r + i < s2.rows:\n        s2[r + i, :] = rotate_r(R, i + 1)\n        i += 1\n        mr -= 1\n    return s2",
            "def final_touches(s2, r, deg_g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    s2 is sylvester2, r is the row pointer in s2,\\n    deg_g is the degree of the poly last inserted in s2.\\n\\n    After a gcd of degree > 0 has been found with Van Vleck's\\n    method, and was inserted into s2, if its last term is not\\n    in the last column of s2, then it is inserted as many\\n    times as needed, rotated right by one each time, until\\n    the condition is met.\\n\\n    \"\n    R = s2.row(r - 1)\n    for i in range(s2.cols):\n        if R[0, i] == 0:\n            continue\n        else:\n            break\n    mr = s2.cols - (i + deg_g + 1)\n    i = 0\n    while mr != 0 and r + i < s2.rows:\n        s2[r + i, :] = rotate_r(R, i + 1)\n        i += 1\n        mr -= 1\n    return s2",
            "def final_touches(s2, r, deg_g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    s2 is sylvester2, r is the row pointer in s2,\\n    deg_g is the degree of the poly last inserted in s2.\\n\\n    After a gcd of degree > 0 has been found with Van Vleck's\\n    method, and was inserted into s2, if its last term is not\\n    in the last column of s2, then it is inserted as many\\n    times as needed, rotated right by one each time, until\\n    the condition is met.\\n\\n    \"\n    R = s2.row(r - 1)\n    for i in range(s2.cols):\n        if R[0, i] == 0:\n            continue\n        else:\n            break\n    mr = s2.cols - (i + deg_g + 1)\n    i = 0\n    while mr != 0 and r + i < s2.rows:\n        s2[r + i, :] = rotate_r(R, i + 1)\n        i += 1\n        mr -= 1\n    return s2",
            "def final_touches(s2, r, deg_g):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    s2 is sylvester2, r is the row pointer in s2,\\n    deg_g is the degree of the poly last inserted in s2.\\n\\n    After a gcd of degree > 0 has been found with Van Vleck's\\n    method, and was inserted into s2, if its last term is not\\n    in the last column of s2, then it is inserted as many\\n    times as needed, rotated right by one each time, until\\n    the condition is met.\\n\\n    \"\n    R = s2.row(r - 1)\n    for i in range(s2.cols):\n        if R[0, i] == 0:\n            continue\n        else:\n            break\n    mr = s2.cols - (i + deg_g + 1)\n    i = 0\n    while mr != 0 and r + i < s2.rows:\n        s2[r + i, :] = rotate_r(R, i + 1)\n        i += 1\n        mr -= 1\n    return s2"
        ]
    },
    {
        "func_name": "subresultants_vv",
        "original": "def subresultants_vv(p, q, x, method=0):\n    \"\"\"\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the subresultant prs of p, q by triangularizing,\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\n    see references 1 and 2 for Van Vleck's method. With each remainder,\n    sylvester2 gets updated and is prepared to be printed if requested.\n\n    If sylvester2 has small dimensions and you want to see the final,\n    triangularized matrix use this version with method=1; otherwise,\n    use either this version with method=0 (default) or the faster version,\n    subresultants_vv_2(p, q, x), where sylvester2 is used implicitly.\n\n    Sylvester's matrix sylvester1  is also used to compute one\n    subresultant per remainder; namely, that of the leading\n    coefficient, in order to obtain the correct sign and to\n    force the remainder coefficients to become subresultants.\n\n    If the subresultant prs is complete, then it coincides with the\n    Euclidean sequence of the polynomials p, q.\n\n    If the final, triangularized matrix s2 is printed, then:\n        (a) if deg(p) - deg(q) > 1 or deg( gcd(p, q) ) > 0, several\n            of the last rows in s2 will remain unprocessed;\n        (b) if deg(p) - deg(q) == 0, p will not appear in the final matrix.\n\n    References\n    ==========\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\n    common divisors and polynomial remainder sequences.''\n    Numerische MatheMatik 52, 119-127, 1988.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\n    by Van Vleck Regarding Sturm Sequences.''\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\n\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\n\n    \"\"\"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    s2 = sylvester(f, g, x, 2)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    r = 2\n    if deg_f - deg_g > 1:\n        r = 1\n        for i in range(deg_f - deg_g - 1):\n            s2[r + i, :] = rotate_r(row0, i + 1)\n        r = r + deg_f - deg_g - 1\n        for i in range(deg_f - deg_g):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_f - deg_g\n    if deg_f - deg_g == 0:\n        r = 0\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            break\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        temp2 = LC(poly, x)\n        poly = simplify(poly / temp2 * sign_value)\n        row0 = M[0, :]\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row0, r + i)\n        r = r + deg_g - d\n        row1 = rotate_l(M[M.rows - 1, :], deg_f - d)\n        row1 = row1 / temp2 * sign_value\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_g - d\n        (deg_f, deg_g) = (deg_g, d)\n        sr_list.append(poly)\n    if method != 0 and s2.rows > 2:\n        s2 = final_touches(s2, r, deg_g)\n        pprint(s2)\n    elif method != 0 and s2.rows == 2:\n        s2[1, :] = rotate_r(s2.row(1), 1)\n        pprint(s2)\n    return sr_list",
        "mutated": [
            "def subresultants_vv(p, q, x, method=0):\n    if False:\n        i = 10\n    \"\\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p, q by triangularizing,\\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\\n    see references 1 and 2 for Van Vleck's method. With each remainder,\\n    sylvester2 gets updated and is prepared to be printed if requested.\\n\\n    If sylvester2 has small dimensions and you want to see the final,\\n    triangularized matrix use this version with method=1; otherwise,\\n    use either this version with method=0 (default) or the faster version,\\n    subresultants_vv_2(p, q, x), where sylvester2 is used implicitly.\\n\\n    Sylvester's matrix sylvester1  is also used to compute one\\n    subresultant per remainder; namely, that of the leading\\n    coefficient, in order to obtain the correct sign and to\\n    force the remainder coefficients to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    If the final, triangularized matrix s2 is printed, then:\\n        (a) if deg(p) - deg(q) > 1 or deg( gcd(p, q) ) > 0, several\\n            of the last rows in s2 will remain unprocessed;\\n        (b) if deg(p) - deg(q) == 0, p will not appear in the final matrix.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    s2 = sylvester(f, g, x, 2)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    r = 2\n    if deg_f - deg_g > 1:\n        r = 1\n        for i in range(deg_f - deg_g - 1):\n            s2[r + i, :] = rotate_r(row0, i + 1)\n        r = r + deg_f - deg_g - 1\n        for i in range(deg_f - deg_g):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_f - deg_g\n    if deg_f - deg_g == 0:\n        r = 0\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            break\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        temp2 = LC(poly, x)\n        poly = simplify(poly / temp2 * sign_value)\n        row0 = M[0, :]\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row0, r + i)\n        r = r + deg_g - d\n        row1 = rotate_l(M[M.rows - 1, :], deg_f - d)\n        row1 = row1 / temp2 * sign_value\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_g - d\n        (deg_f, deg_g) = (deg_g, d)\n        sr_list.append(poly)\n    if method != 0 and s2.rows > 2:\n        s2 = final_touches(s2, r, deg_g)\n        pprint(s2)\n    elif method != 0 and s2.rows == 2:\n        s2[1, :] = rotate_r(s2.row(1), 1)\n        pprint(s2)\n    return sr_list",
            "def subresultants_vv(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p, q by triangularizing,\\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\\n    see references 1 and 2 for Van Vleck's method. With each remainder,\\n    sylvester2 gets updated and is prepared to be printed if requested.\\n\\n    If sylvester2 has small dimensions and you want to see the final,\\n    triangularized matrix use this version with method=1; otherwise,\\n    use either this version with method=0 (default) or the faster version,\\n    subresultants_vv_2(p, q, x), where sylvester2 is used implicitly.\\n\\n    Sylvester's matrix sylvester1  is also used to compute one\\n    subresultant per remainder; namely, that of the leading\\n    coefficient, in order to obtain the correct sign and to\\n    force the remainder coefficients to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    If the final, triangularized matrix s2 is printed, then:\\n        (a) if deg(p) - deg(q) > 1 or deg( gcd(p, q) ) > 0, several\\n            of the last rows in s2 will remain unprocessed;\\n        (b) if deg(p) - deg(q) == 0, p will not appear in the final matrix.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    s2 = sylvester(f, g, x, 2)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    r = 2\n    if deg_f - deg_g > 1:\n        r = 1\n        for i in range(deg_f - deg_g - 1):\n            s2[r + i, :] = rotate_r(row0, i + 1)\n        r = r + deg_f - deg_g - 1\n        for i in range(deg_f - deg_g):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_f - deg_g\n    if deg_f - deg_g == 0:\n        r = 0\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            break\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        temp2 = LC(poly, x)\n        poly = simplify(poly / temp2 * sign_value)\n        row0 = M[0, :]\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row0, r + i)\n        r = r + deg_g - d\n        row1 = rotate_l(M[M.rows - 1, :], deg_f - d)\n        row1 = row1 / temp2 * sign_value\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_g - d\n        (deg_f, deg_g) = (deg_g, d)\n        sr_list.append(poly)\n    if method != 0 and s2.rows > 2:\n        s2 = final_touches(s2, r, deg_g)\n        pprint(s2)\n    elif method != 0 and s2.rows == 2:\n        s2[1, :] = rotate_r(s2.row(1), 1)\n        pprint(s2)\n    return sr_list",
            "def subresultants_vv(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p, q by triangularizing,\\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\\n    see references 1 and 2 for Van Vleck's method. With each remainder,\\n    sylvester2 gets updated and is prepared to be printed if requested.\\n\\n    If sylvester2 has small dimensions and you want to see the final,\\n    triangularized matrix use this version with method=1; otherwise,\\n    use either this version with method=0 (default) or the faster version,\\n    subresultants_vv_2(p, q, x), where sylvester2 is used implicitly.\\n\\n    Sylvester's matrix sylvester1  is also used to compute one\\n    subresultant per remainder; namely, that of the leading\\n    coefficient, in order to obtain the correct sign and to\\n    force the remainder coefficients to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    If the final, triangularized matrix s2 is printed, then:\\n        (a) if deg(p) - deg(q) > 1 or deg( gcd(p, q) ) > 0, several\\n            of the last rows in s2 will remain unprocessed;\\n        (b) if deg(p) - deg(q) == 0, p will not appear in the final matrix.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    s2 = sylvester(f, g, x, 2)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    r = 2\n    if deg_f - deg_g > 1:\n        r = 1\n        for i in range(deg_f - deg_g - 1):\n            s2[r + i, :] = rotate_r(row0, i + 1)\n        r = r + deg_f - deg_g - 1\n        for i in range(deg_f - deg_g):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_f - deg_g\n    if deg_f - deg_g == 0:\n        r = 0\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            break\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        temp2 = LC(poly, x)\n        poly = simplify(poly / temp2 * sign_value)\n        row0 = M[0, :]\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row0, r + i)\n        r = r + deg_g - d\n        row1 = rotate_l(M[M.rows - 1, :], deg_f - d)\n        row1 = row1 / temp2 * sign_value\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_g - d\n        (deg_f, deg_g) = (deg_g, d)\n        sr_list.append(poly)\n    if method != 0 and s2.rows > 2:\n        s2 = final_touches(s2, r, deg_g)\n        pprint(s2)\n    elif method != 0 and s2.rows == 2:\n        s2[1, :] = rotate_r(s2.row(1), 1)\n        pprint(s2)\n    return sr_list",
            "def subresultants_vv(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p, q by triangularizing,\\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\\n    see references 1 and 2 for Van Vleck's method. With each remainder,\\n    sylvester2 gets updated and is prepared to be printed if requested.\\n\\n    If sylvester2 has small dimensions and you want to see the final,\\n    triangularized matrix use this version with method=1; otherwise,\\n    use either this version with method=0 (default) or the faster version,\\n    subresultants_vv_2(p, q, x), where sylvester2 is used implicitly.\\n\\n    Sylvester's matrix sylvester1  is also used to compute one\\n    subresultant per remainder; namely, that of the leading\\n    coefficient, in order to obtain the correct sign and to\\n    force the remainder coefficients to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    If the final, triangularized matrix s2 is printed, then:\\n        (a) if deg(p) - deg(q) > 1 or deg( gcd(p, q) ) > 0, several\\n            of the last rows in s2 will remain unprocessed;\\n        (b) if deg(p) - deg(q) == 0, p will not appear in the final matrix.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    s2 = sylvester(f, g, x, 2)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    r = 2\n    if deg_f - deg_g > 1:\n        r = 1\n        for i in range(deg_f - deg_g - 1):\n            s2[r + i, :] = rotate_r(row0, i + 1)\n        r = r + deg_f - deg_g - 1\n        for i in range(deg_f - deg_g):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_f - deg_g\n    if deg_f - deg_g == 0:\n        r = 0\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            break\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        temp2 = LC(poly, x)\n        poly = simplify(poly / temp2 * sign_value)\n        row0 = M[0, :]\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row0, r + i)\n        r = r + deg_g - d\n        row1 = rotate_l(M[M.rows - 1, :], deg_f - d)\n        row1 = row1 / temp2 * sign_value\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_g - d\n        (deg_f, deg_g) = (deg_g, d)\n        sr_list.append(poly)\n    if method != 0 and s2.rows > 2:\n        s2 = final_touches(s2, r, deg_g)\n        pprint(s2)\n    elif method != 0 and s2.rows == 2:\n        s2[1, :] = rotate_r(s2.row(1), 1)\n        pprint(s2)\n    return sr_list",
            "def subresultants_vv(p, q, x, method=0):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p, q by triangularizing,\\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\\n    see references 1 and 2 for Van Vleck's method. With each remainder,\\n    sylvester2 gets updated and is prepared to be printed if requested.\\n\\n    If sylvester2 has small dimensions and you want to see the final,\\n    triangularized matrix use this version with method=1; otherwise,\\n    use either this version with method=0 (default) or the faster version,\\n    subresultants_vv_2(p, q, x), where sylvester2 is used implicitly.\\n\\n    Sylvester's matrix sylvester1  is also used to compute one\\n    subresultant per remainder; namely, that of the leading\\n    coefficient, in order to obtain the correct sign and to\\n    force the remainder coefficients to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    If the final, triangularized matrix s2 is printed, then:\\n        (a) if deg(p) - deg(q) > 1 or deg( gcd(p, q) ) > 0, several\\n            of the last rows in s2 will remain unprocessed;\\n        (b) if deg(p) - deg(q) == 0, p will not appear in the final matrix.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    s2 = sylvester(f, g, x, 2)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    r = 2\n    if deg_f - deg_g > 1:\n        r = 1\n        for i in range(deg_f - deg_g - 1):\n            s2[r + i, :] = rotate_r(row0, i + 1)\n        r = r + deg_f - deg_g - 1\n        for i in range(deg_f - deg_g):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_f - deg_g\n    if deg_f - deg_g == 0:\n        r = 0\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            break\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        temp2 = LC(poly, x)\n        poly = simplify(poly / temp2 * sign_value)\n        row0 = M[0, :]\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row0, r + i)\n        r = r + deg_g - d\n        row1 = rotate_l(M[M.rows - 1, :], deg_f - d)\n        row1 = row1 / temp2 * sign_value\n        for i in range(deg_g - d):\n            s2[r + i, :] = rotate_r(row1, r + i)\n        r = r + deg_g - d\n        (deg_f, deg_g) = (deg_g, d)\n        sr_list.append(poly)\n    if method != 0 and s2.rows > 2:\n        s2 = final_touches(s2, r, deg_g)\n        pprint(s2)\n    elif method != 0 and s2.rows == 2:\n        s2[1, :] = rotate_r(s2.row(1), 1)\n        pprint(s2)\n    return sr_list"
        ]
    },
    {
        "func_name": "subresultants_vv_2",
        "original": "def subresultants_vv_2(p, q, x):\n    \"\"\"\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\n    that degree(p, x) >= degree(q, x).\n\n    Computes the subresultant prs of p, q by triangularizing,\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\n    see references 1 and 2 for Van Vleck's method.\n\n    If the sylvester2 matrix has big dimensions use this version,\n    where sylvester2 is used implicitly. If you want to see the final,\n    triangularized matrix sylvester2, then use the first version,\n    subresultants_vv(p, q, x, 1).\n\n    sylvester1, Sylvester's matrix of 1840, is also used to compute\n    one subresultant per remainder; namely, that of the leading\n    coefficient, in order to obtain the correct sign and to\n    ``force'' the remainder coefficients to become subresultants.\n\n    If the subresultant prs is complete, then it coincides with the\n    Euclidean sequence of the polynomials p, q.\n\n    References\n    ==========\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\n    common divisors and polynomial remainder sequences.''\n    Numerische MatheMatik 52, 119-127, 1988.\n\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\n    by Van Vleck Regarding Sturm Sequences.''\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\n\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\n\n    \"\"\"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        poly = simplify(poly / LC(poly, x) * sign_value)\n        sr_list.append(poly)\n        (deg_f, deg_g) = (deg_g, d)\n        row0 = row1\n        row1 = Poly(poly, x, domain=QQ).all_coeffs()\n        leng1 = len(row1)\n        for i in range(col_num - leng1):\n            row1.append(0)\n        row1 = Matrix([row1])\n    return sr_list",
        "mutated": [
            "def subresultants_vv_2(p, q, x):\n    if False:\n        i = 10\n    \"\\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p, q by triangularizing,\\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\\n    see references 1 and 2 for Van Vleck's method.\\n\\n    If the sylvester2 matrix has big dimensions use this version,\\n    where sylvester2 is used implicitly. If you want to see the final,\\n    triangularized matrix sylvester2, then use the first version,\\n    subresultants_vv(p, q, x, 1).\\n\\n    sylvester1, Sylvester's matrix of 1840, is also used to compute\\n    one subresultant per remainder; namely, that of the leading\\n    coefficient, in order to obtain the correct sign and to\\n    ``force'' the remainder coefficients to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        poly = simplify(poly / LC(poly, x) * sign_value)\n        sr_list.append(poly)\n        (deg_f, deg_g) = (deg_g, d)\n        row0 = row1\n        row1 = Poly(poly, x, domain=QQ).all_coeffs()\n        leng1 = len(row1)\n        for i in range(col_num - leng1):\n            row1.append(0)\n        row1 = Matrix([row1])\n    return sr_list",
            "def subresultants_vv_2(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p, q by triangularizing,\\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\\n    see references 1 and 2 for Van Vleck's method.\\n\\n    If the sylvester2 matrix has big dimensions use this version,\\n    where sylvester2 is used implicitly. If you want to see the final,\\n    triangularized matrix sylvester2, then use the first version,\\n    subresultants_vv(p, q, x, 1).\\n\\n    sylvester1, Sylvester's matrix of 1840, is also used to compute\\n    one subresultant per remainder; namely, that of the leading\\n    coefficient, in order to obtain the correct sign and to\\n    ``force'' the remainder coefficients to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        poly = simplify(poly / LC(poly, x) * sign_value)\n        sr_list.append(poly)\n        (deg_f, deg_g) = (deg_g, d)\n        row0 = row1\n        row1 = Poly(poly, x, domain=QQ).all_coeffs()\n        leng1 = len(row1)\n        for i in range(col_num - leng1):\n            row1.append(0)\n        row1 = Matrix([row1])\n    return sr_list",
            "def subresultants_vv_2(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p, q by triangularizing,\\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\\n    see references 1 and 2 for Van Vleck's method.\\n\\n    If the sylvester2 matrix has big dimensions use this version,\\n    where sylvester2 is used implicitly. If you want to see the final,\\n    triangularized matrix sylvester2, then use the first version,\\n    subresultants_vv(p, q, x, 1).\\n\\n    sylvester1, Sylvester's matrix of 1840, is also used to compute\\n    one subresultant per remainder; namely, that of the leading\\n    coefficient, in order to obtain the correct sign and to\\n    ``force'' the remainder coefficients to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        poly = simplify(poly / LC(poly, x) * sign_value)\n        sr_list.append(poly)\n        (deg_f, deg_g) = (deg_g, d)\n        row0 = row1\n        row1 = Poly(poly, x, domain=QQ).all_coeffs()\n        leng1 = len(row1)\n        for i in range(col_num - leng1):\n            row1.append(0)\n        row1 = Matrix([row1])\n    return sr_list",
            "def subresultants_vv_2(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p, q by triangularizing,\\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\\n    see references 1 and 2 for Van Vleck's method.\\n\\n    If the sylvester2 matrix has big dimensions use this version,\\n    where sylvester2 is used implicitly. If you want to see the final,\\n    triangularized matrix sylvester2, then use the first version,\\n    subresultants_vv(p, q, x, 1).\\n\\n    sylvester1, Sylvester's matrix of 1840, is also used to compute\\n    one subresultant per remainder; namely, that of the leading\\n    coefficient, in order to obtain the correct sign and to\\n    ``force'' the remainder coefficients to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        poly = simplify(poly / LC(poly, x) * sign_value)\n        sr_list.append(poly)\n        (deg_f, deg_g) = (deg_g, d)\n        row0 = row1\n        row1 = Poly(poly, x, domain=QQ).all_coeffs()\n        leng1 = len(row1)\n        for i in range(col_num - leng1):\n            row1.append(0)\n        row1 = Matrix([row1])\n    return sr_list",
            "def subresultants_vv_2(p, q, x):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    p, q are polynomials in Z[x] (intended) or Q[x]. It is assumed\\n    that degree(p, x) >= degree(q, x).\\n\\n    Computes the subresultant prs of p, q by triangularizing,\\n    in Z[x] or in Q[x], all the smaller matrices encountered in the\\n    process of triangularizing sylvester2, Sylvester's matrix of 1853;\\n    see references 1 and 2 for Van Vleck's method.\\n\\n    If the sylvester2 matrix has big dimensions use this version,\\n    where sylvester2 is used implicitly. If you want to see the final,\\n    triangularized matrix sylvester2, then use the first version,\\n    subresultants_vv(p, q, x, 1).\\n\\n    sylvester1, Sylvester's matrix of 1840, is also used to compute\\n    one subresultant per remainder; namely, that of the leading\\n    coefficient, in order to obtain the correct sign and to\\n    ``force'' the remainder coefficients to become subresultants.\\n\\n    If the subresultant prs is complete, then it coincides with the\\n    Euclidean sequence of the polynomials p, q.\\n\\n    References\\n    ==========\\n    1. Akritas, A. G.: ``A new method for computing polynomial greatest\\n    common divisors and polynomial remainder sequences.''\\n    Numerische MatheMatik 52, 119-127, 1988.\\n\\n    2. Akritas, A. G., G.I. Malaschonok and P.S. Vigklas: ``On a Theorem\\n    by Van Vleck Regarding Sturm Sequences.''\\n    Serdica Journal of Computing, 7, No 4, 101-134, 2013.\\n\\n    3. Akritas, A. G.:``Three New Methods for Computing Subresultant\\n    Polynomial Remainder Sequences (PRS's).'' Serdica Journal of Computing 9(1) (2015), 1-26.\\n\\n    \"\n    if p == 0 or q == 0:\n        return [p, q]\n    (f, g) = (p, q)\n    n = deg_f = degree(f, x)\n    m = deg_g = degree(g, x)\n    if n == 0 and m == 0:\n        return [f, g]\n    if n < m:\n        (n, m, deg_f, deg_g, f, g) = (m, n, deg_g, deg_f, g, f)\n    if n > 0 and m == 0:\n        return [f, g]\n    s1 = sylvester(f, g, x, 1)\n    sr_list = [f, g]\n    col_num = 2 * n\n    row0 = Poly(f, x, domain=QQ).all_coeffs()\n    leng0 = len(row0)\n    for i in range(col_num - leng0):\n        row0.append(0)\n    row0 = Matrix([row0])\n    row1 = Poly(g, x, domain=QQ).all_coeffs()\n    leng1 = len(row1)\n    for i in range(col_num - leng1):\n        row1.append(0)\n    row1 = Matrix([row1])\n    while deg_g > 0:\n        M = create_ma(deg_f, deg_g, row1, row0, col_num)\n        for i in range(deg_f - deg_g + 1):\n            M1 = pivot(M, i, i)\n            M = M1[:, :]\n        d = find_degree(M, deg_f)\n        if d is None:\n            return sr_list\n        exp_deg = deg_g - 1\n        sign_value = correct_sign(n, m, s1, exp_deg, exp_deg - d)\n        poly = row2poly(M[M.rows - 1, :], d, x)\n        poly = simplify(poly / LC(poly, x) * sign_value)\n        sr_list.append(poly)\n        (deg_f, deg_g) = (deg_g, d)\n        row0 = row1\n        row1 = Poly(poly, x, domain=QQ).all_coeffs()\n        leng1 = len(row1)\n        for i in range(col_num - leng1):\n            row1.append(0)\n        row1 = Matrix([row1])\n    return sr_list"
        ]
    }
]