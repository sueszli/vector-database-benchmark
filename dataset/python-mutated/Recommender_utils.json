[
    {
        "func_name": "check_matrix",
        "original": "def check_matrix(X, format='csc', dtype=np.float32):\n    \"\"\"\n    This function takes a matrix as input and transforms it into the specified format.\n    The matrix in input can be either sparse or ndarray.\n    If the matrix in input has already the desired format, it is returned as-is\n    the dtype parameter is always applied and the default is np.float32\n    :param X:\n    :param format:\n    :param dtype:\n    :return:\n    \"\"\"\n    if format == 'csc' and (not isinstance(X, sps.csc_matrix)):\n        return X.tocsc().astype(dtype)\n    elif format == 'csr' and (not isinstance(X, sps.csr_matrix)):\n        return X.tocsr().astype(dtype)\n    elif format == 'coo' and (not isinstance(X, sps.coo_matrix)):\n        return X.tocoo().astype(dtype)\n    elif format == 'dok' and (not isinstance(X, sps.dok_matrix)):\n        return X.todok().astype(dtype)\n    elif format == 'bsr' and (not isinstance(X, sps.bsr_matrix)):\n        return X.tobsr().astype(dtype)\n    elif format == 'dia' and (not isinstance(X, sps.dia_matrix)):\n        return X.todia().astype(dtype)\n    elif format == 'lil' and (not isinstance(X, sps.lil_matrix)):\n        return X.tolil().astype(dtype)\n    elif format == 'npy':\n        if sps.issparse(X):\n            return X.toarray().astype(dtype)\n        else:\n            return np.array(X)\n    elif isinstance(X, np.ndarray):\n        X = sps.csr_matrix(X, dtype=dtype)\n        X.eliminate_zeros()\n        return check_matrix(X, format=format, dtype=dtype)\n    else:\n        return X.astype(dtype)",
        "mutated": [
            "def check_matrix(X, format='csc', dtype=np.float32):\n    if False:\n        i = 10\n    '\\n    This function takes a matrix as input and transforms it into the specified format.\\n    The matrix in input can be either sparse or ndarray.\\n    If the matrix in input has already the desired format, it is returned as-is\\n    the dtype parameter is always applied and the default is np.float32\\n    :param X:\\n    :param format:\\n    :param dtype:\\n    :return:\\n    '\n    if format == 'csc' and (not isinstance(X, sps.csc_matrix)):\n        return X.tocsc().astype(dtype)\n    elif format == 'csr' and (not isinstance(X, sps.csr_matrix)):\n        return X.tocsr().astype(dtype)\n    elif format == 'coo' and (not isinstance(X, sps.coo_matrix)):\n        return X.tocoo().astype(dtype)\n    elif format == 'dok' and (not isinstance(X, sps.dok_matrix)):\n        return X.todok().astype(dtype)\n    elif format == 'bsr' and (not isinstance(X, sps.bsr_matrix)):\n        return X.tobsr().astype(dtype)\n    elif format == 'dia' and (not isinstance(X, sps.dia_matrix)):\n        return X.todia().astype(dtype)\n    elif format == 'lil' and (not isinstance(X, sps.lil_matrix)):\n        return X.tolil().astype(dtype)\n    elif format == 'npy':\n        if sps.issparse(X):\n            return X.toarray().astype(dtype)\n        else:\n            return np.array(X)\n    elif isinstance(X, np.ndarray):\n        X = sps.csr_matrix(X, dtype=dtype)\n        X.eliminate_zeros()\n        return check_matrix(X, format=format, dtype=dtype)\n    else:\n        return X.astype(dtype)",
            "def check_matrix(X, format='csc', dtype=np.float32):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    This function takes a matrix as input and transforms it into the specified format.\\n    The matrix in input can be either sparse or ndarray.\\n    If the matrix in input has already the desired format, it is returned as-is\\n    the dtype parameter is always applied and the default is np.float32\\n    :param X:\\n    :param format:\\n    :param dtype:\\n    :return:\\n    '\n    if format == 'csc' and (not isinstance(X, sps.csc_matrix)):\n        return X.tocsc().astype(dtype)\n    elif format == 'csr' and (not isinstance(X, sps.csr_matrix)):\n        return X.tocsr().astype(dtype)\n    elif format == 'coo' and (not isinstance(X, sps.coo_matrix)):\n        return X.tocoo().astype(dtype)\n    elif format == 'dok' and (not isinstance(X, sps.dok_matrix)):\n        return X.todok().astype(dtype)\n    elif format == 'bsr' and (not isinstance(X, sps.bsr_matrix)):\n        return X.tobsr().astype(dtype)\n    elif format == 'dia' and (not isinstance(X, sps.dia_matrix)):\n        return X.todia().astype(dtype)\n    elif format == 'lil' and (not isinstance(X, sps.lil_matrix)):\n        return X.tolil().astype(dtype)\n    elif format == 'npy':\n        if sps.issparse(X):\n            return X.toarray().astype(dtype)\n        else:\n            return np.array(X)\n    elif isinstance(X, np.ndarray):\n        X = sps.csr_matrix(X, dtype=dtype)\n        X.eliminate_zeros()\n        return check_matrix(X, format=format, dtype=dtype)\n    else:\n        return X.astype(dtype)",
            "def check_matrix(X, format='csc', dtype=np.float32):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    This function takes a matrix as input and transforms it into the specified format.\\n    The matrix in input can be either sparse or ndarray.\\n    If the matrix in input has already the desired format, it is returned as-is\\n    the dtype parameter is always applied and the default is np.float32\\n    :param X:\\n    :param format:\\n    :param dtype:\\n    :return:\\n    '\n    if format == 'csc' and (not isinstance(X, sps.csc_matrix)):\n        return X.tocsc().astype(dtype)\n    elif format == 'csr' and (not isinstance(X, sps.csr_matrix)):\n        return X.tocsr().astype(dtype)\n    elif format == 'coo' and (not isinstance(X, sps.coo_matrix)):\n        return X.tocoo().astype(dtype)\n    elif format == 'dok' and (not isinstance(X, sps.dok_matrix)):\n        return X.todok().astype(dtype)\n    elif format == 'bsr' and (not isinstance(X, sps.bsr_matrix)):\n        return X.tobsr().astype(dtype)\n    elif format == 'dia' and (not isinstance(X, sps.dia_matrix)):\n        return X.todia().astype(dtype)\n    elif format == 'lil' and (not isinstance(X, sps.lil_matrix)):\n        return X.tolil().astype(dtype)\n    elif format == 'npy':\n        if sps.issparse(X):\n            return X.toarray().astype(dtype)\n        else:\n            return np.array(X)\n    elif isinstance(X, np.ndarray):\n        X = sps.csr_matrix(X, dtype=dtype)\n        X.eliminate_zeros()\n        return check_matrix(X, format=format, dtype=dtype)\n    else:\n        return X.astype(dtype)",
            "def check_matrix(X, format='csc', dtype=np.float32):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    This function takes a matrix as input and transforms it into the specified format.\\n    The matrix in input can be either sparse or ndarray.\\n    If the matrix in input has already the desired format, it is returned as-is\\n    the dtype parameter is always applied and the default is np.float32\\n    :param X:\\n    :param format:\\n    :param dtype:\\n    :return:\\n    '\n    if format == 'csc' and (not isinstance(X, sps.csc_matrix)):\n        return X.tocsc().astype(dtype)\n    elif format == 'csr' and (not isinstance(X, sps.csr_matrix)):\n        return X.tocsr().astype(dtype)\n    elif format == 'coo' and (not isinstance(X, sps.coo_matrix)):\n        return X.tocoo().astype(dtype)\n    elif format == 'dok' and (not isinstance(X, sps.dok_matrix)):\n        return X.todok().astype(dtype)\n    elif format == 'bsr' and (not isinstance(X, sps.bsr_matrix)):\n        return X.tobsr().astype(dtype)\n    elif format == 'dia' and (not isinstance(X, sps.dia_matrix)):\n        return X.todia().astype(dtype)\n    elif format == 'lil' and (not isinstance(X, sps.lil_matrix)):\n        return X.tolil().astype(dtype)\n    elif format == 'npy':\n        if sps.issparse(X):\n            return X.toarray().astype(dtype)\n        else:\n            return np.array(X)\n    elif isinstance(X, np.ndarray):\n        X = sps.csr_matrix(X, dtype=dtype)\n        X.eliminate_zeros()\n        return check_matrix(X, format=format, dtype=dtype)\n    else:\n        return X.astype(dtype)",
            "def check_matrix(X, format='csc', dtype=np.float32):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    This function takes a matrix as input and transforms it into the specified format.\\n    The matrix in input can be either sparse or ndarray.\\n    If the matrix in input has already the desired format, it is returned as-is\\n    the dtype parameter is always applied and the default is np.float32\\n    :param X:\\n    :param format:\\n    :param dtype:\\n    :return:\\n    '\n    if format == 'csc' and (not isinstance(X, sps.csc_matrix)):\n        return X.tocsc().astype(dtype)\n    elif format == 'csr' and (not isinstance(X, sps.csr_matrix)):\n        return X.tocsr().astype(dtype)\n    elif format == 'coo' and (not isinstance(X, sps.coo_matrix)):\n        return X.tocoo().astype(dtype)\n    elif format == 'dok' and (not isinstance(X, sps.dok_matrix)):\n        return X.todok().astype(dtype)\n    elif format == 'bsr' and (not isinstance(X, sps.bsr_matrix)):\n        return X.tobsr().astype(dtype)\n    elif format == 'dia' and (not isinstance(X, sps.dia_matrix)):\n        return X.todia().astype(dtype)\n    elif format == 'lil' and (not isinstance(X, sps.lil_matrix)):\n        return X.tolil().astype(dtype)\n    elif format == 'npy':\n        if sps.issparse(X):\n            return X.toarray().astype(dtype)\n        else:\n            return np.array(X)\n    elif isinstance(X, np.ndarray):\n        X = sps.csr_matrix(X, dtype=dtype)\n        X.eliminate_zeros()\n        return check_matrix(X, format=format, dtype=dtype)\n    else:\n        return X.astype(dtype)"
        ]
    },
    {
        "func_name": "similarityMatrixTopK",
        "original": "def similarityMatrixTopK(item_weights, k=100, verbose=False):\n    \"\"\"\n    The function selects the TopK most similar elements, column-wise\n\n    :param item_weights:\n    :param forceSparseOutput:\n    :param k:\n    :param verbose:\n    :param inplace: Default True, WARNING matrix will be modified\n    :return:\n    \"\"\"\n    assert item_weights.shape[0] == item_weights.shape[1], 'selectTopK: ItemWeights is not a square matrix'\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, rows_indices, cols_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_row_index = np.arange(nitems, dtype=np.int32)\n    for item_idx in range(nitems):\n        cols_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[item_idx]\n            end_position = item_weights.indptr[item_idx + 1]\n            column_data = item_weights.data[start_position:end_position]\n            column_row_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[:, item_idx]\n        non_zero_data = column_data != 0\n        idx_sorted = np.argsort(column_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(column_data[non_zero_data][top_k_idx])\n        rows_indices.extend(column_row_index[non_zero_data][top_k_idx])\n    cols_indptr.append(len(data))\n    W_sparse = sps.csc_matrix((data, rows_indices, cols_indptr), shape=(nitems, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse",
        "mutated": [
            "def similarityMatrixTopK(item_weights, k=100, verbose=False):\n    if False:\n        i = 10\n    '\\n    The function selects the TopK most similar elements, column-wise\\n\\n    :param item_weights:\\n    :param forceSparseOutput:\\n    :param k:\\n    :param verbose:\\n    :param inplace: Default True, WARNING matrix will be modified\\n    :return:\\n    '\n    assert item_weights.shape[0] == item_weights.shape[1], 'selectTopK: ItemWeights is not a square matrix'\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, rows_indices, cols_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_row_index = np.arange(nitems, dtype=np.int32)\n    for item_idx in range(nitems):\n        cols_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[item_idx]\n            end_position = item_weights.indptr[item_idx + 1]\n            column_data = item_weights.data[start_position:end_position]\n            column_row_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[:, item_idx]\n        non_zero_data = column_data != 0\n        idx_sorted = np.argsort(column_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(column_data[non_zero_data][top_k_idx])\n        rows_indices.extend(column_row_index[non_zero_data][top_k_idx])\n    cols_indptr.append(len(data))\n    W_sparse = sps.csc_matrix((data, rows_indices, cols_indptr), shape=(nitems, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse",
            "def similarityMatrixTopK(item_weights, k=100, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The function selects the TopK most similar elements, column-wise\\n\\n    :param item_weights:\\n    :param forceSparseOutput:\\n    :param k:\\n    :param verbose:\\n    :param inplace: Default True, WARNING matrix will be modified\\n    :return:\\n    '\n    assert item_weights.shape[0] == item_weights.shape[1], 'selectTopK: ItemWeights is not a square matrix'\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, rows_indices, cols_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_row_index = np.arange(nitems, dtype=np.int32)\n    for item_idx in range(nitems):\n        cols_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[item_idx]\n            end_position = item_weights.indptr[item_idx + 1]\n            column_data = item_weights.data[start_position:end_position]\n            column_row_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[:, item_idx]\n        non_zero_data = column_data != 0\n        idx_sorted = np.argsort(column_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(column_data[non_zero_data][top_k_idx])\n        rows_indices.extend(column_row_index[non_zero_data][top_k_idx])\n    cols_indptr.append(len(data))\n    W_sparse = sps.csc_matrix((data, rows_indices, cols_indptr), shape=(nitems, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse",
            "def similarityMatrixTopK(item_weights, k=100, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The function selects the TopK most similar elements, column-wise\\n\\n    :param item_weights:\\n    :param forceSparseOutput:\\n    :param k:\\n    :param verbose:\\n    :param inplace: Default True, WARNING matrix will be modified\\n    :return:\\n    '\n    assert item_weights.shape[0] == item_weights.shape[1], 'selectTopK: ItemWeights is not a square matrix'\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, rows_indices, cols_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_row_index = np.arange(nitems, dtype=np.int32)\n    for item_idx in range(nitems):\n        cols_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[item_idx]\n            end_position = item_weights.indptr[item_idx + 1]\n            column_data = item_weights.data[start_position:end_position]\n            column_row_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[:, item_idx]\n        non_zero_data = column_data != 0\n        idx_sorted = np.argsort(column_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(column_data[non_zero_data][top_k_idx])\n        rows_indices.extend(column_row_index[non_zero_data][top_k_idx])\n    cols_indptr.append(len(data))\n    W_sparse = sps.csc_matrix((data, rows_indices, cols_indptr), shape=(nitems, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse",
            "def similarityMatrixTopK(item_weights, k=100, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The function selects the TopK most similar elements, column-wise\\n\\n    :param item_weights:\\n    :param forceSparseOutput:\\n    :param k:\\n    :param verbose:\\n    :param inplace: Default True, WARNING matrix will be modified\\n    :return:\\n    '\n    assert item_weights.shape[0] == item_weights.shape[1], 'selectTopK: ItemWeights is not a square matrix'\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, rows_indices, cols_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_row_index = np.arange(nitems, dtype=np.int32)\n    for item_idx in range(nitems):\n        cols_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[item_idx]\n            end_position = item_weights.indptr[item_idx + 1]\n            column_data = item_weights.data[start_position:end_position]\n            column_row_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[:, item_idx]\n        non_zero_data = column_data != 0\n        idx_sorted = np.argsort(column_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(column_data[non_zero_data][top_k_idx])\n        rows_indices.extend(column_row_index[non_zero_data][top_k_idx])\n    cols_indptr.append(len(data))\n    W_sparse = sps.csc_matrix((data, rows_indices, cols_indptr), shape=(nitems, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse",
            "def similarityMatrixTopK(item_weights, k=100, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The function selects the TopK most similar elements, column-wise\\n\\n    :param item_weights:\\n    :param forceSparseOutput:\\n    :param k:\\n    :param verbose:\\n    :param inplace: Default True, WARNING matrix will be modified\\n    :return:\\n    '\n    assert item_weights.shape[0] == item_weights.shape[1], 'selectTopK: ItemWeights is not a square matrix'\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, rows_indices, cols_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_row_index = np.arange(nitems, dtype=np.int32)\n    for item_idx in range(nitems):\n        cols_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[item_idx]\n            end_position = item_weights.indptr[item_idx + 1]\n            column_data = item_weights.data[start_position:end_position]\n            column_row_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[:, item_idx]\n        non_zero_data = column_data != 0\n        idx_sorted = np.argsort(column_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(column_data[non_zero_data][top_k_idx])\n        rows_indices.extend(column_row_index[non_zero_data][top_k_idx])\n    cols_indptr.append(len(data))\n    W_sparse = sps.csc_matrix((data, rows_indices, cols_indptr), shape=(nitems, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse"
        ]
    },
    {
        "func_name": "areURMequals",
        "original": "def areURMequals(URM1, URM2):\n    if URM1.shape != URM2.shape:\n        return False\n    return (URM1 - URM2).nnz == 0",
        "mutated": [
            "def areURMequals(URM1, URM2):\n    if False:\n        i = 10\n    if URM1.shape != URM2.shape:\n        return False\n    return (URM1 - URM2).nnz == 0",
            "def areURMequals(URM1, URM2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if URM1.shape != URM2.shape:\n        return False\n    return (URM1 - URM2).nnz == 0",
            "def areURMequals(URM1, URM2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if URM1.shape != URM2.shape:\n        return False\n    return (URM1 - URM2).nnz == 0",
            "def areURMequals(URM1, URM2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if URM1.shape != URM2.shape:\n        return False\n    return (URM1 - URM2).nnz == 0",
            "def areURMequals(URM1, URM2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if URM1.shape != URM2.shape:\n        return False\n    return (URM1 - URM2).nnz == 0"
        ]
    },
    {
        "func_name": "removeTopPop",
        "original": "def removeTopPop(URM_1, URM_2=None, percentageToRemove=0.2):\n    \"\"\"\n    Remove the top popular items from the matrix\n    :param URM_1: user X items\n    :param URM_2: user X items\n    :param percentageToRemove: value 1 corresponds to 100%\n    :return: URM: user X selectedItems, obtained from URM_1\n             Array: itemMappings[selectedItemIndex] = originalItemIndex\n             Array: removedItems\n    \"\"\"\n    item_pop = URM_1.sum(axis=0)\n    if URM_2 != None:\n        assert URM_2.shape[1] == URM_1.shape[1], 'The two URM do not contain the same number of columns, URM_1 has {}, URM_2 has {}'.format(URM_1.shape[1], URM_2.shape[1])\n        item_pop += URM_2.sum(axis=0)\n    item_pop = np.asarray(item_pop).squeeze()\n    popularItemsSorted = np.argsort(item_pop)[::-1]\n    numItemsToRemove = int(len(popularItemsSorted) * percentageToRemove)\n    itemMask = np.in1d(np.arange(len(popularItemsSorted)), popularItemsSorted[:numItemsToRemove], invert=True)\n    itemMappings = np.arange(len(popularItemsSorted))[itemMask]\n    removedItems = np.arange(len(popularItemsSorted))[np.logical_not(itemMask)]\n    return (URM_1[:, itemMask], itemMappings, removedItems)",
        "mutated": [
            "def removeTopPop(URM_1, URM_2=None, percentageToRemove=0.2):\n    if False:\n        i = 10\n    '\\n    Remove the top popular items from the matrix\\n    :param URM_1: user X items\\n    :param URM_2: user X items\\n    :param percentageToRemove: value 1 corresponds to 100%\\n    :return: URM: user X selectedItems, obtained from URM_1\\n             Array: itemMappings[selectedItemIndex] = originalItemIndex\\n             Array: removedItems\\n    '\n    item_pop = URM_1.sum(axis=0)\n    if URM_2 != None:\n        assert URM_2.shape[1] == URM_1.shape[1], 'The two URM do not contain the same number of columns, URM_1 has {}, URM_2 has {}'.format(URM_1.shape[1], URM_2.shape[1])\n        item_pop += URM_2.sum(axis=0)\n    item_pop = np.asarray(item_pop).squeeze()\n    popularItemsSorted = np.argsort(item_pop)[::-1]\n    numItemsToRemove = int(len(popularItemsSorted) * percentageToRemove)\n    itemMask = np.in1d(np.arange(len(popularItemsSorted)), popularItemsSorted[:numItemsToRemove], invert=True)\n    itemMappings = np.arange(len(popularItemsSorted))[itemMask]\n    removedItems = np.arange(len(popularItemsSorted))[np.logical_not(itemMask)]\n    return (URM_1[:, itemMask], itemMappings, removedItems)",
            "def removeTopPop(URM_1, URM_2=None, percentageToRemove=0.2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Remove the top popular items from the matrix\\n    :param URM_1: user X items\\n    :param URM_2: user X items\\n    :param percentageToRemove: value 1 corresponds to 100%\\n    :return: URM: user X selectedItems, obtained from URM_1\\n             Array: itemMappings[selectedItemIndex] = originalItemIndex\\n             Array: removedItems\\n    '\n    item_pop = URM_1.sum(axis=0)\n    if URM_2 != None:\n        assert URM_2.shape[1] == URM_1.shape[1], 'The two URM do not contain the same number of columns, URM_1 has {}, URM_2 has {}'.format(URM_1.shape[1], URM_2.shape[1])\n        item_pop += URM_2.sum(axis=0)\n    item_pop = np.asarray(item_pop).squeeze()\n    popularItemsSorted = np.argsort(item_pop)[::-1]\n    numItemsToRemove = int(len(popularItemsSorted) * percentageToRemove)\n    itemMask = np.in1d(np.arange(len(popularItemsSorted)), popularItemsSorted[:numItemsToRemove], invert=True)\n    itemMappings = np.arange(len(popularItemsSorted))[itemMask]\n    removedItems = np.arange(len(popularItemsSorted))[np.logical_not(itemMask)]\n    return (URM_1[:, itemMask], itemMappings, removedItems)",
            "def removeTopPop(URM_1, URM_2=None, percentageToRemove=0.2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Remove the top popular items from the matrix\\n    :param URM_1: user X items\\n    :param URM_2: user X items\\n    :param percentageToRemove: value 1 corresponds to 100%\\n    :return: URM: user X selectedItems, obtained from URM_1\\n             Array: itemMappings[selectedItemIndex] = originalItemIndex\\n             Array: removedItems\\n    '\n    item_pop = URM_1.sum(axis=0)\n    if URM_2 != None:\n        assert URM_2.shape[1] == URM_1.shape[1], 'The two URM do not contain the same number of columns, URM_1 has {}, URM_2 has {}'.format(URM_1.shape[1], URM_2.shape[1])\n        item_pop += URM_2.sum(axis=0)\n    item_pop = np.asarray(item_pop).squeeze()\n    popularItemsSorted = np.argsort(item_pop)[::-1]\n    numItemsToRemove = int(len(popularItemsSorted) * percentageToRemove)\n    itemMask = np.in1d(np.arange(len(popularItemsSorted)), popularItemsSorted[:numItemsToRemove], invert=True)\n    itemMappings = np.arange(len(popularItemsSorted))[itemMask]\n    removedItems = np.arange(len(popularItemsSorted))[np.logical_not(itemMask)]\n    return (URM_1[:, itemMask], itemMappings, removedItems)",
            "def removeTopPop(URM_1, URM_2=None, percentageToRemove=0.2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Remove the top popular items from the matrix\\n    :param URM_1: user X items\\n    :param URM_2: user X items\\n    :param percentageToRemove: value 1 corresponds to 100%\\n    :return: URM: user X selectedItems, obtained from URM_1\\n             Array: itemMappings[selectedItemIndex] = originalItemIndex\\n             Array: removedItems\\n    '\n    item_pop = URM_1.sum(axis=0)\n    if URM_2 != None:\n        assert URM_2.shape[1] == URM_1.shape[1], 'The two URM do not contain the same number of columns, URM_1 has {}, URM_2 has {}'.format(URM_1.shape[1], URM_2.shape[1])\n        item_pop += URM_2.sum(axis=0)\n    item_pop = np.asarray(item_pop).squeeze()\n    popularItemsSorted = np.argsort(item_pop)[::-1]\n    numItemsToRemove = int(len(popularItemsSorted) * percentageToRemove)\n    itemMask = np.in1d(np.arange(len(popularItemsSorted)), popularItemsSorted[:numItemsToRemove], invert=True)\n    itemMappings = np.arange(len(popularItemsSorted))[itemMask]\n    removedItems = np.arange(len(popularItemsSorted))[np.logical_not(itemMask)]\n    return (URM_1[:, itemMask], itemMappings, removedItems)",
            "def removeTopPop(URM_1, URM_2=None, percentageToRemove=0.2):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Remove the top popular items from the matrix\\n    :param URM_1: user X items\\n    :param URM_2: user X items\\n    :param percentageToRemove: value 1 corresponds to 100%\\n    :return: URM: user X selectedItems, obtained from URM_1\\n             Array: itemMappings[selectedItemIndex] = originalItemIndex\\n             Array: removedItems\\n    '\n    item_pop = URM_1.sum(axis=0)\n    if URM_2 != None:\n        assert URM_2.shape[1] == URM_1.shape[1], 'The two URM do not contain the same number of columns, URM_1 has {}, URM_2 has {}'.format(URM_1.shape[1], URM_2.shape[1])\n        item_pop += URM_2.sum(axis=0)\n    item_pop = np.asarray(item_pop).squeeze()\n    popularItemsSorted = np.argsort(item_pop)[::-1]\n    numItemsToRemove = int(len(popularItemsSorted) * percentageToRemove)\n    itemMask = np.in1d(np.arange(len(popularItemsSorted)), popularItemsSorted[:numItemsToRemove], invert=True)\n    itemMappings = np.arange(len(popularItemsSorted))[itemMask]\n    removedItems = np.arange(len(popularItemsSorted))[np.logical_not(itemMask)]\n    return (URM_1[:, itemMask], itemMappings, removedItems)"
        ]
    },
    {
        "func_name": "addZeroSamples",
        "original": "def addZeroSamples(S_matrix, numSamplesToAdd):\n    n_items = S_matrix.shape[1]\n    S_matrix_coo = S_matrix.tocoo()\n    row_index = list(S_matrix_coo.row)\n    col_index = list(S_matrix_coo.col)\n    data = list(S_matrix_coo.data)\n    existingSamples = set(zip(row_index, col_index))\n    addedSamples = 0\n    consecutiveFailures = 0\n    while addedSamples < numSamplesToAdd:\n        item1 = np.random.randint(0, n_items)\n        item2 = np.random.randint(0, n_items)\n        if item1 != item2 and (item1, item2) not in existingSamples:\n            row_index.append(item1)\n            col_index.append(item2)\n            data.append(0)\n            existingSamples.add((item1, item2))\n            addedSamples += 1\n            consecutiveFailures = 0\n        else:\n            consecutiveFailures += 1\n        if consecutiveFailures >= 100:\n            raise SystemExit('Unable to generate required zero samples, termination at 100 consecutive discarded samples')\n    return (row_index, col_index, data)",
        "mutated": [
            "def addZeroSamples(S_matrix, numSamplesToAdd):\n    if False:\n        i = 10\n    n_items = S_matrix.shape[1]\n    S_matrix_coo = S_matrix.tocoo()\n    row_index = list(S_matrix_coo.row)\n    col_index = list(S_matrix_coo.col)\n    data = list(S_matrix_coo.data)\n    existingSamples = set(zip(row_index, col_index))\n    addedSamples = 0\n    consecutiveFailures = 0\n    while addedSamples < numSamplesToAdd:\n        item1 = np.random.randint(0, n_items)\n        item2 = np.random.randint(0, n_items)\n        if item1 != item2 and (item1, item2) not in existingSamples:\n            row_index.append(item1)\n            col_index.append(item2)\n            data.append(0)\n            existingSamples.add((item1, item2))\n            addedSamples += 1\n            consecutiveFailures = 0\n        else:\n            consecutiveFailures += 1\n        if consecutiveFailures >= 100:\n            raise SystemExit('Unable to generate required zero samples, termination at 100 consecutive discarded samples')\n    return (row_index, col_index, data)",
            "def addZeroSamples(S_matrix, numSamplesToAdd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    n_items = S_matrix.shape[1]\n    S_matrix_coo = S_matrix.tocoo()\n    row_index = list(S_matrix_coo.row)\n    col_index = list(S_matrix_coo.col)\n    data = list(S_matrix_coo.data)\n    existingSamples = set(zip(row_index, col_index))\n    addedSamples = 0\n    consecutiveFailures = 0\n    while addedSamples < numSamplesToAdd:\n        item1 = np.random.randint(0, n_items)\n        item2 = np.random.randint(0, n_items)\n        if item1 != item2 and (item1, item2) not in existingSamples:\n            row_index.append(item1)\n            col_index.append(item2)\n            data.append(0)\n            existingSamples.add((item1, item2))\n            addedSamples += 1\n            consecutiveFailures = 0\n        else:\n            consecutiveFailures += 1\n        if consecutiveFailures >= 100:\n            raise SystemExit('Unable to generate required zero samples, termination at 100 consecutive discarded samples')\n    return (row_index, col_index, data)",
            "def addZeroSamples(S_matrix, numSamplesToAdd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    n_items = S_matrix.shape[1]\n    S_matrix_coo = S_matrix.tocoo()\n    row_index = list(S_matrix_coo.row)\n    col_index = list(S_matrix_coo.col)\n    data = list(S_matrix_coo.data)\n    existingSamples = set(zip(row_index, col_index))\n    addedSamples = 0\n    consecutiveFailures = 0\n    while addedSamples < numSamplesToAdd:\n        item1 = np.random.randint(0, n_items)\n        item2 = np.random.randint(0, n_items)\n        if item1 != item2 and (item1, item2) not in existingSamples:\n            row_index.append(item1)\n            col_index.append(item2)\n            data.append(0)\n            existingSamples.add((item1, item2))\n            addedSamples += 1\n            consecutiveFailures = 0\n        else:\n            consecutiveFailures += 1\n        if consecutiveFailures >= 100:\n            raise SystemExit('Unable to generate required zero samples, termination at 100 consecutive discarded samples')\n    return (row_index, col_index, data)",
            "def addZeroSamples(S_matrix, numSamplesToAdd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    n_items = S_matrix.shape[1]\n    S_matrix_coo = S_matrix.tocoo()\n    row_index = list(S_matrix_coo.row)\n    col_index = list(S_matrix_coo.col)\n    data = list(S_matrix_coo.data)\n    existingSamples = set(zip(row_index, col_index))\n    addedSamples = 0\n    consecutiveFailures = 0\n    while addedSamples < numSamplesToAdd:\n        item1 = np.random.randint(0, n_items)\n        item2 = np.random.randint(0, n_items)\n        if item1 != item2 and (item1, item2) not in existingSamples:\n            row_index.append(item1)\n            col_index.append(item2)\n            data.append(0)\n            existingSamples.add((item1, item2))\n            addedSamples += 1\n            consecutiveFailures = 0\n        else:\n            consecutiveFailures += 1\n        if consecutiveFailures >= 100:\n            raise SystemExit('Unable to generate required zero samples, termination at 100 consecutive discarded samples')\n    return (row_index, col_index, data)",
            "def addZeroSamples(S_matrix, numSamplesToAdd):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    n_items = S_matrix.shape[1]\n    S_matrix_coo = S_matrix.tocoo()\n    row_index = list(S_matrix_coo.row)\n    col_index = list(S_matrix_coo.col)\n    data = list(S_matrix_coo.data)\n    existingSamples = set(zip(row_index, col_index))\n    addedSamples = 0\n    consecutiveFailures = 0\n    while addedSamples < numSamplesToAdd:\n        item1 = np.random.randint(0, n_items)\n        item2 = np.random.randint(0, n_items)\n        if item1 != item2 and (item1, item2) not in existingSamples:\n            row_index.append(item1)\n            col_index.append(item2)\n            data.append(0)\n            existingSamples.add((item1, item2))\n            addedSamples += 1\n            consecutiveFailures = 0\n        else:\n            consecutiveFailures += 1\n        if consecutiveFailures >= 100:\n            raise SystemExit('Unable to generate required zero samples, termination at 100 consecutive discarded samples')\n    return (row_index, col_index, data)"
        ]
    },
    {
        "func_name": "reshapeSparse",
        "original": "def reshapeSparse(sparseMatrix, newShape):\n    if sparseMatrix.shape[0] > newShape[0] or sparseMatrix.shape[1] > newShape[1]:\n        ValueError('New shape cannot be smaller than SparseMatrix. SparseMatrix shape is: {}, newShape is {}'.format(sparseMatrix.shape, newShape))\n    sparseMatrix = sparseMatrix.tocoo()\n    newMatrix = sps.csr_matrix((sparseMatrix.data, (sparseMatrix.row, sparseMatrix.col)), shape=newShape)\n    return newMatrix",
        "mutated": [
            "def reshapeSparse(sparseMatrix, newShape):\n    if False:\n        i = 10\n    if sparseMatrix.shape[0] > newShape[0] or sparseMatrix.shape[1] > newShape[1]:\n        ValueError('New shape cannot be smaller than SparseMatrix. SparseMatrix shape is: {}, newShape is {}'.format(sparseMatrix.shape, newShape))\n    sparseMatrix = sparseMatrix.tocoo()\n    newMatrix = sps.csr_matrix((sparseMatrix.data, (sparseMatrix.row, sparseMatrix.col)), shape=newShape)\n    return newMatrix",
            "def reshapeSparse(sparseMatrix, newShape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if sparseMatrix.shape[0] > newShape[0] or sparseMatrix.shape[1] > newShape[1]:\n        ValueError('New shape cannot be smaller than SparseMatrix. SparseMatrix shape is: {}, newShape is {}'.format(sparseMatrix.shape, newShape))\n    sparseMatrix = sparseMatrix.tocoo()\n    newMatrix = sps.csr_matrix((sparseMatrix.data, (sparseMatrix.row, sparseMatrix.col)), shape=newShape)\n    return newMatrix",
            "def reshapeSparse(sparseMatrix, newShape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if sparseMatrix.shape[0] > newShape[0] or sparseMatrix.shape[1] > newShape[1]:\n        ValueError('New shape cannot be smaller than SparseMatrix. SparseMatrix shape is: {}, newShape is {}'.format(sparseMatrix.shape, newShape))\n    sparseMatrix = sparseMatrix.tocoo()\n    newMatrix = sps.csr_matrix((sparseMatrix.data, (sparseMatrix.row, sparseMatrix.col)), shape=newShape)\n    return newMatrix",
            "def reshapeSparse(sparseMatrix, newShape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if sparseMatrix.shape[0] > newShape[0] or sparseMatrix.shape[1] > newShape[1]:\n        ValueError('New shape cannot be smaller than SparseMatrix. SparseMatrix shape is: {}, newShape is {}'.format(sparseMatrix.shape, newShape))\n    sparseMatrix = sparseMatrix.tocoo()\n    newMatrix = sps.csr_matrix((sparseMatrix.data, (sparseMatrix.row, sparseMatrix.col)), shape=newShape)\n    return newMatrix",
            "def reshapeSparse(sparseMatrix, newShape):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if sparseMatrix.shape[0] > newShape[0] or sparseMatrix.shape[1] > newShape[1]:\n        ValueError('New shape cannot be smaller than SparseMatrix. SparseMatrix shape is: {}, newShape is {}'.format(sparseMatrix.shape, newShape))\n    sparseMatrix = sparseMatrix.tocoo()\n    newMatrix = sps.csr_matrix((sparseMatrix.data, (sparseMatrix.row, sparseMatrix.col)), shape=newShape)\n    return newMatrix"
        ]
    },
    {
        "func_name": "get_unique_temp_folder",
        "original": "def get_unique_temp_folder(input_temp_folder_path):\n    \"\"\"\n    The function returns the path of a folder in result_experiments\n    The function guarantees that the folder is not already existent and it creates it\n    :return:\n    \"\"\"\n    if input_temp_folder_path[-1] == '/':\n        input_temp_folder_path = input_temp_folder_path[:-1]\n    progressive_temp_folder_name = input_temp_folder_path\n    counter_suffix = 0\n    while os.path.isdir(progressive_temp_folder_name):\n        counter_suffix += 1\n        progressive_temp_folder_name = input_temp_folder_path + '_' + str(counter_suffix)\n    progressive_temp_folder_name += '/'\n    os.makedirs(progressive_temp_folder_name)\n    return progressive_temp_folder_name",
        "mutated": [
            "def get_unique_temp_folder(input_temp_folder_path):\n    if False:\n        i = 10\n    '\\n    The function returns the path of a folder in result_experiments\\n    The function guarantees that the folder is not already existent and it creates it\\n    :return:\\n    '\n    if input_temp_folder_path[-1] == '/':\n        input_temp_folder_path = input_temp_folder_path[:-1]\n    progressive_temp_folder_name = input_temp_folder_path\n    counter_suffix = 0\n    while os.path.isdir(progressive_temp_folder_name):\n        counter_suffix += 1\n        progressive_temp_folder_name = input_temp_folder_path + '_' + str(counter_suffix)\n    progressive_temp_folder_name += '/'\n    os.makedirs(progressive_temp_folder_name)\n    return progressive_temp_folder_name",
            "def get_unique_temp_folder(input_temp_folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The function returns the path of a folder in result_experiments\\n    The function guarantees that the folder is not already existent and it creates it\\n    :return:\\n    '\n    if input_temp_folder_path[-1] == '/':\n        input_temp_folder_path = input_temp_folder_path[:-1]\n    progressive_temp_folder_name = input_temp_folder_path\n    counter_suffix = 0\n    while os.path.isdir(progressive_temp_folder_name):\n        counter_suffix += 1\n        progressive_temp_folder_name = input_temp_folder_path + '_' + str(counter_suffix)\n    progressive_temp_folder_name += '/'\n    os.makedirs(progressive_temp_folder_name)\n    return progressive_temp_folder_name",
            "def get_unique_temp_folder(input_temp_folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The function returns the path of a folder in result_experiments\\n    The function guarantees that the folder is not already existent and it creates it\\n    :return:\\n    '\n    if input_temp_folder_path[-1] == '/':\n        input_temp_folder_path = input_temp_folder_path[:-1]\n    progressive_temp_folder_name = input_temp_folder_path\n    counter_suffix = 0\n    while os.path.isdir(progressive_temp_folder_name):\n        counter_suffix += 1\n        progressive_temp_folder_name = input_temp_folder_path + '_' + str(counter_suffix)\n    progressive_temp_folder_name += '/'\n    os.makedirs(progressive_temp_folder_name)\n    return progressive_temp_folder_name",
            "def get_unique_temp_folder(input_temp_folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The function returns the path of a folder in result_experiments\\n    The function guarantees that the folder is not already existent and it creates it\\n    :return:\\n    '\n    if input_temp_folder_path[-1] == '/':\n        input_temp_folder_path = input_temp_folder_path[:-1]\n    progressive_temp_folder_name = input_temp_folder_path\n    counter_suffix = 0\n    while os.path.isdir(progressive_temp_folder_name):\n        counter_suffix += 1\n        progressive_temp_folder_name = input_temp_folder_path + '_' + str(counter_suffix)\n    progressive_temp_folder_name += '/'\n    os.makedirs(progressive_temp_folder_name)\n    return progressive_temp_folder_name",
            "def get_unique_temp_folder(input_temp_folder_path):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The function returns the path of a folder in result_experiments\\n    The function guarantees that the folder is not already existent and it creates it\\n    :return:\\n    '\n    if input_temp_folder_path[-1] == '/':\n        input_temp_folder_path = input_temp_folder_path[:-1]\n    progressive_temp_folder_name = input_temp_folder_path\n    counter_suffix = 0\n    while os.path.isdir(progressive_temp_folder_name):\n        counter_suffix += 1\n        progressive_temp_folder_name = input_temp_folder_path + '_' + str(counter_suffix)\n    progressive_temp_folder_name += '/'\n    os.makedirs(progressive_temp_folder_name)\n    return progressive_temp_folder_name"
        ]
    },
    {
        "func_name": "ratingMatrixTopK",
        "original": "def ratingMatrixTopK(item_weights, k=100, verbose=False):\n    \"\"\"\n    The function selects the TopK most similar elements, column-wise\n\n    :param item_weights:\n    :param forceSparseOutput:\n    :param k:\n    :param verbose:\n    :param inplace: Default True, WARNING matrix will be modified\n    :return:\n    \"\"\"\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nusers = item_weights.shape[0]\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, cols_indices, rows_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_index = np.arange(nitems, dtype=np.int32)\n    for user_idx in range(nusers):\n        rows_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[user_idx]\n            end_position = item_weights.indptr[user_idx + 1]\n            row_data = item_weights.data[start_position:end_position]\n            column_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[user_idx, :]\n        non_zero_data = row_data != 0\n        idx_sorted = np.argsort(row_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(row_data[non_zero_data][top_k_idx])\n        cols_indices.extend(column_index[non_zero_data][top_k_idx])\n    rows_indptr.append(len(data))\n    W_sparse = sps.csr_matrix((data, cols_indices, rows_indptr), shape=(nusers, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse",
        "mutated": [
            "def ratingMatrixTopK(item_weights, k=100, verbose=False):\n    if False:\n        i = 10\n    '\\n    The function selects the TopK most similar elements, column-wise\\n\\n    :param item_weights:\\n    :param forceSparseOutput:\\n    :param k:\\n    :param verbose:\\n    :param inplace: Default True, WARNING matrix will be modified\\n    :return:\\n    '\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nusers = item_weights.shape[0]\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, cols_indices, rows_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_index = np.arange(nitems, dtype=np.int32)\n    for user_idx in range(nusers):\n        rows_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[user_idx]\n            end_position = item_weights.indptr[user_idx + 1]\n            row_data = item_weights.data[start_position:end_position]\n            column_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[user_idx, :]\n        non_zero_data = row_data != 0\n        idx_sorted = np.argsort(row_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(row_data[non_zero_data][top_k_idx])\n        cols_indices.extend(column_index[non_zero_data][top_k_idx])\n    rows_indptr.append(len(data))\n    W_sparse = sps.csr_matrix((data, cols_indices, rows_indptr), shape=(nusers, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse",
            "def ratingMatrixTopK(item_weights, k=100, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    The function selects the TopK most similar elements, column-wise\\n\\n    :param item_weights:\\n    :param forceSparseOutput:\\n    :param k:\\n    :param verbose:\\n    :param inplace: Default True, WARNING matrix will be modified\\n    :return:\\n    '\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nusers = item_weights.shape[0]\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, cols_indices, rows_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_index = np.arange(nitems, dtype=np.int32)\n    for user_idx in range(nusers):\n        rows_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[user_idx]\n            end_position = item_weights.indptr[user_idx + 1]\n            row_data = item_weights.data[start_position:end_position]\n            column_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[user_idx, :]\n        non_zero_data = row_data != 0\n        idx_sorted = np.argsort(row_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(row_data[non_zero_data][top_k_idx])\n        cols_indices.extend(column_index[non_zero_data][top_k_idx])\n    rows_indptr.append(len(data))\n    W_sparse = sps.csr_matrix((data, cols_indices, rows_indptr), shape=(nusers, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse",
            "def ratingMatrixTopK(item_weights, k=100, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    The function selects the TopK most similar elements, column-wise\\n\\n    :param item_weights:\\n    :param forceSparseOutput:\\n    :param k:\\n    :param verbose:\\n    :param inplace: Default True, WARNING matrix will be modified\\n    :return:\\n    '\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nusers = item_weights.shape[0]\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, cols_indices, rows_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_index = np.arange(nitems, dtype=np.int32)\n    for user_idx in range(nusers):\n        rows_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[user_idx]\n            end_position = item_weights.indptr[user_idx + 1]\n            row_data = item_weights.data[start_position:end_position]\n            column_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[user_idx, :]\n        non_zero_data = row_data != 0\n        idx_sorted = np.argsort(row_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(row_data[non_zero_data][top_k_idx])\n        cols_indices.extend(column_index[non_zero_data][top_k_idx])\n    rows_indptr.append(len(data))\n    W_sparse = sps.csr_matrix((data, cols_indices, rows_indptr), shape=(nusers, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse",
            "def ratingMatrixTopK(item_weights, k=100, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    The function selects the TopK most similar elements, column-wise\\n\\n    :param item_weights:\\n    :param forceSparseOutput:\\n    :param k:\\n    :param verbose:\\n    :param inplace: Default True, WARNING matrix will be modified\\n    :return:\\n    '\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nusers = item_weights.shape[0]\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, cols_indices, rows_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_index = np.arange(nitems, dtype=np.int32)\n    for user_idx in range(nusers):\n        rows_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[user_idx]\n            end_position = item_weights.indptr[user_idx + 1]\n            row_data = item_weights.data[start_position:end_position]\n            column_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[user_idx, :]\n        non_zero_data = row_data != 0\n        idx_sorted = np.argsort(row_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(row_data[non_zero_data][top_k_idx])\n        cols_indices.extend(column_index[non_zero_data][top_k_idx])\n    rows_indptr.append(len(data))\n    W_sparse = sps.csr_matrix((data, cols_indices, rows_indptr), shape=(nusers, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse",
            "def ratingMatrixTopK(item_weights, k=100, verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    The function selects the TopK most similar elements, column-wise\\n\\n    :param item_weights:\\n    :param forceSparseOutput:\\n    :param k:\\n    :param verbose:\\n    :param inplace: Default True, WARNING matrix will be modified\\n    :return:\\n    '\n    start_time = time.time()\n    if verbose:\n        print('Generating topK matrix')\n    nusers = item_weights.shape[0]\n    nitems = item_weights.shape[1]\n    k = min(k, nitems)\n    sparse_weights = not isinstance(item_weights, np.ndarray)\n    (data, cols_indices, rows_indptr) = ([], [], [])\n    if sparse_weights:\n        item_weights = check_matrix(item_weights, format='csc', dtype=np.float32)\n    else:\n        column_index = np.arange(nitems, dtype=np.int32)\n    for user_idx in range(nusers):\n        rows_indptr.append(len(data))\n        if sparse_weights:\n            start_position = item_weights.indptr[user_idx]\n            end_position = item_weights.indptr[user_idx + 1]\n            row_data = item_weights.data[start_position:end_position]\n            column_index = item_weights.indices[start_position:end_position]\n        else:\n            column_data = item_weights[user_idx, :]\n        non_zero_data = row_data != 0\n        idx_sorted = np.argsort(row_data[non_zero_data])\n        top_k_idx = idx_sorted[-k:]\n        data.extend(row_data[non_zero_data][top_k_idx])\n        cols_indices.extend(column_index[non_zero_data][top_k_idx])\n    rows_indptr.append(len(data))\n    W_sparse = sps.csr_matrix((data, cols_indices, rows_indptr), shape=(nusers, nitems), dtype=np.float32)\n    if verbose:\n        print('Sparse TopK matrix generated in {:.2f} seconds'.format(time.time() - start_time))\n    return W_sparse"
        ]
    }
]