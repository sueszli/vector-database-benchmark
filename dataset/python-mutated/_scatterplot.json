[
    {
        "func_name": "endpts_to_intervals",
        "original": "def endpts_to_intervals(endpts):\n    \"\"\"\n    Returns a list of intervals for categorical colormaps\n\n    Accepts a list or tuple of sequentially increasing numbers and returns\n    a list representation of the mathematical intervals with these numbers\n    as endpoints. For example, [1, 6] returns [[-inf, 1], [1, 6], [6, inf]]\n\n    :raises: (PlotlyError) If input is not a list or tuple\n    :raises: (PlotlyError) If the input contains a string\n    :raises: (PlotlyError) If any number does not increase after the\n        previous one in the sequence\n    \"\"\"\n    length = len(endpts)\n    if not (isinstance(endpts, tuple) or isinstance(endpts, list)):\n        raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for item in endpts:\n        if isinstance(item, str):\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for k in range(length - 1):\n        if endpts[k] >= endpts[k + 1]:\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    else:\n        intervals = []\n        intervals.append([float('-inf'), endpts[0]])\n        for k in range(length - 1):\n            interval = []\n            interval.append(endpts[k])\n            interval.append(endpts[k + 1])\n            intervals.append(interval)\n        intervals.append([endpts[length - 1], float('inf')])\n        return intervals",
        "mutated": [
            "def endpts_to_intervals(endpts):\n    if False:\n        i = 10\n    '\\n    Returns a list of intervals for categorical colormaps\\n\\n    Accepts a list or tuple of sequentially increasing numbers and returns\\n    a list representation of the mathematical intervals with these numbers\\n    as endpoints. For example, [1, 6] returns [[-inf, 1], [1, 6], [6, inf]]\\n\\n    :raises: (PlotlyError) If input is not a list or tuple\\n    :raises: (PlotlyError) If the input contains a string\\n    :raises: (PlotlyError) If any number does not increase after the\\n        previous one in the sequence\\n    '\n    length = len(endpts)\n    if not (isinstance(endpts, tuple) or isinstance(endpts, list)):\n        raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for item in endpts:\n        if isinstance(item, str):\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for k in range(length - 1):\n        if endpts[k] >= endpts[k + 1]:\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    else:\n        intervals = []\n        intervals.append([float('-inf'), endpts[0]])\n        for k in range(length - 1):\n            interval = []\n            interval.append(endpts[k])\n            interval.append(endpts[k + 1])\n            intervals.append(interval)\n        intervals.append([endpts[length - 1], float('inf')])\n        return intervals",
            "def endpts_to_intervals(endpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Returns a list of intervals for categorical colormaps\\n\\n    Accepts a list or tuple of sequentially increasing numbers and returns\\n    a list representation of the mathematical intervals with these numbers\\n    as endpoints. For example, [1, 6] returns [[-inf, 1], [1, 6], [6, inf]]\\n\\n    :raises: (PlotlyError) If input is not a list or tuple\\n    :raises: (PlotlyError) If the input contains a string\\n    :raises: (PlotlyError) If any number does not increase after the\\n        previous one in the sequence\\n    '\n    length = len(endpts)\n    if not (isinstance(endpts, tuple) or isinstance(endpts, list)):\n        raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for item in endpts:\n        if isinstance(item, str):\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for k in range(length - 1):\n        if endpts[k] >= endpts[k + 1]:\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    else:\n        intervals = []\n        intervals.append([float('-inf'), endpts[0]])\n        for k in range(length - 1):\n            interval = []\n            interval.append(endpts[k])\n            interval.append(endpts[k + 1])\n            intervals.append(interval)\n        intervals.append([endpts[length - 1], float('inf')])\n        return intervals",
            "def endpts_to_intervals(endpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Returns a list of intervals for categorical colormaps\\n\\n    Accepts a list or tuple of sequentially increasing numbers and returns\\n    a list representation of the mathematical intervals with these numbers\\n    as endpoints. For example, [1, 6] returns [[-inf, 1], [1, 6], [6, inf]]\\n\\n    :raises: (PlotlyError) If input is not a list or tuple\\n    :raises: (PlotlyError) If the input contains a string\\n    :raises: (PlotlyError) If any number does not increase after the\\n        previous one in the sequence\\n    '\n    length = len(endpts)\n    if not (isinstance(endpts, tuple) or isinstance(endpts, list)):\n        raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for item in endpts:\n        if isinstance(item, str):\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for k in range(length - 1):\n        if endpts[k] >= endpts[k + 1]:\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    else:\n        intervals = []\n        intervals.append([float('-inf'), endpts[0]])\n        for k in range(length - 1):\n            interval = []\n            interval.append(endpts[k])\n            interval.append(endpts[k + 1])\n            intervals.append(interval)\n        intervals.append([endpts[length - 1], float('inf')])\n        return intervals",
            "def endpts_to_intervals(endpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Returns a list of intervals for categorical colormaps\\n\\n    Accepts a list or tuple of sequentially increasing numbers and returns\\n    a list representation of the mathematical intervals with these numbers\\n    as endpoints. For example, [1, 6] returns [[-inf, 1], [1, 6], [6, inf]]\\n\\n    :raises: (PlotlyError) If input is not a list or tuple\\n    :raises: (PlotlyError) If the input contains a string\\n    :raises: (PlotlyError) If any number does not increase after the\\n        previous one in the sequence\\n    '\n    length = len(endpts)\n    if not (isinstance(endpts, tuple) or isinstance(endpts, list)):\n        raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for item in endpts:\n        if isinstance(item, str):\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for k in range(length - 1):\n        if endpts[k] >= endpts[k + 1]:\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    else:\n        intervals = []\n        intervals.append([float('-inf'), endpts[0]])\n        for k in range(length - 1):\n            interval = []\n            interval.append(endpts[k])\n            interval.append(endpts[k + 1])\n            intervals.append(interval)\n        intervals.append([endpts[length - 1], float('inf')])\n        return intervals",
            "def endpts_to_intervals(endpts):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Returns a list of intervals for categorical colormaps\\n\\n    Accepts a list or tuple of sequentially increasing numbers and returns\\n    a list representation of the mathematical intervals with these numbers\\n    as endpoints. For example, [1, 6] returns [[-inf, 1], [1, 6], [6, inf]]\\n\\n    :raises: (PlotlyError) If input is not a list or tuple\\n    :raises: (PlotlyError) If the input contains a string\\n    :raises: (PlotlyError) If any number does not increase after the\\n        previous one in the sequence\\n    '\n    length = len(endpts)\n    if not (isinstance(endpts, tuple) or isinstance(endpts, list)):\n        raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for item in endpts:\n        if isinstance(item, str):\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    for k in range(length - 1):\n        if endpts[k] >= endpts[k + 1]:\n            raise exceptions.PlotlyError('The intervals_endpts argument must be a list or tuple of a sequence of increasing numbers.')\n    else:\n        intervals = []\n        intervals.append([float('-inf'), endpts[0]])\n        for k in range(length - 1):\n            interval = []\n            interval.append(endpts[k])\n            interval.append(endpts[k + 1])\n            intervals.append(interval)\n        intervals.append([endpts[length - 1], float('inf')])\n        return intervals"
        ]
    },
    {
        "func_name": "hide_tick_labels_from_box_subplots",
        "original": "def hide_tick_labels_from_box_subplots(fig):\n    \"\"\"\n    Hides tick labels for box plots in scatterplotmatrix subplots.\n    \"\"\"\n    boxplot_xaxes = []\n    for trace in fig['data']:\n        if trace['type'] == 'box':\n            boxplot_xaxes.append('xaxis{}'.format(trace['xaxis'][1:]))\n    for xaxis in boxplot_xaxes:\n        fig['layout'][xaxis]['showticklabels'] = False",
        "mutated": [
            "def hide_tick_labels_from_box_subplots(fig):\n    if False:\n        i = 10\n    '\\n    Hides tick labels for box plots in scatterplotmatrix subplots.\\n    '\n    boxplot_xaxes = []\n    for trace in fig['data']:\n        if trace['type'] == 'box':\n            boxplot_xaxes.append('xaxis{}'.format(trace['xaxis'][1:]))\n    for xaxis in boxplot_xaxes:\n        fig['layout'][xaxis]['showticklabels'] = False",
            "def hide_tick_labels_from_box_subplots(fig):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Hides tick labels for box plots in scatterplotmatrix subplots.\\n    '\n    boxplot_xaxes = []\n    for trace in fig['data']:\n        if trace['type'] == 'box':\n            boxplot_xaxes.append('xaxis{}'.format(trace['xaxis'][1:]))\n    for xaxis in boxplot_xaxes:\n        fig['layout'][xaxis]['showticklabels'] = False",
            "def hide_tick_labels_from_box_subplots(fig):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Hides tick labels for box plots in scatterplotmatrix subplots.\\n    '\n    boxplot_xaxes = []\n    for trace in fig['data']:\n        if trace['type'] == 'box':\n            boxplot_xaxes.append('xaxis{}'.format(trace['xaxis'][1:]))\n    for xaxis in boxplot_xaxes:\n        fig['layout'][xaxis]['showticklabels'] = False",
            "def hide_tick_labels_from_box_subplots(fig):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Hides tick labels for box plots in scatterplotmatrix subplots.\\n    '\n    boxplot_xaxes = []\n    for trace in fig['data']:\n        if trace['type'] == 'box':\n            boxplot_xaxes.append('xaxis{}'.format(trace['xaxis'][1:]))\n    for xaxis in boxplot_xaxes:\n        fig['layout'][xaxis]['showticklabels'] = False",
            "def hide_tick_labels_from_box_subplots(fig):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Hides tick labels for box plots in scatterplotmatrix subplots.\\n    '\n    boxplot_xaxes = []\n    for trace in fig['data']:\n        if trace['type'] == 'box':\n            boxplot_xaxes.append('xaxis{}'.format(trace['xaxis'][1:]))\n    for xaxis in boxplot_xaxes:\n        fig['layout'][xaxis]['showticklabels'] = False"
        ]
    },
    {
        "func_name": "validate_scatterplotmatrix",
        "original": "def validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs):\n    \"\"\"\n    Validates basic inputs for FigureFactory.create_scatterplotmatrix()\n\n    :raises: (PlotlyError) If pandas is not imported\n    :raises: (PlotlyError) If pandas dataframe is not inputted\n    :raises: (PlotlyError) If pandas dataframe has <= 1 columns\n    :raises: (PlotlyError) If diagonal plot choice (diag) is not one of\n        the viable options\n    :raises: (PlotlyError) If colormap_type is not a valid choice\n    :raises: (PlotlyError) If kwargs contains 'size', 'color' or\n        'colorscale'\n    \"\"\"\n    if not pd:\n        raise ImportError('FigureFactory.scatterplotmatrix requires a pandas DataFrame.')\n    if not isinstance(df, pd.core.frame.DataFrame):\n        raise exceptions.PlotlyError('Dataframe not inputed. Please use a pandas dataframe to produce a scatterplot matrix.')\n    if len(df.columns) <= 1:\n        raise exceptions.PlotlyError('Dataframe has only one column. To use the scatterplot matrix, use at least 2 columns.')\n    if diag not in DIAG_CHOICES:\n        raise exceptions.PlotlyError('Make sure diag is set to one of {}'.format(DIAG_CHOICES))\n    if colormap_type not in VALID_COLORMAP_TYPES:\n        raise exceptions.PlotlyError(\"Must choose a valid colormap type. Either 'cat' or 'seq' for a categorical and sequential colormap respectively.\")\n    if 'marker' in kwargs:\n        FORBIDDEN_PARAMS = ['size', 'color', 'colorscale']\n        if any((param in kwargs['marker'] for param in FORBIDDEN_PARAMS)):\n            raise exceptions.PlotlyError(\"Your kwargs dictionary cannot include the 'size', 'color' or 'colorscale' key words inside the marker dict since 'size' is already an argument of the scatterplot matrix function and both 'color' and 'colorscale are set internally.\")",
        "mutated": [
            "def validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Validates basic inputs for FigureFactory.create_scatterplotmatrix()\\n\\n    :raises: (PlotlyError) If pandas is not imported\\n    :raises: (PlotlyError) If pandas dataframe is not inputted\\n    :raises: (PlotlyError) If pandas dataframe has <= 1 columns\\n    :raises: (PlotlyError) If diagonal plot choice (diag) is not one of\\n        the viable options\\n    :raises: (PlotlyError) If colormap_type is not a valid choice\\n    :raises: (PlotlyError) If kwargs contains 'size', 'color' or\\n        'colorscale'\\n    \"\n    if not pd:\n        raise ImportError('FigureFactory.scatterplotmatrix requires a pandas DataFrame.')\n    if not isinstance(df, pd.core.frame.DataFrame):\n        raise exceptions.PlotlyError('Dataframe not inputed. Please use a pandas dataframe to produce a scatterplot matrix.')\n    if len(df.columns) <= 1:\n        raise exceptions.PlotlyError('Dataframe has only one column. To use the scatterplot matrix, use at least 2 columns.')\n    if diag not in DIAG_CHOICES:\n        raise exceptions.PlotlyError('Make sure diag is set to one of {}'.format(DIAG_CHOICES))\n    if colormap_type not in VALID_COLORMAP_TYPES:\n        raise exceptions.PlotlyError(\"Must choose a valid colormap type. Either 'cat' or 'seq' for a categorical and sequential colormap respectively.\")\n    if 'marker' in kwargs:\n        FORBIDDEN_PARAMS = ['size', 'color', 'colorscale']\n        if any((param in kwargs['marker'] for param in FORBIDDEN_PARAMS)):\n            raise exceptions.PlotlyError(\"Your kwargs dictionary cannot include the 'size', 'color' or 'colorscale' key words inside the marker dict since 'size' is already an argument of the scatterplot matrix function and both 'color' and 'colorscale are set internally.\")",
            "def validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Validates basic inputs for FigureFactory.create_scatterplotmatrix()\\n\\n    :raises: (PlotlyError) If pandas is not imported\\n    :raises: (PlotlyError) If pandas dataframe is not inputted\\n    :raises: (PlotlyError) If pandas dataframe has <= 1 columns\\n    :raises: (PlotlyError) If diagonal plot choice (diag) is not one of\\n        the viable options\\n    :raises: (PlotlyError) If colormap_type is not a valid choice\\n    :raises: (PlotlyError) If kwargs contains 'size', 'color' or\\n        'colorscale'\\n    \"\n    if not pd:\n        raise ImportError('FigureFactory.scatterplotmatrix requires a pandas DataFrame.')\n    if not isinstance(df, pd.core.frame.DataFrame):\n        raise exceptions.PlotlyError('Dataframe not inputed. Please use a pandas dataframe to produce a scatterplot matrix.')\n    if len(df.columns) <= 1:\n        raise exceptions.PlotlyError('Dataframe has only one column. To use the scatterplot matrix, use at least 2 columns.')\n    if diag not in DIAG_CHOICES:\n        raise exceptions.PlotlyError('Make sure diag is set to one of {}'.format(DIAG_CHOICES))\n    if colormap_type not in VALID_COLORMAP_TYPES:\n        raise exceptions.PlotlyError(\"Must choose a valid colormap type. Either 'cat' or 'seq' for a categorical and sequential colormap respectively.\")\n    if 'marker' in kwargs:\n        FORBIDDEN_PARAMS = ['size', 'color', 'colorscale']\n        if any((param in kwargs['marker'] for param in FORBIDDEN_PARAMS)):\n            raise exceptions.PlotlyError(\"Your kwargs dictionary cannot include the 'size', 'color' or 'colorscale' key words inside the marker dict since 'size' is already an argument of the scatterplot matrix function and both 'color' and 'colorscale are set internally.\")",
            "def validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Validates basic inputs for FigureFactory.create_scatterplotmatrix()\\n\\n    :raises: (PlotlyError) If pandas is not imported\\n    :raises: (PlotlyError) If pandas dataframe is not inputted\\n    :raises: (PlotlyError) If pandas dataframe has <= 1 columns\\n    :raises: (PlotlyError) If diagonal plot choice (diag) is not one of\\n        the viable options\\n    :raises: (PlotlyError) If colormap_type is not a valid choice\\n    :raises: (PlotlyError) If kwargs contains 'size', 'color' or\\n        'colorscale'\\n    \"\n    if not pd:\n        raise ImportError('FigureFactory.scatterplotmatrix requires a pandas DataFrame.')\n    if not isinstance(df, pd.core.frame.DataFrame):\n        raise exceptions.PlotlyError('Dataframe not inputed. Please use a pandas dataframe to produce a scatterplot matrix.')\n    if len(df.columns) <= 1:\n        raise exceptions.PlotlyError('Dataframe has only one column. To use the scatterplot matrix, use at least 2 columns.')\n    if diag not in DIAG_CHOICES:\n        raise exceptions.PlotlyError('Make sure diag is set to one of {}'.format(DIAG_CHOICES))\n    if colormap_type not in VALID_COLORMAP_TYPES:\n        raise exceptions.PlotlyError(\"Must choose a valid colormap type. Either 'cat' or 'seq' for a categorical and sequential colormap respectively.\")\n    if 'marker' in kwargs:\n        FORBIDDEN_PARAMS = ['size', 'color', 'colorscale']\n        if any((param in kwargs['marker'] for param in FORBIDDEN_PARAMS)):\n            raise exceptions.PlotlyError(\"Your kwargs dictionary cannot include the 'size', 'color' or 'colorscale' key words inside the marker dict since 'size' is already an argument of the scatterplot matrix function and both 'color' and 'colorscale are set internally.\")",
            "def validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Validates basic inputs for FigureFactory.create_scatterplotmatrix()\\n\\n    :raises: (PlotlyError) If pandas is not imported\\n    :raises: (PlotlyError) If pandas dataframe is not inputted\\n    :raises: (PlotlyError) If pandas dataframe has <= 1 columns\\n    :raises: (PlotlyError) If diagonal plot choice (diag) is not one of\\n        the viable options\\n    :raises: (PlotlyError) If colormap_type is not a valid choice\\n    :raises: (PlotlyError) If kwargs contains 'size', 'color' or\\n        'colorscale'\\n    \"\n    if not pd:\n        raise ImportError('FigureFactory.scatterplotmatrix requires a pandas DataFrame.')\n    if not isinstance(df, pd.core.frame.DataFrame):\n        raise exceptions.PlotlyError('Dataframe not inputed. Please use a pandas dataframe to produce a scatterplot matrix.')\n    if len(df.columns) <= 1:\n        raise exceptions.PlotlyError('Dataframe has only one column. To use the scatterplot matrix, use at least 2 columns.')\n    if diag not in DIAG_CHOICES:\n        raise exceptions.PlotlyError('Make sure diag is set to one of {}'.format(DIAG_CHOICES))\n    if colormap_type not in VALID_COLORMAP_TYPES:\n        raise exceptions.PlotlyError(\"Must choose a valid colormap type. Either 'cat' or 'seq' for a categorical and sequential colormap respectively.\")\n    if 'marker' in kwargs:\n        FORBIDDEN_PARAMS = ['size', 'color', 'colorscale']\n        if any((param in kwargs['marker'] for param in FORBIDDEN_PARAMS)):\n            raise exceptions.PlotlyError(\"Your kwargs dictionary cannot include the 'size', 'color' or 'colorscale' key words inside the marker dict since 'size' is already an argument of the scatterplot matrix function and both 'color' and 'colorscale are set internally.\")",
            "def validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Validates basic inputs for FigureFactory.create_scatterplotmatrix()\\n\\n    :raises: (PlotlyError) If pandas is not imported\\n    :raises: (PlotlyError) If pandas dataframe is not inputted\\n    :raises: (PlotlyError) If pandas dataframe has <= 1 columns\\n    :raises: (PlotlyError) If diagonal plot choice (diag) is not one of\\n        the viable options\\n    :raises: (PlotlyError) If colormap_type is not a valid choice\\n    :raises: (PlotlyError) If kwargs contains 'size', 'color' or\\n        'colorscale'\\n    \"\n    if not pd:\n        raise ImportError('FigureFactory.scatterplotmatrix requires a pandas DataFrame.')\n    if not isinstance(df, pd.core.frame.DataFrame):\n        raise exceptions.PlotlyError('Dataframe not inputed. Please use a pandas dataframe to produce a scatterplot matrix.')\n    if len(df.columns) <= 1:\n        raise exceptions.PlotlyError('Dataframe has only one column. To use the scatterplot matrix, use at least 2 columns.')\n    if diag not in DIAG_CHOICES:\n        raise exceptions.PlotlyError('Make sure diag is set to one of {}'.format(DIAG_CHOICES))\n    if colormap_type not in VALID_COLORMAP_TYPES:\n        raise exceptions.PlotlyError(\"Must choose a valid colormap type. Either 'cat' or 'seq' for a categorical and sequential colormap respectively.\")\n    if 'marker' in kwargs:\n        FORBIDDEN_PARAMS = ['size', 'color', 'colorscale']\n        if any((param in kwargs['marker'] for param in FORBIDDEN_PARAMS)):\n            raise exceptions.PlotlyError(\"Your kwargs dictionary cannot include the 'size', 'color' or 'colorscale' key words inside the marker dict since 'size' is already an argument of the scatterplot matrix function and both 'color' and 'colorscale are set internally.\")"
        ]
    },
    {
        "func_name": "scatterplot",
        "original": "def scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs):\n    \"\"\"\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\n\n    Returns fig for scatterplotmatrix without index\n\n    \"\"\"\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    for listy in dataframe:\n        for listx in dataframe:\n            if listx == listy and diag == 'histogram':\n                trace = graph_objs.Histogram(x=listx, showlegend=False)\n            elif listx == listy and diag == 'box':\n                trace = graph_objs.Box(y=listx, name=None, showlegend=False)\n            elif 'marker' in kwargs:\n                kwargs['marker']['size'] = size\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                trace_list.append(trace)\n            else:\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size), showlegend=False, **kwargs)\n            trace_list.append(trace)\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            fig.append_trace(trace_list[trace_index], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n    hide_tick_labels_from_box_subplots(fig)\n    return fig",
        "mutated": [
            "def scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs):\n    if False:\n        i = 10\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix without index\\n\\n    '\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    for listy in dataframe:\n        for listx in dataframe:\n            if listx == listy and diag == 'histogram':\n                trace = graph_objs.Histogram(x=listx, showlegend=False)\n            elif listx == listy and diag == 'box':\n                trace = graph_objs.Box(y=listx, name=None, showlegend=False)\n            elif 'marker' in kwargs:\n                kwargs['marker']['size'] = size\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                trace_list.append(trace)\n            else:\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size), showlegend=False, **kwargs)\n            trace_list.append(trace)\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            fig.append_trace(trace_list[trace_index], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n    hide_tick_labels_from_box_subplots(fig)\n    return fig",
            "def scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix without index\\n\\n    '\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    for listy in dataframe:\n        for listx in dataframe:\n            if listx == listy and diag == 'histogram':\n                trace = graph_objs.Histogram(x=listx, showlegend=False)\n            elif listx == listy and diag == 'box':\n                trace = graph_objs.Box(y=listx, name=None, showlegend=False)\n            elif 'marker' in kwargs:\n                kwargs['marker']['size'] = size\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                trace_list.append(trace)\n            else:\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size), showlegend=False, **kwargs)\n            trace_list.append(trace)\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            fig.append_trace(trace_list[trace_index], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n    hide_tick_labels_from_box_subplots(fig)\n    return fig",
            "def scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix without index\\n\\n    '\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    for listy in dataframe:\n        for listx in dataframe:\n            if listx == listy and diag == 'histogram':\n                trace = graph_objs.Histogram(x=listx, showlegend=False)\n            elif listx == listy and diag == 'box':\n                trace = graph_objs.Box(y=listx, name=None, showlegend=False)\n            elif 'marker' in kwargs:\n                kwargs['marker']['size'] = size\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                trace_list.append(trace)\n            else:\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size), showlegend=False, **kwargs)\n            trace_list.append(trace)\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            fig.append_trace(trace_list[trace_index], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n    hide_tick_labels_from_box_subplots(fig)\n    return fig",
            "def scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix without index\\n\\n    '\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    for listy in dataframe:\n        for listx in dataframe:\n            if listx == listy and diag == 'histogram':\n                trace = graph_objs.Histogram(x=listx, showlegend=False)\n            elif listx == listy and diag == 'box':\n                trace = graph_objs.Box(y=listx, name=None, showlegend=False)\n            elif 'marker' in kwargs:\n                kwargs['marker']['size'] = size\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                trace_list.append(trace)\n            else:\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size), showlegend=False, **kwargs)\n            trace_list.append(trace)\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            fig.append_trace(trace_list[trace_index], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n    hide_tick_labels_from_box_subplots(fig)\n    return fig",
            "def scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix without index\\n\\n    '\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    for listy in dataframe:\n        for listx in dataframe:\n            if listx == listy and diag == 'histogram':\n                trace = graph_objs.Histogram(x=listx, showlegend=False)\n            elif listx == listy and diag == 'box':\n                trace = graph_objs.Box(y=listx, name=None, showlegend=False)\n            elif 'marker' in kwargs:\n                kwargs['marker']['size'] = size\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                trace_list.append(trace)\n            else:\n                trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size), showlegend=False, **kwargs)\n            trace_list.append(trace)\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            fig.append_trace(trace_list[trace_index], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n    hide_tick_labels_from_box_subplots(fig)\n    return fig"
        ]
    },
    {
        "func_name": "scatterplot_dict",
        "original": "def scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    \"\"\"\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\n\n    Returns fig for scatterplotmatrix with both index and colormap picked.\n    Used if colormap is a dictionary with index values as keys pointing to\n    colors. Forces colormap_type to behave categorically because it would\n    not make sense colors are assigned to each index value and thus\n    implies that a categorical approach should be taken\n\n    \"\"\"\n    theme = colormap\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    legend_param = 0\n    for listy in dataframe:\n        for listx in dataframe:\n            unique_index_vals = {}\n            for name in index_vals:\n                if name not in unique_index_vals:\n                    unique_index_vals[name] = []\n            for name in sorted(unique_index_vals.keys()):\n                new_listx = []\n                new_listy = []\n                for j in range(len(index_vals)):\n                    if index_vals[j] == name:\n                        new_listx.append(listx[j])\n                        new_listy.append(listy[j])\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=True)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=True)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[name]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=True, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = theme[name]\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=False, **kwargs)\n                unique_index_vals[name] = trace\n            trace_list.append(unique_index_vals)\n            legend_param += 1\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            for name in sorted(trace_list[trace_index].keys()):\n                fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    hide_tick_labels_from_box_subplots(fig)\n    if diag == 'histogram':\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n        return fig\n    else:\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n        return fig",
        "mutated": [
            "def scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    if False:\n        i = 10\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix with both index and colormap picked.\\n    Used if colormap is a dictionary with index values as keys pointing to\\n    colors. Forces colormap_type to behave categorically because it would\\n    not make sense colors are assigned to each index value and thus\\n    implies that a categorical approach should be taken\\n\\n    '\n    theme = colormap\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    legend_param = 0\n    for listy in dataframe:\n        for listx in dataframe:\n            unique_index_vals = {}\n            for name in index_vals:\n                if name not in unique_index_vals:\n                    unique_index_vals[name] = []\n            for name in sorted(unique_index_vals.keys()):\n                new_listx = []\n                new_listy = []\n                for j in range(len(index_vals)):\n                    if index_vals[j] == name:\n                        new_listx.append(listx[j])\n                        new_listy.append(listy[j])\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=True)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=True)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[name]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=True, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = theme[name]\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=False, **kwargs)\n                unique_index_vals[name] = trace\n            trace_list.append(unique_index_vals)\n            legend_param += 1\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            for name in sorted(trace_list[trace_index].keys()):\n                fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    hide_tick_labels_from_box_subplots(fig)\n    if diag == 'histogram':\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n        return fig\n    else:\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n        return fig",
            "def scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix with both index and colormap picked.\\n    Used if colormap is a dictionary with index values as keys pointing to\\n    colors. Forces colormap_type to behave categorically because it would\\n    not make sense colors are assigned to each index value and thus\\n    implies that a categorical approach should be taken\\n\\n    '\n    theme = colormap\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    legend_param = 0\n    for listy in dataframe:\n        for listx in dataframe:\n            unique_index_vals = {}\n            for name in index_vals:\n                if name not in unique_index_vals:\n                    unique_index_vals[name] = []\n            for name in sorted(unique_index_vals.keys()):\n                new_listx = []\n                new_listy = []\n                for j in range(len(index_vals)):\n                    if index_vals[j] == name:\n                        new_listx.append(listx[j])\n                        new_listy.append(listy[j])\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=True)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=True)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[name]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=True, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = theme[name]\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=False, **kwargs)\n                unique_index_vals[name] = trace\n            trace_list.append(unique_index_vals)\n            legend_param += 1\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            for name in sorted(trace_list[trace_index].keys()):\n                fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    hide_tick_labels_from_box_subplots(fig)\n    if diag == 'histogram':\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n        return fig\n    else:\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n        return fig",
            "def scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix with both index and colormap picked.\\n    Used if colormap is a dictionary with index values as keys pointing to\\n    colors. Forces colormap_type to behave categorically because it would\\n    not make sense colors are assigned to each index value and thus\\n    implies that a categorical approach should be taken\\n\\n    '\n    theme = colormap\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    legend_param = 0\n    for listy in dataframe:\n        for listx in dataframe:\n            unique_index_vals = {}\n            for name in index_vals:\n                if name not in unique_index_vals:\n                    unique_index_vals[name] = []\n            for name in sorted(unique_index_vals.keys()):\n                new_listx = []\n                new_listy = []\n                for j in range(len(index_vals)):\n                    if index_vals[j] == name:\n                        new_listx.append(listx[j])\n                        new_listy.append(listy[j])\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=True)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=True)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[name]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=True, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = theme[name]\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=False, **kwargs)\n                unique_index_vals[name] = trace\n            trace_list.append(unique_index_vals)\n            legend_param += 1\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            for name in sorted(trace_list[trace_index].keys()):\n                fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    hide_tick_labels_from_box_subplots(fig)\n    if diag == 'histogram':\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n        return fig\n    else:\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n        return fig",
            "def scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix with both index and colormap picked.\\n    Used if colormap is a dictionary with index values as keys pointing to\\n    colors. Forces colormap_type to behave categorically because it would\\n    not make sense colors are assigned to each index value and thus\\n    implies that a categorical approach should be taken\\n\\n    '\n    theme = colormap\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    legend_param = 0\n    for listy in dataframe:\n        for listx in dataframe:\n            unique_index_vals = {}\n            for name in index_vals:\n                if name not in unique_index_vals:\n                    unique_index_vals[name] = []\n            for name in sorted(unique_index_vals.keys()):\n                new_listx = []\n                new_listy = []\n                for j in range(len(index_vals)):\n                    if index_vals[j] == name:\n                        new_listx.append(listx[j])\n                        new_listy.append(listy[j])\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=True)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=True)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[name]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=True, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = theme[name]\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=False, **kwargs)\n                unique_index_vals[name] = trace\n            trace_list.append(unique_index_vals)\n            legend_param += 1\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            for name in sorted(trace_list[trace_index].keys()):\n                fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    hide_tick_labels_from_box_subplots(fig)\n    if diag == 'histogram':\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n        return fig\n    else:\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n        return fig",
            "def scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix with both index and colormap picked.\\n    Used if colormap is a dictionary with index values as keys pointing to\\n    colors. Forces colormap_type to behave categorically because it would\\n    not make sense colors are assigned to each index value and thus\\n    implies that a categorical approach should be taken\\n\\n    '\n    theme = colormap\n    dim = len(dataframe)\n    fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n    trace_list = []\n    legend_param = 0\n    for listy in dataframe:\n        for listx in dataframe:\n            unique_index_vals = {}\n            for name in index_vals:\n                if name not in unique_index_vals:\n                    unique_index_vals[name] = []\n            for name in sorted(unique_index_vals.keys()):\n                new_listx = []\n                new_listy = []\n                for j in range(len(index_vals)):\n                    if index_vals[j] == name:\n                        new_listx.append(listx[j])\n                        new_listy.append(listy[j])\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=True)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=True)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[name]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=True, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[name]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[name]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = theme[name]\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[name]), showlegend=False, **kwargs)\n                unique_index_vals[name] = trace\n            trace_list.append(unique_index_vals)\n            legend_param += 1\n    trace_index = 0\n    indices = range(1, dim + 1)\n    for y_index in indices:\n        for x_index in indices:\n            for name in sorted(trace_list[trace_index].keys()):\n                fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n            trace_index += 1\n    for j in range(dim):\n        xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n        fig['layout'][xaxis_key].update(title=headers[j])\n    for j in range(dim):\n        yaxis_key = 'yaxis{}'.format(1 + dim * j)\n        fig['layout'][yaxis_key].update(title=headers[j])\n    hide_tick_labels_from_box_subplots(fig)\n    if diag == 'histogram':\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n        return fig\n    else:\n        fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n        return fig"
        ]
    },
    {
        "func_name": "scatterplot_theme",
        "original": "def scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    \"\"\"\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\n\n    Returns fig for scatterplotmatrix with both index and colormap picked\n\n    \"\"\"\n    if isinstance(index_vals[0], str):\n        unique_index_vals = []\n        for name in index_vals:\n            if name not in unique_index_vals:\n                unique_index_vals.append(name)\n        n_colors_len = len(unique_index_vals)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], n_colors_len)\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                unique_index_vals = {}\n                for name in index_vals:\n                    if name not in unique_index_vals:\n                        unique_index_vals[name] = []\n                c_indx = 0\n                for name in sorted(unique_index_vals.keys()):\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if index_vals[j] == name:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    unique_index_vals[name] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(unique_index_vals)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for name in sorted(trace_list[trace_index].keys()):\n                    fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    elif endpts:\n        intervals = utils.endpts_to_intervals(endpts)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], len(intervals))\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                interval_labels = {}\n                for interval in intervals:\n                    interval_labels[str(interval)] = []\n                c_indx = 0\n                for interval in intervals:\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if interval[0] < index_vals[j] <= interval[1]:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    interval_labels[str(interval)] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(interval_labels)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for interval in intervals:\n                    fig.append_trace(trace_list[trace_index][str(interval)], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    else:\n        theme = colormap\n        if len(theme) <= 1:\n            theme.append(theme[0])\n        color = []\n        for incr in range(len(theme)):\n            color.append([1.0 / (len(theme) - 1) * incr, theme[incr]])\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = index_vals\n                        kwargs['marker']['colorscale'] = color\n                        kwargs['marker']['showscale'] = True\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=True), showlegend=False, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = index_vals\n                    kwargs['marker']['colorscale'] = color\n                    kwargs['marker']['showscale'] = False\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=False), showlegend=False, **kwargs)\n                trace_list.append(trace)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                fig.append_trace(trace_list[trace_index], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig",
        "mutated": [
            "def scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    if False:\n        i = 10\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix with both index and colormap picked\\n\\n    '\n    if isinstance(index_vals[0], str):\n        unique_index_vals = []\n        for name in index_vals:\n            if name not in unique_index_vals:\n                unique_index_vals.append(name)\n        n_colors_len = len(unique_index_vals)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], n_colors_len)\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                unique_index_vals = {}\n                for name in index_vals:\n                    if name not in unique_index_vals:\n                        unique_index_vals[name] = []\n                c_indx = 0\n                for name in sorted(unique_index_vals.keys()):\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if index_vals[j] == name:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    unique_index_vals[name] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(unique_index_vals)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for name in sorted(trace_list[trace_index].keys()):\n                    fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    elif endpts:\n        intervals = utils.endpts_to_intervals(endpts)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], len(intervals))\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                interval_labels = {}\n                for interval in intervals:\n                    interval_labels[str(interval)] = []\n                c_indx = 0\n                for interval in intervals:\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if interval[0] < index_vals[j] <= interval[1]:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    interval_labels[str(interval)] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(interval_labels)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for interval in intervals:\n                    fig.append_trace(trace_list[trace_index][str(interval)], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    else:\n        theme = colormap\n        if len(theme) <= 1:\n            theme.append(theme[0])\n        color = []\n        for incr in range(len(theme)):\n            color.append([1.0 / (len(theme) - 1) * incr, theme[incr]])\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = index_vals\n                        kwargs['marker']['colorscale'] = color\n                        kwargs['marker']['showscale'] = True\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=True), showlegend=False, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = index_vals\n                    kwargs['marker']['colorscale'] = color\n                    kwargs['marker']['showscale'] = False\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=False), showlegend=False, **kwargs)\n                trace_list.append(trace)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                fig.append_trace(trace_list[trace_index], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig",
            "def scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix with both index and colormap picked\\n\\n    '\n    if isinstance(index_vals[0], str):\n        unique_index_vals = []\n        for name in index_vals:\n            if name not in unique_index_vals:\n                unique_index_vals.append(name)\n        n_colors_len = len(unique_index_vals)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], n_colors_len)\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                unique_index_vals = {}\n                for name in index_vals:\n                    if name not in unique_index_vals:\n                        unique_index_vals[name] = []\n                c_indx = 0\n                for name in sorted(unique_index_vals.keys()):\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if index_vals[j] == name:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    unique_index_vals[name] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(unique_index_vals)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for name in sorted(trace_list[trace_index].keys()):\n                    fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    elif endpts:\n        intervals = utils.endpts_to_intervals(endpts)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], len(intervals))\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                interval_labels = {}\n                for interval in intervals:\n                    interval_labels[str(interval)] = []\n                c_indx = 0\n                for interval in intervals:\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if interval[0] < index_vals[j] <= interval[1]:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    interval_labels[str(interval)] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(interval_labels)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for interval in intervals:\n                    fig.append_trace(trace_list[trace_index][str(interval)], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    else:\n        theme = colormap\n        if len(theme) <= 1:\n            theme.append(theme[0])\n        color = []\n        for incr in range(len(theme)):\n            color.append([1.0 / (len(theme) - 1) * incr, theme[incr]])\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = index_vals\n                        kwargs['marker']['colorscale'] = color\n                        kwargs['marker']['showscale'] = True\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=True), showlegend=False, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = index_vals\n                    kwargs['marker']['colorscale'] = color\n                    kwargs['marker']['showscale'] = False\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=False), showlegend=False, **kwargs)\n                trace_list.append(trace)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                fig.append_trace(trace_list[trace_index], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig",
            "def scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix with both index and colormap picked\\n\\n    '\n    if isinstance(index_vals[0], str):\n        unique_index_vals = []\n        for name in index_vals:\n            if name not in unique_index_vals:\n                unique_index_vals.append(name)\n        n_colors_len = len(unique_index_vals)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], n_colors_len)\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                unique_index_vals = {}\n                for name in index_vals:\n                    if name not in unique_index_vals:\n                        unique_index_vals[name] = []\n                c_indx = 0\n                for name in sorted(unique_index_vals.keys()):\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if index_vals[j] == name:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    unique_index_vals[name] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(unique_index_vals)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for name in sorted(trace_list[trace_index].keys()):\n                    fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    elif endpts:\n        intervals = utils.endpts_to_intervals(endpts)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], len(intervals))\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                interval_labels = {}\n                for interval in intervals:\n                    interval_labels[str(interval)] = []\n                c_indx = 0\n                for interval in intervals:\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if interval[0] < index_vals[j] <= interval[1]:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    interval_labels[str(interval)] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(interval_labels)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for interval in intervals:\n                    fig.append_trace(trace_list[trace_index][str(interval)], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    else:\n        theme = colormap\n        if len(theme) <= 1:\n            theme.append(theme[0])\n        color = []\n        for incr in range(len(theme)):\n            color.append([1.0 / (len(theme) - 1) * incr, theme[incr]])\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = index_vals\n                        kwargs['marker']['colorscale'] = color\n                        kwargs['marker']['showscale'] = True\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=True), showlegend=False, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = index_vals\n                    kwargs['marker']['colorscale'] = color\n                    kwargs['marker']['showscale'] = False\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=False), showlegend=False, **kwargs)\n                trace_list.append(trace)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                fig.append_trace(trace_list[trace_index], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig",
            "def scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix with both index and colormap picked\\n\\n    '\n    if isinstance(index_vals[0], str):\n        unique_index_vals = []\n        for name in index_vals:\n            if name not in unique_index_vals:\n                unique_index_vals.append(name)\n        n_colors_len = len(unique_index_vals)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], n_colors_len)\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                unique_index_vals = {}\n                for name in index_vals:\n                    if name not in unique_index_vals:\n                        unique_index_vals[name] = []\n                c_indx = 0\n                for name in sorted(unique_index_vals.keys()):\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if index_vals[j] == name:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    unique_index_vals[name] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(unique_index_vals)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for name in sorted(trace_list[trace_index].keys()):\n                    fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    elif endpts:\n        intervals = utils.endpts_to_intervals(endpts)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], len(intervals))\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                interval_labels = {}\n                for interval in intervals:\n                    interval_labels[str(interval)] = []\n                c_indx = 0\n                for interval in intervals:\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if interval[0] < index_vals[j] <= interval[1]:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    interval_labels[str(interval)] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(interval_labels)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for interval in intervals:\n                    fig.append_trace(trace_list[trace_index][str(interval)], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    else:\n        theme = colormap\n        if len(theme) <= 1:\n            theme.append(theme[0])\n        color = []\n        for incr in range(len(theme)):\n            color.append([1.0 / (len(theme) - 1) * incr, theme[incr]])\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = index_vals\n                        kwargs['marker']['colorscale'] = color\n                        kwargs['marker']['showscale'] = True\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=True), showlegend=False, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = index_vals\n                    kwargs['marker']['colorscale'] = color\n                    kwargs['marker']['showscale'] = False\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=False), showlegend=False, **kwargs)\n                trace_list.append(trace)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                fig.append_trace(trace_list[trace_index], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig",
            "def scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Refer to FigureFactory.create_scatterplotmatrix() for docstring\\n\\n    Returns fig for scatterplotmatrix with both index and colormap picked\\n\\n    '\n    if isinstance(index_vals[0], str):\n        unique_index_vals = []\n        for name in index_vals:\n            if name not in unique_index_vals:\n                unique_index_vals.append(name)\n        n_colors_len = len(unique_index_vals)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], n_colors_len)\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                unique_index_vals = {}\n                for name in index_vals:\n                    if name not in unique_index_vals:\n                        unique_index_vals[name] = []\n                c_indx = 0\n                for name in sorted(unique_index_vals.keys()):\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if index_vals[j] == name:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=name, marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    unique_index_vals[name] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(unique_index_vals)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for name in sorted(trace_list[trace_index].keys()):\n                    fig.append_trace(trace_list[trace_index][name], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    elif endpts:\n        intervals = utils.endpts_to_intervals(endpts)\n        if colormap_type == 'seq':\n            foo = clrs.color_parser(colormap, clrs.unlabel_rgb)\n            foo = clrs.n_colors(foo[0], foo[1], len(intervals))\n            theme = clrs.color_parser(foo, clrs.label_rgb)\n        if colormap_type == 'cat':\n            theme = colormap\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                interval_labels = {}\n                for interval in intervals:\n                    interval_labels[str(interval)] = []\n                c_indx = 0\n                for interval in intervals:\n                    new_listx = []\n                    new_listy = []\n                    for j in range(len(index_vals)):\n                        if interval[0] < index_vals[j] <= interval[1]:\n                            new_listx.append(listx[j])\n                            new_listy.append(listy[j])\n                    if legend_param == 1:\n                        if listx == listy and diag == 'histogram':\n                            trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif listx == listy and diag == 'box':\n                            trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=True)\n                        elif 'marker' in kwargs:\n                            kwargs['marker']['size'] = size\n                            kwargs['marker']['color'] = theme[c_indx]\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=True, **kwargs)\n                        else:\n                            trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=True, **kwargs)\n                    elif listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=new_listx, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=new_listx, name=None, marker=dict(color=theme[c_indx]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = theme[c_indx]\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=new_listx, y=new_listy, mode='markers', name=str(interval), marker=dict(size=size, color=theme[c_indx]), showlegend=False, **kwargs)\n                    interval_labels[str(interval)] = trace\n                    if c_indx >= len(theme) - 1:\n                        c_indx = -1\n                    c_indx += 1\n                trace_list.append(interval_labels)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                for interval in intervals:\n                    fig.append_trace(trace_list[trace_index][str(interval)], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n    else:\n        theme = colormap\n        if len(theme) <= 1:\n            theme.append(theme[0])\n        color = []\n        for incr in range(len(theme)):\n            color.append([1.0 / (len(theme) - 1) * incr, theme[incr]])\n        dim = len(dataframe)\n        fig = make_subplots(rows=dim, cols=dim, print_grid=False)\n        trace_list = []\n        legend_param = 0\n        for listy in dataframe:\n            for listx in dataframe:\n                if legend_param == 1:\n                    if listx == listy and diag == 'histogram':\n                        trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif listx == listy and diag == 'box':\n                        trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                    elif 'marker' in kwargs:\n                        kwargs['marker']['size'] = size\n                        kwargs['marker']['color'] = index_vals\n                        kwargs['marker']['colorscale'] = color\n                        kwargs['marker']['showscale'] = True\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                    else:\n                        trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=True), showlegend=False, **kwargs)\n                elif listx == listy and diag == 'histogram':\n                    trace = graph_objs.Histogram(x=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif listx == listy and diag == 'box':\n                    trace = graph_objs.Box(y=listx, marker=dict(color=theme[0]), showlegend=False)\n                elif 'marker' in kwargs:\n                    kwargs['marker']['size'] = size\n                    kwargs['marker']['color'] = index_vals\n                    kwargs['marker']['colorscale'] = color\n                    kwargs['marker']['showscale'] = False\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', showlegend=False, **kwargs)\n                else:\n                    trace = graph_objs.Scatter(x=listx, y=listy, mode='markers', marker=dict(size=size, color=index_vals, colorscale=color, showscale=False), showlegend=False, **kwargs)\n                trace_list.append(trace)\n                legend_param += 1\n        trace_index = 0\n        indices = range(1, dim + 1)\n        for y_index in indices:\n            for x_index in indices:\n                fig.append_trace(trace_list[trace_index], y_index, x_index)\n                trace_index += 1\n        for j in range(dim):\n            xaxis_key = 'xaxis{}'.format(dim * dim - dim + 1 + j)\n            fig['layout'][xaxis_key].update(title=headers[j])\n        for j in range(dim):\n            yaxis_key = 'yaxis{}'.format(1 + dim * j)\n            fig['layout'][yaxis_key].update(title=headers[j])\n        hide_tick_labels_from_box_subplots(fig)\n        if diag == 'histogram':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True, barmode='stack')\n            return fig\n        elif diag == 'box':\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig\n        else:\n            fig['layout'].update(height=height, width=width, title=title, showlegend=True)\n            return fig"
        ]
    },
    {
        "func_name": "create_scatterplotmatrix",
        "original": "def create_scatterplotmatrix(df, index=None, endpts=None, diag='scatter', height=500, width=500, size=6, title='Scatterplot Matrix', colormap=None, colormap_type='cat', dataframe=None, headers=None, index_vals=None, **kwargs):\n    \"\"\"\n    Returns data for a scatterplot matrix;\n    **deprecated**,\n    use instead the plotly.graph_objects trace\n    :class:`plotly.graph_objects.Splom`.\n\n    :param (array) df: array of the data with column headers\n    :param (str) index: name of the index column in data array\n    :param (list|tuple) endpts: takes an increasing sequece of numbers\n        that defines intervals on the real line. They are used to group\n        the entries in an index of numbers into their corresponding\n        interval and therefore can be treated as categorical data\n    :param (str) diag: sets the chart type for the main diagonal plots.\n        The options are 'scatter', 'histogram' and 'box'.\n    :param (int|float) height: sets the height of the chart\n    :param (int|float) width: sets the width of the chart\n    :param (float) size: sets the marker size (in px)\n    :param (str) title: the title label of the scatterplot matrix\n    :param (str|tuple|list|dict) colormap: either a plotly scale name,\n        an rgb or hex color, a color tuple, a list of colors or a\n        dictionary. An rgb color is of the form 'rgb(x, y, z)' where\n        x, y and z belong to the interval [0, 255] and a color tuple is a\n        tuple of the form (a, b, c) where a, b and c belong to [0, 1].\n        If colormap is a list, it must contain valid color types as its\n        members.\n        If colormap is a dictionary, all the string entries in\n        the index column must be a key in colormap. In this case, the\n        colormap_type is forced to 'cat' or categorical\n    :param (str) colormap_type: determines how colormap is interpreted.\n        Valid choices are 'seq' (sequential) and 'cat' (categorical). If\n        'seq' is selected, only the first two colors in colormap will be\n        considered (when colormap is a list) and the index values will be\n        linearly interpolated between those two colors. This option is\n        forced if all index values are numeric.\n        If 'cat' is selected, a color from colormap will be assigned to\n        each category from index, including the intervals if endpts is\n        being used\n    :param (dict) **kwargs: a dictionary of scatterplot arguments\n        The only forbidden parameters are 'size', 'color' and\n        'colorscale' in 'marker'\n\n    Example 1: Vanilla Scatterplot Matrix\n\n    >>> from plotly.graph_objs import graph_objs\n    >>> from plotly.figure_factory import create_scatterplotmatrix\n\n    >>> import numpy as np\n    >>> import pandas as pd\n\n    >>> # Create dataframe\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\n    ...                 columns=['Column 1', 'Column 2'])\n\n    >>> # Create scatterplot matrix\n    >>> fig = create_scatterplotmatrix(df)\n    >>> fig.show()\n\n\n    Example 2: Indexing a Column\n\n    >>> from plotly.graph_objs import graph_objs\n    >>> from plotly.figure_factory import create_scatterplotmatrix\n\n    >>> import numpy as np\n    >>> import pandas as pd\n\n    >>> # Create dataframe with index\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\n    ...                    columns=['A', 'B'])\n\n    >>> # Add another column of strings to the dataframe\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\n\n    >>> # Create scatterplot matrix\n    >>> fig = create_scatterplotmatrix(df, index='Fruit', size=10)\n    >>> fig.show()\n\n\n    Example 3: Styling the Diagonal Subplots\n\n    >>> from plotly.graph_objs import graph_objs\n    >>> from plotly.figure_factory import create_scatterplotmatrix\n\n    >>> import numpy as np\n    >>> import pandas as pd\n\n    >>> # Create dataframe with index\n    >>> df = pd.DataFrame(np.random.randn(10, 4),\n    ...                    columns=['A', 'B', 'C', 'D'])\n\n    >>> # Add another column of strings to the dataframe\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\n\n    >>> # Create scatterplot matrix\n    >>> fig = create_scatterplotmatrix(df, diag='box', index='Fruit', height=1000,\n    ...                                width=1000)\n    >>> fig.show()\n\n\n    Example 4: Use a Theme to Style the Subplots\n\n    >>> from plotly.graph_objs import graph_objs\n    >>> from plotly.figure_factory import create_scatterplotmatrix\n\n    >>> import numpy as np\n    >>> import pandas as pd\n\n    >>> # Create dataframe with random data\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\n    ...                    columns=['A', 'B', 'C'])\n\n    >>> # Create scatterplot matrix using a built-in\n    >>> # Plotly palette scale and indexing column 'A'\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\n    ...                                colormap='Blues', height=800, width=800)\n    >>> fig.show()\n\n\n    Example 5: Example 4 with Interval Factoring\n\n    >>> from plotly.graph_objs import graph_objs\n    >>> from plotly.figure_factory import create_scatterplotmatrix\n\n    >>> import numpy as np\n    >>> import pandas as pd\n\n    >>> # Create dataframe with random data\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\n    ...                    columns=['A', 'B', 'C'])\n\n    >>> # Create scatterplot matrix using a list of 2 rgb tuples\n    >>> # and endpoints at -1, 0 and 1\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\n    ...                                colormap=['rgb(140, 255, 50)',\n    ...                                          'rgb(170, 60, 115)', '#6c4774',\n    ...                                          (0.5, 0.1, 0.8)],\n    ...                                endpts=[-1, 0, 1], height=800, width=800)\n    >>> fig.show()\n\n\n    Example 6: Using the colormap as a Dictionary\n\n    >>> from plotly.graph_objs import graph_objs\n    >>> from plotly.figure_factory import create_scatterplotmatrix\n\n    >>> import numpy as np\n    >>> import pandas as pd\n    >>> import random\n\n    >>> # Create dataframe with random data\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\n    ...                    columns=['Column A',\n    ...                             'Column B',\n    ...                             'Column C'])\n\n    >>> # Add new color column to dataframe\n    >>> new_column = []\n    >>> strange_colors = ['turquoise', 'limegreen', 'goldenrod']\n\n    >>> for j in range(100):\n    ...     new_column.append(random.choice(strange_colors))\n    >>> df['Colors'] = pd.Series(new_column, index=df.index)\n\n    >>> # Create scatterplot matrix using a dictionary of hex color values\n    >>> # which correspond to actual color names in 'Colors' column\n    >>> fig = create_scatterplotmatrix(\n    ...     df, diag='box', index='Colors',\n    ...     colormap= dict(\n    ...         turquoise = '#00F5FF',\n    ...         limegreen = '#32CD32',\n    ...         goldenrod = '#DAA520'\n    ...     ),\n    ...     colormap_type='cat',\n    ...     height=800, width=800\n    ... )\n    >>> fig.show()\n    \"\"\"\n    if dataframe is None:\n        dataframe = []\n    if headers is None:\n        headers = []\n    if index_vals is None:\n        index_vals = []\n    validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs)\n    if isinstance(colormap, dict):\n        colormap = clrs.validate_colors_dict(colormap, 'rgb')\n    elif isinstance(colormap, str) and 'rgb' not in colormap and ('#' not in colormap):\n        if colormap not in clrs.PLOTLY_SCALES.keys():\n            raise exceptions.PlotlyError(\"If 'colormap' is a string, it must be the name of a Plotly Colorscale. The available colorscale names are {}\".format(clrs.PLOTLY_SCALES.keys()))\n        else:\n            colormap = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES[colormap])\n            colormap = [colormap[0]] + [colormap[-1]]\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    else:\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    if not index:\n        for name in df:\n            headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        figure = scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs)\n        return figure\n    else:\n        if index not in df:\n            raise exceptions.PlotlyError('Make sure you set the index input variable to one of the column names of your dataframe.')\n        index_vals = df[index].values.tolist()\n        for name in df:\n            if name != index:\n                headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        utils.validate_index(index_vals)\n        if isinstance(colormap, dict):\n            for key in colormap:\n                if not all((index in colormap for index in index_vals)):\n                    raise exceptions.PlotlyError('If colormap is a dictionary, all the names in the index must be keys.')\n            figure = scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure\n        else:\n            figure = scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure",
        "mutated": [
            "def create_scatterplotmatrix(df, index=None, endpts=None, diag='scatter', height=500, width=500, size=6, title='Scatterplot Matrix', colormap=None, colormap_type='cat', dataframe=None, headers=None, index_vals=None, **kwargs):\n    if False:\n        i = 10\n    \"\\n    Returns data for a scatterplot matrix;\\n    **deprecated**,\\n    use instead the plotly.graph_objects trace\\n    :class:`plotly.graph_objects.Splom`.\\n\\n    :param (array) df: array of the data with column headers\\n    :param (str) index: name of the index column in data array\\n    :param (list|tuple) endpts: takes an increasing sequece of numbers\\n        that defines intervals on the real line. They are used to group\\n        the entries in an index of numbers into their corresponding\\n        interval and therefore can be treated as categorical data\\n    :param (str) diag: sets the chart type for the main diagonal plots.\\n        The options are 'scatter', 'histogram' and 'box'.\\n    :param (int|float) height: sets the height of the chart\\n    :param (int|float) width: sets the width of the chart\\n    :param (float) size: sets the marker size (in px)\\n    :param (str) title: the title label of the scatterplot matrix\\n    :param (str|tuple|list|dict) colormap: either a plotly scale name,\\n        an rgb or hex color, a color tuple, a list of colors or a\\n        dictionary. An rgb color is of the form 'rgb(x, y, z)' where\\n        x, y and z belong to the interval [0, 255] and a color tuple is a\\n        tuple of the form (a, b, c) where a, b and c belong to [0, 1].\\n        If colormap is a list, it must contain valid color types as its\\n        members.\\n        If colormap is a dictionary, all the string entries in\\n        the index column must be a key in colormap. In this case, the\\n        colormap_type is forced to 'cat' or categorical\\n    :param (str) colormap_type: determines how colormap is interpreted.\\n        Valid choices are 'seq' (sequential) and 'cat' (categorical). If\\n        'seq' is selected, only the first two colors in colormap will be\\n        considered (when colormap is a list) and the index values will be\\n        linearly interpolated between those two colors. This option is\\n        forced if all index values are numeric.\\n        If 'cat' is selected, a color from colormap will be assigned to\\n        each category from index, including the intervals if endpts is\\n        being used\\n    :param (dict) **kwargs: a dictionary of scatterplot arguments\\n        The only forbidden parameters are 'size', 'color' and\\n        'colorscale' in 'marker'\\n\\n    Example 1: Vanilla Scatterplot Matrix\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe\\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\\n    ...                 columns=['Column 1', 'Column 2'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df)\\n    >>> fig.show()\\n\\n\\n    Example 2: Indexing a Column\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with index\\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\\n    ...                    columns=['A', 'B'])\\n\\n    >>> # Add another column of strings to the dataframe\\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df, index='Fruit', size=10)\\n    >>> fig.show()\\n\\n\\n    Example 3: Styling the Diagonal Subplots\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with index\\n    >>> df = pd.DataFrame(np.random.randn(10, 4),\\n    ...                    columns=['A', 'B', 'C', 'D'])\\n\\n    >>> # Add another column of strings to the dataframe\\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df, diag='box', index='Fruit', height=1000,\\n    ...                                width=1000)\\n    >>> fig.show()\\n\\n\\n    Example 4: Use a Theme to Style the Subplots\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['A', 'B', 'C'])\\n\\n    >>> # Create scatterplot matrix using a built-in\\n    >>> # Plotly palette scale and indexing column 'A'\\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\\n    ...                                colormap='Blues', height=800, width=800)\\n    >>> fig.show()\\n\\n\\n    Example 5: Example 4 with Interval Factoring\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['A', 'B', 'C'])\\n\\n    >>> # Create scatterplot matrix using a list of 2 rgb tuples\\n    >>> # and endpoints at -1, 0 and 1\\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\\n    ...                                colormap=['rgb(140, 255, 50)',\\n    ...                                          'rgb(170, 60, 115)', '#6c4774',\\n    ...                                          (0.5, 0.1, 0.8)],\\n    ...                                endpts=[-1, 0, 1], height=800, width=800)\\n    >>> fig.show()\\n\\n\\n    Example 6: Using the colormap as a Dictionary\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n    >>> import random\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['Column A',\\n    ...                             'Column B',\\n    ...                             'Column C'])\\n\\n    >>> # Add new color column to dataframe\\n    >>> new_column = []\\n    >>> strange_colors = ['turquoise', 'limegreen', 'goldenrod']\\n\\n    >>> for j in range(100):\\n    ...     new_column.append(random.choice(strange_colors))\\n    >>> df['Colors'] = pd.Series(new_column, index=df.index)\\n\\n    >>> # Create scatterplot matrix using a dictionary of hex color values\\n    >>> # which correspond to actual color names in 'Colors' column\\n    >>> fig = create_scatterplotmatrix(\\n    ...     df, diag='box', index='Colors',\\n    ...     colormap= dict(\\n    ...         turquoise = '#00F5FF',\\n    ...         limegreen = '#32CD32',\\n    ...         goldenrod = '#DAA520'\\n    ...     ),\\n    ...     colormap_type='cat',\\n    ...     height=800, width=800\\n    ... )\\n    >>> fig.show()\\n    \"\n    if dataframe is None:\n        dataframe = []\n    if headers is None:\n        headers = []\n    if index_vals is None:\n        index_vals = []\n    validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs)\n    if isinstance(colormap, dict):\n        colormap = clrs.validate_colors_dict(colormap, 'rgb')\n    elif isinstance(colormap, str) and 'rgb' not in colormap and ('#' not in colormap):\n        if colormap not in clrs.PLOTLY_SCALES.keys():\n            raise exceptions.PlotlyError(\"If 'colormap' is a string, it must be the name of a Plotly Colorscale. The available colorscale names are {}\".format(clrs.PLOTLY_SCALES.keys()))\n        else:\n            colormap = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES[colormap])\n            colormap = [colormap[0]] + [colormap[-1]]\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    else:\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    if not index:\n        for name in df:\n            headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        figure = scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs)\n        return figure\n    else:\n        if index not in df:\n            raise exceptions.PlotlyError('Make sure you set the index input variable to one of the column names of your dataframe.')\n        index_vals = df[index].values.tolist()\n        for name in df:\n            if name != index:\n                headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        utils.validate_index(index_vals)\n        if isinstance(colormap, dict):\n            for key in colormap:\n                if not all((index in colormap for index in index_vals)):\n                    raise exceptions.PlotlyError('If colormap is a dictionary, all the names in the index must be keys.')\n            figure = scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure\n        else:\n            figure = scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure",
            "def create_scatterplotmatrix(df, index=None, endpts=None, diag='scatter', height=500, width=500, size=6, title='Scatterplot Matrix', colormap=None, colormap_type='cat', dataframe=None, headers=None, index_vals=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Returns data for a scatterplot matrix;\\n    **deprecated**,\\n    use instead the plotly.graph_objects trace\\n    :class:`plotly.graph_objects.Splom`.\\n\\n    :param (array) df: array of the data with column headers\\n    :param (str) index: name of the index column in data array\\n    :param (list|tuple) endpts: takes an increasing sequece of numbers\\n        that defines intervals on the real line. They are used to group\\n        the entries in an index of numbers into their corresponding\\n        interval and therefore can be treated as categorical data\\n    :param (str) diag: sets the chart type for the main diagonal plots.\\n        The options are 'scatter', 'histogram' and 'box'.\\n    :param (int|float) height: sets the height of the chart\\n    :param (int|float) width: sets the width of the chart\\n    :param (float) size: sets the marker size (in px)\\n    :param (str) title: the title label of the scatterplot matrix\\n    :param (str|tuple|list|dict) colormap: either a plotly scale name,\\n        an rgb or hex color, a color tuple, a list of colors or a\\n        dictionary. An rgb color is of the form 'rgb(x, y, z)' where\\n        x, y and z belong to the interval [0, 255] and a color tuple is a\\n        tuple of the form (a, b, c) where a, b and c belong to [0, 1].\\n        If colormap is a list, it must contain valid color types as its\\n        members.\\n        If colormap is a dictionary, all the string entries in\\n        the index column must be a key in colormap. In this case, the\\n        colormap_type is forced to 'cat' or categorical\\n    :param (str) colormap_type: determines how colormap is interpreted.\\n        Valid choices are 'seq' (sequential) and 'cat' (categorical). If\\n        'seq' is selected, only the first two colors in colormap will be\\n        considered (when colormap is a list) and the index values will be\\n        linearly interpolated between those two colors. This option is\\n        forced if all index values are numeric.\\n        If 'cat' is selected, a color from colormap will be assigned to\\n        each category from index, including the intervals if endpts is\\n        being used\\n    :param (dict) **kwargs: a dictionary of scatterplot arguments\\n        The only forbidden parameters are 'size', 'color' and\\n        'colorscale' in 'marker'\\n\\n    Example 1: Vanilla Scatterplot Matrix\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe\\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\\n    ...                 columns=['Column 1', 'Column 2'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df)\\n    >>> fig.show()\\n\\n\\n    Example 2: Indexing a Column\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with index\\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\\n    ...                    columns=['A', 'B'])\\n\\n    >>> # Add another column of strings to the dataframe\\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df, index='Fruit', size=10)\\n    >>> fig.show()\\n\\n\\n    Example 3: Styling the Diagonal Subplots\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with index\\n    >>> df = pd.DataFrame(np.random.randn(10, 4),\\n    ...                    columns=['A', 'B', 'C', 'D'])\\n\\n    >>> # Add another column of strings to the dataframe\\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df, diag='box', index='Fruit', height=1000,\\n    ...                                width=1000)\\n    >>> fig.show()\\n\\n\\n    Example 4: Use a Theme to Style the Subplots\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['A', 'B', 'C'])\\n\\n    >>> # Create scatterplot matrix using a built-in\\n    >>> # Plotly palette scale and indexing column 'A'\\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\\n    ...                                colormap='Blues', height=800, width=800)\\n    >>> fig.show()\\n\\n\\n    Example 5: Example 4 with Interval Factoring\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['A', 'B', 'C'])\\n\\n    >>> # Create scatterplot matrix using a list of 2 rgb tuples\\n    >>> # and endpoints at -1, 0 and 1\\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\\n    ...                                colormap=['rgb(140, 255, 50)',\\n    ...                                          'rgb(170, 60, 115)', '#6c4774',\\n    ...                                          (0.5, 0.1, 0.8)],\\n    ...                                endpts=[-1, 0, 1], height=800, width=800)\\n    >>> fig.show()\\n\\n\\n    Example 6: Using the colormap as a Dictionary\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n    >>> import random\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['Column A',\\n    ...                             'Column B',\\n    ...                             'Column C'])\\n\\n    >>> # Add new color column to dataframe\\n    >>> new_column = []\\n    >>> strange_colors = ['turquoise', 'limegreen', 'goldenrod']\\n\\n    >>> for j in range(100):\\n    ...     new_column.append(random.choice(strange_colors))\\n    >>> df['Colors'] = pd.Series(new_column, index=df.index)\\n\\n    >>> # Create scatterplot matrix using a dictionary of hex color values\\n    >>> # which correspond to actual color names in 'Colors' column\\n    >>> fig = create_scatterplotmatrix(\\n    ...     df, diag='box', index='Colors',\\n    ...     colormap= dict(\\n    ...         turquoise = '#00F5FF',\\n    ...         limegreen = '#32CD32',\\n    ...         goldenrod = '#DAA520'\\n    ...     ),\\n    ...     colormap_type='cat',\\n    ...     height=800, width=800\\n    ... )\\n    >>> fig.show()\\n    \"\n    if dataframe is None:\n        dataframe = []\n    if headers is None:\n        headers = []\n    if index_vals is None:\n        index_vals = []\n    validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs)\n    if isinstance(colormap, dict):\n        colormap = clrs.validate_colors_dict(colormap, 'rgb')\n    elif isinstance(colormap, str) and 'rgb' not in colormap and ('#' not in colormap):\n        if colormap not in clrs.PLOTLY_SCALES.keys():\n            raise exceptions.PlotlyError(\"If 'colormap' is a string, it must be the name of a Plotly Colorscale. The available colorscale names are {}\".format(clrs.PLOTLY_SCALES.keys()))\n        else:\n            colormap = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES[colormap])\n            colormap = [colormap[0]] + [colormap[-1]]\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    else:\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    if not index:\n        for name in df:\n            headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        figure = scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs)\n        return figure\n    else:\n        if index not in df:\n            raise exceptions.PlotlyError('Make sure you set the index input variable to one of the column names of your dataframe.')\n        index_vals = df[index].values.tolist()\n        for name in df:\n            if name != index:\n                headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        utils.validate_index(index_vals)\n        if isinstance(colormap, dict):\n            for key in colormap:\n                if not all((index in colormap for index in index_vals)):\n                    raise exceptions.PlotlyError('If colormap is a dictionary, all the names in the index must be keys.')\n            figure = scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure\n        else:\n            figure = scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure",
            "def create_scatterplotmatrix(df, index=None, endpts=None, diag='scatter', height=500, width=500, size=6, title='Scatterplot Matrix', colormap=None, colormap_type='cat', dataframe=None, headers=None, index_vals=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Returns data for a scatterplot matrix;\\n    **deprecated**,\\n    use instead the plotly.graph_objects trace\\n    :class:`plotly.graph_objects.Splom`.\\n\\n    :param (array) df: array of the data with column headers\\n    :param (str) index: name of the index column in data array\\n    :param (list|tuple) endpts: takes an increasing sequece of numbers\\n        that defines intervals on the real line. They are used to group\\n        the entries in an index of numbers into their corresponding\\n        interval and therefore can be treated as categorical data\\n    :param (str) diag: sets the chart type for the main diagonal plots.\\n        The options are 'scatter', 'histogram' and 'box'.\\n    :param (int|float) height: sets the height of the chart\\n    :param (int|float) width: sets the width of the chart\\n    :param (float) size: sets the marker size (in px)\\n    :param (str) title: the title label of the scatterplot matrix\\n    :param (str|tuple|list|dict) colormap: either a plotly scale name,\\n        an rgb or hex color, a color tuple, a list of colors or a\\n        dictionary. An rgb color is of the form 'rgb(x, y, z)' where\\n        x, y and z belong to the interval [0, 255] and a color tuple is a\\n        tuple of the form (a, b, c) where a, b and c belong to [0, 1].\\n        If colormap is a list, it must contain valid color types as its\\n        members.\\n        If colormap is a dictionary, all the string entries in\\n        the index column must be a key in colormap. In this case, the\\n        colormap_type is forced to 'cat' or categorical\\n    :param (str) colormap_type: determines how colormap is interpreted.\\n        Valid choices are 'seq' (sequential) and 'cat' (categorical). If\\n        'seq' is selected, only the first two colors in colormap will be\\n        considered (when colormap is a list) and the index values will be\\n        linearly interpolated between those two colors. This option is\\n        forced if all index values are numeric.\\n        If 'cat' is selected, a color from colormap will be assigned to\\n        each category from index, including the intervals if endpts is\\n        being used\\n    :param (dict) **kwargs: a dictionary of scatterplot arguments\\n        The only forbidden parameters are 'size', 'color' and\\n        'colorscale' in 'marker'\\n\\n    Example 1: Vanilla Scatterplot Matrix\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe\\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\\n    ...                 columns=['Column 1', 'Column 2'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df)\\n    >>> fig.show()\\n\\n\\n    Example 2: Indexing a Column\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with index\\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\\n    ...                    columns=['A', 'B'])\\n\\n    >>> # Add another column of strings to the dataframe\\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df, index='Fruit', size=10)\\n    >>> fig.show()\\n\\n\\n    Example 3: Styling the Diagonal Subplots\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with index\\n    >>> df = pd.DataFrame(np.random.randn(10, 4),\\n    ...                    columns=['A', 'B', 'C', 'D'])\\n\\n    >>> # Add another column of strings to the dataframe\\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df, diag='box', index='Fruit', height=1000,\\n    ...                                width=1000)\\n    >>> fig.show()\\n\\n\\n    Example 4: Use a Theme to Style the Subplots\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['A', 'B', 'C'])\\n\\n    >>> # Create scatterplot matrix using a built-in\\n    >>> # Plotly palette scale and indexing column 'A'\\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\\n    ...                                colormap='Blues', height=800, width=800)\\n    >>> fig.show()\\n\\n\\n    Example 5: Example 4 with Interval Factoring\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['A', 'B', 'C'])\\n\\n    >>> # Create scatterplot matrix using a list of 2 rgb tuples\\n    >>> # and endpoints at -1, 0 and 1\\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\\n    ...                                colormap=['rgb(140, 255, 50)',\\n    ...                                          'rgb(170, 60, 115)', '#6c4774',\\n    ...                                          (0.5, 0.1, 0.8)],\\n    ...                                endpts=[-1, 0, 1], height=800, width=800)\\n    >>> fig.show()\\n\\n\\n    Example 6: Using the colormap as a Dictionary\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n    >>> import random\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['Column A',\\n    ...                             'Column B',\\n    ...                             'Column C'])\\n\\n    >>> # Add new color column to dataframe\\n    >>> new_column = []\\n    >>> strange_colors = ['turquoise', 'limegreen', 'goldenrod']\\n\\n    >>> for j in range(100):\\n    ...     new_column.append(random.choice(strange_colors))\\n    >>> df['Colors'] = pd.Series(new_column, index=df.index)\\n\\n    >>> # Create scatterplot matrix using a dictionary of hex color values\\n    >>> # which correspond to actual color names in 'Colors' column\\n    >>> fig = create_scatterplotmatrix(\\n    ...     df, diag='box', index='Colors',\\n    ...     colormap= dict(\\n    ...         turquoise = '#00F5FF',\\n    ...         limegreen = '#32CD32',\\n    ...         goldenrod = '#DAA520'\\n    ...     ),\\n    ...     colormap_type='cat',\\n    ...     height=800, width=800\\n    ... )\\n    >>> fig.show()\\n    \"\n    if dataframe is None:\n        dataframe = []\n    if headers is None:\n        headers = []\n    if index_vals is None:\n        index_vals = []\n    validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs)\n    if isinstance(colormap, dict):\n        colormap = clrs.validate_colors_dict(colormap, 'rgb')\n    elif isinstance(colormap, str) and 'rgb' not in colormap and ('#' not in colormap):\n        if colormap not in clrs.PLOTLY_SCALES.keys():\n            raise exceptions.PlotlyError(\"If 'colormap' is a string, it must be the name of a Plotly Colorscale. The available colorscale names are {}\".format(clrs.PLOTLY_SCALES.keys()))\n        else:\n            colormap = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES[colormap])\n            colormap = [colormap[0]] + [colormap[-1]]\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    else:\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    if not index:\n        for name in df:\n            headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        figure = scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs)\n        return figure\n    else:\n        if index not in df:\n            raise exceptions.PlotlyError('Make sure you set the index input variable to one of the column names of your dataframe.')\n        index_vals = df[index].values.tolist()\n        for name in df:\n            if name != index:\n                headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        utils.validate_index(index_vals)\n        if isinstance(colormap, dict):\n            for key in colormap:\n                if not all((index in colormap for index in index_vals)):\n                    raise exceptions.PlotlyError('If colormap is a dictionary, all the names in the index must be keys.')\n            figure = scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure\n        else:\n            figure = scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure",
            "def create_scatterplotmatrix(df, index=None, endpts=None, diag='scatter', height=500, width=500, size=6, title='Scatterplot Matrix', colormap=None, colormap_type='cat', dataframe=None, headers=None, index_vals=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Returns data for a scatterplot matrix;\\n    **deprecated**,\\n    use instead the plotly.graph_objects trace\\n    :class:`plotly.graph_objects.Splom`.\\n\\n    :param (array) df: array of the data with column headers\\n    :param (str) index: name of the index column in data array\\n    :param (list|tuple) endpts: takes an increasing sequece of numbers\\n        that defines intervals on the real line. They are used to group\\n        the entries in an index of numbers into their corresponding\\n        interval and therefore can be treated as categorical data\\n    :param (str) diag: sets the chart type for the main diagonal plots.\\n        The options are 'scatter', 'histogram' and 'box'.\\n    :param (int|float) height: sets the height of the chart\\n    :param (int|float) width: sets the width of the chart\\n    :param (float) size: sets the marker size (in px)\\n    :param (str) title: the title label of the scatterplot matrix\\n    :param (str|tuple|list|dict) colormap: either a plotly scale name,\\n        an rgb or hex color, a color tuple, a list of colors or a\\n        dictionary. An rgb color is of the form 'rgb(x, y, z)' where\\n        x, y and z belong to the interval [0, 255] and a color tuple is a\\n        tuple of the form (a, b, c) where a, b and c belong to [0, 1].\\n        If colormap is a list, it must contain valid color types as its\\n        members.\\n        If colormap is a dictionary, all the string entries in\\n        the index column must be a key in colormap. In this case, the\\n        colormap_type is forced to 'cat' or categorical\\n    :param (str) colormap_type: determines how colormap is interpreted.\\n        Valid choices are 'seq' (sequential) and 'cat' (categorical). If\\n        'seq' is selected, only the first two colors in colormap will be\\n        considered (when colormap is a list) and the index values will be\\n        linearly interpolated between those two colors. This option is\\n        forced if all index values are numeric.\\n        If 'cat' is selected, a color from colormap will be assigned to\\n        each category from index, including the intervals if endpts is\\n        being used\\n    :param (dict) **kwargs: a dictionary of scatterplot arguments\\n        The only forbidden parameters are 'size', 'color' and\\n        'colorscale' in 'marker'\\n\\n    Example 1: Vanilla Scatterplot Matrix\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe\\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\\n    ...                 columns=['Column 1', 'Column 2'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df)\\n    >>> fig.show()\\n\\n\\n    Example 2: Indexing a Column\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with index\\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\\n    ...                    columns=['A', 'B'])\\n\\n    >>> # Add another column of strings to the dataframe\\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df, index='Fruit', size=10)\\n    >>> fig.show()\\n\\n\\n    Example 3: Styling the Diagonal Subplots\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with index\\n    >>> df = pd.DataFrame(np.random.randn(10, 4),\\n    ...                    columns=['A', 'B', 'C', 'D'])\\n\\n    >>> # Add another column of strings to the dataframe\\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df, diag='box', index='Fruit', height=1000,\\n    ...                                width=1000)\\n    >>> fig.show()\\n\\n\\n    Example 4: Use a Theme to Style the Subplots\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['A', 'B', 'C'])\\n\\n    >>> # Create scatterplot matrix using a built-in\\n    >>> # Plotly palette scale and indexing column 'A'\\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\\n    ...                                colormap='Blues', height=800, width=800)\\n    >>> fig.show()\\n\\n\\n    Example 5: Example 4 with Interval Factoring\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['A', 'B', 'C'])\\n\\n    >>> # Create scatterplot matrix using a list of 2 rgb tuples\\n    >>> # and endpoints at -1, 0 and 1\\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\\n    ...                                colormap=['rgb(140, 255, 50)',\\n    ...                                          'rgb(170, 60, 115)', '#6c4774',\\n    ...                                          (0.5, 0.1, 0.8)],\\n    ...                                endpts=[-1, 0, 1], height=800, width=800)\\n    >>> fig.show()\\n\\n\\n    Example 6: Using the colormap as a Dictionary\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n    >>> import random\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['Column A',\\n    ...                             'Column B',\\n    ...                             'Column C'])\\n\\n    >>> # Add new color column to dataframe\\n    >>> new_column = []\\n    >>> strange_colors = ['turquoise', 'limegreen', 'goldenrod']\\n\\n    >>> for j in range(100):\\n    ...     new_column.append(random.choice(strange_colors))\\n    >>> df['Colors'] = pd.Series(new_column, index=df.index)\\n\\n    >>> # Create scatterplot matrix using a dictionary of hex color values\\n    >>> # which correspond to actual color names in 'Colors' column\\n    >>> fig = create_scatterplotmatrix(\\n    ...     df, diag='box', index='Colors',\\n    ...     colormap= dict(\\n    ...         turquoise = '#00F5FF',\\n    ...         limegreen = '#32CD32',\\n    ...         goldenrod = '#DAA520'\\n    ...     ),\\n    ...     colormap_type='cat',\\n    ...     height=800, width=800\\n    ... )\\n    >>> fig.show()\\n    \"\n    if dataframe is None:\n        dataframe = []\n    if headers is None:\n        headers = []\n    if index_vals is None:\n        index_vals = []\n    validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs)\n    if isinstance(colormap, dict):\n        colormap = clrs.validate_colors_dict(colormap, 'rgb')\n    elif isinstance(colormap, str) and 'rgb' not in colormap and ('#' not in colormap):\n        if colormap not in clrs.PLOTLY_SCALES.keys():\n            raise exceptions.PlotlyError(\"If 'colormap' is a string, it must be the name of a Plotly Colorscale. The available colorscale names are {}\".format(clrs.PLOTLY_SCALES.keys()))\n        else:\n            colormap = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES[colormap])\n            colormap = [colormap[0]] + [colormap[-1]]\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    else:\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    if not index:\n        for name in df:\n            headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        figure = scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs)\n        return figure\n    else:\n        if index not in df:\n            raise exceptions.PlotlyError('Make sure you set the index input variable to one of the column names of your dataframe.')\n        index_vals = df[index].values.tolist()\n        for name in df:\n            if name != index:\n                headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        utils.validate_index(index_vals)\n        if isinstance(colormap, dict):\n            for key in colormap:\n                if not all((index in colormap for index in index_vals)):\n                    raise exceptions.PlotlyError('If colormap is a dictionary, all the names in the index must be keys.')\n            figure = scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure\n        else:\n            figure = scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure",
            "def create_scatterplotmatrix(df, index=None, endpts=None, diag='scatter', height=500, width=500, size=6, title='Scatterplot Matrix', colormap=None, colormap_type='cat', dataframe=None, headers=None, index_vals=None, **kwargs):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Returns data for a scatterplot matrix;\\n    **deprecated**,\\n    use instead the plotly.graph_objects trace\\n    :class:`plotly.graph_objects.Splom`.\\n\\n    :param (array) df: array of the data with column headers\\n    :param (str) index: name of the index column in data array\\n    :param (list|tuple) endpts: takes an increasing sequece of numbers\\n        that defines intervals on the real line. They are used to group\\n        the entries in an index of numbers into their corresponding\\n        interval and therefore can be treated as categorical data\\n    :param (str) diag: sets the chart type for the main diagonal plots.\\n        The options are 'scatter', 'histogram' and 'box'.\\n    :param (int|float) height: sets the height of the chart\\n    :param (int|float) width: sets the width of the chart\\n    :param (float) size: sets the marker size (in px)\\n    :param (str) title: the title label of the scatterplot matrix\\n    :param (str|tuple|list|dict) colormap: either a plotly scale name,\\n        an rgb or hex color, a color tuple, a list of colors or a\\n        dictionary. An rgb color is of the form 'rgb(x, y, z)' where\\n        x, y and z belong to the interval [0, 255] and a color tuple is a\\n        tuple of the form (a, b, c) where a, b and c belong to [0, 1].\\n        If colormap is a list, it must contain valid color types as its\\n        members.\\n        If colormap is a dictionary, all the string entries in\\n        the index column must be a key in colormap. In this case, the\\n        colormap_type is forced to 'cat' or categorical\\n    :param (str) colormap_type: determines how colormap is interpreted.\\n        Valid choices are 'seq' (sequential) and 'cat' (categorical). If\\n        'seq' is selected, only the first two colors in colormap will be\\n        considered (when colormap is a list) and the index values will be\\n        linearly interpolated between those two colors. This option is\\n        forced if all index values are numeric.\\n        If 'cat' is selected, a color from colormap will be assigned to\\n        each category from index, including the intervals if endpts is\\n        being used\\n    :param (dict) **kwargs: a dictionary of scatterplot arguments\\n        The only forbidden parameters are 'size', 'color' and\\n        'colorscale' in 'marker'\\n\\n    Example 1: Vanilla Scatterplot Matrix\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe\\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\\n    ...                 columns=['Column 1', 'Column 2'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df)\\n    >>> fig.show()\\n\\n\\n    Example 2: Indexing a Column\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with index\\n    >>> df = pd.DataFrame(np.random.randn(10, 2),\\n    ...                    columns=['A', 'B'])\\n\\n    >>> # Add another column of strings to the dataframe\\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df, index='Fruit', size=10)\\n    >>> fig.show()\\n\\n\\n    Example 3: Styling the Diagonal Subplots\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with index\\n    >>> df = pd.DataFrame(np.random.randn(10, 4),\\n    ...                    columns=['A', 'B', 'C', 'D'])\\n\\n    >>> # Add another column of strings to the dataframe\\n    >>> df['Fruit'] = pd.Series(['apple', 'apple', 'grape', 'apple', 'apple',\\n    ...                          'grape', 'pear', 'pear', 'apple', 'pear'])\\n\\n    >>> # Create scatterplot matrix\\n    >>> fig = create_scatterplotmatrix(df, diag='box', index='Fruit', height=1000,\\n    ...                                width=1000)\\n    >>> fig.show()\\n\\n\\n    Example 4: Use a Theme to Style the Subplots\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['A', 'B', 'C'])\\n\\n    >>> # Create scatterplot matrix using a built-in\\n    >>> # Plotly palette scale and indexing column 'A'\\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\\n    ...                                colormap='Blues', height=800, width=800)\\n    >>> fig.show()\\n\\n\\n    Example 5: Example 4 with Interval Factoring\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['A', 'B', 'C'])\\n\\n    >>> # Create scatterplot matrix using a list of 2 rgb tuples\\n    >>> # and endpoints at -1, 0 and 1\\n    >>> fig = create_scatterplotmatrix(df, diag='histogram', index='A',\\n    ...                                colormap=['rgb(140, 255, 50)',\\n    ...                                          'rgb(170, 60, 115)', '#6c4774',\\n    ...                                          (0.5, 0.1, 0.8)],\\n    ...                                endpts=[-1, 0, 1], height=800, width=800)\\n    >>> fig.show()\\n\\n\\n    Example 6: Using the colormap as a Dictionary\\n\\n    >>> from plotly.graph_objs import graph_objs\\n    >>> from plotly.figure_factory import create_scatterplotmatrix\\n\\n    >>> import numpy as np\\n    >>> import pandas as pd\\n    >>> import random\\n\\n    >>> # Create dataframe with random data\\n    >>> df = pd.DataFrame(np.random.randn(100, 3),\\n    ...                    columns=['Column A',\\n    ...                             'Column B',\\n    ...                             'Column C'])\\n\\n    >>> # Add new color column to dataframe\\n    >>> new_column = []\\n    >>> strange_colors = ['turquoise', 'limegreen', 'goldenrod']\\n\\n    >>> for j in range(100):\\n    ...     new_column.append(random.choice(strange_colors))\\n    >>> df['Colors'] = pd.Series(new_column, index=df.index)\\n\\n    >>> # Create scatterplot matrix using a dictionary of hex color values\\n    >>> # which correspond to actual color names in 'Colors' column\\n    >>> fig = create_scatterplotmatrix(\\n    ...     df, diag='box', index='Colors',\\n    ...     colormap= dict(\\n    ...         turquoise = '#00F5FF',\\n    ...         limegreen = '#32CD32',\\n    ...         goldenrod = '#DAA520'\\n    ...     ),\\n    ...     colormap_type='cat',\\n    ...     height=800, width=800\\n    ... )\\n    >>> fig.show()\\n    \"\n    if dataframe is None:\n        dataframe = []\n    if headers is None:\n        headers = []\n    if index_vals is None:\n        index_vals = []\n    validate_scatterplotmatrix(df, index, diag, colormap_type, **kwargs)\n    if isinstance(colormap, dict):\n        colormap = clrs.validate_colors_dict(colormap, 'rgb')\n    elif isinstance(colormap, str) and 'rgb' not in colormap and ('#' not in colormap):\n        if colormap not in clrs.PLOTLY_SCALES.keys():\n            raise exceptions.PlotlyError(\"If 'colormap' is a string, it must be the name of a Plotly Colorscale. The available colorscale names are {}\".format(clrs.PLOTLY_SCALES.keys()))\n        else:\n            colormap = clrs.colorscale_to_colors(clrs.PLOTLY_SCALES[colormap])\n            colormap = [colormap[0]] + [colormap[-1]]\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    else:\n        colormap = clrs.validate_colors(colormap, 'rgb')\n    if not index:\n        for name in df:\n            headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        figure = scatterplot(dataframe, headers, diag, size, height, width, title, **kwargs)\n        return figure\n    else:\n        if index not in df:\n            raise exceptions.PlotlyError('Make sure you set the index input variable to one of the column names of your dataframe.')\n        index_vals = df[index].values.tolist()\n        for name in df:\n            if name != index:\n                headers.append(name)\n        for name in headers:\n            dataframe.append(df[name].values.tolist())\n        utils.validate_dataframe(dataframe)\n        utils.validate_index(index_vals)\n        if isinstance(colormap, dict):\n            for key in colormap:\n                if not all((index in colormap for index in index_vals)):\n                    raise exceptions.PlotlyError('If colormap is a dictionary, all the names in the index must be keys.')\n            figure = scatterplot_dict(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure\n        else:\n            figure = scatterplot_theme(dataframe, headers, diag, size, height, width, title, index, index_vals, endpts, colormap, colormap_type, **kwargs)\n            return figure"
        ]
    }
]