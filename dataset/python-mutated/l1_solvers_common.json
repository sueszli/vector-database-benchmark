[
    {
        "func_name": "qc_results",
        "original": "def qc_results(params, alpha, score, qc_tol, qc_verbose=False):\n    \"\"\"\n    Theory dictates that one of two conditions holds:\n        i) abs(score[i]) == alpha[i]  and  params[i] != 0\n        ii) abs(score[i]) <= alpha[i]  and  params[i] == 0\n    qc_results checks to see that (ii) holds, within qc_tol\n\n    qc_results also checks for nan or results of the wrong shape.\n\n    Parameters\n    ----------\n    params : ndarray\n        model parameters.  Not including the added variables x_added.\n    alpha : ndarray\n        regularization coefficients\n    score : function\n        Gradient of unregularized objective function\n    qc_tol : float\n        Tolerance to hold conditions (i) and (ii) to for QC check.\n    qc_verbose : bool\n        If true, print out a full QC report upon failure\n\n    Returns\n    -------\n    passed : bool\n        True if QC check passed\n    qc_dict : Dictionary\n        Keys are fprime, alpha, params, passed_array\n\n    Prints\n    ------\n    Warning message if QC check fails.\n    \"\"\"\n    assert not np.isnan(params).max()\n    assert (params == params.ravel('F')).min(), 'params should have already been 1-d'\n    fprime = score(params)\n    k_params = len(params)\n    passed_array = np.array([True] * k_params)\n    for i in range(k_params):\n        if alpha[i] > 0:\n            if (abs(fprime[i]) - alpha[i]) / alpha[i] > qc_tol:\n                passed_array[i] = False\n    qc_dict = dict(fprime=fprime, alpha=alpha, params=params, passed_array=passed_array)\n    passed = passed_array.min()\n    if not passed:\n        num_failed = (~passed_array).sum()\n        message = 'QC check did not pass for %d out of %d parameters' % (num_failed, k_params)\n        message += '\\nTry increasing solver accuracy or number of iterations, decreasing alpha, or switch solvers'\n        if qc_verbose:\n            message += _get_verbose_addon(qc_dict)\n        import warnings\n        warnings.warn(message, ConvergenceWarning)\n    return passed",
        "mutated": [
            "def qc_results(params, alpha, score, qc_tol, qc_verbose=False):\n    if False:\n        i = 10\n    '\\n    Theory dictates that one of two conditions holds:\\n        i) abs(score[i]) == alpha[i]  and  params[i] != 0\\n        ii) abs(score[i]) <= alpha[i]  and  params[i] == 0\\n    qc_results checks to see that (ii) holds, within qc_tol\\n\\n    qc_results also checks for nan or results of the wrong shape.\\n\\n    Parameters\\n    ----------\\n    params : ndarray\\n        model parameters.  Not including the added variables x_added.\\n    alpha : ndarray\\n        regularization coefficients\\n    score : function\\n        Gradient of unregularized objective function\\n    qc_tol : float\\n        Tolerance to hold conditions (i) and (ii) to for QC check.\\n    qc_verbose : bool\\n        If true, print out a full QC report upon failure\\n\\n    Returns\\n    -------\\n    passed : bool\\n        True if QC check passed\\n    qc_dict : Dictionary\\n        Keys are fprime, alpha, params, passed_array\\n\\n    Prints\\n    ------\\n    Warning message if QC check fails.\\n    '\n    assert not np.isnan(params).max()\n    assert (params == params.ravel('F')).min(), 'params should have already been 1-d'\n    fprime = score(params)\n    k_params = len(params)\n    passed_array = np.array([True] * k_params)\n    for i in range(k_params):\n        if alpha[i] > 0:\n            if (abs(fprime[i]) - alpha[i]) / alpha[i] > qc_tol:\n                passed_array[i] = False\n    qc_dict = dict(fprime=fprime, alpha=alpha, params=params, passed_array=passed_array)\n    passed = passed_array.min()\n    if not passed:\n        num_failed = (~passed_array).sum()\n        message = 'QC check did not pass for %d out of %d parameters' % (num_failed, k_params)\n        message += '\\nTry increasing solver accuracy or number of iterations, decreasing alpha, or switch solvers'\n        if qc_verbose:\n            message += _get_verbose_addon(qc_dict)\n        import warnings\n        warnings.warn(message, ConvergenceWarning)\n    return passed",
            "def qc_results(params, alpha, score, qc_tol, qc_verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Theory dictates that one of two conditions holds:\\n        i) abs(score[i]) == alpha[i]  and  params[i] != 0\\n        ii) abs(score[i]) <= alpha[i]  and  params[i] == 0\\n    qc_results checks to see that (ii) holds, within qc_tol\\n\\n    qc_results also checks for nan or results of the wrong shape.\\n\\n    Parameters\\n    ----------\\n    params : ndarray\\n        model parameters.  Not including the added variables x_added.\\n    alpha : ndarray\\n        regularization coefficients\\n    score : function\\n        Gradient of unregularized objective function\\n    qc_tol : float\\n        Tolerance to hold conditions (i) and (ii) to for QC check.\\n    qc_verbose : bool\\n        If true, print out a full QC report upon failure\\n\\n    Returns\\n    -------\\n    passed : bool\\n        True if QC check passed\\n    qc_dict : Dictionary\\n        Keys are fprime, alpha, params, passed_array\\n\\n    Prints\\n    ------\\n    Warning message if QC check fails.\\n    '\n    assert not np.isnan(params).max()\n    assert (params == params.ravel('F')).min(), 'params should have already been 1-d'\n    fprime = score(params)\n    k_params = len(params)\n    passed_array = np.array([True] * k_params)\n    for i in range(k_params):\n        if alpha[i] > 0:\n            if (abs(fprime[i]) - alpha[i]) / alpha[i] > qc_tol:\n                passed_array[i] = False\n    qc_dict = dict(fprime=fprime, alpha=alpha, params=params, passed_array=passed_array)\n    passed = passed_array.min()\n    if not passed:\n        num_failed = (~passed_array).sum()\n        message = 'QC check did not pass for %d out of %d parameters' % (num_failed, k_params)\n        message += '\\nTry increasing solver accuracy or number of iterations, decreasing alpha, or switch solvers'\n        if qc_verbose:\n            message += _get_verbose_addon(qc_dict)\n        import warnings\n        warnings.warn(message, ConvergenceWarning)\n    return passed",
            "def qc_results(params, alpha, score, qc_tol, qc_verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Theory dictates that one of two conditions holds:\\n        i) abs(score[i]) == alpha[i]  and  params[i] != 0\\n        ii) abs(score[i]) <= alpha[i]  and  params[i] == 0\\n    qc_results checks to see that (ii) holds, within qc_tol\\n\\n    qc_results also checks for nan or results of the wrong shape.\\n\\n    Parameters\\n    ----------\\n    params : ndarray\\n        model parameters.  Not including the added variables x_added.\\n    alpha : ndarray\\n        regularization coefficients\\n    score : function\\n        Gradient of unregularized objective function\\n    qc_tol : float\\n        Tolerance to hold conditions (i) and (ii) to for QC check.\\n    qc_verbose : bool\\n        If true, print out a full QC report upon failure\\n\\n    Returns\\n    -------\\n    passed : bool\\n        True if QC check passed\\n    qc_dict : Dictionary\\n        Keys are fprime, alpha, params, passed_array\\n\\n    Prints\\n    ------\\n    Warning message if QC check fails.\\n    '\n    assert not np.isnan(params).max()\n    assert (params == params.ravel('F')).min(), 'params should have already been 1-d'\n    fprime = score(params)\n    k_params = len(params)\n    passed_array = np.array([True] * k_params)\n    for i in range(k_params):\n        if alpha[i] > 0:\n            if (abs(fprime[i]) - alpha[i]) / alpha[i] > qc_tol:\n                passed_array[i] = False\n    qc_dict = dict(fprime=fprime, alpha=alpha, params=params, passed_array=passed_array)\n    passed = passed_array.min()\n    if not passed:\n        num_failed = (~passed_array).sum()\n        message = 'QC check did not pass for %d out of %d parameters' % (num_failed, k_params)\n        message += '\\nTry increasing solver accuracy or number of iterations, decreasing alpha, or switch solvers'\n        if qc_verbose:\n            message += _get_verbose_addon(qc_dict)\n        import warnings\n        warnings.warn(message, ConvergenceWarning)\n    return passed",
            "def qc_results(params, alpha, score, qc_tol, qc_verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Theory dictates that one of two conditions holds:\\n        i) abs(score[i]) == alpha[i]  and  params[i] != 0\\n        ii) abs(score[i]) <= alpha[i]  and  params[i] == 0\\n    qc_results checks to see that (ii) holds, within qc_tol\\n\\n    qc_results also checks for nan or results of the wrong shape.\\n\\n    Parameters\\n    ----------\\n    params : ndarray\\n        model parameters.  Not including the added variables x_added.\\n    alpha : ndarray\\n        regularization coefficients\\n    score : function\\n        Gradient of unregularized objective function\\n    qc_tol : float\\n        Tolerance to hold conditions (i) and (ii) to for QC check.\\n    qc_verbose : bool\\n        If true, print out a full QC report upon failure\\n\\n    Returns\\n    -------\\n    passed : bool\\n        True if QC check passed\\n    qc_dict : Dictionary\\n        Keys are fprime, alpha, params, passed_array\\n\\n    Prints\\n    ------\\n    Warning message if QC check fails.\\n    '\n    assert not np.isnan(params).max()\n    assert (params == params.ravel('F')).min(), 'params should have already been 1-d'\n    fprime = score(params)\n    k_params = len(params)\n    passed_array = np.array([True] * k_params)\n    for i in range(k_params):\n        if alpha[i] > 0:\n            if (abs(fprime[i]) - alpha[i]) / alpha[i] > qc_tol:\n                passed_array[i] = False\n    qc_dict = dict(fprime=fprime, alpha=alpha, params=params, passed_array=passed_array)\n    passed = passed_array.min()\n    if not passed:\n        num_failed = (~passed_array).sum()\n        message = 'QC check did not pass for %d out of %d parameters' % (num_failed, k_params)\n        message += '\\nTry increasing solver accuracy or number of iterations, decreasing alpha, or switch solvers'\n        if qc_verbose:\n            message += _get_verbose_addon(qc_dict)\n        import warnings\n        warnings.warn(message, ConvergenceWarning)\n    return passed",
            "def qc_results(params, alpha, score, qc_tol, qc_verbose=False):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Theory dictates that one of two conditions holds:\\n        i) abs(score[i]) == alpha[i]  and  params[i] != 0\\n        ii) abs(score[i]) <= alpha[i]  and  params[i] == 0\\n    qc_results checks to see that (ii) holds, within qc_tol\\n\\n    qc_results also checks for nan or results of the wrong shape.\\n\\n    Parameters\\n    ----------\\n    params : ndarray\\n        model parameters.  Not including the added variables x_added.\\n    alpha : ndarray\\n        regularization coefficients\\n    score : function\\n        Gradient of unregularized objective function\\n    qc_tol : float\\n        Tolerance to hold conditions (i) and (ii) to for QC check.\\n    qc_verbose : bool\\n        If true, print out a full QC report upon failure\\n\\n    Returns\\n    -------\\n    passed : bool\\n        True if QC check passed\\n    qc_dict : Dictionary\\n        Keys are fprime, alpha, params, passed_array\\n\\n    Prints\\n    ------\\n    Warning message if QC check fails.\\n    '\n    assert not np.isnan(params).max()\n    assert (params == params.ravel('F')).min(), 'params should have already been 1-d'\n    fprime = score(params)\n    k_params = len(params)\n    passed_array = np.array([True] * k_params)\n    for i in range(k_params):\n        if alpha[i] > 0:\n            if (abs(fprime[i]) - alpha[i]) / alpha[i] > qc_tol:\n                passed_array[i] = False\n    qc_dict = dict(fprime=fprime, alpha=alpha, params=params, passed_array=passed_array)\n    passed = passed_array.min()\n    if not passed:\n        num_failed = (~passed_array).sum()\n        message = 'QC check did not pass for %d out of %d parameters' % (num_failed, k_params)\n        message += '\\nTry increasing solver accuracy or number of iterations, decreasing alpha, or switch solvers'\n        if qc_verbose:\n            message += _get_verbose_addon(qc_dict)\n        import warnings\n        warnings.warn(message, ConvergenceWarning)\n    return passed"
        ]
    },
    {
        "func_name": "_get_verbose_addon",
        "original": "def _get_verbose_addon(qc_dict):\n    alpha = qc_dict['alpha']\n    params = qc_dict['params']\n    fprime = qc_dict['fprime']\n    passed_array = qc_dict['passed_array']\n    addon = '\\n------ verbose QC printout -----------------'\n    addon = '\\n------ Recall the problem was rescaled by 1 / nobs ---'\n    addon += '\\n|%-10s|%-10s|%-10s|%-10s|' % ('passed', 'alpha', 'fprime', 'param')\n    addon += '\\n--------------------------------------------'\n    for i in range(len(alpha)):\n        addon += '\\n|%-10s|%-10.3e|%-10.3e|%-10.3e|' % (passed_array[i], alpha[i], fprime[i], params[i])\n    return addon",
        "mutated": [
            "def _get_verbose_addon(qc_dict):\n    if False:\n        i = 10\n    alpha = qc_dict['alpha']\n    params = qc_dict['params']\n    fprime = qc_dict['fprime']\n    passed_array = qc_dict['passed_array']\n    addon = '\\n------ verbose QC printout -----------------'\n    addon = '\\n------ Recall the problem was rescaled by 1 / nobs ---'\n    addon += '\\n|%-10s|%-10s|%-10s|%-10s|' % ('passed', 'alpha', 'fprime', 'param')\n    addon += '\\n--------------------------------------------'\n    for i in range(len(alpha)):\n        addon += '\\n|%-10s|%-10.3e|%-10.3e|%-10.3e|' % (passed_array[i], alpha[i], fprime[i], params[i])\n    return addon",
            "def _get_verbose_addon(qc_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    alpha = qc_dict['alpha']\n    params = qc_dict['params']\n    fprime = qc_dict['fprime']\n    passed_array = qc_dict['passed_array']\n    addon = '\\n------ verbose QC printout -----------------'\n    addon = '\\n------ Recall the problem was rescaled by 1 / nobs ---'\n    addon += '\\n|%-10s|%-10s|%-10s|%-10s|' % ('passed', 'alpha', 'fprime', 'param')\n    addon += '\\n--------------------------------------------'\n    for i in range(len(alpha)):\n        addon += '\\n|%-10s|%-10.3e|%-10.3e|%-10.3e|' % (passed_array[i], alpha[i], fprime[i], params[i])\n    return addon",
            "def _get_verbose_addon(qc_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    alpha = qc_dict['alpha']\n    params = qc_dict['params']\n    fprime = qc_dict['fprime']\n    passed_array = qc_dict['passed_array']\n    addon = '\\n------ verbose QC printout -----------------'\n    addon = '\\n------ Recall the problem was rescaled by 1 / nobs ---'\n    addon += '\\n|%-10s|%-10s|%-10s|%-10s|' % ('passed', 'alpha', 'fprime', 'param')\n    addon += '\\n--------------------------------------------'\n    for i in range(len(alpha)):\n        addon += '\\n|%-10s|%-10.3e|%-10.3e|%-10.3e|' % (passed_array[i], alpha[i], fprime[i], params[i])\n    return addon",
            "def _get_verbose_addon(qc_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    alpha = qc_dict['alpha']\n    params = qc_dict['params']\n    fprime = qc_dict['fprime']\n    passed_array = qc_dict['passed_array']\n    addon = '\\n------ verbose QC printout -----------------'\n    addon = '\\n------ Recall the problem was rescaled by 1 / nobs ---'\n    addon += '\\n|%-10s|%-10s|%-10s|%-10s|' % ('passed', 'alpha', 'fprime', 'param')\n    addon += '\\n--------------------------------------------'\n    for i in range(len(alpha)):\n        addon += '\\n|%-10s|%-10.3e|%-10.3e|%-10.3e|' % (passed_array[i], alpha[i], fprime[i], params[i])\n    return addon",
            "def _get_verbose_addon(qc_dict):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    alpha = qc_dict['alpha']\n    params = qc_dict['params']\n    fprime = qc_dict['fprime']\n    passed_array = qc_dict['passed_array']\n    addon = '\\n------ verbose QC printout -----------------'\n    addon = '\\n------ Recall the problem was rescaled by 1 / nobs ---'\n    addon += '\\n|%-10s|%-10s|%-10s|%-10s|' % ('passed', 'alpha', 'fprime', 'param')\n    addon += '\\n--------------------------------------------'\n    for i in range(len(alpha)):\n        addon += '\\n|%-10s|%-10.3e|%-10.3e|%-10.3e|' % (passed_array[i], alpha[i], fprime[i], params[i])\n    return addon"
        ]
    },
    {
        "func_name": "do_trim_params",
        "original": "def do_trim_params(params, k_params, alpha, score, passed, trim_mode, size_trim_tol, auto_trim_tol):\n    \"\"\"\n    Trims (set to zero) params that are zero at the theoretical minimum.\n    Uses heuristics to account for the solver not actually finding the minimum.\n\n    In all cases, if alpha[i] == 0, then do not trim the ith param.\n    In all cases, do nothing with the added variables.\n\n    Parameters\n    ----------\n    params : ndarray\n        model parameters.  Not including added variables.\n    k_params : Int\n        Number of parameters\n    alpha : ndarray\n        regularization coefficients\n    score : Function.\n        score(params) should return a 1-d vector of derivatives of the\n        unpenalized objective function.\n    passed : bool\n        True if the QC check passed\n    trim_mode : 'auto, 'size', or 'off'\n        If not 'off', trim (set to zero) parameters that would have been zero\n            if the solver reached the theoretical minimum.\n        If 'auto', trim params using the Theory above.\n        If 'size', trim params if they have very small absolute value\n    size_trim_tol : float or 'auto' (default = 'auto')\n        For use when trim_mode === 'size'\n    auto_trim_tol : float\n        For sue when trim_mode == 'auto'.  Use\n    qc_tol : float\n        Print warning and do not allow auto trim when (ii) in \"Theory\" (above)\n        is violated by this much.\n\n    Returns\n    -------\n    params : ndarray\n        Trimmed model parameters\n    trimmed : ndarray of booleans\n        trimmed[i] == True if the ith parameter was trimmed.\n    \"\"\"\n    trimmed = [False] * k_params\n    if trim_mode == 'off':\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and (not passed):\n        import warnings\n        msg = \"Could not trim params automatically due to failed QC check. Trimming using trim_mode == 'size' will still work.\"\n        warnings.warn(msg, ConvergenceWarning)\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and passed:\n        fprime = score(params)\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if (alpha[i] - abs(fprime[i])) / alpha[i] > auto_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    elif trim_mode == 'size':\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if abs(params[i]) < size_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    else:\n        raise ValueError('trim_mode == %s, which is not recognized' % trim_mode)\n    return (params, np.asarray(trimmed))",
        "mutated": [
            "def do_trim_params(params, k_params, alpha, score, passed, trim_mode, size_trim_tol, auto_trim_tol):\n    if False:\n        i = 10\n    '\\n    Trims (set to zero) params that are zero at the theoretical minimum.\\n    Uses heuristics to account for the solver not actually finding the minimum.\\n\\n    In all cases, if alpha[i] == 0, then do not trim the ith param.\\n    In all cases, do nothing with the added variables.\\n\\n    Parameters\\n    ----------\\n    params : ndarray\\n        model parameters.  Not including added variables.\\n    k_params : Int\\n        Number of parameters\\n    alpha : ndarray\\n        regularization coefficients\\n    score : Function.\\n        score(params) should return a 1-d vector of derivatives of the\\n        unpenalized objective function.\\n    passed : bool\\n        True if the QC check passed\\n    trim_mode : \\'auto, \\'size\\', or \\'off\\'\\n        If not \\'off\\', trim (set to zero) parameters that would have been zero\\n            if the solver reached the theoretical minimum.\\n        If \\'auto\\', trim params using the Theory above.\\n        If \\'size\\', trim params if they have very small absolute value\\n    size_trim_tol : float or \\'auto\\' (default = \\'auto\\')\\n        For use when trim_mode === \\'size\\'\\n    auto_trim_tol : float\\n        For sue when trim_mode == \\'auto\\'.  Use\\n    qc_tol : float\\n        Print warning and do not allow auto trim when (ii) in \"Theory\" (above)\\n        is violated by this much.\\n\\n    Returns\\n    -------\\n    params : ndarray\\n        Trimmed model parameters\\n    trimmed : ndarray of booleans\\n        trimmed[i] == True if the ith parameter was trimmed.\\n    '\n    trimmed = [False] * k_params\n    if trim_mode == 'off':\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and (not passed):\n        import warnings\n        msg = \"Could not trim params automatically due to failed QC check. Trimming using trim_mode == 'size' will still work.\"\n        warnings.warn(msg, ConvergenceWarning)\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and passed:\n        fprime = score(params)\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if (alpha[i] - abs(fprime[i])) / alpha[i] > auto_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    elif trim_mode == 'size':\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if abs(params[i]) < size_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    else:\n        raise ValueError('trim_mode == %s, which is not recognized' % trim_mode)\n    return (params, np.asarray(trimmed))",
            "def do_trim_params(params, k_params, alpha, score, passed, trim_mode, size_trim_tol, auto_trim_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Trims (set to zero) params that are zero at the theoretical minimum.\\n    Uses heuristics to account for the solver not actually finding the minimum.\\n\\n    In all cases, if alpha[i] == 0, then do not trim the ith param.\\n    In all cases, do nothing with the added variables.\\n\\n    Parameters\\n    ----------\\n    params : ndarray\\n        model parameters.  Not including added variables.\\n    k_params : Int\\n        Number of parameters\\n    alpha : ndarray\\n        regularization coefficients\\n    score : Function.\\n        score(params) should return a 1-d vector of derivatives of the\\n        unpenalized objective function.\\n    passed : bool\\n        True if the QC check passed\\n    trim_mode : \\'auto, \\'size\\', or \\'off\\'\\n        If not \\'off\\', trim (set to zero) parameters that would have been zero\\n            if the solver reached the theoretical minimum.\\n        If \\'auto\\', trim params using the Theory above.\\n        If \\'size\\', trim params if they have very small absolute value\\n    size_trim_tol : float or \\'auto\\' (default = \\'auto\\')\\n        For use when trim_mode === \\'size\\'\\n    auto_trim_tol : float\\n        For sue when trim_mode == \\'auto\\'.  Use\\n    qc_tol : float\\n        Print warning and do not allow auto trim when (ii) in \"Theory\" (above)\\n        is violated by this much.\\n\\n    Returns\\n    -------\\n    params : ndarray\\n        Trimmed model parameters\\n    trimmed : ndarray of booleans\\n        trimmed[i] == True if the ith parameter was trimmed.\\n    '\n    trimmed = [False] * k_params\n    if trim_mode == 'off':\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and (not passed):\n        import warnings\n        msg = \"Could not trim params automatically due to failed QC check. Trimming using trim_mode == 'size' will still work.\"\n        warnings.warn(msg, ConvergenceWarning)\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and passed:\n        fprime = score(params)\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if (alpha[i] - abs(fprime[i])) / alpha[i] > auto_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    elif trim_mode == 'size':\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if abs(params[i]) < size_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    else:\n        raise ValueError('trim_mode == %s, which is not recognized' % trim_mode)\n    return (params, np.asarray(trimmed))",
            "def do_trim_params(params, k_params, alpha, score, passed, trim_mode, size_trim_tol, auto_trim_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Trims (set to zero) params that are zero at the theoretical minimum.\\n    Uses heuristics to account for the solver not actually finding the minimum.\\n\\n    In all cases, if alpha[i] == 0, then do not trim the ith param.\\n    In all cases, do nothing with the added variables.\\n\\n    Parameters\\n    ----------\\n    params : ndarray\\n        model parameters.  Not including added variables.\\n    k_params : Int\\n        Number of parameters\\n    alpha : ndarray\\n        regularization coefficients\\n    score : Function.\\n        score(params) should return a 1-d vector of derivatives of the\\n        unpenalized objective function.\\n    passed : bool\\n        True if the QC check passed\\n    trim_mode : \\'auto, \\'size\\', or \\'off\\'\\n        If not \\'off\\', trim (set to zero) parameters that would have been zero\\n            if the solver reached the theoretical minimum.\\n        If \\'auto\\', trim params using the Theory above.\\n        If \\'size\\', trim params if they have very small absolute value\\n    size_trim_tol : float or \\'auto\\' (default = \\'auto\\')\\n        For use when trim_mode === \\'size\\'\\n    auto_trim_tol : float\\n        For sue when trim_mode == \\'auto\\'.  Use\\n    qc_tol : float\\n        Print warning and do not allow auto trim when (ii) in \"Theory\" (above)\\n        is violated by this much.\\n\\n    Returns\\n    -------\\n    params : ndarray\\n        Trimmed model parameters\\n    trimmed : ndarray of booleans\\n        trimmed[i] == True if the ith parameter was trimmed.\\n    '\n    trimmed = [False] * k_params\n    if trim_mode == 'off':\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and (not passed):\n        import warnings\n        msg = \"Could not trim params automatically due to failed QC check. Trimming using trim_mode == 'size' will still work.\"\n        warnings.warn(msg, ConvergenceWarning)\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and passed:\n        fprime = score(params)\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if (alpha[i] - abs(fprime[i])) / alpha[i] > auto_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    elif trim_mode == 'size':\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if abs(params[i]) < size_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    else:\n        raise ValueError('trim_mode == %s, which is not recognized' % trim_mode)\n    return (params, np.asarray(trimmed))",
            "def do_trim_params(params, k_params, alpha, score, passed, trim_mode, size_trim_tol, auto_trim_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Trims (set to zero) params that are zero at the theoretical minimum.\\n    Uses heuristics to account for the solver not actually finding the minimum.\\n\\n    In all cases, if alpha[i] == 0, then do not trim the ith param.\\n    In all cases, do nothing with the added variables.\\n\\n    Parameters\\n    ----------\\n    params : ndarray\\n        model parameters.  Not including added variables.\\n    k_params : Int\\n        Number of parameters\\n    alpha : ndarray\\n        regularization coefficients\\n    score : Function.\\n        score(params) should return a 1-d vector of derivatives of the\\n        unpenalized objective function.\\n    passed : bool\\n        True if the QC check passed\\n    trim_mode : \\'auto, \\'size\\', or \\'off\\'\\n        If not \\'off\\', trim (set to zero) parameters that would have been zero\\n            if the solver reached the theoretical minimum.\\n        If \\'auto\\', trim params using the Theory above.\\n        If \\'size\\', trim params if they have very small absolute value\\n    size_trim_tol : float or \\'auto\\' (default = \\'auto\\')\\n        For use when trim_mode === \\'size\\'\\n    auto_trim_tol : float\\n        For sue when trim_mode == \\'auto\\'.  Use\\n    qc_tol : float\\n        Print warning and do not allow auto trim when (ii) in \"Theory\" (above)\\n        is violated by this much.\\n\\n    Returns\\n    -------\\n    params : ndarray\\n        Trimmed model parameters\\n    trimmed : ndarray of booleans\\n        trimmed[i] == True if the ith parameter was trimmed.\\n    '\n    trimmed = [False] * k_params\n    if trim_mode == 'off':\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and (not passed):\n        import warnings\n        msg = \"Could not trim params automatically due to failed QC check. Trimming using trim_mode == 'size' will still work.\"\n        warnings.warn(msg, ConvergenceWarning)\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and passed:\n        fprime = score(params)\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if (alpha[i] - abs(fprime[i])) / alpha[i] > auto_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    elif trim_mode == 'size':\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if abs(params[i]) < size_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    else:\n        raise ValueError('trim_mode == %s, which is not recognized' % trim_mode)\n    return (params, np.asarray(trimmed))",
            "def do_trim_params(params, k_params, alpha, score, passed, trim_mode, size_trim_tol, auto_trim_tol):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Trims (set to zero) params that are zero at the theoretical minimum.\\n    Uses heuristics to account for the solver not actually finding the minimum.\\n\\n    In all cases, if alpha[i] == 0, then do not trim the ith param.\\n    In all cases, do nothing with the added variables.\\n\\n    Parameters\\n    ----------\\n    params : ndarray\\n        model parameters.  Not including added variables.\\n    k_params : Int\\n        Number of parameters\\n    alpha : ndarray\\n        regularization coefficients\\n    score : Function.\\n        score(params) should return a 1-d vector of derivatives of the\\n        unpenalized objective function.\\n    passed : bool\\n        True if the QC check passed\\n    trim_mode : \\'auto, \\'size\\', or \\'off\\'\\n        If not \\'off\\', trim (set to zero) parameters that would have been zero\\n            if the solver reached the theoretical minimum.\\n        If \\'auto\\', trim params using the Theory above.\\n        If \\'size\\', trim params if they have very small absolute value\\n    size_trim_tol : float or \\'auto\\' (default = \\'auto\\')\\n        For use when trim_mode === \\'size\\'\\n    auto_trim_tol : float\\n        For sue when trim_mode == \\'auto\\'.  Use\\n    qc_tol : float\\n        Print warning and do not allow auto trim when (ii) in \"Theory\" (above)\\n        is violated by this much.\\n\\n    Returns\\n    -------\\n    params : ndarray\\n        Trimmed model parameters\\n    trimmed : ndarray of booleans\\n        trimmed[i] == True if the ith parameter was trimmed.\\n    '\n    trimmed = [False] * k_params\n    if trim_mode == 'off':\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and (not passed):\n        import warnings\n        msg = \"Could not trim params automatically due to failed QC check. Trimming using trim_mode == 'size' will still work.\"\n        warnings.warn(msg, ConvergenceWarning)\n        trimmed = np.array([False] * k_params)\n    elif trim_mode == 'auto' and passed:\n        fprime = score(params)\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if (alpha[i] - abs(fprime[i])) / alpha[i] > auto_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    elif trim_mode == 'size':\n        for i in range(k_params):\n            if alpha[i] != 0:\n                if abs(params[i]) < size_trim_tol:\n                    params[i] = 0.0\n                    trimmed[i] = True\n    else:\n        raise ValueError('trim_mode == %s, which is not recognized' % trim_mode)\n    return (params, np.asarray(trimmed))"
        ]
    }
]