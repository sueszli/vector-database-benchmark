[
    {
        "func_name": "generate_sudoku",
        "original": "def generate_sudoku(mask_rate):\n    \"\"\"\n    Create a Sukoku board\n\n    :param mask_rate: % of squares to hide\n    :type mask_rate: float\n    :rtype: List[numpy.ndarry, numpy.ndarry]\n    \"\"\"\n    while True:\n        n = 9\n        solution = np.zeros((n, n), np.int_)\n        rg = np.arange(1, n + 1)\n        solution[0, :] = np.random.choice(rg, n, replace=False)\n        try:\n            for r in range(1, n):\n                for c in range(n):\n                    col_rest = np.setdiff1d(rg, solution[:r, c])\n                    row_rest = np.setdiff1d(rg, solution[r, :c])\n                    avb1 = np.intersect1d(col_rest, row_rest)\n                    (sub_r, sub_c) = (r // 3, c // 3)\n                    avb2 = np.setdiff1d(np.arange(0, n + 1), solution[sub_r * 3:(sub_r + 1) * 3, sub_c * 3:(sub_c + 1) * 3].ravel())\n                    avb = np.intersect1d(avb1, avb2)\n                    solution[r, c] = np.random.choice(avb, size=1)[0]\n            break\n        except ValueError:\n            pass\n    puzzle = solution.copy()\n    puzzle[np.random.choice([True, False], size=solution.shape, p=[mask_rate, 1 - mask_rate])] = 0\n    return (puzzle, solution)",
        "mutated": [
            "def generate_sudoku(mask_rate):\n    if False:\n        i = 10\n    '\\n    Create a Sukoku board\\n\\n    :param mask_rate: % of squares to hide\\n    :type mask_rate: float\\n    :rtype: List[numpy.ndarry, numpy.ndarry]\\n    '\n    while True:\n        n = 9\n        solution = np.zeros((n, n), np.int_)\n        rg = np.arange(1, n + 1)\n        solution[0, :] = np.random.choice(rg, n, replace=False)\n        try:\n            for r in range(1, n):\n                for c in range(n):\n                    col_rest = np.setdiff1d(rg, solution[:r, c])\n                    row_rest = np.setdiff1d(rg, solution[r, :c])\n                    avb1 = np.intersect1d(col_rest, row_rest)\n                    (sub_r, sub_c) = (r // 3, c // 3)\n                    avb2 = np.setdiff1d(np.arange(0, n + 1), solution[sub_r * 3:(sub_r + 1) * 3, sub_c * 3:(sub_c + 1) * 3].ravel())\n                    avb = np.intersect1d(avb1, avb2)\n                    solution[r, c] = np.random.choice(avb, size=1)[0]\n            break\n        except ValueError:\n            pass\n    puzzle = solution.copy()\n    puzzle[np.random.choice([True, False], size=solution.shape, p=[mask_rate, 1 - mask_rate])] = 0\n    return (puzzle, solution)",
            "def generate_sudoku(mask_rate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\\n    Create a Sukoku board\\n\\n    :param mask_rate: % of squares to hide\\n    :type mask_rate: float\\n    :rtype: List[numpy.ndarry, numpy.ndarry]\\n    '\n    while True:\n        n = 9\n        solution = np.zeros((n, n), np.int_)\n        rg = np.arange(1, n + 1)\n        solution[0, :] = np.random.choice(rg, n, replace=False)\n        try:\n            for r in range(1, n):\n                for c in range(n):\n                    col_rest = np.setdiff1d(rg, solution[:r, c])\n                    row_rest = np.setdiff1d(rg, solution[r, :c])\n                    avb1 = np.intersect1d(col_rest, row_rest)\n                    (sub_r, sub_c) = (r // 3, c // 3)\n                    avb2 = np.setdiff1d(np.arange(0, n + 1), solution[sub_r * 3:(sub_r + 1) * 3, sub_c * 3:(sub_c + 1) * 3].ravel())\n                    avb = np.intersect1d(avb1, avb2)\n                    solution[r, c] = np.random.choice(avb, size=1)[0]\n            break\n        except ValueError:\n            pass\n    puzzle = solution.copy()\n    puzzle[np.random.choice([True, False], size=solution.shape, p=[mask_rate, 1 - mask_rate])] = 0\n    return (puzzle, solution)",
            "def generate_sudoku(mask_rate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\\n    Create a Sukoku board\\n\\n    :param mask_rate: % of squares to hide\\n    :type mask_rate: float\\n    :rtype: List[numpy.ndarry, numpy.ndarry]\\n    '\n    while True:\n        n = 9\n        solution = np.zeros((n, n), np.int_)\n        rg = np.arange(1, n + 1)\n        solution[0, :] = np.random.choice(rg, n, replace=False)\n        try:\n            for r in range(1, n):\n                for c in range(n):\n                    col_rest = np.setdiff1d(rg, solution[:r, c])\n                    row_rest = np.setdiff1d(rg, solution[r, :c])\n                    avb1 = np.intersect1d(col_rest, row_rest)\n                    (sub_r, sub_c) = (r // 3, c // 3)\n                    avb2 = np.setdiff1d(np.arange(0, n + 1), solution[sub_r * 3:(sub_r + 1) * 3, sub_c * 3:(sub_c + 1) * 3].ravel())\n                    avb = np.intersect1d(avb1, avb2)\n                    solution[r, c] = np.random.choice(avb, size=1)[0]\n            break\n        except ValueError:\n            pass\n    puzzle = solution.copy()\n    puzzle[np.random.choice([True, False], size=solution.shape, p=[mask_rate, 1 - mask_rate])] = 0\n    return (puzzle, solution)",
            "def generate_sudoku(mask_rate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\\n    Create a Sukoku board\\n\\n    :param mask_rate: % of squares to hide\\n    :type mask_rate: float\\n    :rtype: List[numpy.ndarry, numpy.ndarry]\\n    '\n    while True:\n        n = 9\n        solution = np.zeros((n, n), np.int_)\n        rg = np.arange(1, n + 1)\n        solution[0, :] = np.random.choice(rg, n, replace=False)\n        try:\n            for r in range(1, n):\n                for c in range(n):\n                    col_rest = np.setdiff1d(rg, solution[:r, c])\n                    row_rest = np.setdiff1d(rg, solution[r, :c])\n                    avb1 = np.intersect1d(col_rest, row_rest)\n                    (sub_r, sub_c) = (r // 3, c // 3)\n                    avb2 = np.setdiff1d(np.arange(0, n + 1), solution[sub_r * 3:(sub_r + 1) * 3, sub_c * 3:(sub_c + 1) * 3].ravel())\n                    avb = np.intersect1d(avb1, avb2)\n                    solution[r, c] = np.random.choice(avb, size=1)[0]\n            break\n        except ValueError:\n            pass\n    puzzle = solution.copy()\n    puzzle[np.random.choice([True, False], size=solution.shape, p=[mask_rate, 1 - mask_rate])] = 0\n    return (puzzle, solution)",
            "def generate_sudoku(mask_rate):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\\n    Create a Sukoku board\\n\\n    :param mask_rate: % of squares to hide\\n    :type mask_rate: float\\n    :rtype: List[numpy.ndarry, numpy.ndarry]\\n    '\n    while True:\n        n = 9\n        solution = np.zeros((n, n), np.int_)\n        rg = np.arange(1, n + 1)\n        solution[0, :] = np.random.choice(rg, n, replace=False)\n        try:\n            for r in range(1, n):\n                for c in range(n):\n                    col_rest = np.setdiff1d(rg, solution[:r, c])\n                    row_rest = np.setdiff1d(rg, solution[r, :c])\n                    avb1 = np.intersect1d(col_rest, row_rest)\n                    (sub_r, sub_c) = (r // 3, c // 3)\n                    avb2 = np.setdiff1d(np.arange(0, n + 1), solution[sub_r * 3:(sub_r + 1) * 3, sub_c * 3:(sub_c + 1) * 3].ravel())\n                    avb = np.intersect1d(avb1, avb2)\n                    solution[r, c] = np.random.choice(avb, size=1)[0]\n            break\n        except ValueError:\n            pass\n    puzzle = solution.copy()\n    puzzle[np.random.choice([True, False], size=solution.shape, p=[mask_rate, 1 - mask_rate])] = 0\n    return (puzzle, solution)"
        ]
    },
    {
        "func_name": "check_progress",
        "original": "def check_progress(window, solution):\n    \"\"\"\n    Gives you a visual hint on your progress.\n    Red - You've got an incorrect number at the location\n    Yellow - You're missing an anwer for that location\n\n    :param window: The GUI's Window\n    :type window: sg.Window\n    :param solution: A 2D array containing the solution\n    :type solution: numpy.ndarray\n    :return: True if the puzzle has been solved correctly\n    :rtype: bool\n    \"\"\"\n    solved = True\n    for (r, row) in enumerate(solution):\n        for (c, col) in enumerate(row):\n            value = window[r, c].get()\n            if value:\n                try:\n                    value = int(value)\n                except:\n                    value = 0\n                if value != solution[r][c]:\n                    window[r, c].update(background_color='red')\n                    solved = False\n                else:\n                    window[r, c].update(background_color=sg.theme_input_background_color())\n            else:\n                solved = False\n                window[r, c].update(background_color='yellow')\n    return solved",
        "mutated": [
            "def check_progress(window, solution):\n    if False:\n        i = 10\n    \"\\n    Gives you a visual hint on your progress.\\n    Red - You've got an incorrect number at the location\\n    Yellow - You're missing an anwer for that location\\n\\n    :param window: The GUI's Window\\n    :type window: sg.Window\\n    :param solution: A 2D array containing the solution\\n    :type solution: numpy.ndarray\\n    :return: True if the puzzle has been solved correctly\\n    :rtype: bool\\n    \"\n    solved = True\n    for (r, row) in enumerate(solution):\n        for (c, col) in enumerate(row):\n            value = window[r, c].get()\n            if value:\n                try:\n                    value = int(value)\n                except:\n                    value = 0\n                if value != solution[r][c]:\n                    window[r, c].update(background_color='red')\n                    solved = False\n                else:\n                    window[r, c].update(background_color=sg.theme_input_background_color())\n            else:\n                solved = False\n                window[r, c].update(background_color='yellow')\n    return solved",
            "def check_progress(window, solution):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Gives you a visual hint on your progress.\\n    Red - You've got an incorrect number at the location\\n    Yellow - You're missing an anwer for that location\\n\\n    :param window: The GUI's Window\\n    :type window: sg.Window\\n    :param solution: A 2D array containing the solution\\n    :type solution: numpy.ndarray\\n    :return: True if the puzzle has been solved correctly\\n    :rtype: bool\\n    \"\n    solved = True\n    for (r, row) in enumerate(solution):\n        for (c, col) in enumerate(row):\n            value = window[r, c].get()\n            if value:\n                try:\n                    value = int(value)\n                except:\n                    value = 0\n                if value != solution[r][c]:\n                    window[r, c].update(background_color='red')\n                    solved = False\n                else:\n                    window[r, c].update(background_color=sg.theme_input_background_color())\n            else:\n                solved = False\n                window[r, c].update(background_color='yellow')\n    return solved",
            "def check_progress(window, solution):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Gives you a visual hint on your progress.\\n    Red - You've got an incorrect number at the location\\n    Yellow - You're missing an anwer for that location\\n\\n    :param window: The GUI's Window\\n    :type window: sg.Window\\n    :param solution: A 2D array containing the solution\\n    :type solution: numpy.ndarray\\n    :return: True if the puzzle has been solved correctly\\n    :rtype: bool\\n    \"\n    solved = True\n    for (r, row) in enumerate(solution):\n        for (c, col) in enumerate(row):\n            value = window[r, c].get()\n            if value:\n                try:\n                    value = int(value)\n                except:\n                    value = 0\n                if value != solution[r][c]:\n                    window[r, c].update(background_color='red')\n                    solved = False\n                else:\n                    window[r, c].update(background_color=sg.theme_input_background_color())\n            else:\n                solved = False\n                window[r, c].update(background_color='yellow')\n    return solved",
            "def check_progress(window, solution):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Gives you a visual hint on your progress.\\n    Red - You've got an incorrect number at the location\\n    Yellow - You're missing an anwer for that location\\n\\n    :param window: The GUI's Window\\n    :type window: sg.Window\\n    :param solution: A 2D array containing the solution\\n    :type solution: numpy.ndarray\\n    :return: True if the puzzle has been solved correctly\\n    :rtype: bool\\n    \"\n    solved = True\n    for (r, row) in enumerate(solution):\n        for (c, col) in enumerate(row):\n            value = window[r, c].get()\n            if value:\n                try:\n                    value = int(value)\n                except:\n                    value = 0\n                if value != solution[r][c]:\n                    window[r, c].update(background_color='red')\n                    solved = False\n                else:\n                    window[r, c].update(background_color=sg.theme_input_background_color())\n            else:\n                solved = False\n                window[r, c].update(background_color='yellow')\n    return solved",
            "def check_progress(window, solution):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Gives you a visual hint on your progress.\\n    Red - You've got an incorrect number at the location\\n    Yellow - You're missing an anwer for that location\\n\\n    :param window: The GUI's Window\\n    :type window: sg.Window\\n    :param solution: A 2D array containing the solution\\n    :type solution: numpy.ndarray\\n    :return: True if the puzzle has been solved correctly\\n    :rtype: bool\\n    \"\n    solved = True\n    for (r, row) in enumerate(solution):\n        for (c, col) in enumerate(row):\n            value = window[r, c].get()\n            if value:\n                try:\n                    value = int(value)\n                except:\n                    value = 0\n                if value != solution[r][c]:\n                    window[r, c].update(background_color='red')\n                    solved = False\n                else:\n                    window[r, c].update(background_color=sg.theme_input_background_color())\n            else:\n                solved = False\n                window[r, c].update(background_color='yellow')\n    return solved"
        ]
    },
    {
        "func_name": "create_and_show_puzzle",
        "original": "def create_and_show_puzzle():\n    rate = mask_rate\n    if window['-RATE-'].get():\n        try:\n            rate = float(window['-RATE-'].get())\n        except:\n            pass\n    (puzzle, solution) = generate_sudoku(mask_rate=rate)\n    for (r, row) in enumerate(puzzle):\n        for (c, col) in enumerate(row):\n            window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n    return (puzzle, solution)",
        "mutated": [
            "def create_and_show_puzzle():\n    if False:\n        i = 10\n    rate = mask_rate\n    if window['-RATE-'].get():\n        try:\n            rate = float(window['-RATE-'].get())\n        except:\n            pass\n    (puzzle, solution) = generate_sudoku(mask_rate=rate)\n    for (r, row) in enumerate(puzzle):\n        for (c, col) in enumerate(row):\n            window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n    return (puzzle, solution)",
            "def create_and_show_puzzle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    rate = mask_rate\n    if window['-RATE-'].get():\n        try:\n            rate = float(window['-RATE-'].get())\n        except:\n            pass\n    (puzzle, solution) = generate_sudoku(mask_rate=rate)\n    for (r, row) in enumerate(puzzle):\n        for (c, col) in enumerate(row):\n            window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n    return (puzzle, solution)",
            "def create_and_show_puzzle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    rate = mask_rate\n    if window['-RATE-'].get():\n        try:\n            rate = float(window['-RATE-'].get())\n        except:\n            pass\n    (puzzle, solution) = generate_sudoku(mask_rate=rate)\n    for (r, row) in enumerate(puzzle):\n        for (c, col) in enumerate(row):\n            window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n    return (puzzle, solution)",
            "def create_and_show_puzzle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    rate = mask_rate\n    if window['-RATE-'].get():\n        try:\n            rate = float(window['-RATE-'].get())\n        except:\n            pass\n    (puzzle, solution) = generate_sudoku(mask_rate=rate)\n    for (r, row) in enumerate(puzzle):\n        for (c, col) in enumerate(row):\n            window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n    return (puzzle, solution)",
            "def create_and_show_puzzle():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    rate = mask_rate\n    if window['-RATE-'].get():\n        try:\n            rate = float(window['-RATE-'].get())\n        except:\n            pass\n    (puzzle, solution) = generate_sudoku(mask_rate=rate)\n    for (r, row) in enumerate(puzzle):\n        for (c, col) in enumerate(row):\n            window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n    return (puzzle, solution)"
        ]
    },
    {
        "func_name": "main",
        "original": "def main(mask_rate=0.7):\n    \"\"\"\"\n    The Main GUI - It does it all.\n\n    The \"Board\" is a grid that's 9 x 9.  Even though the layout is a grid of 9 Frames, the\n    addressing of the individual squares is via a key that's a tuple (0,0) to (8,8)\n    \"\"\"\n\n    def create_and_show_puzzle():\n        rate = mask_rate\n        if window['-RATE-'].get():\n            try:\n                rate = float(window['-RATE-'].get())\n            except:\n                pass\n        (puzzle, solution) = generate_sudoku(mask_rate=rate)\n        for (r, row) in enumerate(puzzle):\n            for (c, col) in enumerate(row):\n                window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n        return (puzzle, solution)\n    window = sg.Window('Sudoku', [[sg.Frame('', [[sg.I(random.randint(1, 9), justification='r', size=(3, 1), key=(fr * 3 + r, fc * 3 + c)) for c in range(3)] for r in range(3)]) for fc in range(3)] for fr in range(3)] + [[sg.B('Solve'), sg.B('Check'), sg.B('Hint'), sg.B('New Game')], [sg.T('Mask rate (0-1)'), sg.In(str(mask_rate), size=(3, 1), key='-RATE-')]], finalize=True)\n    (puzzle, solution) = create_and_show_puzzle()\n    while True:\n        (event, values) = window.read()\n        if event is None:\n            break\n        if event == 'Solve':\n            for (r, row) in enumerate(solution):\n                for (c, col) in enumerate(row):\n                    window[r, c].update(solution[r][c], background_color=sg.theme_input_background_color())\n        elif event == 'Check':\n            solved = check_progress(window, solution)\n            if solved:\n                sg.popup('Solved! You have solved the puzzle correctly.')\n        elif event == 'Hint':\n            elem = window.find_element_with_focus()\n            try:\n                elem.update(solution[elem.Key[0]][elem.Key[1]], background_color=sg.theme_input_background_color())\n            except:\n                pass\n        elif event == 'New Game':\n            (puzzle, solution) = create_and_show_puzzle()\n    window.close()",
        "mutated": [
            "def main(mask_rate=0.7):\n    if False:\n        i = 10\n    '\"\\n    The Main GUI - It does it all.\\n\\n    The \"Board\" is a grid that\\'s 9 x 9.  Even though the layout is a grid of 9 Frames, the\\n    addressing of the individual squares is via a key that\\'s a tuple (0,0) to (8,8)\\n    '\n\n    def create_and_show_puzzle():\n        rate = mask_rate\n        if window['-RATE-'].get():\n            try:\n                rate = float(window['-RATE-'].get())\n            except:\n                pass\n        (puzzle, solution) = generate_sudoku(mask_rate=rate)\n        for (r, row) in enumerate(puzzle):\n            for (c, col) in enumerate(row):\n                window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n        return (puzzle, solution)\n    window = sg.Window('Sudoku', [[sg.Frame('', [[sg.I(random.randint(1, 9), justification='r', size=(3, 1), key=(fr * 3 + r, fc * 3 + c)) for c in range(3)] for r in range(3)]) for fc in range(3)] for fr in range(3)] + [[sg.B('Solve'), sg.B('Check'), sg.B('Hint'), sg.B('New Game')], [sg.T('Mask rate (0-1)'), sg.In(str(mask_rate), size=(3, 1), key='-RATE-')]], finalize=True)\n    (puzzle, solution) = create_and_show_puzzle()\n    while True:\n        (event, values) = window.read()\n        if event is None:\n            break\n        if event == 'Solve':\n            for (r, row) in enumerate(solution):\n                for (c, col) in enumerate(row):\n                    window[r, c].update(solution[r][c], background_color=sg.theme_input_background_color())\n        elif event == 'Check':\n            solved = check_progress(window, solution)\n            if solved:\n                sg.popup('Solved! You have solved the puzzle correctly.')\n        elif event == 'Hint':\n            elem = window.find_element_with_focus()\n            try:\n                elem.update(solution[elem.Key[0]][elem.Key[1]], background_color=sg.theme_input_background_color())\n            except:\n                pass\n        elif event == 'New Game':\n            (puzzle, solution) = create_and_show_puzzle()\n    window.close()",
            "def main(mask_rate=0.7):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    '\"\\n    The Main GUI - It does it all.\\n\\n    The \"Board\" is a grid that\\'s 9 x 9.  Even though the layout is a grid of 9 Frames, the\\n    addressing of the individual squares is via a key that\\'s a tuple (0,0) to (8,8)\\n    '\n\n    def create_and_show_puzzle():\n        rate = mask_rate\n        if window['-RATE-'].get():\n            try:\n                rate = float(window['-RATE-'].get())\n            except:\n                pass\n        (puzzle, solution) = generate_sudoku(mask_rate=rate)\n        for (r, row) in enumerate(puzzle):\n            for (c, col) in enumerate(row):\n                window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n        return (puzzle, solution)\n    window = sg.Window('Sudoku', [[sg.Frame('', [[sg.I(random.randint(1, 9), justification='r', size=(3, 1), key=(fr * 3 + r, fc * 3 + c)) for c in range(3)] for r in range(3)]) for fc in range(3)] for fr in range(3)] + [[sg.B('Solve'), sg.B('Check'), sg.B('Hint'), sg.B('New Game')], [sg.T('Mask rate (0-1)'), sg.In(str(mask_rate), size=(3, 1), key='-RATE-')]], finalize=True)\n    (puzzle, solution) = create_and_show_puzzle()\n    while True:\n        (event, values) = window.read()\n        if event is None:\n            break\n        if event == 'Solve':\n            for (r, row) in enumerate(solution):\n                for (c, col) in enumerate(row):\n                    window[r, c].update(solution[r][c], background_color=sg.theme_input_background_color())\n        elif event == 'Check':\n            solved = check_progress(window, solution)\n            if solved:\n                sg.popup('Solved! You have solved the puzzle correctly.')\n        elif event == 'Hint':\n            elem = window.find_element_with_focus()\n            try:\n                elem.update(solution[elem.Key[0]][elem.Key[1]], background_color=sg.theme_input_background_color())\n            except:\n                pass\n        elif event == 'New Game':\n            (puzzle, solution) = create_and_show_puzzle()\n    window.close()",
            "def main(mask_rate=0.7):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    '\"\\n    The Main GUI - It does it all.\\n\\n    The \"Board\" is a grid that\\'s 9 x 9.  Even though the layout is a grid of 9 Frames, the\\n    addressing of the individual squares is via a key that\\'s a tuple (0,0) to (8,8)\\n    '\n\n    def create_and_show_puzzle():\n        rate = mask_rate\n        if window['-RATE-'].get():\n            try:\n                rate = float(window['-RATE-'].get())\n            except:\n                pass\n        (puzzle, solution) = generate_sudoku(mask_rate=rate)\n        for (r, row) in enumerate(puzzle):\n            for (c, col) in enumerate(row):\n                window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n        return (puzzle, solution)\n    window = sg.Window('Sudoku', [[sg.Frame('', [[sg.I(random.randint(1, 9), justification='r', size=(3, 1), key=(fr * 3 + r, fc * 3 + c)) for c in range(3)] for r in range(3)]) for fc in range(3)] for fr in range(3)] + [[sg.B('Solve'), sg.B('Check'), sg.B('Hint'), sg.B('New Game')], [sg.T('Mask rate (0-1)'), sg.In(str(mask_rate), size=(3, 1), key='-RATE-')]], finalize=True)\n    (puzzle, solution) = create_and_show_puzzle()\n    while True:\n        (event, values) = window.read()\n        if event is None:\n            break\n        if event == 'Solve':\n            for (r, row) in enumerate(solution):\n                for (c, col) in enumerate(row):\n                    window[r, c].update(solution[r][c], background_color=sg.theme_input_background_color())\n        elif event == 'Check':\n            solved = check_progress(window, solution)\n            if solved:\n                sg.popup('Solved! You have solved the puzzle correctly.')\n        elif event == 'Hint':\n            elem = window.find_element_with_focus()\n            try:\n                elem.update(solution[elem.Key[0]][elem.Key[1]], background_color=sg.theme_input_background_color())\n            except:\n                pass\n        elif event == 'New Game':\n            (puzzle, solution) = create_and_show_puzzle()\n    window.close()",
            "def main(mask_rate=0.7):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    '\"\\n    The Main GUI - It does it all.\\n\\n    The \"Board\" is a grid that\\'s 9 x 9.  Even though the layout is a grid of 9 Frames, the\\n    addressing of the individual squares is via a key that\\'s a tuple (0,0) to (8,8)\\n    '\n\n    def create_and_show_puzzle():\n        rate = mask_rate\n        if window['-RATE-'].get():\n            try:\n                rate = float(window['-RATE-'].get())\n            except:\n                pass\n        (puzzle, solution) = generate_sudoku(mask_rate=rate)\n        for (r, row) in enumerate(puzzle):\n            for (c, col) in enumerate(row):\n                window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n        return (puzzle, solution)\n    window = sg.Window('Sudoku', [[sg.Frame('', [[sg.I(random.randint(1, 9), justification='r', size=(3, 1), key=(fr * 3 + r, fc * 3 + c)) for c in range(3)] for r in range(3)]) for fc in range(3)] for fr in range(3)] + [[sg.B('Solve'), sg.B('Check'), sg.B('Hint'), sg.B('New Game')], [sg.T('Mask rate (0-1)'), sg.In(str(mask_rate), size=(3, 1), key='-RATE-')]], finalize=True)\n    (puzzle, solution) = create_and_show_puzzle()\n    while True:\n        (event, values) = window.read()\n        if event is None:\n            break\n        if event == 'Solve':\n            for (r, row) in enumerate(solution):\n                for (c, col) in enumerate(row):\n                    window[r, c].update(solution[r][c], background_color=sg.theme_input_background_color())\n        elif event == 'Check':\n            solved = check_progress(window, solution)\n            if solved:\n                sg.popup('Solved! You have solved the puzzle correctly.')\n        elif event == 'Hint':\n            elem = window.find_element_with_focus()\n            try:\n                elem.update(solution[elem.Key[0]][elem.Key[1]], background_color=sg.theme_input_background_color())\n            except:\n                pass\n        elif event == 'New Game':\n            (puzzle, solution) = create_and_show_puzzle()\n    window.close()",
            "def main(mask_rate=0.7):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    '\"\\n    The Main GUI - It does it all.\\n\\n    The \"Board\" is a grid that\\'s 9 x 9.  Even though the layout is a grid of 9 Frames, the\\n    addressing of the individual squares is via a key that\\'s a tuple (0,0) to (8,8)\\n    '\n\n    def create_and_show_puzzle():\n        rate = mask_rate\n        if window['-RATE-'].get():\n            try:\n                rate = float(window['-RATE-'].get())\n            except:\n                pass\n        (puzzle, solution) = generate_sudoku(mask_rate=rate)\n        for (r, row) in enumerate(puzzle):\n            for (c, col) in enumerate(row):\n                window[r, c].update(puzzle[r][c] if puzzle[r][c] else '', background_color=sg.theme_input_background_color())\n        return (puzzle, solution)\n    window = sg.Window('Sudoku', [[sg.Frame('', [[sg.I(random.randint(1, 9), justification='r', size=(3, 1), key=(fr * 3 + r, fc * 3 + c)) for c in range(3)] for r in range(3)]) for fc in range(3)] for fr in range(3)] + [[sg.B('Solve'), sg.B('Check'), sg.B('Hint'), sg.B('New Game')], [sg.T('Mask rate (0-1)'), sg.In(str(mask_rate), size=(3, 1), key='-RATE-')]], finalize=True)\n    (puzzle, solution) = create_and_show_puzzle()\n    while True:\n        (event, values) = window.read()\n        if event is None:\n            break\n        if event == 'Solve':\n            for (r, row) in enumerate(solution):\n                for (c, col) in enumerate(row):\n                    window[r, c].update(solution[r][c], background_color=sg.theme_input_background_color())\n        elif event == 'Check':\n            solved = check_progress(window, solution)\n            if solved:\n                sg.popup('Solved! You have solved the puzzle correctly.')\n        elif event == 'Hint':\n            elem = window.find_element_with_focus()\n            try:\n                elem.update(solution[elem.Key[0]][elem.Key[1]], background_color=sg.theme_input_background_color())\n            except:\n                pass\n        elif event == 'New Game':\n            (puzzle, solution) = create_and_show_puzzle()\n    window.close()"
        ]
    }
]