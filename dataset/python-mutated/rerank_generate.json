[
    {
        "func_name": "gen_and_reprocess_nbest",
        "original": "def gen_and_reprocess_nbest(args):\n    if args.score_dict_dir is None:\n        args.score_dict_dir = args.data\n    if args.prefix_len is not None:\n        assert args.right_to_left1 is False, 'prefix length not compatible with right to left models'\n        assert args.right_to_left2 is False, 'prefix length not compatible with right to left models'\n    if args.nbest_list is not None:\n        assert args.score_model2 is None\n    if args.backwards1:\n        scorer1_src = args.target_lang\n        scorer1_tgt = args.source_lang\n    else:\n        scorer1_src = args.source_lang\n        scorer1_tgt = args.target_lang\n    store_data = os.path.join(os.path.dirname(__file__)) + '/rerank_data/' + args.data_dir_name\n    if not os.path.exists(store_data):\n        os.makedirs(store_data)\n    (pre_gen, left_to_right_preprocessed_dir, right_to_left_preprocessed_dir, backwards_preprocessed_dir, lm_preprocessed_dir) = rerank_utils.get_directories(args.data_dir_name, args.num_rescore, args.gen_subset, args.gen_model_name, args.shard_id, args.num_shards, args.sampling, args.prefix_len, args.target_prefix_frac, args.source_prefix_frac)\n    assert not (args.right_to_left1 and args.backwards1), 'backwards right to left not supported'\n    assert not (args.right_to_left2 and args.backwards2), 'backwards right to left not supported'\n    assert not (args.prefix_len is not None and args.target_prefix_frac is not None), 'target prefix frac and target prefix len incompatible'\n    if not os.path.exists(pre_gen):\n        os.makedirs(pre_gen)\n    rerank1_is_gen = args.gen_model == args.score_model1 and args.source_prefix_frac is None\n    rerank2_is_gen = args.gen_model == args.score_model2 and args.source_prefix_frac is None\n    if args.nbest_list is not None:\n        rerank2_is_gen = True\n    if not os.path.exists(left_to_right_preprocessed_dir):\n        os.makedirs(left_to_right_preprocessed_dir)\n    if not os.path.exists(right_to_left_preprocessed_dir):\n        os.makedirs(right_to_left_preprocessed_dir)\n    if not os.path.exists(lm_preprocessed_dir):\n        os.makedirs(lm_preprocessed_dir)\n    if not os.path.exists(backwards_preprocessed_dir):\n        os.makedirs(backwards_preprocessed_dir)\n    score1_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model1_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards1)\n    if args.score_model2 is not None:\n        score2_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model2_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards2)\n    predictions_bpe_file = pre_gen + '/generate_output_bpe.txt'\n    using_nbest = args.nbest_list is not None\n    if using_nbest:\n        print('Using predefined n-best list from interactive.py')\n        predictions_bpe_file = args.nbest_list\n    elif not os.path.isfile(predictions_bpe_file):\n        print('STEP 1: generate predictions using the p(T|S) model with bpe')\n        print(args.data)\n        param1 = [args.data, '--path', args.gen_model, '--shard-id', str(args.shard_id), '--num-shards', str(args.num_shards), '--nbest', str(args.num_rescore), '--batch-size', str(args.batch_size), '--beam', str(args.num_rescore), '--batch-size', str(args.num_rescore), '--gen-subset', args.gen_subset, '--source-lang', args.source_lang, '--target-lang', args.target_lang]\n        if args.sampling:\n            param1 += ['--sampling']\n        gen_parser = options.get_generation_parser()\n        input_args = options.parse_args_and_arch(gen_parser, param1)\n        print(input_args)\n        with open(predictions_bpe_file, 'w') as f:\n            with redirect_stdout(f):\n                generate.main(input_args)\n    gen_output = rerank_utils.BitextOutputFromGen(predictions_bpe_file, bpe_symbol=args.post_process, nbest=using_nbest, prefix_len=args.prefix_len, target_prefix_frac=args.target_prefix_frac)\n    if args.diff_bpe:\n        rerank_utils.write_reprocessed(gen_output.no_bpe_source, gen_output.no_bpe_hypo, gen_output.no_bpe_target, pre_gen + '/source_gen_bpe.' + args.source_lang, pre_gen + '/target_gen_bpe.' + args.target_lang, pre_gen + '/reference_gen_bpe.' + args.target_lang)\n        bitext_bpe = args.rescore_bpe_code\n        bpe_src_param = ['-c', bitext_bpe, '--input', pre_gen + '/source_gen_bpe.' + args.source_lang, '--output', pre_gen + '/rescore_data.' + args.source_lang]\n        bpe_tgt_param = ['-c', bitext_bpe, '--input', pre_gen + '/target_gen_bpe.' + args.target_lang, '--output', pre_gen + '/rescore_data.' + args.target_lang]\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_src_param, shell=False)\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_tgt_param, shell=False)\n    if not os.path.isfile(score1_file) and (not rerank1_is_gen) or (args.score_model2 is not None and (not os.path.isfile(score2_file)) and (not rerank2_is_gen)):\n        print('STEP 2: process the output of generate.py so we have clean text files with the translations')\n        rescore_file = '/rescore_data'\n        if args.prefix_len is not None:\n            prefix_len_rescore_file = rescore_file + 'prefix' + str(args.prefix_len)\n        if args.target_prefix_frac is not None:\n            target_prefix_frac_rescore_file = rescore_file + 'target_prefix_frac' + str(args.target_prefix_frac)\n        if args.source_prefix_frac is not None:\n            source_prefix_frac_rescore_file = rescore_file + 'source_prefix_frac' + str(args.source_prefix_frac)\n        if not args.right_to_left1 or not args.right_to_left2:\n            if not args.diff_bpe:\n                rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + rescore_file + '.' + args.source_lang, pre_gen + rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process)\n                if args.prefix_len is not None:\n                    bw_rescore_file = prefix_len_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + prefix_len_rescore_file + '.' + args.source_lang, pre_gen + prefix_len_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', prefix_len=args.prefix_len, bpe_symbol=args.post_process)\n                elif args.target_prefix_frac is not None:\n                    bw_rescore_file = target_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + target_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + target_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, target_prefix_frac=args.target_prefix_frac)\n                else:\n                    bw_rescore_file = rescore_file\n                if args.source_prefix_frac is not None:\n                    fw_rescore_file = source_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + source_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + source_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, source_prefix_frac=args.source_prefix_frac)\n                else:\n                    fw_rescore_file = rescore_file\n        if args.right_to_left1 or args.right_to_left2:\n            rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + '/right_to_left_rescore_data.' + args.source_lang, pre_gen + '/right_to_left_rescore_data.' + args.target_lang, pre_gen + '/right_to_left_reference_file', right_to_left=True, bpe_symbol=args.post_process)\n        print('STEP 3: binarize the translations')\n        if not args.right_to_left1 or (args.score_model2 is not None and (not args.right_to_left2)) or (not rerank1_is_gen):\n            if args.backwards1 or args.backwards2:\n                if args.backwards_score_dict_dir is not None:\n                    bw_dict = args.backwards_score_dict_dir\n                else:\n                    bw_dict = args.score_dict_dir\n                bw_preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + bw_rescore_file, '--srcdict', bw_dict + '/dict.' + scorer1_src + '.txt', '--tgtdict', bw_dict + '/dict.' + scorer1_tgt + '.txt', '--destdir', backwards_preprocessed_dir]\n                preprocess_parser = options.get_preprocessing_parser()\n                input_args = preprocess_parser.parse_args(bw_preprocess_param)\n                preprocess.main(input_args)\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + fw_rescore_file, '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', left_to_right_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n        if args.right_to_left1 or args.right_to_left2:\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + '/right_to_left_rescore_data', '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', right_to_left_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n    return gen_output",
        "mutated": [
            "def gen_and_reprocess_nbest(args):\n    if False:\n        i = 10\n    if args.score_dict_dir is None:\n        args.score_dict_dir = args.data\n    if args.prefix_len is not None:\n        assert args.right_to_left1 is False, 'prefix length not compatible with right to left models'\n        assert args.right_to_left2 is False, 'prefix length not compatible with right to left models'\n    if args.nbest_list is not None:\n        assert args.score_model2 is None\n    if args.backwards1:\n        scorer1_src = args.target_lang\n        scorer1_tgt = args.source_lang\n    else:\n        scorer1_src = args.source_lang\n        scorer1_tgt = args.target_lang\n    store_data = os.path.join(os.path.dirname(__file__)) + '/rerank_data/' + args.data_dir_name\n    if not os.path.exists(store_data):\n        os.makedirs(store_data)\n    (pre_gen, left_to_right_preprocessed_dir, right_to_left_preprocessed_dir, backwards_preprocessed_dir, lm_preprocessed_dir) = rerank_utils.get_directories(args.data_dir_name, args.num_rescore, args.gen_subset, args.gen_model_name, args.shard_id, args.num_shards, args.sampling, args.prefix_len, args.target_prefix_frac, args.source_prefix_frac)\n    assert not (args.right_to_left1 and args.backwards1), 'backwards right to left not supported'\n    assert not (args.right_to_left2 and args.backwards2), 'backwards right to left not supported'\n    assert not (args.prefix_len is not None and args.target_prefix_frac is not None), 'target prefix frac and target prefix len incompatible'\n    if not os.path.exists(pre_gen):\n        os.makedirs(pre_gen)\n    rerank1_is_gen = args.gen_model == args.score_model1 and args.source_prefix_frac is None\n    rerank2_is_gen = args.gen_model == args.score_model2 and args.source_prefix_frac is None\n    if args.nbest_list is not None:\n        rerank2_is_gen = True\n    if not os.path.exists(left_to_right_preprocessed_dir):\n        os.makedirs(left_to_right_preprocessed_dir)\n    if not os.path.exists(right_to_left_preprocessed_dir):\n        os.makedirs(right_to_left_preprocessed_dir)\n    if not os.path.exists(lm_preprocessed_dir):\n        os.makedirs(lm_preprocessed_dir)\n    if not os.path.exists(backwards_preprocessed_dir):\n        os.makedirs(backwards_preprocessed_dir)\n    score1_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model1_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards1)\n    if args.score_model2 is not None:\n        score2_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model2_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards2)\n    predictions_bpe_file = pre_gen + '/generate_output_bpe.txt'\n    using_nbest = args.nbest_list is not None\n    if using_nbest:\n        print('Using predefined n-best list from interactive.py')\n        predictions_bpe_file = args.nbest_list\n    elif not os.path.isfile(predictions_bpe_file):\n        print('STEP 1: generate predictions using the p(T|S) model with bpe')\n        print(args.data)\n        param1 = [args.data, '--path', args.gen_model, '--shard-id', str(args.shard_id), '--num-shards', str(args.num_shards), '--nbest', str(args.num_rescore), '--batch-size', str(args.batch_size), '--beam', str(args.num_rescore), '--batch-size', str(args.num_rescore), '--gen-subset', args.gen_subset, '--source-lang', args.source_lang, '--target-lang', args.target_lang]\n        if args.sampling:\n            param1 += ['--sampling']\n        gen_parser = options.get_generation_parser()\n        input_args = options.parse_args_and_arch(gen_parser, param1)\n        print(input_args)\n        with open(predictions_bpe_file, 'w') as f:\n            with redirect_stdout(f):\n                generate.main(input_args)\n    gen_output = rerank_utils.BitextOutputFromGen(predictions_bpe_file, bpe_symbol=args.post_process, nbest=using_nbest, prefix_len=args.prefix_len, target_prefix_frac=args.target_prefix_frac)\n    if args.diff_bpe:\n        rerank_utils.write_reprocessed(gen_output.no_bpe_source, gen_output.no_bpe_hypo, gen_output.no_bpe_target, pre_gen + '/source_gen_bpe.' + args.source_lang, pre_gen + '/target_gen_bpe.' + args.target_lang, pre_gen + '/reference_gen_bpe.' + args.target_lang)\n        bitext_bpe = args.rescore_bpe_code\n        bpe_src_param = ['-c', bitext_bpe, '--input', pre_gen + '/source_gen_bpe.' + args.source_lang, '--output', pre_gen + '/rescore_data.' + args.source_lang]\n        bpe_tgt_param = ['-c', bitext_bpe, '--input', pre_gen + '/target_gen_bpe.' + args.target_lang, '--output', pre_gen + '/rescore_data.' + args.target_lang]\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_src_param, shell=False)\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_tgt_param, shell=False)\n    if not os.path.isfile(score1_file) and (not rerank1_is_gen) or (args.score_model2 is not None and (not os.path.isfile(score2_file)) and (not rerank2_is_gen)):\n        print('STEP 2: process the output of generate.py so we have clean text files with the translations')\n        rescore_file = '/rescore_data'\n        if args.prefix_len is not None:\n            prefix_len_rescore_file = rescore_file + 'prefix' + str(args.prefix_len)\n        if args.target_prefix_frac is not None:\n            target_prefix_frac_rescore_file = rescore_file + 'target_prefix_frac' + str(args.target_prefix_frac)\n        if args.source_prefix_frac is not None:\n            source_prefix_frac_rescore_file = rescore_file + 'source_prefix_frac' + str(args.source_prefix_frac)\n        if not args.right_to_left1 or not args.right_to_left2:\n            if not args.diff_bpe:\n                rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + rescore_file + '.' + args.source_lang, pre_gen + rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process)\n                if args.prefix_len is not None:\n                    bw_rescore_file = prefix_len_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + prefix_len_rescore_file + '.' + args.source_lang, pre_gen + prefix_len_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', prefix_len=args.prefix_len, bpe_symbol=args.post_process)\n                elif args.target_prefix_frac is not None:\n                    bw_rescore_file = target_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + target_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + target_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, target_prefix_frac=args.target_prefix_frac)\n                else:\n                    bw_rescore_file = rescore_file\n                if args.source_prefix_frac is not None:\n                    fw_rescore_file = source_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + source_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + source_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, source_prefix_frac=args.source_prefix_frac)\n                else:\n                    fw_rescore_file = rescore_file\n        if args.right_to_left1 or args.right_to_left2:\n            rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + '/right_to_left_rescore_data.' + args.source_lang, pre_gen + '/right_to_left_rescore_data.' + args.target_lang, pre_gen + '/right_to_left_reference_file', right_to_left=True, bpe_symbol=args.post_process)\n        print('STEP 3: binarize the translations')\n        if not args.right_to_left1 or (args.score_model2 is not None and (not args.right_to_left2)) or (not rerank1_is_gen):\n            if args.backwards1 or args.backwards2:\n                if args.backwards_score_dict_dir is not None:\n                    bw_dict = args.backwards_score_dict_dir\n                else:\n                    bw_dict = args.score_dict_dir\n                bw_preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + bw_rescore_file, '--srcdict', bw_dict + '/dict.' + scorer1_src + '.txt', '--tgtdict', bw_dict + '/dict.' + scorer1_tgt + '.txt', '--destdir', backwards_preprocessed_dir]\n                preprocess_parser = options.get_preprocessing_parser()\n                input_args = preprocess_parser.parse_args(bw_preprocess_param)\n                preprocess.main(input_args)\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + fw_rescore_file, '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', left_to_right_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n        if args.right_to_left1 or args.right_to_left2:\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + '/right_to_left_rescore_data', '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', right_to_left_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n    return gen_output",
            "def gen_and_reprocess_nbest(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if args.score_dict_dir is None:\n        args.score_dict_dir = args.data\n    if args.prefix_len is not None:\n        assert args.right_to_left1 is False, 'prefix length not compatible with right to left models'\n        assert args.right_to_left2 is False, 'prefix length not compatible with right to left models'\n    if args.nbest_list is not None:\n        assert args.score_model2 is None\n    if args.backwards1:\n        scorer1_src = args.target_lang\n        scorer1_tgt = args.source_lang\n    else:\n        scorer1_src = args.source_lang\n        scorer1_tgt = args.target_lang\n    store_data = os.path.join(os.path.dirname(__file__)) + '/rerank_data/' + args.data_dir_name\n    if not os.path.exists(store_data):\n        os.makedirs(store_data)\n    (pre_gen, left_to_right_preprocessed_dir, right_to_left_preprocessed_dir, backwards_preprocessed_dir, lm_preprocessed_dir) = rerank_utils.get_directories(args.data_dir_name, args.num_rescore, args.gen_subset, args.gen_model_name, args.shard_id, args.num_shards, args.sampling, args.prefix_len, args.target_prefix_frac, args.source_prefix_frac)\n    assert not (args.right_to_left1 and args.backwards1), 'backwards right to left not supported'\n    assert not (args.right_to_left2 and args.backwards2), 'backwards right to left not supported'\n    assert not (args.prefix_len is not None and args.target_prefix_frac is not None), 'target prefix frac and target prefix len incompatible'\n    if not os.path.exists(pre_gen):\n        os.makedirs(pre_gen)\n    rerank1_is_gen = args.gen_model == args.score_model1 and args.source_prefix_frac is None\n    rerank2_is_gen = args.gen_model == args.score_model2 and args.source_prefix_frac is None\n    if args.nbest_list is not None:\n        rerank2_is_gen = True\n    if not os.path.exists(left_to_right_preprocessed_dir):\n        os.makedirs(left_to_right_preprocessed_dir)\n    if not os.path.exists(right_to_left_preprocessed_dir):\n        os.makedirs(right_to_left_preprocessed_dir)\n    if not os.path.exists(lm_preprocessed_dir):\n        os.makedirs(lm_preprocessed_dir)\n    if not os.path.exists(backwards_preprocessed_dir):\n        os.makedirs(backwards_preprocessed_dir)\n    score1_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model1_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards1)\n    if args.score_model2 is not None:\n        score2_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model2_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards2)\n    predictions_bpe_file = pre_gen + '/generate_output_bpe.txt'\n    using_nbest = args.nbest_list is not None\n    if using_nbest:\n        print('Using predefined n-best list from interactive.py')\n        predictions_bpe_file = args.nbest_list\n    elif not os.path.isfile(predictions_bpe_file):\n        print('STEP 1: generate predictions using the p(T|S) model with bpe')\n        print(args.data)\n        param1 = [args.data, '--path', args.gen_model, '--shard-id', str(args.shard_id), '--num-shards', str(args.num_shards), '--nbest', str(args.num_rescore), '--batch-size', str(args.batch_size), '--beam', str(args.num_rescore), '--batch-size', str(args.num_rescore), '--gen-subset', args.gen_subset, '--source-lang', args.source_lang, '--target-lang', args.target_lang]\n        if args.sampling:\n            param1 += ['--sampling']\n        gen_parser = options.get_generation_parser()\n        input_args = options.parse_args_and_arch(gen_parser, param1)\n        print(input_args)\n        with open(predictions_bpe_file, 'w') as f:\n            with redirect_stdout(f):\n                generate.main(input_args)\n    gen_output = rerank_utils.BitextOutputFromGen(predictions_bpe_file, bpe_symbol=args.post_process, nbest=using_nbest, prefix_len=args.prefix_len, target_prefix_frac=args.target_prefix_frac)\n    if args.diff_bpe:\n        rerank_utils.write_reprocessed(gen_output.no_bpe_source, gen_output.no_bpe_hypo, gen_output.no_bpe_target, pre_gen + '/source_gen_bpe.' + args.source_lang, pre_gen + '/target_gen_bpe.' + args.target_lang, pre_gen + '/reference_gen_bpe.' + args.target_lang)\n        bitext_bpe = args.rescore_bpe_code\n        bpe_src_param = ['-c', bitext_bpe, '--input', pre_gen + '/source_gen_bpe.' + args.source_lang, '--output', pre_gen + '/rescore_data.' + args.source_lang]\n        bpe_tgt_param = ['-c', bitext_bpe, '--input', pre_gen + '/target_gen_bpe.' + args.target_lang, '--output', pre_gen + '/rescore_data.' + args.target_lang]\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_src_param, shell=False)\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_tgt_param, shell=False)\n    if not os.path.isfile(score1_file) and (not rerank1_is_gen) or (args.score_model2 is not None and (not os.path.isfile(score2_file)) and (not rerank2_is_gen)):\n        print('STEP 2: process the output of generate.py so we have clean text files with the translations')\n        rescore_file = '/rescore_data'\n        if args.prefix_len is not None:\n            prefix_len_rescore_file = rescore_file + 'prefix' + str(args.prefix_len)\n        if args.target_prefix_frac is not None:\n            target_prefix_frac_rescore_file = rescore_file + 'target_prefix_frac' + str(args.target_prefix_frac)\n        if args.source_prefix_frac is not None:\n            source_prefix_frac_rescore_file = rescore_file + 'source_prefix_frac' + str(args.source_prefix_frac)\n        if not args.right_to_left1 or not args.right_to_left2:\n            if not args.diff_bpe:\n                rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + rescore_file + '.' + args.source_lang, pre_gen + rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process)\n                if args.prefix_len is not None:\n                    bw_rescore_file = prefix_len_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + prefix_len_rescore_file + '.' + args.source_lang, pre_gen + prefix_len_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', prefix_len=args.prefix_len, bpe_symbol=args.post_process)\n                elif args.target_prefix_frac is not None:\n                    bw_rescore_file = target_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + target_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + target_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, target_prefix_frac=args.target_prefix_frac)\n                else:\n                    bw_rescore_file = rescore_file\n                if args.source_prefix_frac is not None:\n                    fw_rescore_file = source_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + source_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + source_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, source_prefix_frac=args.source_prefix_frac)\n                else:\n                    fw_rescore_file = rescore_file\n        if args.right_to_left1 or args.right_to_left2:\n            rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + '/right_to_left_rescore_data.' + args.source_lang, pre_gen + '/right_to_left_rescore_data.' + args.target_lang, pre_gen + '/right_to_left_reference_file', right_to_left=True, bpe_symbol=args.post_process)\n        print('STEP 3: binarize the translations')\n        if not args.right_to_left1 or (args.score_model2 is not None and (not args.right_to_left2)) or (not rerank1_is_gen):\n            if args.backwards1 or args.backwards2:\n                if args.backwards_score_dict_dir is not None:\n                    bw_dict = args.backwards_score_dict_dir\n                else:\n                    bw_dict = args.score_dict_dir\n                bw_preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + bw_rescore_file, '--srcdict', bw_dict + '/dict.' + scorer1_src + '.txt', '--tgtdict', bw_dict + '/dict.' + scorer1_tgt + '.txt', '--destdir', backwards_preprocessed_dir]\n                preprocess_parser = options.get_preprocessing_parser()\n                input_args = preprocess_parser.parse_args(bw_preprocess_param)\n                preprocess.main(input_args)\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + fw_rescore_file, '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', left_to_right_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n        if args.right_to_left1 or args.right_to_left2:\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + '/right_to_left_rescore_data', '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', right_to_left_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n    return gen_output",
            "def gen_and_reprocess_nbest(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if args.score_dict_dir is None:\n        args.score_dict_dir = args.data\n    if args.prefix_len is not None:\n        assert args.right_to_left1 is False, 'prefix length not compatible with right to left models'\n        assert args.right_to_left2 is False, 'prefix length not compatible with right to left models'\n    if args.nbest_list is not None:\n        assert args.score_model2 is None\n    if args.backwards1:\n        scorer1_src = args.target_lang\n        scorer1_tgt = args.source_lang\n    else:\n        scorer1_src = args.source_lang\n        scorer1_tgt = args.target_lang\n    store_data = os.path.join(os.path.dirname(__file__)) + '/rerank_data/' + args.data_dir_name\n    if not os.path.exists(store_data):\n        os.makedirs(store_data)\n    (pre_gen, left_to_right_preprocessed_dir, right_to_left_preprocessed_dir, backwards_preprocessed_dir, lm_preprocessed_dir) = rerank_utils.get_directories(args.data_dir_name, args.num_rescore, args.gen_subset, args.gen_model_name, args.shard_id, args.num_shards, args.sampling, args.prefix_len, args.target_prefix_frac, args.source_prefix_frac)\n    assert not (args.right_to_left1 and args.backwards1), 'backwards right to left not supported'\n    assert not (args.right_to_left2 and args.backwards2), 'backwards right to left not supported'\n    assert not (args.prefix_len is not None and args.target_prefix_frac is not None), 'target prefix frac and target prefix len incompatible'\n    if not os.path.exists(pre_gen):\n        os.makedirs(pre_gen)\n    rerank1_is_gen = args.gen_model == args.score_model1 and args.source_prefix_frac is None\n    rerank2_is_gen = args.gen_model == args.score_model2 and args.source_prefix_frac is None\n    if args.nbest_list is not None:\n        rerank2_is_gen = True\n    if not os.path.exists(left_to_right_preprocessed_dir):\n        os.makedirs(left_to_right_preprocessed_dir)\n    if not os.path.exists(right_to_left_preprocessed_dir):\n        os.makedirs(right_to_left_preprocessed_dir)\n    if not os.path.exists(lm_preprocessed_dir):\n        os.makedirs(lm_preprocessed_dir)\n    if not os.path.exists(backwards_preprocessed_dir):\n        os.makedirs(backwards_preprocessed_dir)\n    score1_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model1_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards1)\n    if args.score_model2 is not None:\n        score2_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model2_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards2)\n    predictions_bpe_file = pre_gen + '/generate_output_bpe.txt'\n    using_nbest = args.nbest_list is not None\n    if using_nbest:\n        print('Using predefined n-best list from interactive.py')\n        predictions_bpe_file = args.nbest_list\n    elif not os.path.isfile(predictions_bpe_file):\n        print('STEP 1: generate predictions using the p(T|S) model with bpe')\n        print(args.data)\n        param1 = [args.data, '--path', args.gen_model, '--shard-id', str(args.shard_id), '--num-shards', str(args.num_shards), '--nbest', str(args.num_rescore), '--batch-size', str(args.batch_size), '--beam', str(args.num_rescore), '--batch-size', str(args.num_rescore), '--gen-subset', args.gen_subset, '--source-lang', args.source_lang, '--target-lang', args.target_lang]\n        if args.sampling:\n            param1 += ['--sampling']\n        gen_parser = options.get_generation_parser()\n        input_args = options.parse_args_and_arch(gen_parser, param1)\n        print(input_args)\n        with open(predictions_bpe_file, 'w') as f:\n            with redirect_stdout(f):\n                generate.main(input_args)\n    gen_output = rerank_utils.BitextOutputFromGen(predictions_bpe_file, bpe_symbol=args.post_process, nbest=using_nbest, prefix_len=args.prefix_len, target_prefix_frac=args.target_prefix_frac)\n    if args.diff_bpe:\n        rerank_utils.write_reprocessed(gen_output.no_bpe_source, gen_output.no_bpe_hypo, gen_output.no_bpe_target, pre_gen + '/source_gen_bpe.' + args.source_lang, pre_gen + '/target_gen_bpe.' + args.target_lang, pre_gen + '/reference_gen_bpe.' + args.target_lang)\n        bitext_bpe = args.rescore_bpe_code\n        bpe_src_param = ['-c', bitext_bpe, '--input', pre_gen + '/source_gen_bpe.' + args.source_lang, '--output', pre_gen + '/rescore_data.' + args.source_lang]\n        bpe_tgt_param = ['-c', bitext_bpe, '--input', pre_gen + '/target_gen_bpe.' + args.target_lang, '--output', pre_gen + '/rescore_data.' + args.target_lang]\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_src_param, shell=False)\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_tgt_param, shell=False)\n    if not os.path.isfile(score1_file) and (not rerank1_is_gen) or (args.score_model2 is not None and (not os.path.isfile(score2_file)) and (not rerank2_is_gen)):\n        print('STEP 2: process the output of generate.py so we have clean text files with the translations')\n        rescore_file = '/rescore_data'\n        if args.prefix_len is not None:\n            prefix_len_rescore_file = rescore_file + 'prefix' + str(args.prefix_len)\n        if args.target_prefix_frac is not None:\n            target_prefix_frac_rescore_file = rescore_file + 'target_prefix_frac' + str(args.target_prefix_frac)\n        if args.source_prefix_frac is not None:\n            source_prefix_frac_rescore_file = rescore_file + 'source_prefix_frac' + str(args.source_prefix_frac)\n        if not args.right_to_left1 or not args.right_to_left2:\n            if not args.diff_bpe:\n                rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + rescore_file + '.' + args.source_lang, pre_gen + rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process)\n                if args.prefix_len is not None:\n                    bw_rescore_file = prefix_len_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + prefix_len_rescore_file + '.' + args.source_lang, pre_gen + prefix_len_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', prefix_len=args.prefix_len, bpe_symbol=args.post_process)\n                elif args.target_prefix_frac is not None:\n                    bw_rescore_file = target_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + target_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + target_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, target_prefix_frac=args.target_prefix_frac)\n                else:\n                    bw_rescore_file = rescore_file\n                if args.source_prefix_frac is not None:\n                    fw_rescore_file = source_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + source_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + source_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, source_prefix_frac=args.source_prefix_frac)\n                else:\n                    fw_rescore_file = rescore_file\n        if args.right_to_left1 or args.right_to_left2:\n            rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + '/right_to_left_rescore_data.' + args.source_lang, pre_gen + '/right_to_left_rescore_data.' + args.target_lang, pre_gen + '/right_to_left_reference_file', right_to_left=True, bpe_symbol=args.post_process)\n        print('STEP 3: binarize the translations')\n        if not args.right_to_left1 or (args.score_model2 is not None and (not args.right_to_left2)) or (not rerank1_is_gen):\n            if args.backwards1 or args.backwards2:\n                if args.backwards_score_dict_dir is not None:\n                    bw_dict = args.backwards_score_dict_dir\n                else:\n                    bw_dict = args.score_dict_dir\n                bw_preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + bw_rescore_file, '--srcdict', bw_dict + '/dict.' + scorer1_src + '.txt', '--tgtdict', bw_dict + '/dict.' + scorer1_tgt + '.txt', '--destdir', backwards_preprocessed_dir]\n                preprocess_parser = options.get_preprocessing_parser()\n                input_args = preprocess_parser.parse_args(bw_preprocess_param)\n                preprocess.main(input_args)\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + fw_rescore_file, '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', left_to_right_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n        if args.right_to_left1 or args.right_to_left2:\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + '/right_to_left_rescore_data', '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', right_to_left_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n    return gen_output",
            "def gen_and_reprocess_nbest(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if args.score_dict_dir is None:\n        args.score_dict_dir = args.data\n    if args.prefix_len is not None:\n        assert args.right_to_left1 is False, 'prefix length not compatible with right to left models'\n        assert args.right_to_left2 is False, 'prefix length not compatible with right to left models'\n    if args.nbest_list is not None:\n        assert args.score_model2 is None\n    if args.backwards1:\n        scorer1_src = args.target_lang\n        scorer1_tgt = args.source_lang\n    else:\n        scorer1_src = args.source_lang\n        scorer1_tgt = args.target_lang\n    store_data = os.path.join(os.path.dirname(__file__)) + '/rerank_data/' + args.data_dir_name\n    if not os.path.exists(store_data):\n        os.makedirs(store_data)\n    (pre_gen, left_to_right_preprocessed_dir, right_to_left_preprocessed_dir, backwards_preprocessed_dir, lm_preprocessed_dir) = rerank_utils.get_directories(args.data_dir_name, args.num_rescore, args.gen_subset, args.gen_model_name, args.shard_id, args.num_shards, args.sampling, args.prefix_len, args.target_prefix_frac, args.source_prefix_frac)\n    assert not (args.right_to_left1 and args.backwards1), 'backwards right to left not supported'\n    assert not (args.right_to_left2 and args.backwards2), 'backwards right to left not supported'\n    assert not (args.prefix_len is not None and args.target_prefix_frac is not None), 'target prefix frac and target prefix len incompatible'\n    if not os.path.exists(pre_gen):\n        os.makedirs(pre_gen)\n    rerank1_is_gen = args.gen_model == args.score_model1 and args.source_prefix_frac is None\n    rerank2_is_gen = args.gen_model == args.score_model2 and args.source_prefix_frac is None\n    if args.nbest_list is not None:\n        rerank2_is_gen = True\n    if not os.path.exists(left_to_right_preprocessed_dir):\n        os.makedirs(left_to_right_preprocessed_dir)\n    if not os.path.exists(right_to_left_preprocessed_dir):\n        os.makedirs(right_to_left_preprocessed_dir)\n    if not os.path.exists(lm_preprocessed_dir):\n        os.makedirs(lm_preprocessed_dir)\n    if not os.path.exists(backwards_preprocessed_dir):\n        os.makedirs(backwards_preprocessed_dir)\n    score1_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model1_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards1)\n    if args.score_model2 is not None:\n        score2_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model2_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards2)\n    predictions_bpe_file = pre_gen + '/generate_output_bpe.txt'\n    using_nbest = args.nbest_list is not None\n    if using_nbest:\n        print('Using predefined n-best list from interactive.py')\n        predictions_bpe_file = args.nbest_list\n    elif not os.path.isfile(predictions_bpe_file):\n        print('STEP 1: generate predictions using the p(T|S) model with bpe')\n        print(args.data)\n        param1 = [args.data, '--path', args.gen_model, '--shard-id', str(args.shard_id), '--num-shards', str(args.num_shards), '--nbest', str(args.num_rescore), '--batch-size', str(args.batch_size), '--beam', str(args.num_rescore), '--batch-size', str(args.num_rescore), '--gen-subset', args.gen_subset, '--source-lang', args.source_lang, '--target-lang', args.target_lang]\n        if args.sampling:\n            param1 += ['--sampling']\n        gen_parser = options.get_generation_parser()\n        input_args = options.parse_args_and_arch(gen_parser, param1)\n        print(input_args)\n        with open(predictions_bpe_file, 'w') as f:\n            with redirect_stdout(f):\n                generate.main(input_args)\n    gen_output = rerank_utils.BitextOutputFromGen(predictions_bpe_file, bpe_symbol=args.post_process, nbest=using_nbest, prefix_len=args.prefix_len, target_prefix_frac=args.target_prefix_frac)\n    if args.diff_bpe:\n        rerank_utils.write_reprocessed(gen_output.no_bpe_source, gen_output.no_bpe_hypo, gen_output.no_bpe_target, pre_gen + '/source_gen_bpe.' + args.source_lang, pre_gen + '/target_gen_bpe.' + args.target_lang, pre_gen + '/reference_gen_bpe.' + args.target_lang)\n        bitext_bpe = args.rescore_bpe_code\n        bpe_src_param = ['-c', bitext_bpe, '--input', pre_gen + '/source_gen_bpe.' + args.source_lang, '--output', pre_gen + '/rescore_data.' + args.source_lang]\n        bpe_tgt_param = ['-c', bitext_bpe, '--input', pre_gen + '/target_gen_bpe.' + args.target_lang, '--output', pre_gen + '/rescore_data.' + args.target_lang]\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_src_param, shell=False)\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_tgt_param, shell=False)\n    if not os.path.isfile(score1_file) and (not rerank1_is_gen) or (args.score_model2 is not None and (not os.path.isfile(score2_file)) and (not rerank2_is_gen)):\n        print('STEP 2: process the output of generate.py so we have clean text files with the translations')\n        rescore_file = '/rescore_data'\n        if args.prefix_len is not None:\n            prefix_len_rescore_file = rescore_file + 'prefix' + str(args.prefix_len)\n        if args.target_prefix_frac is not None:\n            target_prefix_frac_rescore_file = rescore_file + 'target_prefix_frac' + str(args.target_prefix_frac)\n        if args.source_prefix_frac is not None:\n            source_prefix_frac_rescore_file = rescore_file + 'source_prefix_frac' + str(args.source_prefix_frac)\n        if not args.right_to_left1 or not args.right_to_left2:\n            if not args.diff_bpe:\n                rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + rescore_file + '.' + args.source_lang, pre_gen + rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process)\n                if args.prefix_len is not None:\n                    bw_rescore_file = prefix_len_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + prefix_len_rescore_file + '.' + args.source_lang, pre_gen + prefix_len_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', prefix_len=args.prefix_len, bpe_symbol=args.post_process)\n                elif args.target_prefix_frac is not None:\n                    bw_rescore_file = target_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + target_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + target_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, target_prefix_frac=args.target_prefix_frac)\n                else:\n                    bw_rescore_file = rescore_file\n                if args.source_prefix_frac is not None:\n                    fw_rescore_file = source_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + source_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + source_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, source_prefix_frac=args.source_prefix_frac)\n                else:\n                    fw_rescore_file = rescore_file\n        if args.right_to_left1 or args.right_to_left2:\n            rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + '/right_to_left_rescore_data.' + args.source_lang, pre_gen + '/right_to_left_rescore_data.' + args.target_lang, pre_gen + '/right_to_left_reference_file', right_to_left=True, bpe_symbol=args.post_process)\n        print('STEP 3: binarize the translations')\n        if not args.right_to_left1 or (args.score_model2 is not None and (not args.right_to_left2)) or (not rerank1_is_gen):\n            if args.backwards1 or args.backwards2:\n                if args.backwards_score_dict_dir is not None:\n                    bw_dict = args.backwards_score_dict_dir\n                else:\n                    bw_dict = args.score_dict_dir\n                bw_preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + bw_rescore_file, '--srcdict', bw_dict + '/dict.' + scorer1_src + '.txt', '--tgtdict', bw_dict + '/dict.' + scorer1_tgt + '.txt', '--destdir', backwards_preprocessed_dir]\n                preprocess_parser = options.get_preprocessing_parser()\n                input_args = preprocess_parser.parse_args(bw_preprocess_param)\n                preprocess.main(input_args)\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + fw_rescore_file, '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', left_to_right_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n        if args.right_to_left1 or args.right_to_left2:\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + '/right_to_left_rescore_data', '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', right_to_left_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n    return gen_output",
            "def gen_and_reprocess_nbest(args):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if args.score_dict_dir is None:\n        args.score_dict_dir = args.data\n    if args.prefix_len is not None:\n        assert args.right_to_left1 is False, 'prefix length not compatible with right to left models'\n        assert args.right_to_left2 is False, 'prefix length not compatible with right to left models'\n    if args.nbest_list is not None:\n        assert args.score_model2 is None\n    if args.backwards1:\n        scorer1_src = args.target_lang\n        scorer1_tgt = args.source_lang\n    else:\n        scorer1_src = args.source_lang\n        scorer1_tgt = args.target_lang\n    store_data = os.path.join(os.path.dirname(__file__)) + '/rerank_data/' + args.data_dir_name\n    if not os.path.exists(store_data):\n        os.makedirs(store_data)\n    (pre_gen, left_to_right_preprocessed_dir, right_to_left_preprocessed_dir, backwards_preprocessed_dir, lm_preprocessed_dir) = rerank_utils.get_directories(args.data_dir_name, args.num_rescore, args.gen_subset, args.gen_model_name, args.shard_id, args.num_shards, args.sampling, args.prefix_len, args.target_prefix_frac, args.source_prefix_frac)\n    assert not (args.right_to_left1 and args.backwards1), 'backwards right to left not supported'\n    assert not (args.right_to_left2 and args.backwards2), 'backwards right to left not supported'\n    assert not (args.prefix_len is not None and args.target_prefix_frac is not None), 'target prefix frac and target prefix len incompatible'\n    if not os.path.exists(pre_gen):\n        os.makedirs(pre_gen)\n    rerank1_is_gen = args.gen_model == args.score_model1 and args.source_prefix_frac is None\n    rerank2_is_gen = args.gen_model == args.score_model2 and args.source_prefix_frac is None\n    if args.nbest_list is not None:\n        rerank2_is_gen = True\n    if not os.path.exists(left_to_right_preprocessed_dir):\n        os.makedirs(left_to_right_preprocessed_dir)\n    if not os.path.exists(right_to_left_preprocessed_dir):\n        os.makedirs(right_to_left_preprocessed_dir)\n    if not os.path.exists(lm_preprocessed_dir):\n        os.makedirs(lm_preprocessed_dir)\n    if not os.path.exists(backwards_preprocessed_dir):\n        os.makedirs(backwards_preprocessed_dir)\n    score1_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model1_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards1)\n    if args.score_model2 is not None:\n        score2_file = rerank_utils.rescore_file_name(pre_gen, args.prefix_len, args.model2_name, target_prefix_frac=args.target_prefix_frac, source_prefix_frac=args.source_prefix_frac, backwards=args.backwards2)\n    predictions_bpe_file = pre_gen + '/generate_output_bpe.txt'\n    using_nbest = args.nbest_list is not None\n    if using_nbest:\n        print('Using predefined n-best list from interactive.py')\n        predictions_bpe_file = args.nbest_list\n    elif not os.path.isfile(predictions_bpe_file):\n        print('STEP 1: generate predictions using the p(T|S) model with bpe')\n        print(args.data)\n        param1 = [args.data, '--path', args.gen_model, '--shard-id', str(args.shard_id), '--num-shards', str(args.num_shards), '--nbest', str(args.num_rescore), '--batch-size', str(args.batch_size), '--beam', str(args.num_rescore), '--batch-size', str(args.num_rescore), '--gen-subset', args.gen_subset, '--source-lang', args.source_lang, '--target-lang', args.target_lang]\n        if args.sampling:\n            param1 += ['--sampling']\n        gen_parser = options.get_generation_parser()\n        input_args = options.parse_args_and_arch(gen_parser, param1)\n        print(input_args)\n        with open(predictions_bpe_file, 'w') as f:\n            with redirect_stdout(f):\n                generate.main(input_args)\n    gen_output = rerank_utils.BitextOutputFromGen(predictions_bpe_file, bpe_symbol=args.post_process, nbest=using_nbest, prefix_len=args.prefix_len, target_prefix_frac=args.target_prefix_frac)\n    if args.diff_bpe:\n        rerank_utils.write_reprocessed(gen_output.no_bpe_source, gen_output.no_bpe_hypo, gen_output.no_bpe_target, pre_gen + '/source_gen_bpe.' + args.source_lang, pre_gen + '/target_gen_bpe.' + args.target_lang, pre_gen + '/reference_gen_bpe.' + args.target_lang)\n        bitext_bpe = args.rescore_bpe_code\n        bpe_src_param = ['-c', bitext_bpe, '--input', pre_gen + '/source_gen_bpe.' + args.source_lang, '--output', pre_gen + '/rescore_data.' + args.source_lang]\n        bpe_tgt_param = ['-c', bitext_bpe, '--input', pre_gen + '/target_gen_bpe.' + args.target_lang, '--output', pre_gen + '/rescore_data.' + args.target_lang]\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_src_param, shell=False)\n        subprocess.call(['python', os.path.join(os.path.dirname(__file__), 'subword-nmt/subword_nmt/apply_bpe.py')] + bpe_tgt_param, shell=False)\n    if not os.path.isfile(score1_file) and (not rerank1_is_gen) or (args.score_model2 is not None and (not os.path.isfile(score2_file)) and (not rerank2_is_gen)):\n        print('STEP 2: process the output of generate.py so we have clean text files with the translations')\n        rescore_file = '/rescore_data'\n        if args.prefix_len is not None:\n            prefix_len_rescore_file = rescore_file + 'prefix' + str(args.prefix_len)\n        if args.target_prefix_frac is not None:\n            target_prefix_frac_rescore_file = rescore_file + 'target_prefix_frac' + str(args.target_prefix_frac)\n        if args.source_prefix_frac is not None:\n            source_prefix_frac_rescore_file = rescore_file + 'source_prefix_frac' + str(args.source_prefix_frac)\n        if not args.right_to_left1 or not args.right_to_left2:\n            if not args.diff_bpe:\n                rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + rescore_file + '.' + args.source_lang, pre_gen + rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process)\n                if args.prefix_len is not None:\n                    bw_rescore_file = prefix_len_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + prefix_len_rescore_file + '.' + args.source_lang, pre_gen + prefix_len_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', prefix_len=args.prefix_len, bpe_symbol=args.post_process)\n                elif args.target_prefix_frac is not None:\n                    bw_rescore_file = target_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + target_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + target_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, target_prefix_frac=args.target_prefix_frac)\n                else:\n                    bw_rescore_file = rescore_file\n                if args.source_prefix_frac is not None:\n                    fw_rescore_file = source_prefix_frac_rescore_file\n                    rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + source_prefix_frac_rescore_file + '.' + args.source_lang, pre_gen + source_prefix_frac_rescore_file + '.' + args.target_lang, pre_gen + '/reference_file', bpe_symbol=args.post_process, source_prefix_frac=args.source_prefix_frac)\n                else:\n                    fw_rescore_file = rescore_file\n        if args.right_to_left1 or args.right_to_left2:\n            rerank_utils.write_reprocessed(gen_output.source, gen_output.hypo, gen_output.target, pre_gen + '/right_to_left_rescore_data.' + args.source_lang, pre_gen + '/right_to_left_rescore_data.' + args.target_lang, pre_gen + '/right_to_left_reference_file', right_to_left=True, bpe_symbol=args.post_process)\n        print('STEP 3: binarize the translations')\n        if not args.right_to_left1 or (args.score_model2 is not None and (not args.right_to_left2)) or (not rerank1_is_gen):\n            if args.backwards1 or args.backwards2:\n                if args.backwards_score_dict_dir is not None:\n                    bw_dict = args.backwards_score_dict_dir\n                else:\n                    bw_dict = args.score_dict_dir\n                bw_preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + bw_rescore_file, '--srcdict', bw_dict + '/dict.' + scorer1_src + '.txt', '--tgtdict', bw_dict + '/dict.' + scorer1_tgt + '.txt', '--destdir', backwards_preprocessed_dir]\n                preprocess_parser = options.get_preprocessing_parser()\n                input_args = preprocess_parser.parse_args(bw_preprocess_param)\n                preprocess.main(input_args)\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + fw_rescore_file, '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', left_to_right_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n        if args.right_to_left1 or args.right_to_left2:\n            preprocess_param = ['--source-lang', scorer1_src, '--target-lang', scorer1_tgt, '--trainpref', pre_gen + '/right_to_left_rescore_data', '--srcdict', args.score_dict_dir + '/dict.' + scorer1_src + '.txt', '--tgtdict', args.score_dict_dir + '/dict.' + scorer1_tgt + '.txt', '--destdir', right_to_left_preprocessed_dir]\n            preprocess_parser = options.get_preprocessing_parser()\n            input_args = preprocess_parser.parse_args(preprocess_param)\n            preprocess.main(input_args)\n    return gen_output"
        ]
    },
    {
        "func_name": "cli_main",
        "original": "def cli_main():\n    parser = rerank_options.get_reranking_parser()\n    args = options.parse_args_and_arch(parser)\n    gen_and_reprocess_nbest(args)",
        "mutated": [
            "def cli_main():\n    if False:\n        i = 10\n    parser = rerank_options.get_reranking_parser()\n    args = options.parse_args_and_arch(parser)\n    gen_and_reprocess_nbest(args)",
            "def cli_main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    parser = rerank_options.get_reranking_parser()\n    args = options.parse_args_and_arch(parser)\n    gen_and_reprocess_nbest(args)",
            "def cli_main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    parser = rerank_options.get_reranking_parser()\n    args = options.parse_args_and_arch(parser)\n    gen_and_reprocess_nbest(args)",
            "def cli_main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    parser = rerank_options.get_reranking_parser()\n    args = options.parse_args_and_arch(parser)\n    gen_and_reprocess_nbest(args)",
            "def cli_main():\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    parser = rerank_options.get_reranking_parser()\n    args = options.parse_args_and_arch(parser)\n    gen_and_reprocess_nbest(args)"
        ]
    }
]