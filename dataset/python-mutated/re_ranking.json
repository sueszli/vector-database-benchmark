[
    {
        "func_name": "k_reciprocal_neigh",
        "original": "def k_reciprocal_neigh(initial_rank, i, k1):\n    forward_k_neigh_index = initial_rank[i, :k1 + 1]\n    backward_k_neigh_index = initial_rank[forward_k_neigh_index, :k1 + 1]\n    fi = np.where(backward_k_neigh_index == i)[0]\n    return forward_k_neigh_index[fi]",
        "mutated": [
            "def k_reciprocal_neigh(initial_rank, i, k1):\n    if False:\n        i = 10\n    forward_k_neigh_index = initial_rank[i, :k1 + 1]\n    backward_k_neigh_index = initial_rank[forward_k_neigh_index, :k1 + 1]\n    fi = np.where(backward_k_neigh_index == i)[0]\n    return forward_k_neigh_index[fi]",
            "def k_reciprocal_neigh(initial_rank, i, k1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    forward_k_neigh_index = initial_rank[i, :k1 + 1]\n    backward_k_neigh_index = initial_rank[forward_k_neigh_index, :k1 + 1]\n    fi = np.where(backward_k_neigh_index == i)[0]\n    return forward_k_neigh_index[fi]",
            "def k_reciprocal_neigh(initial_rank, i, k1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    forward_k_neigh_index = initial_rank[i, :k1 + 1]\n    backward_k_neigh_index = initial_rank[forward_k_neigh_index, :k1 + 1]\n    fi = np.where(backward_k_neigh_index == i)[0]\n    return forward_k_neigh_index[fi]",
            "def k_reciprocal_neigh(initial_rank, i, k1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    forward_k_neigh_index = initial_rank[i, :k1 + 1]\n    backward_k_neigh_index = initial_rank[forward_k_neigh_index, :k1 + 1]\n    fi = np.where(backward_k_neigh_index == i)[0]\n    return forward_k_neigh_index[fi]",
            "def k_reciprocal_neigh(initial_rank, i, k1):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    forward_k_neigh_index = initial_rank[i, :k1 + 1]\n    backward_k_neigh_index = initial_rank[forward_k_neigh_index, :k1 + 1]\n    fi = np.where(backward_k_neigh_index == i)[0]\n    return forward_k_neigh_index[fi]"
        ]
    },
    {
        "func_name": "re_ranking",
        "original": "def re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=20, k2=6, lambda_value=0.3):\n    original_dist = np.concatenate([np.concatenate([q_q_dist, q_g_dist], axis=1), np.concatenate([q_g_dist.T, g_g_dist], axis=1)], axis=0)\n    original_dist = 2.0 - 2 * original_dist\n    original_dist = np.power(original_dist, 2).astype(np.float32)\n    original_dist = np.transpose(1.0 * original_dist / np.max(original_dist, axis=0))\n    V = np.zeros_like(original_dist).astype(np.float32)\n    initial_rank = np.argpartition(original_dist, range(1, k1 + 1))\n    query_num = q_g_dist.shape[0]\n    all_num = original_dist.shape[0]\n    for i in range(all_num):\n        k_reciprocal_index = k_reciprocal_neigh(initial_rank, i, k1)\n        k_reciprocal_expansion_index = k_reciprocal_index\n        for j in range(len(k_reciprocal_index)):\n            candidate = k_reciprocal_index[j]\n            candidate_k_reciprocal_index = k_reciprocal_neigh(initial_rank, candidate, int(np.around(k1 / 2)))\n            if len(np.intersect1d(candidate_k_reciprocal_index, k_reciprocal_index)) > 2.0 / 3 * len(candidate_k_reciprocal_index):\n                k_reciprocal_expansion_index = np.append(k_reciprocal_expansion_index, candidate_k_reciprocal_index)\n        k_reciprocal_expansion_index = np.unique(k_reciprocal_expansion_index)\n        weight = np.exp(-original_dist[i, k_reciprocal_expansion_index])\n        V[i, k_reciprocal_expansion_index] = 1.0 * weight / np.sum(weight)\n    original_dist = original_dist[:query_num,]\n    if k2 != 1:\n        V_qe = np.zeros_like(V, dtype=np.float32)\n        for i in range(all_num):\n            V_qe[i, :] = np.mean(V[initial_rank[i, :k2], :], axis=0)\n        V = V_qe\n        del V_qe\n    del initial_rank\n    invIndex = []\n    for i in range(all_num):\n        invIndex.append(np.where(V[:, i] != 0)[0])\n    jaccard_dist = np.zeros_like(original_dist, dtype=np.float32)\n    for i in range(query_num):\n        temp_min = np.zeros(shape=[1, all_num], dtype=np.float32)\n        indNonZero = np.where(V[i, :] != 0)[0]\n        indImages = []\n        indImages = [invIndex[ind] for ind in indNonZero]\n        for j in range(len(indNonZero)):\n            temp_min[0, indImages[j]] = temp_min[0, indImages[j]] + np.minimum(V[i, indNonZero[j]], V[indImages[j], indNonZero[j]])\n        jaccard_dist[i] = 1 - temp_min / (2.0 - temp_min)\n    final_dist = jaccard_dist * (1 - lambda_value) + original_dist * lambda_value\n    del original_dist\n    del V\n    del jaccard_dist\n    final_dist = final_dist[:query_num, query_num:]\n    return final_dist",
        "mutated": [
            "def re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=20, k2=6, lambda_value=0.3):\n    if False:\n        i = 10\n    original_dist = np.concatenate([np.concatenate([q_q_dist, q_g_dist], axis=1), np.concatenate([q_g_dist.T, g_g_dist], axis=1)], axis=0)\n    original_dist = 2.0 - 2 * original_dist\n    original_dist = np.power(original_dist, 2).astype(np.float32)\n    original_dist = np.transpose(1.0 * original_dist / np.max(original_dist, axis=0))\n    V = np.zeros_like(original_dist).astype(np.float32)\n    initial_rank = np.argpartition(original_dist, range(1, k1 + 1))\n    query_num = q_g_dist.shape[0]\n    all_num = original_dist.shape[0]\n    for i in range(all_num):\n        k_reciprocal_index = k_reciprocal_neigh(initial_rank, i, k1)\n        k_reciprocal_expansion_index = k_reciprocal_index\n        for j in range(len(k_reciprocal_index)):\n            candidate = k_reciprocal_index[j]\n            candidate_k_reciprocal_index = k_reciprocal_neigh(initial_rank, candidate, int(np.around(k1 / 2)))\n            if len(np.intersect1d(candidate_k_reciprocal_index, k_reciprocal_index)) > 2.0 / 3 * len(candidate_k_reciprocal_index):\n                k_reciprocal_expansion_index = np.append(k_reciprocal_expansion_index, candidate_k_reciprocal_index)\n        k_reciprocal_expansion_index = np.unique(k_reciprocal_expansion_index)\n        weight = np.exp(-original_dist[i, k_reciprocal_expansion_index])\n        V[i, k_reciprocal_expansion_index] = 1.0 * weight / np.sum(weight)\n    original_dist = original_dist[:query_num,]\n    if k2 != 1:\n        V_qe = np.zeros_like(V, dtype=np.float32)\n        for i in range(all_num):\n            V_qe[i, :] = np.mean(V[initial_rank[i, :k2], :], axis=0)\n        V = V_qe\n        del V_qe\n    del initial_rank\n    invIndex = []\n    for i in range(all_num):\n        invIndex.append(np.where(V[:, i] != 0)[0])\n    jaccard_dist = np.zeros_like(original_dist, dtype=np.float32)\n    for i in range(query_num):\n        temp_min = np.zeros(shape=[1, all_num], dtype=np.float32)\n        indNonZero = np.where(V[i, :] != 0)[0]\n        indImages = []\n        indImages = [invIndex[ind] for ind in indNonZero]\n        for j in range(len(indNonZero)):\n            temp_min[0, indImages[j]] = temp_min[0, indImages[j]] + np.minimum(V[i, indNonZero[j]], V[indImages[j], indNonZero[j]])\n        jaccard_dist[i] = 1 - temp_min / (2.0 - temp_min)\n    final_dist = jaccard_dist * (1 - lambda_value) + original_dist * lambda_value\n    del original_dist\n    del V\n    del jaccard_dist\n    final_dist = final_dist[:query_num, query_num:]\n    return final_dist",
            "def re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=20, k2=6, lambda_value=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    original_dist = np.concatenate([np.concatenate([q_q_dist, q_g_dist], axis=1), np.concatenate([q_g_dist.T, g_g_dist], axis=1)], axis=0)\n    original_dist = 2.0 - 2 * original_dist\n    original_dist = np.power(original_dist, 2).astype(np.float32)\n    original_dist = np.transpose(1.0 * original_dist / np.max(original_dist, axis=0))\n    V = np.zeros_like(original_dist).astype(np.float32)\n    initial_rank = np.argpartition(original_dist, range(1, k1 + 1))\n    query_num = q_g_dist.shape[0]\n    all_num = original_dist.shape[0]\n    for i in range(all_num):\n        k_reciprocal_index = k_reciprocal_neigh(initial_rank, i, k1)\n        k_reciprocal_expansion_index = k_reciprocal_index\n        for j in range(len(k_reciprocal_index)):\n            candidate = k_reciprocal_index[j]\n            candidate_k_reciprocal_index = k_reciprocal_neigh(initial_rank, candidate, int(np.around(k1 / 2)))\n            if len(np.intersect1d(candidate_k_reciprocal_index, k_reciprocal_index)) > 2.0 / 3 * len(candidate_k_reciprocal_index):\n                k_reciprocal_expansion_index = np.append(k_reciprocal_expansion_index, candidate_k_reciprocal_index)\n        k_reciprocal_expansion_index = np.unique(k_reciprocal_expansion_index)\n        weight = np.exp(-original_dist[i, k_reciprocal_expansion_index])\n        V[i, k_reciprocal_expansion_index] = 1.0 * weight / np.sum(weight)\n    original_dist = original_dist[:query_num,]\n    if k2 != 1:\n        V_qe = np.zeros_like(V, dtype=np.float32)\n        for i in range(all_num):\n            V_qe[i, :] = np.mean(V[initial_rank[i, :k2], :], axis=0)\n        V = V_qe\n        del V_qe\n    del initial_rank\n    invIndex = []\n    for i in range(all_num):\n        invIndex.append(np.where(V[:, i] != 0)[0])\n    jaccard_dist = np.zeros_like(original_dist, dtype=np.float32)\n    for i in range(query_num):\n        temp_min = np.zeros(shape=[1, all_num], dtype=np.float32)\n        indNonZero = np.where(V[i, :] != 0)[0]\n        indImages = []\n        indImages = [invIndex[ind] for ind in indNonZero]\n        for j in range(len(indNonZero)):\n            temp_min[0, indImages[j]] = temp_min[0, indImages[j]] + np.minimum(V[i, indNonZero[j]], V[indImages[j], indNonZero[j]])\n        jaccard_dist[i] = 1 - temp_min / (2.0 - temp_min)\n    final_dist = jaccard_dist * (1 - lambda_value) + original_dist * lambda_value\n    del original_dist\n    del V\n    del jaccard_dist\n    final_dist = final_dist[:query_num, query_num:]\n    return final_dist",
            "def re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=20, k2=6, lambda_value=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    original_dist = np.concatenate([np.concatenate([q_q_dist, q_g_dist], axis=1), np.concatenate([q_g_dist.T, g_g_dist], axis=1)], axis=0)\n    original_dist = 2.0 - 2 * original_dist\n    original_dist = np.power(original_dist, 2).astype(np.float32)\n    original_dist = np.transpose(1.0 * original_dist / np.max(original_dist, axis=0))\n    V = np.zeros_like(original_dist).astype(np.float32)\n    initial_rank = np.argpartition(original_dist, range(1, k1 + 1))\n    query_num = q_g_dist.shape[0]\n    all_num = original_dist.shape[0]\n    for i in range(all_num):\n        k_reciprocal_index = k_reciprocal_neigh(initial_rank, i, k1)\n        k_reciprocal_expansion_index = k_reciprocal_index\n        for j in range(len(k_reciprocal_index)):\n            candidate = k_reciprocal_index[j]\n            candidate_k_reciprocal_index = k_reciprocal_neigh(initial_rank, candidate, int(np.around(k1 / 2)))\n            if len(np.intersect1d(candidate_k_reciprocal_index, k_reciprocal_index)) > 2.0 / 3 * len(candidate_k_reciprocal_index):\n                k_reciprocal_expansion_index = np.append(k_reciprocal_expansion_index, candidate_k_reciprocal_index)\n        k_reciprocal_expansion_index = np.unique(k_reciprocal_expansion_index)\n        weight = np.exp(-original_dist[i, k_reciprocal_expansion_index])\n        V[i, k_reciprocal_expansion_index] = 1.0 * weight / np.sum(weight)\n    original_dist = original_dist[:query_num,]\n    if k2 != 1:\n        V_qe = np.zeros_like(V, dtype=np.float32)\n        for i in range(all_num):\n            V_qe[i, :] = np.mean(V[initial_rank[i, :k2], :], axis=0)\n        V = V_qe\n        del V_qe\n    del initial_rank\n    invIndex = []\n    for i in range(all_num):\n        invIndex.append(np.where(V[:, i] != 0)[0])\n    jaccard_dist = np.zeros_like(original_dist, dtype=np.float32)\n    for i in range(query_num):\n        temp_min = np.zeros(shape=[1, all_num], dtype=np.float32)\n        indNonZero = np.where(V[i, :] != 0)[0]\n        indImages = []\n        indImages = [invIndex[ind] for ind in indNonZero]\n        for j in range(len(indNonZero)):\n            temp_min[0, indImages[j]] = temp_min[0, indImages[j]] + np.minimum(V[i, indNonZero[j]], V[indImages[j], indNonZero[j]])\n        jaccard_dist[i] = 1 - temp_min / (2.0 - temp_min)\n    final_dist = jaccard_dist * (1 - lambda_value) + original_dist * lambda_value\n    del original_dist\n    del V\n    del jaccard_dist\n    final_dist = final_dist[:query_num, query_num:]\n    return final_dist",
            "def re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=20, k2=6, lambda_value=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    original_dist = np.concatenate([np.concatenate([q_q_dist, q_g_dist], axis=1), np.concatenate([q_g_dist.T, g_g_dist], axis=1)], axis=0)\n    original_dist = 2.0 - 2 * original_dist\n    original_dist = np.power(original_dist, 2).astype(np.float32)\n    original_dist = np.transpose(1.0 * original_dist / np.max(original_dist, axis=0))\n    V = np.zeros_like(original_dist).astype(np.float32)\n    initial_rank = np.argpartition(original_dist, range(1, k1 + 1))\n    query_num = q_g_dist.shape[0]\n    all_num = original_dist.shape[0]\n    for i in range(all_num):\n        k_reciprocal_index = k_reciprocal_neigh(initial_rank, i, k1)\n        k_reciprocal_expansion_index = k_reciprocal_index\n        for j in range(len(k_reciprocal_index)):\n            candidate = k_reciprocal_index[j]\n            candidate_k_reciprocal_index = k_reciprocal_neigh(initial_rank, candidate, int(np.around(k1 / 2)))\n            if len(np.intersect1d(candidate_k_reciprocal_index, k_reciprocal_index)) > 2.0 / 3 * len(candidate_k_reciprocal_index):\n                k_reciprocal_expansion_index = np.append(k_reciprocal_expansion_index, candidate_k_reciprocal_index)\n        k_reciprocal_expansion_index = np.unique(k_reciprocal_expansion_index)\n        weight = np.exp(-original_dist[i, k_reciprocal_expansion_index])\n        V[i, k_reciprocal_expansion_index] = 1.0 * weight / np.sum(weight)\n    original_dist = original_dist[:query_num,]\n    if k2 != 1:\n        V_qe = np.zeros_like(V, dtype=np.float32)\n        for i in range(all_num):\n            V_qe[i, :] = np.mean(V[initial_rank[i, :k2], :], axis=0)\n        V = V_qe\n        del V_qe\n    del initial_rank\n    invIndex = []\n    for i in range(all_num):\n        invIndex.append(np.where(V[:, i] != 0)[0])\n    jaccard_dist = np.zeros_like(original_dist, dtype=np.float32)\n    for i in range(query_num):\n        temp_min = np.zeros(shape=[1, all_num], dtype=np.float32)\n        indNonZero = np.where(V[i, :] != 0)[0]\n        indImages = []\n        indImages = [invIndex[ind] for ind in indNonZero]\n        for j in range(len(indNonZero)):\n            temp_min[0, indImages[j]] = temp_min[0, indImages[j]] + np.minimum(V[i, indNonZero[j]], V[indImages[j], indNonZero[j]])\n        jaccard_dist[i] = 1 - temp_min / (2.0 - temp_min)\n    final_dist = jaccard_dist * (1 - lambda_value) + original_dist * lambda_value\n    del original_dist\n    del V\n    del jaccard_dist\n    final_dist = final_dist[:query_num, query_num:]\n    return final_dist",
            "def re_ranking(q_g_dist, q_q_dist, g_g_dist, k1=20, k2=6, lambda_value=0.3):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    original_dist = np.concatenate([np.concatenate([q_q_dist, q_g_dist], axis=1), np.concatenate([q_g_dist.T, g_g_dist], axis=1)], axis=0)\n    original_dist = 2.0 - 2 * original_dist\n    original_dist = np.power(original_dist, 2).astype(np.float32)\n    original_dist = np.transpose(1.0 * original_dist / np.max(original_dist, axis=0))\n    V = np.zeros_like(original_dist).astype(np.float32)\n    initial_rank = np.argpartition(original_dist, range(1, k1 + 1))\n    query_num = q_g_dist.shape[0]\n    all_num = original_dist.shape[0]\n    for i in range(all_num):\n        k_reciprocal_index = k_reciprocal_neigh(initial_rank, i, k1)\n        k_reciprocal_expansion_index = k_reciprocal_index\n        for j in range(len(k_reciprocal_index)):\n            candidate = k_reciprocal_index[j]\n            candidate_k_reciprocal_index = k_reciprocal_neigh(initial_rank, candidate, int(np.around(k1 / 2)))\n            if len(np.intersect1d(candidate_k_reciprocal_index, k_reciprocal_index)) > 2.0 / 3 * len(candidate_k_reciprocal_index):\n                k_reciprocal_expansion_index = np.append(k_reciprocal_expansion_index, candidate_k_reciprocal_index)\n        k_reciprocal_expansion_index = np.unique(k_reciprocal_expansion_index)\n        weight = np.exp(-original_dist[i, k_reciprocal_expansion_index])\n        V[i, k_reciprocal_expansion_index] = 1.0 * weight / np.sum(weight)\n    original_dist = original_dist[:query_num,]\n    if k2 != 1:\n        V_qe = np.zeros_like(V, dtype=np.float32)\n        for i in range(all_num):\n            V_qe[i, :] = np.mean(V[initial_rank[i, :k2], :], axis=0)\n        V = V_qe\n        del V_qe\n    del initial_rank\n    invIndex = []\n    for i in range(all_num):\n        invIndex.append(np.where(V[:, i] != 0)[0])\n    jaccard_dist = np.zeros_like(original_dist, dtype=np.float32)\n    for i in range(query_num):\n        temp_min = np.zeros(shape=[1, all_num], dtype=np.float32)\n        indNonZero = np.where(V[i, :] != 0)[0]\n        indImages = []\n        indImages = [invIndex[ind] for ind in indNonZero]\n        for j in range(len(indNonZero)):\n            temp_min[0, indImages[j]] = temp_min[0, indImages[j]] + np.minimum(V[i, indNonZero[j]], V[indImages[j], indNonZero[j]])\n        jaccard_dist[i] = 1 - temp_min / (2.0 - temp_min)\n    final_dist = jaccard_dist * (1 - lambda_value) + original_dist * lambda_value\n    del original_dist\n    del V\n    del jaccard_dist\n    final_dist = final_dist[:query_num, query_num:]\n    return final_dist"
        ]
    }
]