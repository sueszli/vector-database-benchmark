[
    {
        "func_name": "printTable",
        "original": "@staticmethod\ndef printTable(items, header):\n    colLen = []\n    for (i, col) in enumerate(header):\n        rowMaxLen = max([len(row[i]) for row in items])\n        colLen.append(max(rowMaxLen, len(col)))\n    outputFormat = ' '.join(['{%d:%ds} ' % (num, width) for (num, width) in enumerate(colLen)])\n    print(outputFormat.format(*header))\n    print('  '.join(['-' * itemLen for itemLen in colLen]))\n    for row in items:\n        print(outputFormat.format(*row))",
        "mutated": [
            "@staticmethod\ndef printTable(items, header):\n    if False:\n        i = 10\n    colLen = []\n    for (i, col) in enumerate(header):\n        rowMaxLen = max([len(row[i]) for row in items])\n        colLen.append(max(rowMaxLen, len(col)))\n    outputFormat = ' '.join(['{%d:%ds} ' % (num, width) for (num, width) in enumerate(colLen)])\n    print(outputFormat.format(*header))\n    print('  '.join(['-' * itemLen for itemLen in colLen]))\n    for row in items:\n        print(outputFormat.format(*row))",
            "@staticmethod\ndef printTable(items, header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    colLen = []\n    for (i, col) in enumerate(header):\n        rowMaxLen = max([len(row[i]) for row in items])\n        colLen.append(max(rowMaxLen, len(col)))\n    outputFormat = ' '.join(['{%d:%ds} ' % (num, width) for (num, width) in enumerate(colLen)])\n    print(outputFormat.format(*header))\n    print('  '.join(['-' * itemLen for itemLen in colLen]))\n    for row in items:\n        print(outputFormat.format(*row))",
            "@staticmethod\ndef printTable(items, header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    colLen = []\n    for (i, col) in enumerate(header):\n        rowMaxLen = max([len(row[i]) for row in items])\n        colLen.append(max(rowMaxLen, len(col)))\n    outputFormat = ' '.join(['{%d:%ds} ' % (num, width) for (num, width) in enumerate(colLen)])\n    print(outputFormat.format(*header))\n    print('  '.join(['-' * itemLen for itemLen in colLen]))\n    for row in items:\n        print(outputFormat.format(*row))",
            "@staticmethod\ndef printTable(items, header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    colLen = []\n    for (i, col) in enumerate(header):\n        rowMaxLen = max([len(row[i]) for row in items])\n        colLen.append(max(rowMaxLen, len(col)))\n    outputFormat = ' '.join(['{%d:%ds} ' % (num, width) for (num, width) in enumerate(colLen)])\n    print(outputFormat.format(*header))\n    print('  '.join(['-' * itemLen for itemLen in colLen]))\n    for row in items:\n        print(outputFormat.format(*row))",
            "@staticmethod\ndef printTable(items, header):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    colLen = []\n    for (i, col) in enumerate(header):\n        rowMaxLen = max([len(row[i]) for row in items])\n        colLen.append(max(rowMaxLen, len(col)))\n    outputFormat = ' '.join(['{%d:%ds} ' % (num, width) for (num, width) in enumerate(colLen)])\n    print(outputFormat.format(*header))\n    print('  '.join(['-' * itemLen for itemLen in colLen]))\n    for row in items:\n        print(outputFormat.format(*row))"
        ]
    },
    {
        "func_name": "__init__",
        "original": "def __init__(self, username, password, user_domain, target_domain, cmdLineOptions):\n    self.__username = username\n    self.__password = password\n    self.__domain = user_domain\n    self.__target = None\n    self.__targetDomain = target_domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = cmdLineOptions.aesKey\n    self.__doKerberos = cmdLineOptions.k\n    self.__kdcIP = cmdLineOptions.dc_ip\n    self.__kdcHost = cmdLineOptions.dc_host\n    if cmdLineOptions.hashes is not None:\n        (self.__lmhash, self.__nthash) = cmdLineOptions.hashes.split(':')\n    domainParts = self.__targetDomain.split('.')\n    self.baseDN = ''\n    for i in domainParts:\n        self.baseDN += 'dc=%s,' % i\n    self.baseDN = self.baseDN[:-1]\n    if user_domain != self.__targetDomain and (self.__kdcIP or self.__kdcHost):\n        logging.warning('KDC IP address and hostname will be ignored because of cross-domain targeting.')\n        self.__kdcIP = None\n        self.__kdcHost = None",
        "mutated": [
            "def __init__(self, username, password, user_domain, target_domain, cmdLineOptions):\n    if False:\n        i = 10\n    self.__username = username\n    self.__password = password\n    self.__domain = user_domain\n    self.__target = None\n    self.__targetDomain = target_domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = cmdLineOptions.aesKey\n    self.__doKerberos = cmdLineOptions.k\n    self.__kdcIP = cmdLineOptions.dc_ip\n    self.__kdcHost = cmdLineOptions.dc_host\n    if cmdLineOptions.hashes is not None:\n        (self.__lmhash, self.__nthash) = cmdLineOptions.hashes.split(':')\n    domainParts = self.__targetDomain.split('.')\n    self.baseDN = ''\n    for i in domainParts:\n        self.baseDN += 'dc=%s,' % i\n    self.baseDN = self.baseDN[:-1]\n    if user_domain != self.__targetDomain and (self.__kdcIP or self.__kdcHost):\n        logging.warning('KDC IP address and hostname will be ignored because of cross-domain targeting.')\n        self.__kdcIP = None\n        self.__kdcHost = None",
            "def __init__(self, username, password, user_domain, target_domain, cmdLineOptions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    self.__username = username\n    self.__password = password\n    self.__domain = user_domain\n    self.__target = None\n    self.__targetDomain = target_domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = cmdLineOptions.aesKey\n    self.__doKerberos = cmdLineOptions.k\n    self.__kdcIP = cmdLineOptions.dc_ip\n    self.__kdcHost = cmdLineOptions.dc_host\n    if cmdLineOptions.hashes is not None:\n        (self.__lmhash, self.__nthash) = cmdLineOptions.hashes.split(':')\n    domainParts = self.__targetDomain.split('.')\n    self.baseDN = ''\n    for i in domainParts:\n        self.baseDN += 'dc=%s,' % i\n    self.baseDN = self.baseDN[:-1]\n    if user_domain != self.__targetDomain and (self.__kdcIP or self.__kdcHost):\n        logging.warning('KDC IP address and hostname will be ignored because of cross-domain targeting.')\n        self.__kdcIP = None\n        self.__kdcHost = None",
            "def __init__(self, username, password, user_domain, target_domain, cmdLineOptions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    self.__username = username\n    self.__password = password\n    self.__domain = user_domain\n    self.__target = None\n    self.__targetDomain = target_domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = cmdLineOptions.aesKey\n    self.__doKerberos = cmdLineOptions.k\n    self.__kdcIP = cmdLineOptions.dc_ip\n    self.__kdcHost = cmdLineOptions.dc_host\n    if cmdLineOptions.hashes is not None:\n        (self.__lmhash, self.__nthash) = cmdLineOptions.hashes.split(':')\n    domainParts = self.__targetDomain.split('.')\n    self.baseDN = ''\n    for i in domainParts:\n        self.baseDN += 'dc=%s,' % i\n    self.baseDN = self.baseDN[:-1]\n    if user_domain != self.__targetDomain and (self.__kdcIP or self.__kdcHost):\n        logging.warning('KDC IP address and hostname will be ignored because of cross-domain targeting.')\n        self.__kdcIP = None\n        self.__kdcHost = None",
            "def __init__(self, username, password, user_domain, target_domain, cmdLineOptions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    self.__username = username\n    self.__password = password\n    self.__domain = user_domain\n    self.__target = None\n    self.__targetDomain = target_domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = cmdLineOptions.aesKey\n    self.__doKerberos = cmdLineOptions.k\n    self.__kdcIP = cmdLineOptions.dc_ip\n    self.__kdcHost = cmdLineOptions.dc_host\n    if cmdLineOptions.hashes is not None:\n        (self.__lmhash, self.__nthash) = cmdLineOptions.hashes.split(':')\n    domainParts = self.__targetDomain.split('.')\n    self.baseDN = ''\n    for i in domainParts:\n        self.baseDN += 'dc=%s,' % i\n    self.baseDN = self.baseDN[:-1]\n    if user_domain != self.__targetDomain and (self.__kdcIP or self.__kdcHost):\n        logging.warning('KDC IP address and hostname will be ignored because of cross-domain targeting.')\n        self.__kdcIP = None\n        self.__kdcHost = None",
            "def __init__(self, username, password, user_domain, target_domain, cmdLineOptions):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    self.__username = username\n    self.__password = password\n    self.__domain = user_domain\n    self.__target = None\n    self.__targetDomain = target_domain\n    self.__lmhash = ''\n    self.__nthash = ''\n    self.__aesKey = cmdLineOptions.aesKey\n    self.__doKerberos = cmdLineOptions.k\n    self.__kdcIP = cmdLineOptions.dc_ip\n    self.__kdcHost = cmdLineOptions.dc_host\n    if cmdLineOptions.hashes is not None:\n        (self.__lmhash, self.__nthash) = cmdLineOptions.hashes.split(':')\n    domainParts = self.__targetDomain.split('.')\n    self.baseDN = ''\n    for i in domainParts:\n        self.baseDN += 'dc=%s,' % i\n    self.baseDN = self.baseDN[:-1]\n    if user_domain != self.__targetDomain and (self.__kdcIP or self.__kdcHost):\n        logging.warning('KDC IP address and hostname will be ignored because of cross-domain targeting.')\n        self.__kdcIP = None\n        self.__kdcHost = None"
        ]
    },
    {
        "func_name": "getMachineName",
        "original": "def getMachineName(self, target):\n    try:\n        s = SMBConnection(target, target)\n        s.login('', '')\n    except OSError as e:\n        if str(e).find('timed out') > 0:\n            raise Exception('The connection is timed out. Probably 445/TCP port is closed. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except SessionError as e:\n        if str(e).find('STATUS_NOT_SUPPORTED') > 0:\n            raise Exception('The SMB request is not supported. Probably NTLM is disabled. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except Exception:\n        if s.getServerName() == '':\n            raise Exception('Error while anonymous logging into %s' % target)\n    else:\n        s.logoff()\n    return '%s.%s' % (s.getServerName(), s.getServerDNSDomainName())",
        "mutated": [
            "def getMachineName(self, target):\n    if False:\n        i = 10\n    try:\n        s = SMBConnection(target, target)\n        s.login('', '')\n    except OSError as e:\n        if str(e).find('timed out') > 0:\n            raise Exception('The connection is timed out. Probably 445/TCP port is closed. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except SessionError as e:\n        if str(e).find('STATUS_NOT_SUPPORTED') > 0:\n            raise Exception('The SMB request is not supported. Probably NTLM is disabled. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except Exception:\n        if s.getServerName() == '':\n            raise Exception('Error while anonymous logging into %s' % target)\n    else:\n        s.logoff()\n    return '%s.%s' % (s.getServerName(), s.getServerDNSDomainName())",
            "def getMachineName(self, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    try:\n        s = SMBConnection(target, target)\n        s.login('', '')\n    except OSError as e:\n        if str(e).find('timed out') > 0:\n            raise Exception('The connection is timed out. Probably 445/TCP port is closed. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except SessionError as e:\n        if str(e).find('STATUS_NOT_SUPPORTED') > 0:\n            raise Exception('The SMB request is not supported. Probably NTLM is disabled. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except Exception:\n        if s.getServerName() == '':\n            raise Exception('Error while anonymous logging into %s' % target)\n    else:\n        s.logoff()\n    return '%s.%s' % (s.getServerName(), s.getServerDNSDomainName())",
            "def getMachineName(self, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    try:\n        s = SMBConnection(target, target)\n        s.login('', '')\n    except OSError as e:\n        if str(e).find('timed out') > 0:\n            raise Exception('The connection is timed out. Probably 445/TCP port is closed. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except SessionError as e:\n        if str(e).find('STATUS_NOT_SUPPORTED') > 0:\n            raise Exception('The SMB request is not supported. Probably NTLM is disabled. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except Exception:\n        if s.getServerName() == '':\n            raise Exception('Error while anonymous logging into %s' % target)\n    else:\n        s.logoff()\n    return '%s.%s' % (s.getServerName(), s.getServerDNSDomainName())",
            "def getMachineName(self, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    try:\n        s = SMBConnection(target, target)\n        s.login('', '')\n    except OSError as e:\n        if str(e).find('timed out') > 0:\n            raise Exception('The connection is timed out. Probably 445/TCP port is closed. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except SessionError as e:\n        if str(e).find('STATUS_NOT_SUPPORTED') > 0:\n            raise Exception('The SMB request is not supported. Probably NTLM is disabled. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except Exception:\n        if s.getServerName() == '':\n            raise Exception('Error while anonymous logging into %s' % target)\n    else:\n        s.logoff()\n    return '%s.%s' % (s.getServerName(), s.getServerDNSDomainName())",
            "def getMachineName(self, target):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    try:\n        s = SMBConnection(target, target)\n        s.login('', '')\n    except OSError as e:\n        if str(e).find('timed out') > 0:\n            raise Exception('The connection is timed out. Probably 445/TCP port is closed. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except SessionError as e:\n        if str(e).find('STATUS_NOT_SUPPORTED') > 0:\n            raise Exception('The SMB request is not supported. Probably NTLM is disabled. Try to specify corresponding NetBIOS name or FQDN as the value of the -dc-host option.')\n        else:\n            raise\n    except Exception:\n        if s.getServerName() == '':\n            raise Exception('Error while anonymous logging into %s' % target)\n    else:\n        s.logoff()\n    return '%s.%s' % (s.getServerName(), s.getServerDNSDomainName())"
        ]
    },
    {
        "func_name": "run",
        "original": "def run(self):\n    if self.__kdcHost is not None and self.__targetDomain == self.__domain:\n        self.__target = self.__kdcHost\n    else:\n        if self.__kdcIP is not None and self.__targetDomain == self.__domain:\n            self.__target = self.__kdcIP\n        else:\n            self.__target = self.__targetDomain\n        if self.__doKerberos:\n            logging.info('Getting machine hostname')\n            self.__target = self.getMachineName(self.__target)\n    try:\n        ldapConnection = ldap.LDAPConnection('ldap://%s' % self.__target, self.baseDN, self.__kdcIP)\n        if self.__doKerberos is not True:\n            ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n        else:\n            ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n    except ldap.LDAPSessionError as e:\n        if str(e).find('strongerAuthRequired') >= 0:\n            ldapConnection = ldap.LDAPConnection('ldaps://%s' % self.__target, self.baseDN, self.__kdcIP)\n            if self.__doKerberos is not True:\n                ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n            else:\n                ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n        else:\n            if str(e).find('NTLMAuthNegotiate') >= 0:\n                logging.critical('NTLM negotiation failed. Probably NTLM is disabled. Try to use Kerberos authentication instead')\n            elif self.__kdcIP is not None and self.__kdcHost is not None:\n                logging.critical('If the credentials are valid, check the hostname and IP address of KDC. They must match exactly each other')\n            raise\n    searchFilter = '(&(|(UserAccountControl:1.2.840.113556.1.4.803:=16777216)(UserAccountControl:1.2.840.113556.1.4.803:=524288)(msDS-AllowedToDelegateTo=*)(msDS-AllowedToActOnBehalfOfOtherIdentity=*))(!(UserAccountControl:1.2.840.113556.1.4.803:=2))(!(UserAccountControl:1.2.840.113556.1.4.803:=8192)))'\n    try:\n        resp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'pwdLastSet', 'userAccountControl', 'objectCategory', 'msDS-AllowedToActOnBehalfOfOtherIdentity', 'msDS-AllowedToDelegateTo'], sizeLimit=999)\n    except ldap.LDAPSearchError as e:\n        if e.getErrorString().find('sizeLimitExceeded') >= 0:\n            logging.debug('sizeLimitExceeded exception caught, giving up and processing the data received')\n            resp = e.getAnswers()\n            pass\n        else:\n            raise\n    answers = []\n    logging.debug('Total of records returned %d' % len(resp))\n    for item in resp:\n        if isinstance(item, ldapasn1.SearchResultEntry) is not True:\n            continue\n        mustCommit = False\n        sAMAccountName = ''\n        userAccountControl = 0\n        delegation = ''\n        objectType = ''\n        rightsTo = []\n        protocolTransition = 0\n        try:\n            for attribute in item['attributes']:\n                if str(attribute['type']) == 'sAMAccountName':\n                    sAMAccountName = str(attribute['vals'][0])\n                    mustCommit = True\n                elif str(attribute['type']) == 'userAccountControl':\n                    userAccountControl = str(attribute['vals'][0])\n                    if int(userAccountControl) & UF_TRUSTED_FOR_DELEGATION:\n                        delegation = 'Unconstrained'\n                        rightsTo.append('N/A')\n                    elif int(userAccountControl) & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION:\n                        delegation = 'Constrained w/ Protocol Transition'\n                        protocolTransition = 1\n                elif str(attribute['type']) == 'objectCategory':\n                    objectType = str(attribute['vals'][0]).split('=')[1].split(',')[0]\n                elif str(attribute['type']) == 'msDS-AllowedToDelegateTo':\n                    if protocolTransition == 0:\n                        delegation = 'Constrained'\n                    for delegRights in attribute['vals']:\n                        rightsTo.append(str(delegRights))\n                if str(attribute['type']) == 'msDS-AllowedToActOnBehalfOfOtherIdentity':\n                    rbcdRights = []\n                    rbcdObjType = []\n                    searchFilter = '(&(|'\n                    sd = ldaptypes.SR_SECURITY_DESCRIPTOR(data=bytes(attribute['vals'][0]))\n                    for ace in sd['Dacl'].aces:\n                        searchFilter = searchFilter + '(objectSid=' + ace['Ace']['Sid'].formatCanonical() + ')'\n                    searchFilter = searchFilter + ')(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))'\n                    delegUserResp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'objectCategory'], sizeLimit=999)\n                    for item2 in delegUserResp:\n                        if isinstance(item2, ldapasn1.SearchResultEntry) is not True:\n                            continue\n                        rbcdRights.append(str(item2['attributes'][0]['vals'][0]))\n                        rbcdObjType.append(str(item2['attributes'][1]['vals'][0]).split('=')[1].split(',')[0])\n                    if mustCommit is True:\n                        if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                            logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                        else:\n                            for (rights, objType) in zip(rbcdRights, rbcdObjType):\n                                answers.append([rights, objType, 'Resource-Based Constrained', sAMAccountName])\n            if delegation in ['Unconstrained', 'Constrained', 'Constrained w/ Protocol Transition']:\n                if mustCommit is True:\n                    if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                        logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                    else:\n                        for rights in rightsTo:\n                            answers.append([sAMAccountName, objectType, delegation, rights])\n        except Exception as e:\n            logging.error('Skipping item, cannot process due to error %s' % str(e))\n            pass\n    if len(answers) > 0:\n        self.printTable(answers, header=['AccountName', 'AccountType', 'DelegationType', 'DelegationRightsTo'])\n        print('\\n\\n')\n    else:\n        print('No entries found!')",
        "mutated": [
            "def run(self):\n    if False:\n        i = 10\n    if self.__kdcHost is not None and self.__targetDomain == self.__domain:\n        self.__target = self.__kdcHost\n    else:\n        if self.__kdcIP is not None and self.__targetDomain == self.__domain:\n            self.__target = self.__kdcIP\n        else:\n            self.__target = self.__targetDomain\n        if self.__doKerberos:\n            logging.info('Getting machine hostname')\n            self.__target = self.getMachineName(self.__target)\n    try:\n        ldapConnection = ldap.LDAPConnection('ldap://%s' % self.__target, self.baseDN, self.__kdcIP)\n        if self.__doKerberos is not True:\n            ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n        else:\n            ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n    except ldap.LDAPSessionError as e:\n        if str(e).find('strongerAuthRequired') >= 0:\n            ldapConnection = ldap.LDAPConnection('ldaps://%s' % self.__target, self.baseDN, self.__kdcIP)\n            if self.__doKerberos is not True:\n                ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n            else:\n                ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n        else:\n            if str(e).find('NTLMAuthNegotiate') >= 0:\n                logging.critical('NTLM negotiation failed. Probably NTLM is disabled. Try to use Kerberos authentication instead')\n            elif self.__kdcIP is not None and self.__kdcHost is not None:\n                logging.critical('If the credentials are valid, check the hostname and IP address of KDC. They must match exactly each other')\n            raise\n    searchFilter = '(&(|(UserAccountControl:1.2.840.113556.1.4.803:=16777216)(UserAccountControl:1.2.840.113556.1.4.803:=524288)(msDS-AllowedToDelegateTo=*)(msDS-AllowedToActOnBehalfOfOtherIdentity=*))(!(UserAccountControl:1.2.840.113556.1.4.803:=2))(!(UserAccountControl:1.2.840.113556.1.4.803:=8192)))'\n    try:\n        resp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'pwdLastSet', 'userAccountControl', 'objectCategory', 'msDS-AllowedToActOnBehalfOfOtherIdentity', 'msDS-AllowedToDelegateTo'], sizeLimit=999)\n    except ldap.LDAPSearchError as e:\n        if e.getErrorString().find('sizeLimitExceeded') >= 0:\n            logging.debug('sizeLimitExceeded exception caught, giving up and processing the data received')\n            resp = e.getAnswers()\n            pass\n        else:\n            raise\n    answers = []\n    logging.debug('Total of records returned %d' % len(resp))\n    for item in resp:\n        if isinstance(item, ldapasn1.SearchResultEntry) is not True:\n            continue\n        mustCommit = False\n        sAMAccountName = ''\n        userAccountControl = 0\n        delegation = ''\n        objectType = ''\n        rightsTo = []\n        protocolTransition = 0\n        try:\n            for attribute in item['attributes']:\n                if str(attribute['type']) == 'sAMAccountName':\n                    sAMAccountName = str(attribute['vals'][0])\n                    mustCommit = True\n                elif str(attribute['type']) == 'userAccountControl':\n                    userAccountControl = str(attribute['vals'][0])\n                    if int(userAccountControl) & UF_TRUSTED_FOR_DELEGATION:\n                        delegation = 'Unconstrained'\n                        rightsTo.append('N/A')\n                    elif int(userAccountControl) & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION:\n                        delegation = 'Constrained w/ Protocol Transition'\n                        protocolTransition = 1\n                elif str(attribute['type']) == 'objectCategory':\n                    objectType = str(attribute['vals'][0]).split('=')[1].split(',')[0]\n                elif str(attribute['type']) == 'msDS-AllowedToDelegateTo':\n                    if protocolTransition == 0:\n                        delegation = 'Constrained'\n                    for delegRights in attribute['vals']:\n                        rightsTo.append(str(delegRights))\n                if str(attribute['type']) == 'msDS-AllowedToActOnBehalfOfOtherIdentity':\n                    rbcdRights = []\n                    rbcdObjType = []\n                    searchFilter = '(&(|'\n                    sd = ldaptypes.SR_SECURITY_DESCRIPTOR(data=bytes(attribute['vals'][0]))\n                    for ace in sd['Dacl'].aces:\n                        searchFilter = searchFilter + '(objectSid=' + ace['Ace']['Sid'].formatCanonical() + ')'\n                    searchFilter = searchFilter + ')(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))'\n                    delegUserResp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'objectCategory'], sizeLimit=999)\n                    for item2 in delegUserResp:\n                        if isinstance(item2, ldapasn1.SearchResultEntry) is not True:\n                            continue\n                        rbcdRights.append(str(item2['attributes'][0]['vals'][0]))\n                        rbcdObjType.append(str(item2['attributes'][1]['vals'][0]).split('=')[1].split(',')[0])\n                    if mustCommit is True:\n                        if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                            logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                        else:\n                            for (rights, objType) in zip(rbcdRights, rbcdObjType):\n                                answers.append([rights, objType, 'Resource-Based Constrained', sAMAccountName])\n            if delegation in ['Unconstrained', 'Constrained', 'Constrained w/ Protocol Transition']:\n                if mustCommit is True:\n                    if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                        logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                    else:\n                        for rights in rightsTo:\n                            answers.append([sAMAccountName, objectType, delegation, rights])\n        except Exception as e:\n            logging.error('Skipping item, cannot process due to error %s' % str(e))\n            pass\n    if len(answers) > 0:\n        self.printTable(answers, header=['AccountName', 'AccountType', 'DelegationType', 'DelegationRightsTo'])\n        print('\\n\\n')\n    else:\n        print('No entries found!')",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    if self.__kdcHost is not None and self.__targetDomain == self.__domain:\n        self.__target = self.__kdcHost\n    else:\n        if self.__kdcIP is not None and self.__targetDomain == self.__domain:\n            self.__target = self.__kdcIP\n        else:\n            self.__target = self.__targetDomain\n        if self.__doKerberos:\n            logging.info('Getting machine hostname')\n            self.__target = self.getMachineName(self.__target)\n    try:\n        ldapConnection = ldap.LDAPConnection('ldap://%s' % self.__target, self.baseDN, self.__kdcIP)\n        if self.__doKerberos is not True:\n            ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n        else:\n            ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n    except ldap.LDAPSessionError as e:\n        if str(e).find('strongerAuthRequired') >= 0:\n            ldapConnection = ldap.LDAPConnection('ldaps://%s' % self.__target, self.baseDN, self.__kdcIP)\n            if self.__doKerberos is not True:\n                ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n            else:\n                ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n        else:\n            if str(e).find('NTLMAuthNegotiate') >= 0:\n                logging.critical('NTLM negotiation failed. Probably NTLM is disabled. Try to use Kerberos authentication instead')\n            elif self.__kdcIP is not None and self.__kdcHost is not None:\n                logging.critical('If the credentials are valid, check the hostname and IP address of KDC. They must match exactly each other')\n            raise\n    searchFilter = '(&(|(UserAccountControl:1.2.840.113556.1.4.803:=16777216)(UserAccountControl:1.2.840.113556.1.4.803:=524288)(msDS-AllowedToDelegateTo=*)(msDS-AllowedToActOnBehalfOfOtherIdentity=*))(!(UserAccountControl:1.2.840.113556.1.4.803:=2))(!(UserAccountControl:1.2.840.113556.1.4.803:=8192)))'\n    try:\n        resp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'pwdLastSet', 'userAccountControl', 'objectCategory', 'msDS-AllowedToActOnBehalfOfOtherIdentity', 'msDS-AllowedToDelegateTo'], sizeLimit=999)\n    except ldap.LDAPSearchError as e:\n        if e.getErrorString().find('sizeLimitExceeded') >= 0:\n            logging.debug('sizeLimitExceeded exception caught, giving up and processing the data received')\n            resp = e.getAnswers()\n            pass\n        else:\n            raise\n    answers = []\n    logging.debug('Total of records returned %d' % len(resp))\n    for item in resp:\n        if isinstance(item, ldapasn1.SearchResultEntry) is not True:\n            continue\n        mustCommit = False\n        sAMAccountName = ''\n        userAccountControl = 0\n        delegation = ''\n        objectType = ''\n        rightsTo = []\n        protocolTransition = 0\n        try:\n            for attribute in item['attributes']:\n                if str(attribute['type']) == 'sAMAccountName':\n                    sAMAccountName = str(attribute['vals'][0])\n                    mustCommit = True\n                elif str(attribute['type']) == 'userAccountControl':\n                    userAccountControl = str(attribute['vals'][0])\n                    if int(userAccountControl) & UF_TRUSTED_FOR_DELEGATION:\n                        delegation = 'Unconstrained'\n                        rightsTo.append('N/A')\n                    elif int(userAccountControl) & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION:\n                        delegation = 'Constrained w/ Protocol Transition'\n                        protocolTransition = 1\n                elif str(attribute['type']) == 'objectCategory':\n                    objectType = str(attribute['vals'][0]).split('=')[1].split(',')[0]\n                elif str(attribute['type']) == 'msDS-AllowedToDelegateTo':\n                    if protocolTransition == 0:\n                        delegation = 'Constrained'\n                    for delegRights in attribute['vals']:\n                        rightsTo.append(str(delegRights))\n                if str(attribute['type']) == 'msDS-AllowedToActOnBehalfOfOtherIdentity':\n                    rbcdRights = []\n                    rbcdObjType = []\n                    searchFilter = '(&(|'\n                    sd = ldaptypes.SR_SECURITY_DESCRIPTOR(data=bytes(attribute['vals'][0]))\n                    for ace in sd['Dacl'].aces:\n                        searchFilter = searchFilter + '(objectSid=' + ace['Ace']['Sid'].formatCanonical() + ')'\n                    searchFilter = searchFilter + ')(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))'\n                    delegUserResp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'objectCategory'], sizeLimit=999)\n                    for item2 in delegUserResp:\n                        if isinstance(item2, ldapasn1.SearchResultEntry) is not True:\n                            continue\n                        rbcdRights.append(str(item2['attributes'][0]['vals'][0]))\n                        rbcdObjType.append(str(item2['attributes'][1]['vals'][0]).split('=')[1].split(',')[0])\n                    if mustCommit is True:\n                        if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                            logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                        else:\n                            for (rights, objType) in zip(rbcdRights, rbcdObjType):\n                                answers.append([rights, objType, 'Resource-Based Constrained', sAMAccountName])\n            if delegation in ['Unconstrained', 'Constrained', 'Constrained w/ Protocol Transition']:\n                if mustCommit is True:\n                    if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                        logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                    else:\n                        for rights in rightsTo:\n                            answers.append([sAMAccountName, objectType, delegation, rights])\n        except Exception as e:\n            logging.error('Skipping item, cannot process due to error %s' % str(e))\n            pass\n    if len(answers) > 0:\n        self.printTable(answers, header=['AccountName', 'AccountType', 'DelegationType', 'DelegationRightsTo'])\n        print('\\n\\n')\n    else:\n        print('No entries found!')",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    if self.__kdcHost is not None and self.__targetDomain == self.__domain:\n        self.__target = self.__kdcHost\n    else:\n        if self.__kdcIP is not None and self.__targetDomain == self.__domain:\n            self.__target = self.__kdcIP\n        else:\n            self.__target = self.__targetDomain\n        if self.__doKerberos:\n            logging.info('Getting machine hostname')\n            self.__target = self.getMachineName(self.__target)\n    try:\n        ldapConnection = ldap.LDAPConnection('ldap://%s' % self.__target, self.baseDN, self.__kdcIP)\n        if self.__doKerberos is not True:\n            ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n        else:\n            ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n    except ldap.LDAPSessionError as e:\n        if str(e).find('strongerAuthRequired') >= 0:\n            ldapConnection = ldap.LDAPConnection('ldaps://%s' % self.__target, self.baseDN, self.__kdcIP)\n            if self.__doKerberos is not True:\n                ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n            else:\n                ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n        else:\n            if str(e).find('NTLMAuthNegotiate') >= 0:\n                logging.critical('NTLM negotiation failed. Probably NTLM is disabled. Try to use Kerberos authentication instead')\n            elif self.__kdcIP is not None and self.__kdcHost is not None:\n                logging.critical('If the credentials are valid, check the hostname and IP address of KDC. They must match exactly each other')\n            raise\n    searchFilter = '(&(|(UserAccountControl:1.2.840.113556.1.4.803:=16777216)(UserAccountControl:1.2.840.113556.1.4.803:=524288)(msDS-AllowedToDelegateTo=*)(msDS-AllowedToActOnBehalfOfOtherIdentity=*))(!(UserAccountControl:1.2.840.113556.1.4.803:=2))(!(UserAccountControl:1.2.840.113556.1.4.803:=8192)))'\n    try:\n        resp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'pwdLastSet', 'userAccountControl', 'objectCategory', 'msDS-AllowedToActOnBehalfOfOtherIdentity', 'msDS-AllowedToDelegateTo'], sizeLimit=999)\n    except ldap.LDAPSearchError as e:\n        if e.getErrorString().find('sizeLimitExceeded') >= 0:\n            logging.debug('sizeLimitExceeded exception caught, giving up and processing the data received')\n            resp = e.getAnswers()\n            pass\n        else:\n            raise\n    answers = []\n    logging.debug('Total of records returned %d' % len(resp))\n    for item in resp:\n        if isinstance(item, ldapasn1.SearchResultEntry) is not True:\n            continue\n        mustCommit = False\n        sAMAccountName = ''\n        userAccountControl = 0\n        delegation = ''\n        objectType = ''\n        rightsTo = []\n        protocolTransition = 0\n        try:\n            for attribute in item['attributes']:\n                if str(attribute['type']) == 'sAMAccountName':\n                    sAMAccountName = str(attribute['vals'][0])\n                    mustCommit = True\n                elif str(attribute['type']) == 'userAccountControl':\n                    userAccountControl = str(attribute['vals'][0])\n                    if int(userAccountControl) & UF_TRUSTED_FOR_DELEGATION:\n                        delegation = 'Unconstrained'\n                        rightsTo.append('N/A')\n                    elif int(userAccountControl) & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION:\n                        delegation = 'Constrained w/ Protocol Transition'\n                        protocolTransition = 1\n                elif str(attribute['type']) == 'objectCategory':\n                    objectType = str(attribute['vals'][0]).split('=')[1].split(',')[0]\n                elif str(attribute['type']) == 'msDS-AllowedToDelegateTo':\n                    if protocolTransition == 0:\n                        delegation = 'Constrained'\n                    for delegRights in attribute['vals']:\n                        rightsTo.append(str(delegRights))\n                if str(attribute['type']) == 'msDS-AllowedToActOnBehalfOfOtherIdentity':\n                    rbcdRights = []\n                    rbcdObjType = []\n                    searchFilter = '(&(|'\n                    sd = ldaptypes.SR_SECURITY_DESCRIPTOR(data=bytes(attribute['vals'][0]))\n                    for ace in sd['Dacl'].aces:\n                        searchFilter = searchFilter + '(objectSid=' + ace['Ace']['Sid'].formatCanonical() + ')'\n                    searchFilter = searchFilter + ')(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))'\n                    delegUserResp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'objectCategory'], sizeLimit=999)\n                    for item2 in delegUserResp:\n                        if isinstance(item2, ldapasn1.SearchResultEntry) is not True:\n                            continue\n                        rbcdRights.append(str(item2['attributes'][0]['vals'][0]))\n                        rbcdObjType.append(str(item2['attributes'][1]['vals'][0]).split('=')[1].split(',')[0])\n                    if mustCommit is True:\n                        if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                            logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                        else:\n                            for (rights, objType) in zip(rbcdRights, rbcdObjType):\n                                answers.append([rights, objType, 'Resource-Based Constrained', sAMAccountName])\n            if delegation in ['Unconstrained', 'Constrained', 'Constrained w/ Protocol Transition']:\n                if mustCommit is True:\n                    if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                        logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                    else:\n                        for rights in rightsTo:\n                            answers.append([sAMAccountName, objectType, delegation, rights])\n        except Exception as e:\n            logging.error('Skipping item, cannot process due to error %s' % str(e))\n            pass\n    if len(answers) > 0:\n        self.printTable(answers, header=['AccountName', 'AccountType', 'DelegationType', 'DelegationRightsTo'])\n        print('\\n\\n')\n    else:\n        print('No entries found!')",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    if self.__kdcHost is not None and self.__targetDomain == self.__domain:\n        self.__target = self.__kdcHost\n    else:\n        if self.__kdcIP is not None and self.__targetDomain == self.__domain:\n            self.__target = self.__kdcIP\n        else:\n            self.__target = self.__targetDomain\n        if self.__doKerberos:\n            logging.info('Getting machine hostname')\n            self.__target = self.getMachineName(self.__target)\n    try:\n        ldapConnection = ldap.LDAPConnection('ldap://%s' % self.__target, self.baseDN, self.__kdcIP)\n        if self.__doKerberos is not True:\n            ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n        else:\n            ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n    except ldap.LDAPSessionError as e:\n        if str(e).find('strongerAuthRequired') >= 0:\n            ldapConnection = ldap.LDAPConnection('ldaps://%s' % self.__target, self.baseDN, self.__kdcIP)\n            if self.__doKerberos is not True:\n                ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n            else:\n                ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n        else:\n            if str(e).find('NTLMAuthNegotiate') >= 0:\n                logging.critical('NTLM negotiation failed. Probably NTLM is disabled. Try to use Kerberos authentication instead')\n            elif self.__kdcIP is not None and self.__kdcHost is not None:\n                logging.critical('If the credentials are valid, check the hostname and IP address of KDC. They must match exactly each other')\n            raise\n    searchFilter = '(&(|(UserAccountControl:1.2.840.113556.1.4.803:=16777216)(UserAccountControl:1.2.840.113556.1.4.803:=524288)(msDS-AllowedToDelegateTo=*)(msDS-AllowedToActOnBehalfOfOtherIdentity=*))(!(UserAccountControl:1.2.840.113556.1.4.803:=2))(!(UserAccountControl:1.2.840.113556.1.4.803:=8192)))'\n    try:\n        resp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'pwdLastSet', 'userAccountControl', 'objectCategory', 'msDS-AllowedToActOnBehalfOfOtherIdentity', 'msDS-AllowedToDelegateTo'], sizeLimit=999)\n    except ldap.LDAPSearchError as e:\n        if e.getErrorString().find('sizeLimitExceeded') >= 0:\n            logging.debug('sizeLimitExceeded exception caught, giving up and processing the data received')\n            resp = e.getAnswers()\n            pass\n        else:\n            raise\n    answers = []\n    logging.debug('Total of records returned %d' % len(resp))\n    for item in resp:\n        if isinstance(item, ldapasn1.SearchResultEntry) is not True:\n            continue\n        mustCommit = False\n        sAMAccountName = ''\n        userAccountControl = 0\n        delegation = ''\n        objectType = ''\n        rightsTo = []\n        protocolTransition = 0\n        try:\n            for attribute in item['attributes']:\n                if str(attribute['type']) == 'sAMAccountName':\n                    sAMAccountName = str(attribute['vals'][0])\n                    mustCommit = True\n                elif str(attribute['type']) == 'userAccountControl':\n                    userAccountControl = str(attribute['vals'][0])\n                    if int(userAccountControl) & UF_TRUSTED_FOR_DELEGATION:\n                        delegation = 'Unconstrained'\n                        rightsTo.append('N/A')\n                    elif int(userAccountControl) & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION:\n                        delegation = 'Constrained w/ Protocol Transition'\n                        protocolTransition = 1\n                elif str(attribute['type']) == 'objectCategory':\n                    objectType = str(attribute['vals'][0]).split('=')[1].split(',')[0]\n                elif str(attribute['type']) == 'msDS-AllowedToDelegateTo':\n                    if protocolTransition == 0:\n                        delegation = 'Constrained'\n                    for delegRights in attribute['vals']:\n                        rightsTo.append(str(delegRights))\n                if str(attribute['type']) == 'msDS-AllowedToActOnBehalfOfOtherIdentity':\n                    rbcdRights = []\n                    rbcdObjType = []\n                    searchFilter = '(&(|'\n                    sd = ldaptypes.SR_SECURITY_DESCRIPTOR(data=bytes(attribute['vals'][0]))\n                    for ace in sd['Dacl'].aces:\n                        searchFilter = searchFilter + '(objectSid=' + ace['Ace']['Sid'].formatCanonical() + ')'\n                    searchFilter = searchFilter + ')(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))'\n                    delegUserResp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'objectCategory'], sizeLimit=999)\n                    for item2 in delegUserResp:\n                        if isinstance(item2, ldapasn1.SearchResultEntry) is not True:\n                            continue\n                        rbcdRights.append(str(item2['attributes'][0]['vals'][0]))\n                        rbcdObjType.append(str(item2['attributes'][1]['vals'][0]).split('=')[1].split(',')[0])\n                    if mustCommit is True:\n                        if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                            logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                        else:\n                            for (rights, objType) in zip(rbcdRights, rbcdObjType):\n                                answers.append([rights, objType, 'Resource-Based Constrained', sAMAccountName])\n            if delegation in ['Unconstrained', 'Constrained', 'Constrained w/ Protocol Transition']:\n                if mustCommit is True:\n                    if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                        logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                    else:\n                        for rights in rightsTo:\n                            answers.append([sAMAccountName, objectType, delegation, rights])\n        except Exception as e:\n            logging.error('Skipping item, cannot process due to error %s' % str(e))\n            pass\n    if len(answers) > 0:\n        self.printTable(answers, header=['AccountName', 'AccountType', 'DelegationType', 'DelegationRightsTo'])\n        print('\\n\\n')\n    else:\n        print('No entries found!')",
            "def run(self):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    if self.__kdcHost is not None and self.__targetDomain == self.__domain:\n        self.__target = self.__kdcHost\n    else:\n        if self.__kdcIP is not None and self.__targetDomain == self.__domain:\n            self.__target = self.__kdcIP\n        else:\n            self.__target = self.__targetDomain\n        if self.__doKerberos:\n            logging.info('Getting machine hostname')\n            self.__target = self.getMachineName(self.__target)\n    try:\n        ldapConnection = ldap.LDAPConnection('ldap://%s' % self.__target, self.baseDN, self.__kdcIP)\n        if self.__doKerberos is not True:\n            ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n        else:\n            ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n    except ldap.LDAPSessionError as e:\n        if str(e).find('strongerAuthRequired') >= 0:\n            ldapConnection = ldap.LDAPConnection('ldaps://%s' % self.__target, self.baseDN, self.__kdcIP)\n            if self.__doKerberos is not True:\n                ldapConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)\n            else:\n                ldapConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, kdcHost=self.__kdcIP)\n        else:\n            if str(e).find('NTLMAuthNegotiate') >= 0:\n                logging.critical('NTLM negotiation failed. Probably NTLM is disabled. Try to use Kerberos authentication instead')\n            elif self.__kdcIP is not None and self.__kdcHost is not None:\n                logging.critical('If the credentials are valid, check the hostname and IP address of KDC. They must match exactly each other')\n            raise\n    searchFilter = '(&(|(UserAccountControl:1.2.840.113556.1.4.803:=16777216)(UserAccountControl:1.2.840.113556.1.4.803:=524288)(msDS-AllowedToDelegateTo=*)(msDS-AllowedToActOnBehalfOfOtherIdentity=*))(!(UserAccountControl:1.2.840.113556.1.4.803:=2))(!(UserAccountControl:1.2.840.113556.1.4.803:=8192)))'\n    try:\n        resp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'pwdLastSet', 'userAccountControl', 'objectCategory', 'msDS-AllowedToActOnBehalfOfOtherIdentity', 'msDS-AllowedToDelegateTo'], sizeLimit=999)\n    except ldap.LDAPSearchError as e:\n        if e.getErrorString().find('sizeLimitExceeded') >= 0:\n            logging.debug('sizeLimitExceeded exception caught, giving up and processing the data received')\n            resp = e.getAnswers()\n            pass\n        else:\n            raise\n    answers = []\n    logging.debug('Total of records returned %d' % len(resp))\n    for item in resp:\n        if isinstance(item, ldapasn1.SearchResultEntry) is not True:\n            continue\n        mustCommit = False\n        sAMAccountName = ''\n        userAccountControl = 0\n        delegation = ''\n        objectType = ''\n        rightsTo = []\n        protocolTransition = 0\n        try:\n            for attribute in item['attributes']:\n                if str(attribute['type']) == 'sAMAccountName':\n                    sAMAccountName = str(attribute['vals'][0])\n                    mustCommit = True\n                elif str(attribute['type']) == 'userAccountControl':\n                    userAccountControl = str(attribute['vals'][0])\n                    if int(userAccountControl) & UF_TRUSTED_FOR_DELEGATION:\n                        delegation = 'Unconstrained'\n                        rightsTo.append('N/A')\n                    elif int(userAccountControl) & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION:\n                        delegation = 'Constrained w/ Protocol Transition'\n                        protocolTransition = 1\n                elif str(attribute['type']) == 'objectCategory':\n                    objectType = str(attribute['vals'][0]).split('=')[1].split(',')[0]\n                elif str(attribute['type']) == 'msDS-AllowedToDelegateTo':\n                    if protocolTransition == 0:\n                        delegation = 'Constrained'\n                    for delegRights in attribute['vals']:\n                        rightsTo.append(str(delegRights))\n                if str(attribute['type']) == 'msDS-AllowedToActOnBehalfOfOtherIdentity':\n                    rbcdRights = []\n                    rbcdObjType = []\n                    searchFilter = '(&(|'\n                    sd = ldaptypes.SR_SECURITY_DESCRIPTOR(data=bytes(attribute['vals'][0]))\n                    for ace in sd['Dacl'].aces:\n                        searchFilter = searchFilter + '(objectSid=' + ace['Ace']['Sid'].formatCanonical() + ')'\n                    searchFilter = searchFilter + ')(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))'\n                    delegUserResp = ldapConnection.search(searchFilter=searchFilter, attributes=['sAMAccountName', 'objectCategory'], sizeLimit=999)\n                    for item2 in delegUserResp:\n                        if isinstance(item2, ldapasn1.SearchResultEntry) is not True:\n                            continue\n                        rbcdRights.append(str(item2['attributes'][0]['vals'][0]))\n                        rbcdObjType.append(str(item2['attributes'][1]['vals'][0]).split('=')[1].split(',')[0])\n                    if mustCommit is True:\n                        if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                            logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                        else:\n                            for (rights, objType) in zip(rbcdRights, rbcdObjType):\n                                answers.append([rights, objType, 'Resource-Based Constrained', sAMAccountName])\n            if delegation in ['Unconstrained', 'Constrained', 'Constrained w/ Protocol Transition']:\n                if mustCommit is True:\n                    if int(userAccountControl) & UF_ACCOUNTDISABLE:\n                        logging.debug('Bypassing disabled account %s ' % sAMAccountName)\n                    else:\n                        for rights in rightsTo:\n                            answers.append([sAMAccountName, objectType, delegation, rights])\n        except Exception as e:\n            logging.error('Skipping item, cannot process due to error %s' % str(e))\n            pass\n    if len(answers) > 0:\n        self.printTable(answers, header=['AccountName', 'AccountType', 'DelegationType', 'DelegationRightsTo'])\n        print('\\n\\n')\n    else:\n        print('No entries found!')"
        ]
    }
]