[
    {
        "func_name": "max_len_seq",
        "original": "def max_len_seq(nbits, state=None, length=None, taps=None):\n    \"\"\"\n    Maximum length sequence (MLS) generator.\n\n    Parameters\n    ----------\n    nbits : int\n        Number of bits to use. Length of the resulting sequence will\n        be ``(2**nbits) - 1``. Note that generating long sequences\n        (e.g., greater than ``nbits == 16``) can take a long time.\n    state : array_like, optional\n        If array, must be of length ``nbits``, and will be cast to binary\n        (bool) representation. If None, a seed of ones will be used,\n        producing a repeatable representation. If ``state`` is all\n        zeros, an error is raised as this is invalid. Default: None.\n    length : int, optional\n        Number of samples to compute. If None, the entire length\n        ``(2**nbits) - 1`` is computed.\n    taps : array_like, optional\n        Polynomial taps to use (e.g., ``[7, 6, 1]`` for an 8-bit sequence).\n        If None, taps will be automatically selected (for up to\n        ``nbits == 32``).\n\n    Returns\n    -------\n    seq : array\n        Resulting MLS sequence of 0's and 1's.\n    state : array\n        The final state of the shift register.\n\n    Notes\n    -----\n    The algorithm for MLS generation is generically described in:\n\n        https://en.wikipedia.org/wiki/Maximum_length_sequence\n\n    The default values for taps are specifically taken from the first\n    option listed for each value of ``nbits`` in:\n\n        https://web.archive.org/web/20181001062252/http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm\n\n    .. versionadded:: 0.15.0\n\n    Examples\n    --------\n    MLS uses binary convention:\n\n    >>> from scipy.signal import max_len_seq\n    >>> max_len_seq(4)[0]\n    array([1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], dtype=int8)\n\n    MLS has a white spectrum (except for DC):\n\n    >>> import numpy as np\n    >>> import matplotlib.pyplot as plt\n    >>> from numpy.fft import fft, ifft, fftshift, fftfreq\n    >>> seq = max_len_seq(6)[0]*2-1  # +1 and -1\n    >>> spec = fft(seq)\n    >>> N = len(seq)\n    >>> plt.plot(fftshift(fftfreq(N)), fftshift(np.abs(spec)), '.-')\n    >>> plt.margins(0.1, 0.1)\n    >>> plt.grid(True)\n    >>> plt.show()\n\n    Circular autocorrelation of MLS is an impulse:\n\n    >>> acorrcirc = ifft(spec * np.conj(spec)).real\n    >>> plt.figure()\n    >>> plt.plot(np.arange(-N/2+1, N/2+1), fftshift(acorrcirc), '.-')\n    >>> plt.margins(0.1, 0.1)\n    >>> plt.grid(True)\n    >>> plt.show()\n\n    Linear autocorrelation of MLS is approximately an impulse:\n\n    >>> acorr = np.correlate(seq, seq, 'full')\n    >>> plt.figure()\n    >>> plt.plot(np.arange(-N+1, N), acorr, '.-')\n    >>> plt.margins(0.1, 0.1)\n    >>> plt.grid(True)\n    >>> plt.show()\n\n    \"\"\"\n    taps_dtype = np.int32 if np.intp().itemsize == 4 else np.int64\n    if taps is None:\n        if nbits not in _mls_taps:\n            known_taps = np.array(list(_mls_taps.keys()))\n            raise ValueError('nbits must be between %s and %s if taps is None' % (known_taps.min(), known_taps.max()))\n        taps = np.array(_mls_taps[nbits], taps_dtype)\n    else:\n        taps = np.unique(np.array(taps, taps_dtype))[::-1]\n        if np.any(taps < 0) or np.any(taps > nbits) or taps.size < 1:\n            raise ValueError('taps must be non-empty with values between zero and nbits (inclusive)')\n        taps = np.array(taps)\n    n_max = 2 ** nbits - 1\n    if length is None:\n        length = n_max\n    else:\n        length = int(length)\n        if length < 0:\n            raise ValueError('length must be greater than or equal to 0')\n    if state is None:\n        state = np.ones(nbits, dtype=np.int8, order='c')\n    else:\n        state = np.array(state, dtype=bool, order='c').astype(np.int8)\n    if state.ndim != 1 or state.size != nbits:\n        raise ValueError('state must be a 1-D array of size nbits')\n    if np.all(state == 0):\n        raise ValueError('state must not be all zeros')\n    seq = np.empty(length, dtype=np.int8, order='c')\n    state = _max_len_seq_inner(taps, state, nbits, length, seq)\n    return (seq, state)",
        "mutated": [
            "def max_len_seq(nbits, state=None, length=None, taps=None):\n    if False:\n        i = 10\n    \"\\n    Maximum length sequence (MLS) generator.\\n\\n    Parameters\\n    ----------\\n    nbits : int\\n        Number of bits to use. Length of the resulting sequence will\\n        be ``(2**nbits) - 1``. Note that generating long sequences\\n        (e.g., greater than ``nbits == 16``) can take a long time.\\n    state : array_like, optional\\n        If array, must be of length ``nbits``, and will be cast to binary\\n        (bool) representation. If None, a seed of ones will be used,\\n        producing a repeatable representation. If ``state`` is all\\n        zeros, an error is raised as this is invalid. Default: None.\\n    length : int, optional\\n        Number of samples to compute. If None, the entire length\\n        ``(2**nbits) - 1`` is computed.\\n    taps : array_like, optional\\n        Polynomial taps to use (e.g., ``[7, 6, 1]`` for an 8-bit sequence).\\n        If None, taps will be automatically selected (for up to\\n        ``nbits == 32``).\\n\\n    Returns\\n    -------\\n    seq : array\\n        Resulting MLS sequence of 0's and 1's.\\n    state : array\\n        The final state of the shift register.\\n\\n    Notes\\n    -----\\n    The algorithm for MLS generation is generically described in:\\n\\n        https://en.wikipedia.org/wiki/Maximum_length_sequence\\n\\n    The default values for taps are specifically taken from the first\\n    option listed for each value of ``nbits`` in:\\n\\n        https://web.archive.org/web/20181001062252/http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm\\n\\n    .. versionadded:: 0.15.0\\n\\n    Examples\\n    --------\\n    MLS uses binary convention:\\n\\n    >>> from scipy.signal import max_len_seq\\n    >>> max_len_seq(4)[0]\\n    array([1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], dtype=int8)\\n\\n    MLS has a white spectrum (except for DC):\\n\\n    >>> import numpy as np\\n    >>> import matplotlib.pyplot as plt\\n    >>> from numpy.fft import fft, ifft, fftshift, fftfreq\\n    >>> seq = max_len_seq(6)[0]*2-1  # +1 and -1\\n    >>> spec = fft(seq)\\n    >>> N = len(seq)\\n    >>> plt.plot(fftshift(fftfreq(N)), fftshift(np.abs(spec)), '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    Circular autocorrelation of MLS is an impulse:\\n\\n    >>> acorrcirc = ifft(spec * np.conj(spec)).real\\n    >>> plt.figure()\\n    >>> plt.plot(np.arange(-N/2+1, N/2+1), fftshift(acorrcirc), '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    Linear autocorrelation of MLS is approximately an impulse:\\n\\n    >>> acorr = np.correlate(seq, seq, 'full')\\n    >>> plt.figure()\\n    >>> plt.plot(np.arange(-N+1, N), acorr, '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    \"\n    taps_dtype = np.int32 if np.intp().itemsize == 4 else np.int64\n    if taps is None:\n        if nbits not in _mls_taps:\n            known_taps = np.array(list(_mls_taps.keys()))\n            raise ValueError('nbits must be between %s and %s if taps is None' % (known_taps.min(), known_taps.max()))\n        taps = np.array(_mls_taps[nbits], taps_dtype)\n    else:\n        taps = np.unique(np.array(taps, taps_dtype))[::-1]\n        if np.any(taps < 0) or np.any(taps > nbits) or taps.size < 1:\n            raise ValueError('taps must be non-empty with values between zero and nbits (inclusive)')\n        taps = np.array(taps)\n    n_max = 2 ** nbits - 1\n    if length is None:\n        length = n_max\n    else:\n        length = int(length)\n        if length < 0:\n            raise ValueError('length must be greater than or equal to 0')\n    if state is None:\n        state = np.ones(nbits, dtype=np.int8, order='c')\n    else:\n        state = np.array(state, dtype=bool, order='c').astype(np.int8)\n    if state.ndim != 1 or state.size != nbits:\n        raise ValueError('state must be a 1-D array of size nbits')\n    if np.all(state == 0):\n        raise ValueError('state must not be all zeros')\n    seq = np.empty(length, dtype=np.int8, order='c')\n    state = _max_len_seq_inner(taps, state, nbits, length, seq)\n    return (seq, state)",
            "def max_len_seq(nbits, state=None, length=None, taps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n    \"\\n    Maximum length sequence (MLS) generator.\\n\\n    Parameters\\n    ----------\\n    nbits : int\\n        Number of bits to use. Length of the resulting sequence will\\n        be ``(2**nbits) - 1``. Note that generating long sequences\\n        (e.g., greater than ``nbits == 16``) can take a long time.\\n    state : array_like, optional\\n        If array, must be of length ``nbits``, and will be cast to binary\\n        (bool) representation. If None, a seed of ones will be used,\\n        producing a repeatable representation. If ``state`` is all\\n        zeros, an error is raised as this is invalid. Default: None.\\n    length : int, optional\\n        Number of samples to compute. If None, the entire length\\n        ``(2**nbits) - 1`` is computed.\\n    taps : array_like, optional\\n        Polynomial taps to use (e.g., ``[7, 6, 1]`` for an 8-bit sequence).\\n        If None, taps will be automatically selected (for up to\\n        ``nbits == 32``).\\n\\n    Returns\\n    -------\\n    seq : array\\n        Resulting MLS sequence of 0's and 1's.\\n    state : array\\n        The final state of the shift register.\\n\\n    Notes\\n    -----\\n    The algorithm for MLS generation is generically described in:\\n\\n        https://en.wikipedia.org/wiki/Maximum_length_sequence\\n\\n    The default values for taps are specifically taken from the first\\n    option listed for each value of ``nbits`` in:\\n\\n        https://web.archive.org/web/20181001062252/http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm\\n\\n    .. versionadded:: 0.15.0\\n\\n    Examples\\n    --------\\n    MLS uses binary convention:\\n\\n    >>> from scipy.signal import max_len_seq\\n    >>> max_len_seq(4)[0]\\n    array([1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], dtype=int8)\\n\\n    MLS has a white spectrum (except for DC):\\n\\n    >>> import numpy as np\\n    >>> import matplotlib.pyplot as plt\\n    >>> from numpy.fft import fft, ifft, fftshift, fftfreq\\n    >>> seq = max_len_seq(6)[0]*2-1  # +1 and -1\\n    >>> spec = fft(seq)\\n    >>> N = len(seq)\\n    >>> plt.plot(fftshift(fftfreq(N)), fftshift(np.abs(spec)), '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    Circular autocorrelation of MLS is an impulse:\\n\\n    >>> acorrcirc = ifft(spec * np.conj(spec)).real\\n    >>> plt.figure()\\n    >>> plt.plot(np.arange(-N/2+1, N/2+1), fftshift(acorrcirc), '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    Linear autocorrelation of MLS is approximately an impulse:\\n\\n    >>> acorr = np.correlate(seq, seq, 'full')\\n    >>> plt.figure()\\n    >>> plt.plot(np.arange(-N+1, N), acorr, '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    \"\n    taps_dtype = np.int32 if np.intp().itemsize == 4 else np.int64\n    if taps is None:\n        if nbits not in _mls_taps:\n            known_taps = np.array(list(_mls_taps.keys()))\n            raise ValueError('nbits must be between %s and %s if taps is None' % (known_taps.min(), known_taps.max()))\n        taps = np.array(_mls_taps[nbits], taps_dtype)\n    else:\n        taps = np.unique(np.array(taps, taps_dtype))[::-1]\n        if np.any(taps < 0) or np.any(taps > nbits) or taps.size < 1:\n            raise ValueError('taps must be non-empty with values between zero and nbits (inclusive)')\n        taps = np.array(taps)\n    n_max = 2 ** nbits - 1\n    if length is None:\n        length = n_max\n    else:\n        length = int(length)\n        if length < 0:\n            raise ValueError('length must be greater than or equal to 0')\n    if state is None:\n        state = np.ones(nbits, dtype=np.int8, order='c')\n    else:\n        state = np.array(state, dtype=bool, order='c').astype(np.int8)\n    if state.ndim != 1 or state.size != nbits:\n        raise ValueError('state must be a 1-D array of size nbits')\n    if np.all(state == 0):\n        raise ValueError('state must not be all zeros')\n    seq = np.empty(length, dtype=np.int8, order='c')\n    state = _max_len_seq_inner(taps, state, nbits, length, seq)\n    return (seq, state)",
            "def max_len_seq(nbits, state=None, length=None, taps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n    \"\\n    Maximum length sequence (MLS) generator.\\n\\n    Parameters\\n    ----------\\n    nbits : int\\n        Number of bits to use. Length of the resulting sequence will\\n        be ``(2**nbits) - 1``. Note that generating long sequences\\n        (e.g., greater than ``nbits == 16``) can take a long time.\\n    state : array_like, optional\\n        If array, must be of length ``nbits``, and will be cast to binary\\n        (bool) representation. If None, a seed of ones will be used,\\n        producing a repeatable representation. If ``state`` is all\\n        zeros, an error is raised as this is invalid. Default: None.\\n    length : int, optional\\n        Number of samples to compute. If None, the entire length\\n        ``(2**nbits) - 1`` is computed.\\n    taps : array_like, optional\\n        Polynomial taps to use (e.g., ``[7, 6, 1]`` for an 8-bit sequence).\\n        If None, taps will be automatically selected (for up to\\n        ``nbits == 32``).\\n\\n    Returns\\n    -------\\n    seq : array\\n        Resulting MLS sequence of 0's and 1's.\\n    state : array\\n        The final state of the shift register.\\n\\n    Notes\\n    -----\\n    The algorithm for MLS generation is generically described in:\\n\\n        https://en.wikipedia.org/wiki/Maximum_length_sequence\\n\\n    The default values for taps are specifically taken from the first\\n    option listed for each value of ``nbits`` in:\\n\\n        https://web.archive.org/web/20181001062252/http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm\\n\\n    .. versionadded:: 0.15.0\\n\\n    Examples\\n    --------\\n    MLS uses binary convention:\\n\\n    >>> from scipy.signal import max_len_seq\\n    >>> max_len_seq(4)[0]\\n    array([1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], dtype=int8)\\n\\n    MLS has a white spectrum (except for DC):\\n\\n    >>> import numpy as np\\n    >>> import matplotlib.pyplot as plt\\n    >>> from numpy.fft import fft, ifft, fftshift, fftfreq\\n    >>> seq = max_len_seq(6)[0]*2-1  # +1 and -1\\n    >>> spec = fft(seq)\\n    >>> N = len(seq)\\n    >>> plt.plot(fftshift(fftfreq(N)), fftshift(np.abs(spec)), '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    Circular autocorrelation of MLS is an impulse:\\n\\n    >>> acorrcirc = ifft(spec * np.conj(spec)).real\\n    >>> plt.figure()\\n    >>> plt.plot(np.arange(-N/2+1, N/2+1), fftshift(acorrcirc), '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    Linear autocorrelation of MLS is approximately an impulse:\\n\\n    >>> acorr = np.correlate(seq, seq, 'full')\\n    >>> plt.figure()\\n    >>> plt.plot(np.arange(-N+1, N), acorr, '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    \"\n    taps_dtype = np.int32 if np.intp().itemsize == 4 else np.int64\n    if taps is None:\n        if nbits not in _mls_taps:\n            known_taps = np.array(list(_mls_taps.keys()))\n            raise ValueError('nbits must be between %s and %s if taps is None' % (known_taps.min(), known_taps.max()))\n        taps = np.array(_mls_taps[nbits], taps_dtype)\n    else:\n        taps = np.unique(np.array(taps, taps_dtype))[::-1]\n        if np.any(taps < 0) or np.any(taps > nbits) or taps.size < 1:\n            raise ValueError('taps must be non-empty with values between zero and nbits (inclusive)')\n        taps = np.array(taps)\n    n_max = 2 ** nbits - 1\n    if length is None:\n        length = n_max\n    else:\n        length = int(length)\n        if length < 0:\n            raise ValueError('length must be greater than or equal to 0')\n    if state is None:\n        state = np.ones(nbits, dtype=np.int8, order='c')\n    else:\n        state = np.array(state, dtype=bool, order='c').astype(np.int8)\n    if state.ndim != 1 or state.size != nbits:\n        raise ValueError('state must be a 1-D array of size nbits')\n    if np.all(state == 0):\n        raise ValueError('state must not be all zeros')\n    seq = np.empty(length, dtype=np.int8, order='c')\n    state = _max_len_seq_inner(taps, state, nbits, length, seq)\n    return (seq, state)",
            "def max_len_seq(nbits, state=None, length=None, taps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        n = 10\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n    \"\\n    Maximum length sequence (MLS) generator.\\n\\n    Parameters\\n    ----------\\n    nbits : int\\n        Number of bits to use. Length of the resulting sequence will\\n        be ``(2**nbits) - 1``. Note that generating long sequences\\n        (e.g., greater than ``nbits == 16``) can take a long time.\\n    state : array_like, optional\\n        If array, must be of length ``nbits``, and will be cast to binary\\n        (bool) representation. If None, a seed of ones will be used,\\n        producing a repeatable representation. If ``state`` is all\\n        zeros, an error is raised as this is invalid. Default: None.\\n    length : int, optional\\n        Number of samples to compute. If None, the entire length\\n        ``(2**nbits) - 1`` is computed.\\n    taps : array_like, optional\\n        Polynomial taps to use (e.g., ``[7, 6, 1]`` for an 8-bit sequence).\\n        If None, taps will be automatically selected (for up to\\n        ``nbits == 32``).\\n\\n    Returns\\n    -------\\n    seq : array\\n        Resulting MLS sequence of 0's and 1's.\\n    state : array\\n        The final state of the shift register.\\n\\n    Notes\\n    -----\\n    The algorithm for MLS generation is generically described in:\\n\\n        https://en.wikipedia.org/wiki/Maximum_length_sequence\\n\\n    The default values for taps are specifically taken from the first\\n    option listed for each value of ``nbits`` in:\\n\\n        https://web.archive.org/web/20181001062252/http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm\\n\\n    .. versionadded:: 0.15.0\\n\\n    Examples\\n    --------\\n    MLS uses binary convention:\\n\\n    >>> from scipy.signal import max_len_seq\\n    >>> max_len_seq(4)[0]\\n    array([1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], dtype=int8)\\n\\n    MLS has a white spectrum (except for DC):\\n\\n    >>> import numpy as np\\n    >>> import matplotlib.pyplot as plt\\n    >>> from numpy.fft import fft, ifft, fftshift, fftfreq\\n    >>> seq = max_len_seq(6)[0]*2-1  # +1 and -1\\n    >>> spec = fft(seq)\\n    >>> N = len(seq)\\n    >>> plt.plot(fftshift(fftfreq(N)), fftshift(np.abs(spec)), '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    Circular autocorrelation of MLS is an impulse:\\n\\n    >>> acorrcirc = ifft(spec * np.conj(spec)).real\\n    >>> plt.figure()\\n    >>> plt.plot(np.arange(-N/2+1, N/2+1), fftshift(acorrcirc), '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    Linear autocorrelation of MLS is approximately an impulse:\\n\\n    >>> acorr = np.correlate(seq, seq, 'full')\\n    >>> plt.figure()\\n    >>> plt.plot(np.arange(-N+1, N), acorr, '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    \"\n    taps_dtype = np.int32 if np.intp().itemsize == 4 else np.int64\n    if taps is None:\n        if nbits not in _mls_taps:\n            known_taps = np.array(list(_mls_taps.keys()))\n            raise ValueError('nbits must be between %s and %s if taps is None' % (known_taps.min(), known_taps.max()))\n        taps = np.array(_mls_taps[nbits], taps_dtype)\n    else:\n        taps = np.unique(np.array(taps, taps_dtype))[::-1]\n        if np.any(taps < 0) or np.any(taps > nbits) or taps.size < 1:\n            raise ValueError('taps must be non-empty with values between zero and nbits (inclusive)')\n        taps = np.array(taps)\n    n_max = 2 ** nbits - 1\n    if length is None:\n        length = n_max\n    else:\n        length = int(length)\n        if length < 0:\n            raise ValueError('length must be greater than or equal to 0')\n    if state is None:\n        state = np.ones(nbits, dtype=np.int8, order='c')\n    else:\n        state = np.array(state, dtype=bool, order='c').astype(np.int8)\n    if state.ndim != 1 or state.size != nbits:\n        raise ValueError('state must be a 1-D array of size nbits')\n    if np.all(state == 0):\n        raise ValueError('state must not be all zeros')\n    seq = np.empty(length, dtype=np.int8, order='c')\n    state = _max_len_seq_inner(taps, state, nbits, length, seq)\n    return (seq, state)",
            "def max_len_seq(nbits, state=None, length=None, taps=None):\n    if False:\n        i = 10\n        while True:\n            print('Mutation')\n        dp = [0, 1]\n        for i in range(2, n + 1):\n            dp.append(dp[i - 1] + dp[i - 2])\n        print(dp[n])\n\n        def dfs(node):\n            if node == None:\n                return []\n            left = dfs(node.left)\n            right = dfs(node.right)\n        length = 15\n        if length <= 0:\n            return []\n        elif length == 1:\n            return [0]\n        sequence = [0, 1]\n        while len(sequence) < length:\n            next_value = sequence[-1] + sequence[-2]\n            sequence.append(next_value)\n        return sequence\n    \"\\n    Maximum length sequence (MLS) generator.\\n\\n    Parameters\\n    ----------\\n    nbits : int\\n        Number of bits to use. Length of the resulting sequence will\\n        be ``(2**nbits) - 1``. Note that generating long sequences\\n        (e.g., greater than ``nbits == 16``) can take a long time.\\n    state : array_like, optional\\n        If array, must be of length ``nbits``, and will be cast to binary\\n        (bool) representation. If None, a seed of ones will be used,\\n        producing a repeatable representation. If ``state`` is all\\n        zeros, an error is raised as this is invalid. Default: None.\\n    length : int, optional\\n        Number of samples to compute. If None, the entire length\\n        ``(2**nbits) - 1`` is computed.\\n    taps : array_like, optional\\n        Polynomial taps to use (e.g., ``[7, 6, 1]`` for an 8-bit sequence).\\n        If None, taps will be automatically selected (for up to\\n        ``nbits == 32``).\\n\\n    Returns\\n    -------\\n    seq : array\\n        Resulting MLS sequence of 0's and 1's.\\n    state : array\\n        The final state of the shift register.\\n\\n    Notes\\n    -----\\n    The algorithm for MLS generation is generically described in:\\n\\n        https://en.wikipedia.org/wiki/Maximum_length_sequence\\n\\n    The default values for taps are specifically taken from the first\\n    option listed for each value of ``nbits`` in:\\n\\n        https://web.archive.org/web/20181001062252/http://www.newwaveinstruments.com/resources/articles/m_sequence_linear_feedback_shift_register_lfsr.htm\\n\\n    .. versionadded:: 0.15.0\\n\\n    Examples\\n    --------\\n    MLS uses binary convention:\\n\\n    >>> from scipy.signal import max_len_seq\\n    >>> max_len_seq(4)[0]\\n    array([1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], dtype=int8)\\n\\n    MLS has a white spectrum (except for DC):\\n\\n    >>> import numpy as np\\n    >>> import matplotlib.pyplot as plt\\n    >>> from numpy.fft import fft, ifft, fftshift, fftfreq\\n    >>> seq = max_len_seq(6)[0]*2-1  # +1 and -1\\n    >>> spec = fft(seq)\\n    >>> N = len(seq)\\n    >>> plt.plot(fftshift(fftfreq(N)), fftshift(np.abs(spec)), '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    Circular autocorrelation of MLS is an impulse:\\n\\n    >>> acorrcirc = ifft(spec * np.conj(spec)).real\\n    >>> plt.figure()\\n    >>> plt.plot(np.arange(-N/2+1, N/2+1), fftshift(acorrcirc), '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    Linear autocorrelation of MLS is approximately an impulse:\\n\\n    >>> acorr = np.correlate(seq, seq, 'full')\\n    >>> plt.figure()\\n    >>> plt.plot(np.arange(-N+1, N), acorr, '.-')\\n    >>> plt.margins(0.1, 0.1)\\n    >>> plt.grid(True)\\n    >>> plt.show()\\n\\n    \"\n    taps_dtype = np.int32 if np.intp().itemsize == 4 else np.int64\n    if taps is None:\n        if nbits not in _mls_taps:\n            known_taps = np.array(list(_mls_taps.keys()))\n            raise ValueError('nbits must be between %s and %s if taps is None' % (known_taps.min(), known_taps.max()))\n        taps = np.array(_mls_taps[nbits], taps_dtype)\n    else:\n        taps = np.unique(np.array(taps, taps_dtype))[::-1]\n        if np.any(taps < 0) or np.any(taps > nbits) or taps.size < 1:\n            raise ValueError('taps must be non-empty with values between zero and nbits (inclusive)')\n        taps = np.array(taps)\n    n_max = 2 ** nbits - 1\n    if length is None:\n        length = n_max\n    else:\n        length = int(length)\n        if length < 0:\n            raise ValueError('length must be greater than or equal to 0')\n    if state is None:\n        state = np.ones(nbits, dtype=np.int8, order='c')\n    else:\n        state = np.array(state, dtype=bool, order='c').astype(np.int8)\n    if state.ndim != 1 or state.size != nbits:\n        raise ValueError('state must be a 1-D array of size nbits')\n    if np.all(state == 0):\n        raise ValueError('state must not be all zeros')\n    seq = np.empty(length, dtype=np.int8, order='c')\n    state = _max_len_seq_inner(taps, state, nbits, length, seq)\n    return (seq, state)"
        ]
    }
]